#pragma TextEncoding = "UTF-8"#pragma rtGlobals=3		// Use modern global access method and strict wave access. ///////////////////// GB functions for ABF loading/////////////////////nomenclature: "indexed" files are ABFs that have been brought into this system, "loaded" files (or sweeps) are data from ABFs that has been made into Igor waves //usage: initialize the loader with fd_abfload("")//ABF handler. Primary attributes://fileInfoWave (2D T wave, rows = # files): this is the core of the GUI to select files. Has one row for each opened file (primarily an ABF). Columns are (from 0) file name, info columns, channel selection columns//	--has an associated window 'filePanel' (contains main GUI panel for this set of functions), ListBox fileListBox, w/ fileInfoWaveColumnTitles, fileSelList//fileDirectory (2D T wave, rows = # files): this is the behind the scenes file info tracker (file information that has to be stored but does not need to be continuously displayed). col 0 is the file path (to reload). col 1 is file comment.//sweepsTracker (1D T wave, rows = # files):  a list representing all the sweeps in each file and whether theyve been selected for loading. Stored in each row is a semi-colon delimited string, each position represnts one sweep (in order from sweep 0 on), with 0 if unselected, 1 if selected//**These two three that really matter. The functions will trust that they are formatted correctly and have a matching row (same index) for each file in fileInfoWave, fileDirectory, and a matching set of sweeps in sweepsTracker for each file//sweepsSelList (1D T wave, # rows updates based on # sweeps for selected files). //	--has an associated ListBox sweepsListBox, which has sweepsListWave, sweepsSelList, sweepsSelWaveTitles//	--allows user to select files (that is, rows) in fileInfoWave (via fileListBox), which will be displayed in sweepsListWave as selected on unselected from sweepsTracker, and update selections there//channelList (1D T wave, rows = max # chans): a list for user to see all possible channels (up to max number in an opened file)//	--has an associated ListBox channelSelBox w/ channelList,  channelSelList,  channelSelWaveTitles//dispPrefsList (2D T Wave, rows = max # chans/graph Axes. Cols = graphical display preferences, accepts userinput. //	has an associated ListBox dispPrefsListBox w/  dispPrefsList, dispPrefsSelWave, dispPrefsTitleWave//sweepsDispList (2D T Wave, rows = one for each loaded, selected file ; cols=0,1 reversed for info, 2+ are for each selected channel for file(s)//	--has an associated ListBox sweepsDispBox w/ sweepsDispList, sweepsDispSelWave, sweepsDispTitleWave//ITEMS NECESSARY FOR PORTING (and recreating abf loader in a different pxp file//fileDirectory//fileInfoWave//fileInfoWaveColumnTitles	--could update to make unnecessary//fileSelList	--could update to make unnecessary//sweepsTracker	--would be time intensive to recreate this each time//COMPLETE LIST OF REMAINING ITEMS (not necessary for recreation but necessary to reproduce exact settings)//channelSelList	X//channelList	X//channelSelWaveTitles	X//sweepsSelList	X//sweepsListWave	X//sweepsSelWaveTitles	X//dispPrefsList	X//dispPrefsSelWave	X//dispPrefsTitleWave	X//sweepsDispSelWave		X//sweepsDispList		X//sweepsDispTitleWave	X//fileSelListByNums	X//fd_juncPotStr//fd_downSampleStr//////variables automatically recreated//numNonChanFileInfoWaveCols	X//yAxScalingOn	X//xAxScalingOn	X//numOfPrimaryFile	X//selectionIndicatorString	X//titleBoxString	X//selectionsSummaryString	X//currFileDispGraphN	X//menu option to start loading abfs: misc menu option "filePanel start\load"//if filePanel doesn't exist, just recreates it (no abf loading.. use the abf load button on filePanel or hit F12 again//if filePanel does exist, the user is prompted to select new abfs to loadMenu "Misc"	"filePanel start\\load/F12",/Q,fd_abfload("",recreation=wintype("filePanel")==0)End//function call to load more abf files into igor's memory.//fd_abfLoad("")	to load abfs from a single folder which the user will be prompted to pick//use fd_loadParentDir() to load abfs from many files stored in a parent folderstatic strconstant ks_fd_graphNameStart="filePanel_mainGraph_"function fd_abfLoad(cmdLinePathsList,[isFileDirectorRef,recreation,pickParentFolder])	String cmdLinePathsList		//user input instead of from file directory, if pathsList is empty, prompts user to select files								//at present, MUST BE carrage return "\r" delimited list of working file paths (would not be hard to modify this)	Variable isFileDirectorRef		//pass to input fileDirectory Ref in cmdLinePathsList	Variable recreation			//pass to recreate all GUI windows (requires presence of waves and variables listed under ITEMS NECESSARY FOR PORTING	Variable pickParentFolder		//optionally pass (and set equal to 1) to scan an entire folder's subfolders and index ABFs in them. User is prompted to pick parent		String/G selectionIndicatorString = "\f05\K(55555,0,0)"		//sets how selections will be indicated. Setting to "\f01" will make selections bolded in list boxes, and the program will use the presence or absence of "\f01" to determine what has been selected in those lists		Variable fromOldFileDir = 0		//if 1, records original file paths in fileDirectory column 2, in case files are being loaded anew from a different hardrive or path	String outputPaths=""				//stores dialog box path selections		recreation = !ParamIsDefault(recreation) ? recreation : 0; 	Variable numFilesSelected = 0,i,j		//default zero new files selected. If not recreation, this is set to number selected (still might be zero in case of cancel)		WAVE/T/Z fileDirectory		if (!recreation)		//skip in case of recreation		if (strlen(cmdLinePathsList) < 1)					//get info on last used load path (assumed bottom row in fileDirectory, if it exists)			Variable usePathToLastLoadFolder = 0			if (WaveExists(fileDirectory))	//does file directory exist?				Variable lastLoad = dimsize(fileDirectory,0)-1				if ((lastLoad > 0) && strlen(fileDirectory[lastLoad][3]) && strlen(fileDirectory[lastLoad][4]))	// and have strings in places we expect to have parent and subfolde for last load?					String loadStartPath = fileDirectory[lastLoad][3] + fileDirectory[lastLoad][4]					Print "loadStartPath", loadStartPath					Newpath/O/Q/Z fd_folderOfLastLoad, loadStartPath					if (!V_flag)	//new path success						usePathToLastLoadFolder = 1					endif				endif			endif				//prompt used to select files, using last directory if possible    		Variable refNum    		    		if (!ParamIsDefault(pickParentFolder) && pickParentFolder)    			newpath/o/q/z/M="select folder--will scan all subfolders for ABFs" fd_selectParentFolderPath    			if (!V_flag)		//worked    				Variable numCharsPreUnderscore=9    				Variable numCharsPostUnderscle=4    				STring expectedFirstChar="G"    				   					String subFolder,subFolderFiles,fname,subFolderFilePaths,path,fname_pre,fname_post,finalPaths    				Variable numFiles,underscores   				    				String subFolders=sortList(indexeddir(fd_selectParentFolderPath,-1,1),";",16)    				Variable numSubFolders=itemsinlist(subFolders)    				    				for (i=0;i<numSubFolders;i+=1)    					subFolder=stringfromlist(i,subFolders)    					newpath/o/q/z fd_getABFsTemp,subFolder    					subFolderFiles=sortList(IndexedFile(fd_getABFsTemp, -1, ".abf"),";",16)    					subFolderFilePaths=text_appendToStrsInList(subFolderFiles,subFolder+":",1,";")    					numFiles=itemsinlist(subFolderFiles)    					finalPaths=""    					for (j=0;j<numFiles;j+=1)    						fname=replacestring(".abf",stringfromlist(j,subFolderFiles),"")    						fname_pre=stringfromlist(0,fname,"_")    						fname_post=stringfromlist(1,fname,"_")    						underscores=itemsinlist(fname,"_")		//should be 2 not more    						path=stringfromlist(j,subFolderFilePaths)    						if (!stringmatch(fname[0],expectedFirstChar) || (strlen(fname_pre) != numCharsPreUnderscore) || (strlen(fname_post) != numCharsPostUnderscle) || (underscores!=2) )    							print "BAD FILE NAME FOUND--SKIPPING--path",path    						else    							finalPaths+=path+";"    						endif    					endfor    					outputPaths+=finalPaths    				endfor    			else    				return 0    			endif    		    		else    									//variable to store a carriage-return delimited list of the paths of the files selected	    		String fileFilters = "ABF Files (*.abf):.abf;"			//when called by the Open function, this string determines what types of file formats will show	    		fileFilters += "All Files:.*;"							    		if (usePathToLastLoadFolder)	    			Open/D/R/MULT=1/F=fileFilters/P=fd_folderOfLastLoad refNum	//creates dialogue box, use path is to same folder (only works if loading on same computer/file architecture)	    		else	    			Open/D/R/MULT=1/F=fileFilters refNum			//creates dialogue box for user to select files, uses Igor's automatically determined last directory	    		endif	    		outputPaths = S_fileName 	    	endif	    		    	outputPaths=replacestring(";",outputPaths,"\r")	   	else	   		if (!ParamIsDefault(isFileDirectorRef))	   			String fileDirRef = cmdLinePathsList	   			Duplicate/O/T $fileDirRef, fileDirectory_BU		//save file directory as about to overwritten	   			cmdLinePathsList = getWaveRowColAsStringList(fileDirRef, 1, 0, ";")		//make list from first row of file directory, as this is most up to date path.	   			Print "num files found from file directory = " + num2str(ItemsInList(cmdLinePathsList,";"))	   			fromOldFileDir = 1	   		endif	   				   		outputPaths = cmdLinePathsList	   		if (!stringmatch(outputPaths, "*\r*"))		//likely not carriage return delimited	   			Print "assuming input list to abfLoad is SEMICOLON rather than CARRIAGE RETURN (\r) delimited. Using list with semi colons changed to carriage returns"	   			outputPaths = ReplaceString(";", outputPaths, "\r")	   		endif	   	endif	   		 	numFilesSelected = ItemsInList(outputPaths, "\r")	endif    	//Variables used to find out how many new files have been selected (if any) 	      	Variable newFileCreationStartNum	//set to 0, or the next unused file num, if any previous files have been created      	Variable totalNumFiles			//set to sum of numFilesSelected and number of files previously created (0 if this is the first time AL is being run in an experiment)      	      	Variable/G numNonChanFileInfoWaveCols=8			//must update if adding file parameters to fileInfoWave      	      	//check whether file loader has already been started      	Variable loaderPreviouslyInstantiated = Wintype("filePanel")			  	if (!loaderPreviouslyInstantiated && !recreation)		//returns true if NO loader has previously been started. In this case we will instantiate all the necessary Segments	    	//this cannot run during "recreation" as fileDirectory, fileInfoWave, sweepsTracker, fileSelList will be overwritten	      	KillWaves/Z fileSelList,fileNames,numChans,sampleRate			//just in case, get rid of old components				//make arrays that will track file info	      	Make/O/T/N=(numFilesSelected,7) fileDirectory			//this stores the paths of all selected files0th col is file path, 1st is file comment, 2 parent folder path, 3 current parent folder path, 4 file subfolder path, 5, file name only,6, extension only. Basically anything that you want to store about file but not display in fileInfoWve	      dl_assignLblsFromList(fileDirectory,1,0,"currentPath;comment;origParentPath;currentParentPath;subFolderPath;fileName;fileExtension","",0)	      	Make/O/T/N=(numFilesSelected, numNonChanFileInfoWaveCols) fileInfoWave	//one row for each file, one column for each file parameter. This is the listWave for the fileListBox (see naming of columns for the list of each parameter)	      	Make/O/N=(numFilesSelected, numNonChanFileInfoWaveCols) fileSelList      //this list will keep track of selections in the file list box. This is the selWave for the fileListBox	      	Make/O/T/N=(numNonChanFileInfoWaveCols) fileInfoWaveColumnTitles                //one row for each column of fileInfoWave. This is the titleWave for fileListBox\	      	Make/O/T/N=(numFilesSelected) sweepsTracker				//a text wave with one row for each file. Each row (one string) is a semi-colon delimited string list with 0 for unselected and 1 for selected 	    	    	//fileInfoWave columns devoted to bringing files into Igor	    	Variable ro=-1	    	ro+=1;fileInfoWaveColumnTitles[ro] = "Load";setdimlabel 1,ro,$fileInfoWaveColumnTitles[ro]	,fileInfoWave				//allows user to click and load (and preview, if set to do so)				//fileInfoWave columns devoted to giving info on files			ro+=1;fileInfoWaveColumnTitles[ro] = "#";setdimlabel 1,ro,$fileInfoWaveColumnTitles[ro]	,fileInfoWave	    	ro+=1;fileInfoWaveColumnTitles[ro] = "File Names";setdimlabel 1,ro,$fileInfoWaveColumnTitles[ro]	,fileInfoWave	    	ro+=1;fileInfoWaveColumnTitles[ro] = "Rec start time";setdimlabel 1,ro,$fileInfoWaveColumnTitles[ro]	,fileInfoWave	    	ro+=1;fileInfoWaveColumnTitles[ro] = "sRate (Hz)";setdimlabel 1,ro,$fileInfoWaveColumnTitles[ro]	,fileInfoWave	    	ro+=1;fileInfoWaveColumnTitles[ro] = "Len (s)";setdimlabel 1,ro,$fileInfoWaveColumnTitles[ro]	,fileInfoWave	    	ro+=1;fileInfoWaveColumnTitles[ro] = "#SW";setdimlabel 1,ro,$fileInfoWaveColumnTitles[ro]	,fileInfoWave	    	ro+=1;fileInfoWaveColumnTitles[ro] = "CH";setdimlabel 1,ro,$fileInfoWaveColumnTitles[ro]	,fileInfoWave	    		    	//NOTE: additional columns are added to fileInfo wave, number equal to the number of channels of the file with the most channels, a number which is tracked by the variable maxChanNum	    						//set file start num to 0 as no files have previously been loaded		newFileCreationStartNum = 0			//sets index of file loading to 0 as no files have been loaded previously		totalNumFiles = numFilesSelected		//after this (first) round of loading, the number of loaded files in total will be equal to the number selected for loading					else		 //handling of what to do if the loader has previously been started. This function is then only being called to display more files with filePanel	 //this runs even for "recreation" without harm		WAVE/T fileInfoWave			//loads pre-existing fileInfoWave into function		newFileCreationStartNum = DimSize(fileInfoWave,0)		//sets newFileCreationStartNum to the index of the last loaded file + 1 		totalNumFiles = newFileCreationStartNum + numFilesSelected		//after loading, the total number of files loaded will be equal to the number selected for this round + the number previously selected (latter is equal to the number of rows in fileInfoWave at present)				//adjust the number of rows in fileDirectory, fileInfoWave, fileSelList, and sweepsTracker to accomodate the new total number of files		Redimension/N=(totalNumFiles, -1) fileDirectory		//file directory: 1 row per file, 0th col is file path, 1st is file comment, 2 parent folder path, 3 file subfolder path, 4, file name only, 5, extension only. Remaining columns good for storing additional parameters		Redimension/N=(totalNumFiles, -1) fileInfoWave					Redimension/N=(totalNumFiles, -1) fileSelList		Redimension/N=(totalNumfiles) sweepsTracker	endif		//now loop through outputPaths (each function below now does the looping), put paths into fileDirectory, and fill in columns of fileInfoWave	//Along the way, if necessary, increase the number of columns in fileInfoWave as files with more channels are discovered	//skipped if doing recreation (numFilesSelected = 0)	if (numFilesSelected > 0)	      fd_updateFileDirForNewLoad(newFileCreationStartNum, numFilesSelected, outputPaths)	//adds files to file directory	      fd_loadNewWaveInfo(newFileCreationStartNum, numFilesSelected)				//adds file info to fileInfoWave	 endif  	   	//handle actually putting together the GUI, if this the first time the loader is being started	if (!loaderPreviouslyInstantiated || recreation)		if (wintype("filePanel") > 0)			killwindow filePanel		endif		NewPanel/K=1/N=filePanel/W=(0,0,850,405) as "filePanel"		//main panel for file list display		Modifypanel/W=filePanel fixedSize=1				//list box containing file info wave and its associates		ListBox fileListBox,listWave=fileInfoWave,selWave=fileSelList,userColumnResize=1,titleWave=fileInfoWaveColumnTitles,widths={22,30,95,112,38,30,20,15,25},mode=4,proc=fileListBoxAction,pos={0,0},size={600,350},win=filePanel		Listbox fileListBox,win=filePanel,help={"Load: dbl click load col at row or header for selected rows\rSelect chans same way\rPick 2+ rows with shift (disjoint), ctrl+shift (joint), right click (all)\rshift+dbl click headers for find; w/shift to keep old selections; w/shift+alt to remove new matches"}				//some tools for sizing display		Variable bWidth = 80, bHeight = 18, bXStart = 0, bYstart = 350				//make a listbox to quickly select and de-select channels		Variable maxNumChans = DimSize(fileInfoWave,1) -  numNonChanFileInfoWaveCols		Make/O/N=(maxNumChans) channelSelList		Make/O/T/N=(maxNumChans) channelList		Make/O/T channelSelWaveTitles = {"CH"}		for (i=0;i<maxNumChans;i+=1)			channelList[i] = num2str(i)		endfor		ListBox channelSelBox, pos={600,0},size={50,100},selWave = channelSelList, listWave = channelList, titleWave = channelSelWaveTitles, mode=4,proc = channelListBoxAction, win=filePanel		//make a listbox to quickly select and de-select sweeps		Make/O/N=1 sweepsSelList		//just a placeholder for the moment, updates once a file is selected		Make/O/T sweepsListWave = {"No Sel"}		Make/O/T sweepsSelWaveTitles = {"SW"};		ListBox sweepsSelBox, pos={600,100}, size={50,250}, selWave = $"sweepsSelList", listWave = $"sweepsListWave", titleWave = $"sweepsSelWaveTitles", mode=4, proc=sweepListBoxAction, win=filePanel				//create a global string to store selected file comments in, and make a title box to display and update this string		String/G titleBoxString			//stores comments of currently selected files for display		TitleBox commentTitleBox, variable = titleBoxString, fixedSize = 1, frame = 0, pos= {bXstart + 1*bWidth,bYstart + 1*bHeight},size={750-(1*bWidth),bHeight}, win=filePanel				//handle selectionsSummaryDisp. handled by fd_updateSelectionSummaryTB()		String/G selectionsSummaryString		TitleBox selectionSummaryTitleBox, variable = selectionsSummaryString, fixedSize = 1, frame = 0, pos= {bXstart + 1*bWidth,bYstart + 0*bHeight},size={750-(2*bWidth),bHeight}, win=filePanel				//handles whether to automatically save axis scaling when switching between sweeps		NVAR/Z yAxScalingOn,xAxScalingOn		if (!NVAR_Exists(xAxScalingOn))			Variable/G xAxScalingOn = 0		endif		Checkbox xAxScalingOn, variable =  xAxScalingOn, title ="X",pos= {750-(.05*bWidth) + bXstart + 1*bWidth ,bYstart + 0*bHeight}, size={bWidth,bHeight}, win=filePanel,help={"preserve x scaling as new waves are plotted"}		if (!NVAR_Exists(yAxScalingOn))			Variable/G yAxScalingOn = 0		endif		Checkbox yAxScalingOn, variable =  yAxScalingOn, title ="Y",pos= {750-(0.35*bWidth) + bXstart + 1*bWidth ,bYstart + 0*bHeight}, size={bWidth,bHeight}, win=filePanel,help={"preserve y scaling as new waves are plotted"}				//checkbox for whether to overwrite files on load		String overwriteOnLoadHelpStr="Check to force overwriting when loading a wave with the same name as one that already exists"		checkbox fd_overwriteOnLoadCB,title="/O? Save:",pos={750-(1.18*bWidth) + bXstart + 1*bWidth,bYstart+0*bHeight},size={bWidth,bHeight},win=filePanel,help={overwriteOnLoadHelpStr}				//checkbox for whether to load from stored IBWs instead of ABFs		String loadFromIbwNotAbfCB_helpStr="Check to load from IBW path instead of ABF path -- \rSelected file waves must be available in IBW parent folder in a subfolder named the same as the File Name"		checkbox fd_loadFromIbwNotAbfCB,title="IBW",pos={750-(1.7*bWidth) + bXstart + 1*bWidth,bYstart+0*bHeight},size={bWidth,bHeight},win=filePanel,help={loadFromIbwNotAbfCB_helpStr}						//Handles current display window (controlled by newFileDispGraph button)		SVAR/Z currFileDispGraphN		if (!svar_exists(currFileDispGraphN))			String/G currFileDispGraphN = ks_fd_graphNameStart+"0"			display/k=1/n=$currFileDispGraphN			currFileDispGraphN=S_name		endif				//make various buttons		Button addABFs, proc=addABFs, title="Index ABFs", pos = {bXstart,bYstart}, size = {bWidth,bHeight}, win=filePanel	,help=	{"Index new ABFs in the file panel"}	//button that recalls this function to allow more files to be displayed		Button newFileDispGraph, proc=newFileDispGraph, title="New graph", pos = {bXstart + 0*bWidth,bYstart + 1*bHeight}, size = {bWidth,bHeight}, win=filePanel,help=	{"Shift click to bring current to top"}	//button that recalls this function to allow more files to be displayed     	Button setAbfFileParentDir, proc=fd_buttonHandling, title="Set ABF Path", pos = {bXstart + 0*bWidth,bYstart + 2*bHeight}, size = {bWidth,bHeight}, win=filePanel,help=	{"Set a new parent (root) folder for ABF loading"}     	Button setIbwFileParentDir, proc=fd_buttonHandling, title="Set IBW Path", pos = {bXstart + bWidth,bYstart + 2*bHeight}, size = {bWidth,bHeight}, win=filePanel,help=	{"Set a new parent (root) folder for IBW loading/saving"}     	Button saveAbfsAsIbws, proc=fd_buttonHandling, title="ABF->IBW", pos = {bXstart + 2*bWidth,bYstart + 2*bHeight}, size = {bWidth,bHeight}, win=filePanel,help=	{"Load waves as ABFs and save them as IBWs in a parent/root folder set by the Set IBW path button\r(or when you click this, if not set already\rABFs must be available at the ABF path)"}	     	     	//Handle listbox for display preferences selections     	fd_makeDispPrefs()   			     	//Handles listbox for display sweep selections		Make/O/N=(1,2) sweepsDispSelWave		//just a placeholder for the moment, updates once a file is loaded and selected 		Make/O/T/N=(1,2) sweepsDispList		Make/O/T sweepsDispTitleWave = {"Load sweeps", "to display"}				ListBox sweepsDispBox,pos={650,100},size={200,250},selWave=sweepsDispSelWave,listWave=sweepsDispList,titleWave=sweepsDispTitleWave,mode=4,proc=sweepsDispBoxAction,userColumnResize=1,win=filePanel,widths={40,40,20,20}     						//new -- handles value of junction potential for automatic subtraction		//fd_juncPotSetVar controls a global string fd_juncPot that holds the value to add as a junction potential correction		SVAR/Z fd_juncPotStr		if (!Svar_exists(fd_juncPotStr))			String/G fd_juncPotStr=""		//FORMAT see help string		endif		String juncPotHelpStr = "AUTO JUNCTION POTENTIAL CORRECTION [shift+ctrl click to apply; automatically performed for new loads]\rFORMAT: 4-item semi-colon list, items are comma-delimited lists\r"		variable juncPotLen=400 		//juncPotHelpStr+="#0:chanNums to correct\r"		//juncPotHelpStr+="#1:chanName(to apply on condition)\r"		//juncPotHelpStr+="#2:unitStrs(to apply on condition)\r"		//juncPotHelpStr+="#3:vals to subtract\r"		juncPotHelpStr+="Ex: 2,4;ch1_1,ch2_1|ch2_2;V,V;-6.5,-6.5;"		setvariable fd_juncPotSetVar,title="Junction Potential Settings",value=fd_juncPotStr,proc=fd_setVarCtrl,pos={bXstart+3.1*bWidth,bYstart+2*bHeight},size={juncPotLen,bHeight},win=filePanel,help={juncPotHelpStr}				//new -- allow user to set rules to automatically downsample waves as they are loaded		Variable downSampleLen=200		SVAR/Z fd_downSampleStr		if (!Svar_exists(fd_downSampleStr))			string/g fd_downSampleStr=""		//see help string for format		endif		String downSampleHelpStr="AUTO DOWNSAMPLING [shift+ctrl click to apply; automatically performed for new loads]\rleave blank for none; pair \"originSsampleRate0,downsampledSampleRate0;orig1,down1;orig2,down2;...\""		setvariable fd_downSampleSetVar,title="Auto downsample",value=fd_downSampleStr,proc=fd_setVarCtrl,pos={bXstart+3.1*bWidth+juncPotLen,bYstart+2*bHeight},size={downSampleLen,bHeight},win=filePanel,help={downSampleHelpStr}				endif  	   	 if (fromOldFileDir)		//transer original file path  	 	fileDirectory[][2] = fileDirectory_BU[p][2]  	 endifend //end fd_abfLoad()function fd_loadAllFileInfo(pathStr,doRecreation)	String pathStr	Variable doRecreation	//pass 1 to start panel anew after load		pathinfo $pathStr	if (!V_flag)		NewPath/M="Where to store file data (select same folder for loading)"/O $pathStr	endif		String files=IndexedFile($pathStr, -1, ".ibw"),fname		String waves=fd_getGuiWavesList(),waven; variable numwaves=itemsinlist(waves)	String nvars=fd_getGuiNvars(),nvarName;  variable numNvars=itemsinlist(nvars)	string svars=fd_getGuiSvars(),svarName;  variable numSvars=itemsinlist(svars)	String epochInfoWaves_fullPaths,epochInfoWaves_names,path		make/o/n=(numNvars)/d fd_saveNvarsWave	make/o/n=(numSvars)/t fd_saveSvarsWave		String allWaves=waves+"fd_saveNvarsWave;fd_saveSvarsWave;"	Variable fInd,i,numAllWaves=itemsinlist(allWaves)	for (i=0;i<numAllWaves;i+=1)		waveN=stringfromlist(i,allwaves)		fInd=whichListitem(waveN+".ibw",files)		if (fInd >= 0)			fname=stringfromlist(fInd,files)			loadwave/p=$pathStr/o/q/h fname		else			print "missing waveN",waveN		endif	endfor		WAVE/D fd_saveNvarsWave	WAVE/T fd_saveSvarsWave		Variable fullPathsRow=finddimlabel(fd_saveSvarsWave,0,"epochInfoWaves_fullPaths")	Variable namesRow=finddimlabel(fd_saveSvarsWave,0,"epochInfoWaves_names")		epochInfoWaves_fullPaths=fd_saveSvarsWave[fullPathsRow]	epochInfoWaves_names=fd_saveSvarsWave[namesRow]	Variable numEpochInfo=itemsinlist(epochInfoWaves_fullPaths)		fd_checkEpochDir()	for (i=0;i<numEpochInfo;i+=1)		waveN=stringfromlist(i,epochInfoWaves_names)		path=stringfromlist(i,epochInfoWaves_fullPaths)		fInd=whichListitem(waveN+".ibw",files)		if (fInd >= 0)			fname=stringfromlist(fInd,files)			loadwave/p=$pathStr/o/q/h fname			killwaves/Z $path			moveWave $stringfromlist(0,S_waveNames), $path		else			print "missing epochInfo waveN",waveN		endif			endfor		Variable var; string s_var	for (i=0;i<numNvars;i+=1)		nvarName=stringfromlist(i,nvars)		var = fd_saveNvarsWave[%$nvarName]		Variable/G $nvarName		NVAR var2 = $nvarName		var2 = var	endfor	for (i=0;i<numSvars;i+=1)		if ( (i != fullPathsRow) && (i != namesRow) )			svarName=stringfromlist(i,svars)			s_var = fd_saveSvarsWave[%$svarName]			String/G $svarName			SVAR s_var2 = $svarName			s_var2 = s_var		endif	endfor		if (doRecreation)		killwindow/Z filePanel		fd_abfload("",recreation=1)	endifendfunction fd_saveAllFileInfo(pathStr)	String pathStr		pathinfo $pathStr	if (!V_flag)		NewPath/M="Where to store file data (select same folder for loading)"/O $pathStr	endif		WAVE/T fileinfowave			String waves=fd_getGuiWavesList(),waven; variable numwaves=itemsinlist(waves)	String nvars=fd_getGuiNvars(),nvarName;  variable numNvars=itemsinlist(nvars)	string svars=fd_getGuiSvars(),svarName;  variable numSvars=itemsinlist(svars)	String epochInfoWaves_fullPaths="",epochInfoWaves_names=""		String missingWaves="",missingNvars="",missingSvars=""		make/o/n=(numNvars) fd_saveNvarsWave	make/o/n=(numSvars)/t fd_saveSvarsWave		string fullPath	Variable i,numfiles=dimsize(fileinfowave,0),items	for (i=0;i<numfiles;i+=1)		fullPath=fd_getepochinfo(i,0)		epochInfoWaves_fullPaths+=fullPAth+";"		items=itemsinlist(fullPath,":")		epochInfoWaves_names+=stringfromlist(items-1,fullPath,":")+";"	endfor		for (i=0;i<numNvars;i+=1)		nvarName=stringfromlist(i,nvars)		NVAR/Z tempNvar = $nvarName		if (nvar_exists(tempNvar))			fd_saveNvarsWave[i]=tempNvar			setdimlabel 0,i,$nvarname,fd_saveNvarsWave		else			missingNvars+=nvarName+";"		endif	endfor	for (i=0;i<numSvars;i+=1)		svarName=stringfromlist(i,svars)		SVAR/Z tempSvar = $svarName		if (svar_Exists(tempSvar))			fd_saveSvarsWave[i]=tempSvar			setdimlabel 0,i,$svarName,fd_saveSvarsWave		else			missingSvars+=svarName+";"		endif	endfor		insertpoints/m=0 0,2,fd_saveSvarsWave	fd_saveSvarsWave[0]=epochInfoWaves_fullPaths	setdimlabel 0,0,epochInfoWaves_fullPaths,fd_saveSvarsWave	fd_saveSvarsWave[1]=epochInfoWaves_names	setdimlabel 0,1,epochInfoWaves_names,fd_saveSvarsWave		String allWaves=waves+"fd_saveNvarsWave;fd_saveSvarsWave;"+epochInfoWaves_fullPaths	Variable numAllWaves=itemsinlist(allWaves)		for (i=0;i<numAllWaves;i+=1)		waveN=stringfromlist(i,allWaves)		if (WaveExists($waveN))			save/c/o/p=$pathStr $waveN		else			missingWaves+=waveN+";"		endif	endfor		if (itemsinlist(missingwaves) >0)		print "fd_saveAllFileInfo() WARNING missingwaves!!",missingWaves	endif	if (itemsinlist(missingNvars) >0)		print "fd_saveAllFileInfo() WARNING missingNvars!!",missingNvars	endif	if (itemsinlist(missingSvars) >0)		print "fd_saveAllFileInfo() WARNING missingSvars!!",missingSvars	endifendfunction/S fd_getGuiWavesList()	String list="fileDirectory;fileInfoWave;fileInfoWaveColumnTitles;fileSelList;sweepsTracker;channelSelList;channelList;"	list+="channelSelWaveTitles;sweepsSelList;sweepsListWave;sweepsSelWaveTitles;dispPrefsList;dispPrefsSelWave;"	list+="dispPrefsTitleWave;sweepsDispSelWave;sweepsDispList;sweepsDispTitleWave;fileSelListByNums;"	return listendfunction/s fd_getGuiNvars()	String list="numNonChanFileInfoWaveCols;yAxScalingOn;xAxScalingOn;numOfPrimaryFile;"	return listendfunction/s fd_getGuiSvars()	string svars="selectionIndicatorString;titleBoxString;selectionsSummaryString;fd_juncPotStr;fd_downSampleStr;currFileDispGraphN;"	return svarsendfunction fd_loadParentDir(subFolderMatchStr)	String subFolderMatchStr 		//match string for subfolders to consider (for example to avoid those that are already in the panel)	NewPath/O/M="Select PARENT folder/directory (containing subfolders with ABFs)" temp; PathInfo temp	String parentPathStr = S_path	String subFolderPath	String/G loadList = ""	Variable j=0, i=0, totalABFs=0; String currPathStr, abfName, fullPathToABF, abfNamesList	do 		subFolderPath= indexeddir(temp, i, 0)		if (strlen(subFolderPath) == 0)		//break if list is done			break		endif		if (stringmatch(subFolderPath, subFolderMatchStr))	//load only matching files			currPathStr = parentPathStr + subFolderPath			NewPath/O temp2, currPathStr			abfNamesList =  sortlist(indexedfile(temp2,-1,".abf"))			totalABFs += itemsInList(abfNamesList)			for (j=0;j<itemsInList(abfNamesList);j+=1)				abfName = StringFromList(j,abfNamesList)				fullPathToABF = currPathStr + ":" + abfName				loadList += fullPathToABF + "\r"			endfor		endif		i+=1	while (strlen(subFolderPath) > 0)		//break if list is done		print "fd_loadParentDir() FinaL folder COUNT = " + num2str(i) + ". final ABF total = " + num2str(totalABFs)		loadList = sortList(loadList, "\r")	fd_abfLoad(loadList)end//fd_loadParentDirFunction/S DoLoadMultipleFiles()	Variable refNum	String message = "Select one or more files"	String outputPaths	String fileFilters = "Data Files (*.txt,*.dat,*.csv):.txt,.dat,.csv;"	fileFilters += "All Files:.*;" 	Open /D /R /MULT=1 /F=fileFilters /M=message refNum	outputPaths = S_fileName 	if (strlen(outputPaths) == 0)		Print "Cancelled"	else		Variable numFilesSelected = ItemsInList(outputPaths, "\r")		Variable i		for(i=0; i<numFilesSelected; i+=1)			String path = StringFromList(i, outputPaths, "\r")			Printf "%d: %s\r", i, path			// Add commands here to load the actual waves.  An example command			// is included below but you will need to modify it depending on how			// the data you are loading is organized.			//LoadWave/A/D/J/W/K=0/V={" "," $",0,0}/L={0,2,0,0,0} path		endfor	endif 	return outputPaths		// Will be empty if user canceledEnd//DoLoadMultipleFiles()function fd_restoreFileListBoxCols()	ListBox fileListBox win=filePanel,userColumnResize=1,widths={22,30,95,112,38,30,20,15,25}endfunction disp_defaultRange([a])	Variable a		String winn = winname(0,1)		if (!Wintype(winn))		return 0	endif		if (ParamIsDefault(a))		SetAxis bottom 0.0716251, 0.0960181;//0.328773, 0.328773+0.0075 //0.328773, 0.338515//  0.073258, 0.083 //0.077 unitl feb 1 2016	else		if (a==2)			SetAxis  bottom,  0.0716251, 0.0960181; // 0.0111969, 0.0111969 + 0.077 - 0.073258//bottom 0.328773, 0.338515		//new window for 4 step version		else			SetAxis  bottom, 0.0716251, 0.0960181; // 0.073258, 0.083  //bottom 0.0111969, 0.0111969 + 0.077 - 0.073258			endif	endif	SetAxis/A=2/Z L_0	SetAxis/A=2/Z L_1	SetAxis/A=2/Z L_2	SetAxis/A=2/Z L_3	Setaxis/A=2/Z left	setaxis/A=2/Z right	endfunction set2()	SetAxis bottom 0.0110278720001,0.0128665end //iterates through new paths, adds to fileDirectoryfunction fd_updateFileDirForNewLoad(newFileCreationStartNum, numFilesSelected, newPaths)	Variable newFileCreationStartNum, numFilesSelected; String newPaths	WAVE/T fileDirectory		String pathSepStr = ":"		//Igor default      	      	Variable i, currentFileIndex; String currentFilePath      	for(i=0; i<numFilesSelected; i+=1)      		currentFileIndex = i + newFileCreationStartNum			//for i=0, currentFileIndex = i if this is the first time this loop runs. Otherwise if i=0, currentFileIndex = firstNewFileNum + 0      		currentFilePath = StringFromList(i, newPaths, "\r")      		fileDirectory[currentFileIndex][0] = currentFilePath		//stores LAST load path //1st col is reserved for file comments		fileDirectory[currentFileIndex][2] = currentFilePath		//stores INITIAL load path		fileDirectory[currentFileIndex][3] = ParseFilePath(1,currentFilePath,":",1,1)	//stores path up to and inlcuding parent folder (not immediate storage folder, but the folder of the storage folder		fileDirectory[currentFileIndex][4] = ParseFilePath(0,currentFilePath,":",1,1)		//stores file subfolder (the folder in which the file is directly stored) (no extension or period)		fileDirectory[currentFileIndex][5] = ParseFilePath(3,currentFilePath,pathSepStr,0,0)		//grabs file name without extension		fileDirectory[currentFileIndex][6] = ParseFilePath(4,currentFilePath,pathSepStr,0,0)			//grabs extension NO PERIOD      		       	endfor end  function fd_makeDispPrefs()   		//Handles display preferences. One row for each channel. One column for each preference   		   		Variable maxNumChans = fd_getFileInfoWaveMaxChanN()   		     		Variable numPrefs = 4     		Make/O/N=(maxNumChans, numPrefs)/T dispPrefsList     		Make/O/N=(maxNumChans, numPrefs) dispPrefsSelWave     		Make/O/T dispPrefsTitleWave = {"G #", "O/L", "Ax Start", "Ax End"}		//num elements must match numPrefs     		dispPrefsSelWave[][1,numPrefs-1] = 2	//sets as editable     		dispPrefsSelWave[][0] = 0	//sets graph # column as non-editable     		String overlayStringTemp     		Variable j     		//make a string of 0s with a 1 at the position of the current channel, for each channel, and store at channel's row of the first the col of dispPrefsList     		Variable i     		for (i=0;i<maxNumChans;i+=1)     			overlayStringTemp = ""     			dispPrefsList[i][1] = text_getPaddedString(i,maxNumChans,"1","0")     			dispPrefsList[i][0] = num2str(i)     		endfor     		ListBox dispPrefsListBox, proc = dispPrefsListBoxAction, titleWave = dispPrefsTitleWave, selWave = dispPrefsSelWave, listWave = dispPrefsList, pos={650,0},size={200,100}, widths = {20,60,60,60}, win=FilePanelend  function fd_changeFileDirParent()	WAVE/T fileDirectory		if (dimsize(fileDirectory,0) < 1)		print "fd_changeFileDirParent()  load ABFs before changing directory -- first load will automatically set directory"		return 0	endif	String oldPathStr = fileDirectory[0][3]	newpath/o/z/q fileDirParentTemp,oldPathStr		//will cause dialog to start from old folder if possible, doesnt matter if it fails		newpath/o/m="Select parent folder for ABFs (ABFs themselves must be stored in subfolders)"/q/z fileDirParentTemp	if (V_flag)		print "fd_changeFileDirParent() choice of new parent folder failed, aborting"		return 0	endif	pathinfo fileDirParentTemp		String newParentFolderPath = S_Path		//gets parent 	fileDirectory[][3] = newParentFolderPath	fileDirectory[][0] = recreateFileDirPathInIndex(p)	//holds current path		killpath/z fileDirParentTemp end  function/S recreateFileDirPathInIndex(fileRow)	Variable fileRow		WAVE/T fileDirectory			//must match as expected 	Variable fileNameCol = 5, currParentPathCol = 3, currSubFolderCol = 4, currExtensionCol = 6	String recreatedPath = fileDirectory[fileRow][currParentPathCol] + fileDirectory[fileRow][currSubFolderCol] + ":" + fileDirectory[fileRow][fileNameCol] + "." + fileDirectory[fileRow][currExtensionCol]		return recreatedPathend  //now use fd_loadWaveInfo() to add information from file to fileInfoWave and to sweepsTracker. This function also puts the file comment in fileDirectory function fd_loadNewWaveInfo(newFileCreationStartNum, numFilesSelected)	 Variable newFileCreationStartNum, numFilesSelected	        Variable i, currentFileIndex      	for(i=0; i<numFilesSelected; i+=1)    		  		currentFileIndex = i + newFileCreationStartNum      		fd_loadWaveInfo(currentFileIndex)	      	endfor end//takes in a file number and fills in the file's information in fileInfoWave, getting the file path from fileDirectory//also adds columns to fileInfo fileInfoWave, fileSelList, fileInfoWaveColumnTitles (actually rows for this last one)//if a new file has more channels than any previously dispayed file//also loads a string list into the input file's row in sweepsTracker, length = numSweepsfunction fd_loadWaveInfo(fileNum)           	Variable fileNum;        	WAVE/T fileInfoWave, fileDirectory, fileInfoWaveColumnTitles, fileSelList, sweepsTracker    	NVAR numNonChanFileInfoWaveCols			//this has stored the number of columns in fileInfoWave that are not used to represent channels    	    	Variable maxNumChans = DimSize(fileInfoWave,1) - numNonChanFileInfoWaveCols 	//difference is current number of channel-representing columns (0 if no files loaded yet)    		String pathTemp = fileDirectory[fileNum][0]    	da_openABF(pathTemp)                                    //openABF opens a file for use by the Bruxton add ons    	    	//place comment in second column of fileDirectory    	fileDirectory[fileNum][1] = da_getOpenFileComment()							//gets comment from open file    	    	//populate fileInfoWave parameters. Currently order of columns is: [0] = "Load"'; [1] = "Unpack"	; [2] = "File Names"; [3] = "Rec start time"; [4] = "sRate (Hz)"; [5] = "#Sweeps"; [6] = "#CHs";     	fd_markFileUnloaded(0)		//empty string indicates not loaded    	fileInfoWave[fileNum][1] = num2str(fileNum)    	fileInfoWave[fileNum][2] = getFileNameFromPath(pathTemp)   				//gets file name for a file path					//getFileNameFromPath  da_getOpenFileCreationTime  da_getOpenFileSampleRate  da_getOpenFileNumSweeps  da_getOpenFileNumChans    	fileInfoWave[fileNum][3] = da_getOpenFileCreationTime()						//gets open file creation time    	Variable sRate = da_getOpenFileSampleRate()    	fileInfoWave[fileNum][4] = num2str(sRate)				//gets sample rate    	    	fileInfoWave[fileNum][5] = num2str(da_getOpenFileSweepLen(0) / sRate)    	    	//do same for file number of sweeps and number of channels, but store this for reference below    	Variable numSweeps = da_getOpenFileNumSweeps()							//gets num sweeps    	fileInfoWave[fileNum][6] = num2str(numSweeps)	    	    	Variable numChans = da_getOpenFileNumChans()										//gets num chans    	fileInfoWave[fileNum][7] = num2str(numChans)    		//fill in file's row in sweepsTracker with a string list, one element for each sweep. Currently the default is all sweeps selected, so all elements = "1"	sweepsTracker[fileNum] = text_makeStringList("1", numSweeps,";")			//returns a string list of "1"s, num elements = numSweeps, semi-colon delimited   			    			      	   	if (numChans > maxNumChans)	//updates maximum channel number   		maxNumChans = numChans   	endif   	   	Variable i   	Variable totalListBoxColumnsNeeded = maxNumChans + numNonChanFileInfoWaveCols   	   	//If necessary because more channels now need to be displayed, updates number of columns in fileInfoWave and fileInfoWaveColumn titles	if (totalListBoxColumnsNeeded > DimSize(fileInfoWave,1))					Redimension/N=(-1,totalListBoxColumnsNeeded) fileInfoWave, fileSelList		Redimension/N=(totalListBoxColumnsNeeded) fileInfoWaveColumnTitles		//add column titles for new channel-representing columns		for (i=0;i<numChans;i+=1) 			fileInfoWaveColumnTitles[numNonChanFileInfoWaveCols+i] = num2str(i)			setdimlabel 1,numNonChanFileInfoWaveCols+i,$("CH_"+num2str(i))	,fileInfoWave		endfor	endif    		    	    	//update channel-representing cells to display the units for each channel, and set these channels to a default of selected for loading/display    	for (i=0;i<numChans;i+=1)    		fileInfoWave[fileNum][numNonChanFileInfoWaveCols+i] = da_getOpenFileChanUnits(i) 		//stores the channel units in each appropriate column for the current file    		fileInfoWave[fileNum][numNonChanFileInfoWaveCols+i] += num2str(da_getOpenFileChanDigIn(i))		//stores the channel digital input number next to the units for each channel    		fd_setChanSelected(fileNum,i,1)												//sets all channels selected by default! Change default here (1 = selected, 0 = unselected)    	endfor  	    	    	da_fd_calcStimInfo(fileNum,"","",usePreOpenedABF=1)    	    	da_closeABF()		//close abf because completed working with it. This allows another to be opened later without errorend //addInfoToFileInfoWave/////////////////////////////////////////////////////////////////////////////////////////Action response functions (non-button)function fileListBoxAction(s) : ListBoxControl	STRUCT WMListBoxAction &s	Variable clickType = guiC_SL_lbSelectionHandling(s, "fileSelListByNums", "fileSelList")		//allows multiple and disjoint selections with shift		//new ctrl f handling for find file	Variable handledFind = guiC_lb_findText(s) >= 0	if (handledFind)		updateSelListByNums("fileSelList", "fileSelListByNums")	//update by nums list		fd_updateSweepsDisplay()	//listbox		return handledFind	endif			if ( (s.eventcode == 8) && ((s.eventMod & 2^1) != 0) )	//addition 1/14/18 shift with scroll moves DOWN by one selection		guiC_lb_moveToSel("filePanel","fileListBox","fileSelList",1)	endif 	if (!((s.eventCode==1) || (s.eventCode==3) || (s.eventCode==4) || (s.eventCode==5)))	//only permits mouse down, double click, cell selection +/- shift to run rest of function		return 0	endif			WAVE/T fileInfoWave		if ((s.row > DimSize(fileInfoWave,0) - 1))		return 0			endif		WAVE fileSelListByNums	Variable i, currFileNum	NVAR numNonChanFileInfoWaveCols		Variable clickedRow = s.row	Variable clickedCol = s.col	Variable files = DimSize(fileSelListByNums,0)          //looks for double clicks, and calls function to select or deselect channel accordingly	if (s.eventCode == 3)	//signifies double click			//CHANNEL SELECTIONS: double click will toggle whether a channel is selected 		if (clickedCol > numNonChanFileInfoWaveCols-1)		//checks that clicked column is a column for a channel selection			if (clickedRow == -1)		//header click -- toggle this channel for all selected files				for (i=0;i<files;i+=1)		//iterate selected files					currFileNum = fileSelListByNums[i]					fd_setChanSelected(currFileNum, clickedCol - numNonChanFileInfoWaveCols, !fd_isChanSelected(currFileNum, clickedCol - numNonChanFileInfoWaveCols))	//toggle file channel					endfor						else    			fd_setChanSelected(clickedRow, clickedCol - numNonChanFileInfoWaveCols, !fd_isChanSelected(clickedRow, clickedCol - numNonChanFileInfoWaveCols))		//toggle clicked file channel    		endif    	endif		   				//LOADING: double click will toggle whether file is loaded. Loaded files are signified by "L" modified by selectionIndicatorString		if (clickedCol == 0)	//click in load indicator column			if ( (clickedRow == -1) || igor_is64() )	//header click -- toggle loading of all selected files OR igor 64 -- in that case handle one and multiple files the same way				String toLoadFromIgor32List=""				variable len = files,neededLoading				for (i=0;i<len;i+=1)					currFileNum = fileSelListByNums[i]					neededLoading=fd_toggleFileLoad(currFileNum)					if (igor_is64() && neededLoading)		//if a file has been loaded from 64 bit, move to special handling function which will wait for 32 bit to complete its load						toLoadFromIgor32List+=num2str(currFileNum)+";"					endif				endfor										//if Igor 64, load any waves				if (itemsinlist(toLoadFromIgor32List)>0)					fd_callLoadAbfAndStore(toLoadFromIgor32List,1,0)				endif							else		//single file, not Igor 64				fd_toggleFileLoad(clickedRow)   	//single file row click -- toggle loading of this file			endif 					endif			endif    		if (clickedRow > -1)		fd_updateCommentDisplay(clickedRow)		//changes comment box to display only last clicked row					//SINGLE CLICKS WITHIN FILE ROWS AND clickType == 1 (see guiC_SL_lbSelectionHandling()): change primary file)		if ((clickedCol < numNonChanFileInfoWaveCols)	&& (clickType == 1))			fd_setPrimaryFileNum(clickedRow)			fd_updateSweepsDisplay()			//changes sweeps box to display sweeps from only last clicked row					//show first sweep traces		WAVE/Z sweepsDispSelWave, sweepsDispSelWaveByNums		//check that sweepsDispSelWave exists and make if not			if (!WaveExists(sweepsDispSelWave) ||  !WaveExists(sweepsDispSelWaveByNums))				Make/O/N=1 sweepsDispSelWave, sweepsDispSelWaveByNums			endif		//update display lists, defaulting to show the first trace, then call fd_updateGraph()		sweepsDispSelWave[0] = 1; Redimension/N=1 sweepsDispSelWaveByNums; sweepsDispSelWaveByNums = 0		fd_updateGraph()			//	Print s.eventMod, clickedcol			if ( (clickedcol == 1) && (s.eventMod & 2^2))				ToCommandLine fileInfoWave[clickedRow][clickedCol] +";"			endif		endif	endif    		fd_updateSelectionSummaryTB()	fd_updateSweepsDisplay()		//NEW: handling for annotation windows. Start with fd_annotationWin	fd_annotationWinHook(s)endfunction guiC_lb_moveToSel(winN,lbName,selWaveName,numFromCurrent)	String winN,lbName,selWaveName	Variable numFromCurrent		controlinfo $lbname	variable i	WAVE wv = $S_value	WAVE selWv = $selWaveName	if (!WaveExists(wv))		return 0	endif	variable rows = dimsize(Wv,0)	for (i=V_startRow+1;i<rows;i+=1)		if (selWv[i])			Listbox $lbname win=$winN, row = i			break		endif	endforend//update 180721: monitors whether loading from 32 bit Igor and waits for load to complete if so//190731 seems I deleted this at some point, not sure if that's workingfunction fd_toggleFileLoad(fileNum)	Variable fileNum		Variable neededLoading			WAVE/T filedirectory	variable minFileNum = 0, maxFileNum = dimsize(filedirectory,0) - 1		if ( (fileNum < minFileNum) || (fileNum >maxFileNum) )		Print "fd_toggleFileLoad(): attempt to index file num out of range. File",fileNum, "this is an error I've been trying to track down!"	endif			if  (fd_isFileLoaded(fileNum))		fd_unloadFile(fileNum)		neededLoading=0	else		neededLoading=1		controlinfo/W=filePanel fd_loadFromIbwNotAbfCB		Variable forceIbwLoad = V_Value		//0 if unchecked, 1 if checked		fd_loadFile(fileNum,forceIbwLoad=forceIbwLoad)	endif		return neededLoadingendfunction fd_isFileLoaded(fileNum)	Variable fileNum			return strlen(fd_getFLoadStrInFileInfoWave(fileNum)) > 0end//PRIMARY FILE LOADING FUNCTION. Uses fd_loadFileChannelFunction//170810: updated to check for and calculate epoch information if absent on call//180721: updated to check if in 64 bit IGor (can't use bruxton) and then ask a 32-bit to load for it//190731: apparently I've since deleted that stuff.. did I move it somewhere else?function/S fd_loadFile(fileNum,[bypassLoadCheck,maxNumSweeps,ignoreChanSels,ignoreSweepSels,skipOverwritePrefCheck,forceIbwLoad])	Variable fileNum	Variable bypassLoadCheck			//pass to load even when already marked as loaded	Variable maxNumSweeps	Variable ignoreChanSels,ignoreSweepSels		//optionally ignore user channel or sweep selections in file panel, just load all channels .. these may not be easily killed from filePanel after	Variable skipOverwritePrefCheck	//pass to skip checking of /O checkbox overwrite check preference. If this is not passed or 0, the wave is not loaded if it already exists unless /O is checked	Variable forceIbwLoad		//pass to attempt load from ibw path instead of abf path (handled by main function fd_storeAbfsAsIbws())		Variable attemptIbwNotAbfLoad = igor_is64() || igor_isMac() || forceIbwLoad		Variable doSkipOverwritePrefCheck = !ParamIsDefault(skipOverwritePrefCheck) && skipOverwritePrefCheck			Variable doIngoreChanSels = !ParamIsDefault(ignoreChanSels) && ignoreChanSels	Variable doIgnoreSweepSels = !ParamIsDefault(ignoreSweepSels) && ignoreSweepSels	Variable doForceIbwLoad = !paramisdefault(forceIbwLoad) && forceIbwLoad	Variable passedMaxNumSweeps = ParamIsDefault(maxNumSweeps)  ? NaN : maxNumSweeps		//passing NaN causes maxNumSweeps to be ignored here and in called function		WAVE/T fileInfoWave		//check if this wave has already been loaded, and skip if so	String fileLoadIndicatorString = fd_getFLoadStrInFileInfoWave(fileNum)	if ((strlen(fileLoadIndicatorString) > 0) && (ParamIsDefault(bypassLoadCheck)||!bypassLoadCheck))		return ""	endif		String loadedWaveList = ""		//handles indicating that this file has been loaded	String ibwLoadSymbolicPathNameStr=""		//"" will cause to be ignored in fd_loadFileChannel	if (attemptIbwNotAbfLoad)			pathinfo fd_storeAbfAsIbwPath		//check if a path to the ibws is set, see if user wants to set one		if (!V_flag)			Variable pathIsSet = fd_changeStoreAbfAsIbwPath("",msg="If files were previously stored as ibws (following filePanel naming), set path to parent folder")			if (!pathIsSet)				print "fd_loadFile() user canceled set path to abfs stored as ibws"				return ""			endif						pathinfo fd_storeAbfAsIbwPath			if (!V_flag)				print "fd_loadFile() could not find set path to abfs stored as ibws. Use set IBW path button to help find them."				return ""						endif		endif				//parent path is good, so see if file path is good		String ibwLoadPathStr = fd_getIbwSavePathFileFolder(S_Path,fileNum)		newpath/o/q fd_ibwLoadSubPathTemp,ibwLoadPathStr		if (V_flag)			print "fd_loadFile() no path to ibws for file, aborting. Uncheck \"IBW\" checkbox to load from ABF instead, if available. Use Set IBW or Set ABF path to help filePanel navigate to them"			return ""		endif				ibwLoadSymbolicPathNameStr="fd_ibwLoadSubPathTemp"	endif	fd_getEpochInfo(fileNum,0) //check for epoch info and calculate if absent. to turn off calculating change second param to 0	Variable i,maxChanNum=fd_getChanNFromFileInfoWave(fileNum)	for (i=0;i<maxChanNum;i+=1)		if (doIngoreChanSels || fd_isChanSelected(fileNum, i))			loadedWaveList += fd_loadFileChannel(fileNum, i, maxNumSweeps=passedMaxNumSweeps,ignoreSweepSels=doIgnoreSweepSels,skipOverwritePrefCheck=doSkipOverwritePrefCheck,ibwLoadSymbolicPathNameStr=ibwLoadSymbolicPathNameStr)		endif	endfor		fd_markFileLoaded(fileNum)	doupdate;//updates display after file is loaded	if (attemptIbwNotAbfLoad)		killpath/z fd_ibwLoadSubPathTemp	endif		return loadedWaveListendfunction/S fd_storeAbfsAsIbws(firstFileNum,numFiles)	Variable firstfileNum	//first file to store (as numbered in filePanel)	Variable numFiles		//num files to store		WAVE/T fileInfoWave	Variable totalNumFiles=dimsize(fileInfoWave,0)		if (numtype(firstFileNum))		firstFileNum = 0		numFiles = totalNumFiles		prompt firstfileNum,"Start with fileNum"		prompt numFiles,"# Files to Save"		doPrompt "Choose first file and number to save (Default is all)",firstFileNum,numFiles		if (V_flag)			print "fd_loadFile() user canceled copying ABFs to IBWs"			return ""		endif	endif		pathinfo fd_storeAbfAsIbwPath	if (!V_flag)		Variable pathIsSet = fd_changeStoreAbfAsIbwPath("")		if (!pathIsSet)			return ""		endif	endif	pathinfo fd_storeAbfAsIbwPath	String parentPathStr = S_path	Variable i,endNum = min(firstFileNum+numFiles,totalNumFiles),j,numLoaded	String pathForFile,wavesForFile,preExistingWaves = wavelist("*_AD*",";",""),wvname	for (i=firstfileNum;i<endNum;i+=1)		pathForFile = fd_getIbwSavePathFileFolder(parentPathStr,i)		newpath/o/c/Q/Z fd_abfToIbwSaveSubPathTemp,pathForFile		if (V_flag)		//set subolder path failed			print "fd_storeAbfsAsIbws() failed to set save (sub) folder for fileNum",i,"file name",fileInfoWave[i][2],"skipping IBW save for this file. This shouldnt happen!"			continue					endif		wavesForFile = fd_loadFile(i,bypassLoadCheck=1,ignoreChanSels=1,ignoreSweepSels=1,skipOverwritePrefCheck=1)		//loads file, not based on user preferences 		save/b/c/o/p=fd_abfToIbwSaveSubPathTemp wavesForFile		numLoaded = itemsinlist(wavesForFile)		for (j=0;j<numLoaded;j+=1)	//attempt to avoid killing pre-existing waves			wvname = stringfromlist(j,wavesForFile)			if (whichlistitem(wvname,preExistingWaves) < 0)				killwaves/Z $wvname			endif		endfor		fd_markFileUnloaded(i)	endfor		killpath/Z fd_abfToIbwSaveSubPathTempendfunction fd_changeStoreAbfAsIbwPath(newFullPathStr,[msg])	String newFullPathStr //pass "" for user prompt	String msg		if (strlen(newFullPathStr) > 0)		newpath/o/q fd_storeAbfAsIbwPath,newFullPathStr		if (!V_flag)		//path was set successfully			return 1		endif	endif		String msgUsed = selectstring(ParamIsDefault(msg),msg,"Select folder to store ibws as abfs")	//default to user prompt	newpath/o/m=(msgUsed)/q fd_storeAbfAsIbwPath	if (V_flag)		print "fd_changeStoreAbfAsIbwPath() failed set path to store ibws from abfs"		return 0	endif		return 1end//if your abfs didnt have unique names, can change this naming scheme to something elsefunction/S fd_getIbwSavePathFileFolder(parentPathStr,fileNum)	Variable fileNum; String parentPathStr		WAVE/T fileInfoWave	String fileName = fileInfoWave[fileNum][2]	return parentPathStr + fileNameendstrconstant selectionIndicatorString =  "\f05\K(55555,0,0)"	function fd_markFileLoaded(fileNum)	Variable fileNum		WAVE/T fileInfoWave		fileInfoWave[fileNum][0] = selectionIndicatorString + "L"endfunction fd_markFileUnloaded(fileNum)	Variable fileNum		WAVE/T fileInfoWave		fileInfoWave[fileNum][0] = ""end //could be improved..currently keeps checking with the user to kill displayed sweeps (unless only displayed on the main graph)//should probably just check once a file then save that preferencefunction fd_unloadFile(fileNum,[noUpdates])	Variable fileNum	Variable noUpdates	//optionally pass true to suppress updates (much faster, but can't see progress of deletions)			Variable symbolToUnloadedForFailures = 1		//set as true to remove load symbol from file with fileNum even in the case where some or all of the waves were not killed (my default is to set as true)		WAVE/T fileInfoWave 		fd_clearFileDispGraph()		//if using this, parameter graphsCleared passed to unloadSweeps should be 1			Variable numSweeps = fd_getSweepNFromFileInfoWave(fileNum)	Variable i	String killCancelsAndFails = ""		for (i=0;i<numSweeps;i+=1)		killCancelsAndFails += fd_unloadSweep(fileNum, i,0,1)		//sets this not to deselect the sweeps by default	endfor		if (itemsinlist(killCancelsAndFails) > 0)		if (symbolToUnloadedForFailures)			Print "fd_unloadFile(): fileNum=",fileNum,"Failed to kill the following wave(s):"+killCancelsAndFails,"File now set to unloaded."			fd_markFileUnloaded(fileNum)	//indicates file no longer loaded		else			Print "fd_unloadFile(): fileNum=",fileNum,"Failed to kill the following wave(s):"+killCancelsAndFails,"File remains set to loaded (though load may now be partial)"		endif	else		fd_markFileUnloaded(fileNum)	endif	if (ParamIsDefault(noUpdates) || !noUpdates)		doupdate;	endifendfunction/S fd_unloadSweep(fileNum, sweepNum, deselectSweep, graphs_clearPerformed)	Variable fileNum, sweepNum, deselectSweep	Variable 	graphs_clearPerformed		//this function will not attempt to clear the graph if calling function passes true for this, usually the callign function has attempted to clear the graph already			Variable promptBeforeWillKill = 0	//set as true to ask user before killing windows with waves that were requested to be killed. dramatically slows the speed of unload files. 												//performance could probably be increased by performing this check on a per-file rather than per-sweep basis, but I haven't bothered implementing	String killCancelsAndFails = ""		if (!graphs_clearPerformed)		//avoids redundency (at risk of errors) by allowing functions calling this function to perform this themselves		fd_clearFileDispGraph()	endif		Variable numChans = fd_getChanNFromFileInfoWave(fileNum)		Variable i; String currWaveName		if (promptBeforeWillKill)		for (i=0;i<numChans;i+=1)			currWaveName = fd_getFileName(fileNum, sweepNum, i)			killCancelsAndFails += disp_killWinsWithWave(currWaveName,promptBeforeWillKill,1)		endfor	else		for (i=0;i<numChans;i+=1)			currWaveName = fd_getFileName(fileNum, sweepNum, i)			KillWaves/Z $currWaveName			if (WaveExists($currWaveName))				//Print "Warning: file \"unloaded\" but wave (" + currWaveName + ") could not be killed. Likely used by window. (Ignore if wave intentionally still loaded.)"			endif		endfor	endif		if (deselectSweep)		WAVE/T sweepsTracker				String sweepSelections = sweepsTracker[fileNum]		sweepSelections[2*sweepNum] = "0"				sweepsTracker[fileNum] = sweepSelections	endif		return killCancelsAndFailsendfunction/S fd_loadFileChannel(fileNum, chanNum, [maxNumSweeps,ignoreSweepSels,skipOverwritePrefCheck,ibwLoadSymbolicPathNameStr])	Variable fileNum, chanNum	Variable maxNumSweeps	Variable ignoreSweepSels		//optionally ignore user channel or sweep selections in file panel, just load all channels	Variable skipOverwritePrefCheck	//pass to skip checking of /O checkbox overwrite check preference. If this is not passed or 0, the wave is not loaded if it already exists unless /O is checked	String ibwLoadSymbolicPathNameStr	//pass the name of a valid symbolic path to a folder containing ibws of the file chan of interest		Variable doSkipOverwritePrefCheck = !ParamIsDefault(skipOverwritePrefCheck) && skipOverwritePrefCheck	Variable doIgnoreSweepSels = !ParamIsDefault(ignoreSweepSels) && ignoreSweepSels	Variable doIbwLoad = !ParamIsDefault(ibwLoadSymbolicPathNameStr) && (strlen(ibwLoadSymbolicPathNameStr) > 0)			String channelAppendString = "_AD"	String loadedWaveList = ""		WAVE/T fileDirectory, fileInfoWave, sweepsTracker			//get file name to use as prefix for wave names	String fName = fd_getFNameFromFileInfoWave(fileNum,0)	String fPath = fileDirectory[fileNum][0]	String sweepSelectionsStr = sweepsTracker[fileNum]			//semi colon delimited list 1 to load each sweep, carriage return delimited for each channel		String outputName = fName + channelAppendString + num2str(chanNum)		if (!doIbwLoad)		da_openABF(fPath)		//opens ABF file for loading	endif		String tempSweepWaveRef = "loadingSweepTemp"		Variable totalNumSelectedSweeps = fd_getTotalNumSelSweeps(fileNum)	if (totalNumSelectedSweeps < 1)		Print "No sweeps selected. Choose a file, choose sweeps, then double click the sweep list box title to select sweeps"		return ""	endif		Variable loadedSweepNum = -1		//keeps track of the current sweep number. We'll build an array where each row is a sweep, and the 0th col is the 0th sweep, 1st col 1st sweep, and so on		Variable i; String finalWaveName	Variable maxSweeps = fd_getSweepNFromFileInfoWave(fileNum)	if (!ParamIsDefault(maxNumSweeps) && !numtype(maxNumSweeps))		maxSweeps = maxNumSweeps	endif	for (i=0;i<maxSweeps;i+=1)		if (doIgnoreSweepSels || stringmatch(StringFromList(i,sweepSelectionsStr,";"),"1"))			finalWaveName = fd_getWaveLoadName(fileNum, i, chanNum)			//returns cellName_fileName_(sweepNum+1)_AD(chan#)			if (doIbwLoad)				loadwave/p=$ibwLoadSymbolicPathNameStr/h/q/o (finalWaveName+".ibw")				loadedWaveList += S_wavenames			else				da_makeWaveFromOpenFile(i, chanNum, finalWaveName,skipOverwritePrefCheck=doSkipOverwritePrefCheck)			//opens 				if (waveExists($finalWaveName))		//maybe not the best way to track this?					loadedWaveList += finalWaveName + ";"				endif			endif		endif	endfor		if (!doIbwLoad)		da_closeABF()		//closes ABF so another can be loaded later	endif			//handle junction potential correction for waves at this channel,if any	Variable numWaves=itemsinlist(loadedWaveList)	String waveRef=stringfromlist(0,loadedWaveList)	if (numWaves)		String juncPotStr_mV = fd_getJuncPotStrForFile(fileNum,chanNum,waveRef)		for (i=0;i<numWaves;i+=1)			waveRef=stringfromlist(i,loadedWaveList)			fd_applyJuncPotToLoadedWv(waveRef,juncPotStr_mV)		endfor	endif		return loadedWaveListend//these two functions, fd_getJuncPotStrForFile then fd_applyJuncPotToLoadedWv, handle junction potentials from the fd_juncPotStr setvariablefunction/S fd_getJuncPotStrForFile(fileNum,chanNum,exWaveRef)	Variable fileNum,chanNum; String exWaveRef		//need to check the note to get ch_name info; probably could get this another way without requiring the wave...		SVAR/Z fd_juncPotStr	if (Svar_exists(fd_juncPotStr) && itemsinlist(fd_juncPotStr))		String chanNumList = replacestring(",",stringfromlist(0,fd_juncPotStr),";")		Variable listPos = WhichListItem(num2str(chanNum), chanNumList)		if (listPos >= 0)			String wavenote = note($exWaveRef)			String ch_name = stringbykey("CH_NAME",wavenote)			String chNameMatchStrList = replacestring(",",stringfromlist(1,fd_juncPotStr),";")			String chNameMatchStr = replacestring("|",stringfromlist(listPos,chNameMatchStrList),";")			if (text_matchToListOfMatchStrs(ch_name,chNameMatchStr))				String ch_units = stringbykey("CH_UNITS",wavenote)				String chUnitsMatchStrList = replacestring(",",stringfromlist(2,fd_juncPotStr),";")				String chUnitsMatchStr = stringfromlist(listPos,chUnitsMatchStrList)				if (stringmatch(ch_units,chUnitsMatchStr))					String juncPotList = replacestring(",",stringfromlist(3,fd_juncPotStr),";")					String juncPotStr_mV = stringfromlist(listPos,juncPotList)	//junction potential in mV					return juncPotStr_mV				endif			endif		endif		endif		return ""endfunction fd_applyJuncPotToLoadedWv(waveRef,juncPotStr_mV)	String waveRef; String juncPotStr_mV	//junction potential as a string, in mV		if ( (strlen(waveRef)==0) || (strlen(juncPotStr_mV)==0) )		return 0	endif	WAVE/Z wv = $waveRef	if (!waveexists(wv))		return 0	endif		String keyStr="ADDED_JUNCTION_POTENTIAL_MV"		Double juncPot = str2num(juncPotStr_mV) * 0.001		String notestr=note($waveRef)	String prevJuncPotStr=stringbykey(keyStr,notestr)	Variable prevJuncPot = str2num(prevJuncPotStr)		if ( (strlen(prevJuncPotStr) < 1) || (numtype(prevJuncPot) > 0) )		prevJuncPot = 0	endif		if (numtype(juncPot))		return 0	endif		wv+=juncPot-(prevJuncPot*0.001)		//undo any previous junction potential correction		notestr=ReplaceStringByKey(keyStr, notestr, juncPotStr_mV)	note/nocr wv, notestrendfunction fd_setVarCtrl(s) : SetVariableControl	STRUCT WMSetVariableAction &s		//ctrl + shift + click to apply run all actions at present	if ( (s.eventcode==9) && ((s.eventmod & 2^1)>0) && ((s.eventmod & 2^3)>0) )		fd_applySetVarToLoadedFiles(s.ctrlname)	endif		return 0Endfunction fd_applySetVarToLoadedFiles(ctrlName)	String ctrlName	WAVE/T sweepsDispList	Variable i,numSweeps=dimsize(sweepsDispList,0),numChans=dimsize(sweepsDispList,1)-2,chanNum,fileNum	String ref,juncPotStr_mV	for (i=0;i<numSweeps;i+=1)		for (chanNum=0;chanNum<numChans;chanNum+=1)			ref=sweepsDispList[i][2+chanNum]			if (chanNum==0)				fileNum=text_getInfoFromWaveName_V(ref, 1)			endif						strswitch (ctrlName)				case "fd_juncPotSetVar":					juncPotStr_mV=fd_getJuncPotStrForFile(fileNum,chanNum,ref)					fd_applyJuncPotToLoadedWv(ref,juncPotStr_mV)					break				case "fd_downSampleSetVar":					fd_downsampleIfNeeded(ref)					break 			endswitch		endfor	endforendfunction/S fd_loadSweep(fileNum, chanNum, sweepNum, overwrite [isPreloaded])	Variable fileNum, chanNum, sweepNum	Variable overwrite 		//pass 0 to do nothing if file is loaded, 1 to overwrite file. Behavior isn't affected by this if file isn't loaded	Variable &isPreLoaded	//pass to have set to 1 if wave was loaded before this function was called		String channelAppendString = "_AD"		WAVE/T fileDirectory, fileInfoWave, sweepsTracker		String finalWaveName = fd_getWaveLoadName(fileNum, sweepNum, chanNum)			//returns cellName_fileName_(sweepNum+1)_AD(chan#)	Variable isPreLoaded_localVar = WaveExists($finalWaveName)		if (!ParamIsDefault(isPreLoaded))		isPreLoaded = isPreLoaded_localVar	endif	if (isPreLoaded_localVar && !overwrite)		//if wave exists and were not overwriting, do nothing		return finalWaveName			endif		Variable maxSweeps = fd_getSweepNFromFileInfoWave(fileNum)		if (sweepNum > maxSweeps - 1)		return ""	endif		//get file name to use as prefix for wave names	String fName = fd_getFNameFromFileInfoWave(fileNum,0)	String fPath = fileDirectory[fileNum][0]	String sweepSelectionsStr = sweepsTracker[fileNum]			//semi colon delimited list 1 to load each sweep, carriage return delimited for each channel		String outputName = fName + channelAppendString + num2str(chanNum)		da_openABF(fPath)		//opens ABF file for loading		da_makeWaveFromOpenFile(sweepNum, chanNum, finalWaveName)			//opens 	da_closeABF()		//closes ABF so another can be loaded later			return finalWaveNameend//sweep num input is 0 to N-1 for N sweeps in a file, but output is fName _ (Sweepnum + 1) _ as for Bruxton standard namingfunction/S fd_getWaveLoadName(fileNum, sweepNum, chanNum)	Variable fileNum, sweepNum, chanNum	WAVE/T fileInfoWave		String channelAppendString = "_AD"		String fName = fd_getFNameFromFileInfoWave(fileNum,0)		return fName + "_" + num2str(sweepNum+1) + channelAppendString + num2str(chanNum)end//iterate through and do not keep individual wavesfunction fd_loadFileChannelToAvg(fileNum, chanNum, avgOutRef)	Variable fileNum, chanNum; String avgOutRef		String channelAppendString = "_AD"		WAVE/T fileDirectory, fileInfoWave, sweepsTracker		//get file name to use as prefix for wave names	String fName = fd_getFNameFromFileInfoWave(fileNum,0)	String fPath = fileDirectory[fileNum][0]	String sweepSelectionsStr = sweepsTracker[fileNum]		da_openABF(fPath)		//opens ABF file for loading		String tempSweepWaveRef = "loadingSweepTemp"		Variable totalNumSelectedSweeps = fd_getTotalNumSelSweeps(fileNum)	if (totalNumSelectedSweeps < 1)		Print "No sweeps selected. Choose a file, choose sweeps, then double click the sweep list box title to select sweeps"		return 0	endif		Variable loadedSweepNum = -1		//keeps track of the current sweep number. We'll build an array where each row is a sweep, and the 0th col is the 0th sweep, 1st col 1st sweep, and so on		Variable i; String tempWaveName		for (i=0;i<fd_getSweepNFromFileInfoWave(fileNum);i+=1)		if (stringmatch(StringFromList(i,sweepSelectionsStr,";"),"1"))			tempWaveName = fName + "_" + num2str(i+1) + channelAppendString + num2str(chanNum) + "T"			da_makeWaveFromOpenFile(i, chanNum, tempWaveName)			if (i == 0)				Duplicate/O $tempWaveName, tempForOut				String juncPotStr_mV=fd_getJuncPotStrForFile(fileNum,chanNum,tempWaveName)				fd_applyJuncPotToLoadedWv("tempForOut",juncPotStr_mV)			else				Duplicate/O $tempWaveName, tempToAdd				fd_applyJuncPotToLoadedWv("tempToAdd",juncPotStr_mV)				tempForOut += tempToAdd			endif					KillWaves/Z $tempWaveName		//removes wave from memory, which is key!		endif	endfor		tempForOut/=i		Duplicate/O tempForOut, $avgOutRef	da_closeABF()		//closes ABF so another can be loaded later	KillWaves/Z tempForOut, tempForAddendfunction fd_getTotalNumSelSweeps(fileNum)	Variable fileNum	WAVE/T sweepsTracker		if ( (fileNum < 0) || (fileNum >= dimsize(sweepsTracker,0)) )		return 0	endif		String sweepSelections = sweepsTracker[fileNum]		Variable count = 0	Variable i	String currSelection	for (i=0;i<ItemsInList(sweepSelections,";");i+=1)		currSelection = StringFromList(i, sweepSelections,";")		if (stringmatch(currSelection,"1"))			count +=1		endif	endfor		return count	end//uses fileInfoWave (for file name) and makes a standard file name. ** Expects sweepNum input is file name sweep num - 1function/S fd_getFileName(fileNum, sweepNum, chanNum)	Variable fileNum, sweepNum, chanNum		String output		sprintf output, "%s_%d_AD%d", fd_getFNameFromFileInfoWave(fileNum,0), sweepNum+1, chanNum	return outputendfunction fd_cellPars(respChanStrList)	String respChanStrList		//list of channels that have VC or IC responses to analyze					end	//iterates through selected files and runs analysis for cell parameters on each sweep//i-clamp and v-clamp traces are handled differently, the function tries to determine how each file //should be handled by checking the wave units//most analyses are limited to files with steps. files that lack steps should be pre-specified using //CTRL + 3 while the file is selected in the fileListBox//CTRL + 4 will clear the list in case of mistakes or starting a new analysis//you can also directly edit the list fa_noStepList, see in function for its format//the search for a step starts from defaultSearchStart_vc and defaultSearchStart_ic//these variables can be overridden with the optional passedp parameters searchVCStepFromCsrA,searchCCStepFromCsrB//what parameters are displayed on the graph can be selected in fa_cellParams_updateDisp()//Details://the function iterates through each response/stimulus pair, then for each one it://iterates through all selected files; it determines if it fits expectations from clampPairList (e.g., does it contain the stimulus/response channel)//if the file does, it determines if its cc or vc and if it has a step (based on fa_noStepList)//then it iterates each (loaded) sweep in the file and runs://analysis_fastCellParams//this function runs a sub-function depending on whether the file was vc or cc//analysis_fastCellParamsT or analysis_fastCellParamsT_cc, respectively--these functions compute actual parametersfunction cp_main_simple(clampPairList,firstFileNum,sealSweepList [searchVCStepFromCsrA,searchCCStepFromCsrB])	String clampPairList		//semi-colon delimited list of response,stimulus channel #s. 									//for one-site, input is e.g., "0,2,;" for a response on channel 0 and a stimulus on channel 2									//for two-site, input is eg., "0,2,;4,6,;" for an additional pipette recorded in channel 4 and stimulated as on channel 6	Variable searchVCStepFromCsrA, searchCCStepFromCsrB	//pass to use csr as position to search for step from	String sealSweepList			//semi colon delim list, one for each clampPair (see clampPairList, above), pass empty strings if no seal sweeps to subtract	Variable firstFileNum //the number of the first file for the cell, generally but not always zero.. this is not a critical parameter			//get no step file list, a comma-delimited list for each clampPair/headstage. Each headstage delimited by semi colon -- now handled by fa_noStepListHandling	//and macros CTRL + 1 through CTRL + 5	SVAR/Z fa_noStepList	if (!Svar_Exists(fa_noStepList))		String/G fa_noStepList = ""	endif	String commonNoStepFiles = ReplaceString(",",StringByKey("both", fa_noStepList),";")	String noStepFileList_hs1 = ReplaceString(",",StringByKey("hs1", fa_noStepList),";")	String noStepFileList_hs2 = ReplaceString(",",StringByKey("hs2", fa_noStepList),";")		Print "commonNoStepFiles:",commonNoStepFiles, "noStepFileList_hs1:",noStepFileList_hs1, "noStepFileList_hs2:",noStepFileList_hs2 		String noStepFileList = ReplaceString(";",commonNoStepFiles + noStepFileList_hs1,",") + ";" + ReplaceString(";",commonNoStepFiles + noStepFileList_hs2,",") +";"	Variable startCol = 2			//current column at which waves start to be listed in sweepsDispList	String iUnitsStr = "A"				//may adjust if data has different units. Presently waves are rejected if they do not much (this allows one to gloss over traces where, for example, the headstage was in Iclamp)	String vUnitsStr = "V"	Variable isNegativeStep = 1	//determine step search start time	Variable defaultSearchStart_vc = 0.02			//for v-clamp (vc) presumed place preceding command step to be analyzed (no other steps may intervene)	Variable defaultSearchStart_ic = 0.08			//same for i-clamp (ic)	//check for default overrides:	Variable searchStartX_vc =( !ParamIsDefault(searchVCStepFromCsrA) && searchVCStepFromCsrA )? xcsr(A) : defaultSearchStart_vc	Variable searchStartX_cc =( !ParamIsDefault(searchCCStepFromCsrB) && searchCCStepFromCsrB )? xcsr(B) : defaultSearchStart_ic			//setup for results naming: parameters and fit waves get a  suffix	String paramsSaveSuffix = "_CP"	String fitSaveSuffix = "_CPf"	String baseName	=""	//leave blank for autogeneration based on first wave in display list. current standard is [cellname]_[1st file num]_HS[clampPairList num]		WAVE/T sweepsDispList		//waves from files currently selected and available for display		Variable vClampPair, i, count, currFNum, respCol, stimCol; String vClampPairStr, noStepFiles, iRef, vRef, breakInTimeStr, sealRef, paramsSaveRef, fitSaveRef, noteStr	String fd_fileNumStr; Variable fd_fileNum, fd_sweepNum	String iRefsList = "", vRefsList = "", outParamsRefList = "", outFitRefList = ""	Variable noStepTrace, outputCreated, timeFromRecStartToBrkIn			//will track whether any given analysis worked or not, won't store results that weren't computed. Only reason for failure would be no step found, e.g. headstage sitting in I=0 or the like	String currCmdInfoRef = ""		//will be an empty string unless a command info wave has been set for the file	Variable currCmdInfoRefIndex = -1	Variable checkCmdInfoRefs = 0	if (WaveExists($"fa_file_list"))		//allows different commands for different sweeps		WAVE/T fa_file_list		checkCmdInfoRefs = 1	endif		Variable lastFileNum, currFileNum, isCC	Variable respChanNum, stimChanNum		//channel number of stim and resp on digitizer	Variable respChanNum_fd, stimChanNum_fd	//channel number of stim and resp in file directory..possible complication if some channels not loaded..because this function assumes each fd channel makes up a column in sweepsDispWave	Variable skipFile		//files are skipped if the expected respChanNum/stimChanNum for a vClampPair does not exist (e.g. that stim/resp channel pair was not recorded on that file)	for (vClampPair = 0; vClampPair < ItemsInList(clampPairList,";"); vClampPair += 1)		vClampPairStr = StringFromList(vClampPair, clampPairList,";")		respChanNum = str2num(stringfromList(0,vClampPairStr,","))		stimChanNum = str2num(stringfromlist(1,vCLampPairStr,","))				noStepFiles = StringFromList(vClampPair, noStepFileList, ";")		sealRef = StringFromList(vClampPair, sealSweepList,";")			//use brkInRef to get time string		breakInTimeStr = fd_note_getWaveTimeStr(sealRef, 1, lastSweepTimingFromAvg=1)		timeFromRecStartToBrkIn = text_fd_getRelTimeSinceFile(sealRef,firstFileNum,5,  lastSweepTimingFromAvg=1)		//5 is unitsStr, specifying time difference is to be returned in seconds				count = 0; lastFileNum = -1		//reset count and fileNum		for (i=0;i<DimSize(sweepsDispList,0);i+=1)		//for each selected trace (each is a row in sweepsDispList)			currFileNum = str2num(sweepsDispList[i][0])			if (currFileNum != lastFileNum)		//new file num encountered, get sweepsDispList column # for respChanNum and stimChanNum				respChanNum_fd = fd_getChanNumForDigIn(currFileNum, respChanNum)				stimChanNum_fd = fd_getChanNumForDigIn(currFileNum, stimChanNum)								if ( (respChanNum_fd < 0 ) || (stimChanNum_fd < 0 ) )					//stim and/or response channels not found, skip this file					Print "cp_main(): warning, for vClampPair",vClampPair,"stim and/or response channels",stimChanNum,respChanNum,"for fileNum=",currfileNum,"not found. file was skipped"					skipFile = 1				else					skipFile = 0				endif								respCol = respChanNum_fd + startCol				stimCol = stimChanNum_fd + startCol				if ( (respCol < startCol) || (stimCol < startCol) )					Print "cp_main():warning. likely failed to find channel for stimulus or response digital input. Found channels for stim,resp are:",respCol-startCol,",",stimCol-startCol				endif 			endif			if (i==0)				baseName = text_getInfoFromWaveName_S(sweepsDispList[0][respCol], 0) + "_" +  text_getInfoFromWaveName_S(sweepsDispList[0][respCol], 1)				paramsSaveRef = baseName + paramsSaveSuffix + stringfromList(0, vClampPairStr,","); outParamsRefList += paramsSaveRef + ";"				fitSaveRef = baseName + fitSaveSuffix + stringfromList(0, vClampPairStr,","); outFitRefList += fitSaveRef + ";"				Print "sealRef", sealRef, "baseName",baseName,"paramsSaveRef", paramsSaveRef,"fitSaveRef", fitSaveRef, "header", analysis_getNewHeader(), "breakInTimeStr",breakInTimeStr,"timeFromRecStartToBrkIn",timeFromRecStartToBrkIn			endif			iRef = sweepsDispList[i][respCol]			vRef = sweepsDispList[i][stimCol]			fd_fileNumStr = sweepsDispList[i][0]			fd_fileNum = str2num(fd_fileNumStr)			fd_sweepNum = str2num(sweepsDispList[i][1])			noStepTrace =  stringmatch(noStepFiles, "*" + fd_fileNumStr + "*")		//true if fd_fileNumStr is present in noStepFiles list for this headstage						if (checkCmdInfoRefs)		//only if commandInfoRefs have been set for any files				//check if a commandInfoRef has been set for the file for this particular sweep				FindValue/TEXT=fd_fileNumStr/Z fa_file_list				currCmdInfoRefIndex = V_value-floor(V_value/DimSize(fa_file_list,0))*DimSize(fa_file_list,0)				currCmdInfoRef = fa_file_list[currCmdInfoRefIndex][1]			endif						//analyze sweeps			if (skipFile)				analysis_fastCellParams(0,firstFileNum,1,"","",NaN,NaN,"","","fa_cellParamsTemp","","",fd_fileNum=fd_fileNum,fd_sweepNum=fd_sweepNum,forceAllNaNOutput=1)			else				if (stringmatch(WaveUnits($iRef,-1), iUnitsStr) && stringmatch(WaveUnits($vRef,-1), vUnitsStr))		//voltage clamp configuration					analysis_fastCellParams(0,firstFileNum,noStepTrace,vRef,iRef,searchStartX_vc,isNegativeStep,sealRef,breakInTimeStr,"fa_cellParamsTemp","fa_fitsTemp",currCmdInfoRef,fd_fileNum=fd_fileNum,fd_sweepNum=fd_sweepNum)					isCC = 0				elseif (stringmatch(WaveUnits($vRef,-1), iUnitsStr) && stringmatch(WaveUnits($iRef,-1), vUnitsStr))		//current clamp configuration					analysis_fastCellParams(1,firstFileNum,noStepTrace,vRef,iRef,searchStartX_cc,isNegativeStep,sealRef,breakInTimeStr,"fa_cellParamsTemp","fa_fitsTemp",currCmdInfoRef,fd_fileNum=fd_fileNum,fd_sweepNum=fd_sweepNum)									isCC = 1				endif			endif						if (count == 0)				concatenate/O/NP=1 {$"fa_cellParamsTemp"}, $paramsSaveRef		//concatenate along columns			else				concatenate/NP=1 {$"fa_cellParamsTemp"}, $paramsSaveRef		//concatenate along columns			endif			if (isCC)				SetDimLabel 1,dimsize($paramsSaveRef,1)-1,$vRef,$paramsSaveRef			else				SetDimLabel 1,dimsize($paramsSaveRef,1)-1,$iRef,$paramsSaveRef			endif			iRefsList += iRef +","			vRefsList += vRef +","			count += 1; lastFileNum=currfileNum		endfor		noteStr = "sealRef:" +sealRef +";"		if ( strlen(sealRef) && WaveExists($sealRef) )			noteStr += "breakInNote:"+note($sealRef) +";"		endif		noteStr += "breakInTimeStr:"+breakInTimeStr+";timeFromRecStartToBrkIn:"+num2str(timeFromRecStartToBrkIn)+";iRefsList:"+iRefsList+";vRefsList:"+vRefsList+";noStepFileList:"+noStepFileList+";"		noteStr += "noStepList:"+Replacestring(";",fa_noStepList,"|") + ";"		Note/NOCR $paramsSaveRef, noteStr;// Note/NOCR $fitSaveRef, noteStr; 		dl_headerToLabels(analysis_getNewHeader(),paramsSaveRef,0)	endfor		Print "outParamsRefList", outParamsRefList, "outFitRefList", outFitRefList	fa_cellParams_updateDisp(0, paramsWvList = outParamsRefList)	end	//cp_main_simple()//fa: file analysis functions//savetopgraphs(1,"t",w=6.5,h=9)//do cell params analysis on files selected//baseName is generally cell name_[first file num]//use wave_avgFromWin (which calls wave_avgFromStrList) to compile avg of sweeps immediately before brk in. Ideally include sweep just before break in in average). Timing comes from that sweepfunction cp_main(somaPedBothOrBothRev,firstFileNum,breakInRefList,streamTags,forceMainRef[searchVCStepFromCsrA,searchCCStepFromCsrB])	Variable somaPedBothOrBothRev	//(0-5:) 0	-soma(hs1) only, 1-soma(hs2) only, 2-ped(hs1) only, 3-ped(hs2) only, 4-both(soma:hs1,ped:hs2), 5-both(soma:hs2,ped:hs1)		//somaPedBothOrBothRev doesnt affect analysis, just storage and display.. could do 1-N sites where N > 2 if one wanted to	Variable searchVCStepFromCsrA, searchCCStepFromCsrB	//pass to use csr as position to search for step from. now optional	String breakInRefList			//semi colon delim list, one for each vClampPair (see clampPairList, below). HS1 first, HS2, second, and so on	Variable firstFileNum //first file, generally but not always zero	String streamTags,forceMainRef		Variable 	reverseParamsWvListAtDisp = somaPedBothOrBothRev == 5 	//reverses params wave list when passed to display function (see last line of this function). Useful if soma is HS2 and one wants it to be HS1		//get no step file list, a comma-delimited list for each clampPair/headstage. Each headstage delimited by semi colon -- now handled by fa_noStepListHandling	SVAR/Z fa_noStepList	if (!Svar_Exists(fa_noStepList))		String/G fa_noStepList = ""	endif	String commonNoStepFiles = ReplaceString(",",StringByKey("both", fa_noStepList),";")	String noStepFileList_hs1 = ReplaceString(",",StringByKey("hs1", fa_noStepList),";")	String noStepFileList_hs2 = ReplaceString(",",StringByKey("hs2", fa_noStepList),";")		Print "commonNoStepFiles:",commonNoStepFiles	Print "noStepFileList_hs1:",noStepFileList_hs1	Print "noStepFileList_hs2:",noStepFileList_hs2 			// Could later control any of these initial setup parameters with a table/listbox whatever	String clampPairList	switch (somaPedBothOrBothRev)		case 0:		//soma only on hs1			clampPairList = "0,2,;"			break		case 1: 		//soma only on hs2			clampPairList = "3,5,;"			break		case 2:		//ped only on hs1			clampPairList = "0,2,;"			break		case 3:		//ped only on hs2			clampPairList = "3,5,;"			break		case 4:		//both, soma hs1, ped hs2			clampPairList = "0,2,;3,5,;"			break		case 5:		//both ped hs1, soma hs2			clampPairList = "0,2,;3,5,;"				break	endswitch		String noStepFileList = ReplaceString(";",commonNoStepFiles + noStepFileList_hs1,",") + ";" + ReplaceString(";",commonNoStepFiles + noStepFileList_hs2,",") +";"	Variable startCol = 2			//current column at which waves start to be listed in sweepsDispList	String iUnitsStr = "A"				//may adjust if data has different units. Presently waves are rejected if they do not much (this allows one to gloss over traces where, for example, the headstage was in Iclamp)	String vUnitsStr = "V"	Variable isNegativeStep = 1	Variable defaultSearchStart_vc = 0.05			//presumed place preceding command step to be analyzed (no other steps may intervene)	Variable defaultSearchStart_ic = 0.08		String paramsSaveSuffix = "_CP"	String fitSaveSuffix = "_CPf"	//removed from parameters, default as if passed as blank now	String baseName	=""	//leave blank for autogeneration based on first wave in display list. current standard is [cellname]_[1st file num]_HS[clampPairList num]		Variable searchStartX_vc =( !ParamIsDefault(searchVCStepFromCsrA) && searchVCStepFromCsrA )? xcsr(A) : defaultSearchStart_vc	Variable searchStartX_cc =( !ParamIsDefault(searchCCStepFromCsrB) && searchCCStepFromCsrB )? xcsr(B) : defaultSearchStart_ic		WAVE/T sweepsDispList		//waves from files currently selected and available for display		Variable vClampPair, i, count, currFNum, respCol, stimCol; String vClampPairStr, noStepFiles, iRef, vRef, breakInTimeStr, breakInRef, paramsSaveRef, fitSaveRef, noteStr	String fd_fileNumStr; Variable fd_fileNum, fd_sweepNum	String iRefsList = "", vRefsList = "", outParamsRefList = "", outFitRefList = ""	Variable noStepTrace, outputCreated, timeFromRecStartToBrkIn			//will track whether any given analysis worked or not, won't store results that weren't computed. Only reason for failure would be no step found, e.g. headstage sitting in I=0 or the like	String currCmdInfoRef = ""		//will be an empty string unless a command info wave has been set for the file	Variable currCmdInfoRefIndex = -1	Variable checkCmdInfoRefs = 0	if (WaveExists($"fa_file_list"))		//allows different commands for different sweeps		WAVE/T fa_file_list		checkCmdInfoRefs = 1	endif		Variable lastFileNum, currFileNum, isCC	Variable respChanNum, stimChanNum		//channel number of stim and resp on digitizer	Variable respChanNum_fd, stimChanNum_fd	//channel number of stim and resp in file directory..possible complication if some channels not loaded..because this function assumes each fd channel makes up a column in sweepsDispWave	Variable skipFile		//files are skipped if the expected respChanNum/stimChanNum for a vClampPair does not exist (e.g. that stim/resp channel pair was not recorded on that file)	for (vClampPair = 0; vClampPair < ItemsInList(clampPairList,";"); vClampPair += 1)		vClampPairStr = StringFromList(vClampPair, clampPairList,";")		respChanNum = str2num(stringfromList(0,vClampPairStr,","))		stimChanNum = str2num(stringfromlist(1,vCLampPairStr,","))				noStepFiles = StringFromList(vClampPair, noStepFileList, ";")		breakInRef = StringFromList(vClampPair, breakInRefList,";")			//use brkInRef to get time string		breakInTimeStr = fd_note_getWaveTimeStr(breakInRef, 1, lastSweepTimingFromAvg=1)		timeFromRecStartToBrkIn = text_fd_getRelTimeSinceFile(breakInRef,firstFileNum,5,  lastSweepTimingFromAvg=1)		//5 is unitsStr, specifying time difference is to be returned in seconds				count = 0; lastFileNum = -1		//reset count and fileNum		for (i=0;i<DimSize(sweepsDispList,0);i+=1)		//for each selected trace (each is a row in sweepsDispList)			currFileNum = str2num(sweepsDispList[i][0])			if (currFileNum != lastFileNum)		//new file num encountered, get sweepsDispList column # for respChanNum and stimChanNum				respChanNum_fd = fd_getChanNumForDigIn(currFileNum, respChanNum)				stimChanNum_fd = fd_getChanNumForDigIn(currFileNum, stimChanNum)								if ( (respChanNum_fd < 0 ) || (stimChanNum_fd < 0 ) )					//stim and/or response channels not found, skip this file					Print "cp_main(): warning, for vClampPair",vClampPair,"stim and/or response channels",stimChanNum,respChanNum,"for fileNum=",currfileNum,"not found. file was skipped"					skipFile = 1				else					skipFile = 0				endif								respCol = respChanNum_fd + startCol				stimCol = stimChanNum_fd + startCol				if ( (respCol < startCol) || (stimCol < startCol) )					Print "cp_main():warning. likely failed to find channel for stimulus or response digital input. Found channels for stim,resp are:",respCol-startCol,",",stimCol-startCol				endif 			endif			if (i==0)				baseName = text_getInfoFromWaveName_S(sweepsDispList[0][respCol], 0) + "_" +  text_getInfoFromWaveName_S(sweepsDispList[0][respCol], 1)				paramsSaveRef = baseName + paramsSaveSuffix + stringfromList(0, vClampPairStr,","); outParamsRefList += paramsSaveRef + ";"				fitSaveRef = baseName + fitSaveSuffix + stringfromList(0, vClampPairStr,","); outFitRefList += fitSaveRef + ";"				Print "breakInRef", breakInRef, "baseName",baseName,"paramsSaveRef", paramsSaveRef,"fitSaveRef", fitSaveRef, "header", analysis_getNewHeader(), "breakInTimeStr",breakInTimeStr,"timeFromRecStartToBrkIn",timeFromRecStartToBrkIn			endif			iRef = sweepsDispList[i][respCol]			vRef = sweepsDispList[i][stimCol]			fd_fileNumStr = sweepsDispList[i][0]			fd_fileNum = str2num(fd_fileNumStr)			fd_sweepNum = str2num(sweepsDispList[i][1])			noStepTrace =  stringmatch(noStepFiles, "*" + fd_fileNumStr + "*")		//true if fd_fileNumStr is present in noStepFiles list for this headstage						if (checkCmdInfoRefs)		//only if commandInfoRefs have been set for any files				//check if a commandInfoRef has been set for the file for this particular sweep				FindValue/TEXT=fd_fileNumStr/Z fa_file_list				currCmdInfoRefIndex = V_value-floor(V_value/DimSize(fa_file_list,0))*DimSize(fa_file_list,0)				currCmdInfoRef = fa_file_list[currCmdInfoRefIndex][1]			endif						//analyze sweeps			if (skipFile)				analysis_fastCellParams(0,firstFileNum,1,"","",NaN,NaN,"","","fa_cellParamsTemp","","",fd_fileNum=fd_fileNum,fd_sweepNum=fd_sweepNum,forceAllNaNOutput=1)			else				if (stringmatch(WaveUnits($iRef,-1), iUnitsStr) && stringmatch(WaveUnits($vRef,-1), vUnitsStr))		//voltage clamp configuration					analysis_fastCellParams(0,firstFileNum,noStepTrace,vRef,iRef,searchStartX_vc,isNegativeStep,breakInRef,breakInTimeStr,"fa_cellParamsTemp","fa_fitsTemp",currCmdInfoRef,fd_fileNum=fd_fileNum,fd_sweepNum=fd_sweepNum)					isCC = 0				elseif (stringmatch(WaveUnits($vRef,-1), iUnitsStr) && stringmatch(WaveUnits($iRef,-1), vUnitsStr))		//current clamp configuration					analysis_fastCellParams(1,firstFileNum,noStepTrace,vRef,iRef,searchStartX_cc,isNegativeStep,breakInRef,breakInTimeStr,"fa_cellParamsTemp","fa_fitsTemp",currCmdInfoRef,fd_fileNum=fd_fileNum,fd_sweepNum=fd_sweepNum)									isCC = 1				endif			endif						if (count == 0)				concatenate/O/NP=1 {$"fa_cellParamsTemp"}, $paramsSaveRef		//concatenate along columns			else				concatenate/NP=1 {$"fa_cellParamsTemp"}, $paramsSaveRef		//concatenate along columns			endif			if (isCC)				SetDimLabel 1,dimsize($paramsSaveRef,1)-1,$vRef,$paramsSaveRef			else				SetDimLabel 1,dimsize($paramsSaveRef,1)-1,$iRef,$paramsSaveRef			endif			iRefsList += iRef +","			vRefsList += vRef +","			count += 1; lastFileNum=currfileNum		endfor		noteStr = "breakInRef:" +breakInRef +";"		if ( strlen(breakInRef) && WaveExists($breakInRef) )			noteStr += "breakInNote:"+note($breakInRef) +";"		endif		noteStr += "breakInTimeStr:"+breakInTimeStr+";timeFromRecStartToBrkIn:"+num2str(timeFromRecStartToBrkIn)+";iRefsList:"+iRefsList+";vRefsList:"+vRefsList+";noStepFileList:"+noStepFileList+";"		noteStr += "noStepList:"+Replacestring(";",fa_noStepList,"|") + ";"		Note/NOCR $paramsSaveRef, noteStr;// Note/NOCR $fitSaveRef, noteStr; 		dl_headerToLabels(analysis_getNewHeader(),paramsSaveRef,0)	endfor		Print "outParamsRefList", outParamsRefList, "outFitRefList", outFitRefList	fa_cellParams_updateDisp(reverseParamsWvListAtDisp, paramsWvList = outParamsRefList)	//	fio_saveWavesByName(outParamsRefList, "",1)		//save params wave; standard is to save to cellparams folder (in analysis folder)		fa_saveCPRefs(outParamsRefList,somaPedBothOrBothRev,streamTags,forceMainRef)	//saved to analysis stream "cp"	end	//cp_main()function cp_main_update_all()	WAVE/T cp_refs_main0	variable i	for (i=13;i<dimsize(cp_refs_main0,0);i+=1)		if (i==5)			continue		endif		Print "STARTING ROW = ",i		cp_main_update(i,1)	endforendfunction cp_main_update(row, reloadFirst)	Variable row,reloadFirst		if (reloadFirst)		fio_stream_dispCellParams(row,0,"")	endif		WAVE/T cp_refs_main0	String info = cp_refs_main0[row]		String hs1Ref="",hs2Ref=""	Variable somaIsHs1,pedIsHS1,hs1,hs2	variable somaPedBothOrBothRev_o = str2num(Stringbykey("somaPedBothOrBothRev",info))	if (stringmatch(info,"*;somaRef:*") || stringmatch(info,"*;pedRef:*"))		switch (somaPedBothOrBothRev_o)			case 0:				hs1 = 1;	hs2 = 0				hs1Ref = stringbykey("somaRef",info)			case 1:				hs1 = 0; hs2 = 1				hs2Ref = stringbykey("somaRef",info)			case 2:				hs1 = 1;	hs2 = 0				hs1Ref = stringbykey("pedRef",info)							case 3:				hs1 = 0;	hs2 = 1				hs2Ref = stringbykey("pedRef",info)								case 4:				hs1 = 1;	hs2 = 1				hs1Ref = stringbykey("somaRef",info)				hs2Ref = stringbykey("pedRef",info)				break			case 5:				hs1 = 1;	hs2 = 1				hs1Ref = stringbykey("pedRef",info)				hs2Ref = stringbykey("somaRef",info)				break		endswitch								else		//old format		hs1Ref = Stringbykey("hs1Ref",info)		hs2Ref = Stringbykey("hs2Ref",info)	endif		Print "hs1Ref",hs1ref,"hs2ref",hs2ref,"somaPedBothOrBothRev_o",somaPedBothOrBothRev_o		String indexName = GetDimLabel(cp_refs_main0, 0, row )	variable firstFileNum_o = text_getinfofromwavename_v(indexName,1)		String streamTags_o=""			//pass to override any stream tags	String streamTags_add=""		//pass to add new stream tags	String forceMainRef = ""		String headerRef = analysis_getNewHeader()	Variable savetoStream =1		//defaults	Variable startCol = 2			//current column at which waves start to be listed in sweepsDispList	String iUnitsStr = "A"				//may adjust if data has different units. Presently waves are rejected if they do not much (this allows one to gloss over traces where, for example, the headstage was in Iclamp)	String vUnitsStr = "V"	Variable isNegativeStep = 1	Variable defaultSearchStart_vc = 0.05			//presumed place preceding command step to be analyzed (no other steps may intervene)	Variable defaultSearchStart_ic = 0.08	Variable searchStartX_vc = defaultSearchStart_vc	Variable searchStartX_cc = defaultSearchStart_ic	String paramsSaveSuffix = "_CP"	String fitSaveSuffix = "_CPf"	String baseName	=""	//leave blank for autogeneration based on first wave in display list. current standard is [cellname]_[1st file num]_HS[clampPairList num]		hs1 = strlen(hs1Ref) > 0	hs2 = strlen(hs2ref) > 0		String refNote	if (hs1)		refNote = note($hs1ref)	elseif(hs2)		refNote = note($hs2ref)	else		return 0	endif		//choose somaPedBothOrBothRev to use	Variable somaPedBothOrBothRev_orig; string somaPedBothOrBothRev_origStr	Variable somaPedBothOrBothRev_used, newSomaPedBothOrBothRev	somaPedBothOrBothRev_origStr = stringbykey("somaPedBothOrBothRev",refNote)	somaPedBothOrBothRev_orig = str2num(somaPedBothOrBothRev_origStr)		if (!numtype(somaPedBothOrBothRev_o))		somaPedBothOrBothRev_used = somaPedBothOrBothRev_o		if (strlen(somaPedBothOrBothRev_origStr) && (somaPedBothOrBothRev_orig != somaPedBothOrBothRev_o))			newSomaPedBothOrBothRev = 1		endif	elseif (strlen(somaPedBothOrBothRev_origStr) && (somaPedBothOrBothRev_orig < 6))		somaPedBothOrBothRev_used = somaPedBothOrBothRev_orig	else		Print "cp_main_update(): Insufficient information on somaPedBothOrBothRev; pass somaPedBothOrBothRev_o to fix"	endif		Print "somaPedBothOrBothRev_orig",somaPedBothOrBothRev_orig,"somaPedBothOrBothRev_used",somaPedBothOrBothRev_used	//choose firstfileNum to use	Variable firstfileNum_orig; string firstfileNum_origStr	Variable firstfileNum_used, newfirstfileNum	firstfileNum_origStr = stringbykey("firstfileNum",refNote)	firstfileNum_orig = str2num(firstfileNum_origStr)		if (!numtype(firstfileNum_o))		firstfileNum_used = firstfileNum_o		if (strlen(firstfileNum_origStr) && (firstfileNum_orig != firstfileNum_o))			newfirstfileNum = 1		endif	elseif (strlen(firstfileNum_origStr) && (firstfileNum_orig < 6))		firstfileNum_used = firstfileNum_orig	else		Print "cp_main_update(): Insufficient information on firstfileNum; pass firstfileNum_o to fix"	endif		Print "firstfileNum_used",firstfileNum_used			// Could later control any of these initial setup parameters with a table/listbox whatever	String clampPairList, usedClampPairList	Variable listRepeats = 0	switch (somaPedBothOrBothRev_used)		case 0:		//soma only on hs1			clampPairList = "0,2,;"			//as it was originally			break		case 1: 		//soma only on hs2			clampPairList = "3,5,;"			break		case 2:		//ped only on hs1			clampPairList = "0,2,;"			break		case 3:		//ped only on hs2			clampPairList = "3,5,;"			break		case 4:		//both, soma hs1, ped hs2			clampPairList = "0,2,;3,5,;"			listRepeats = 1			break		case 5:		//both ped hs1, soma hs2			clampPairList = "0,2,;3,5,;"				listRepeats = 1			break	endswitch		usedClampPairList = clampPairList	Variable 	reverseParamsWvListAtDisp = somaPedBothOrBothRev_used == 5 	//reverses params wave list when passed to display function (see last line of this function). Useful if soma is HS2 and one wants it to be HS1			//get no step file list :: //comma-delimited list for each clampPair/headstage. Each headstage delimited by semi colon -- now handled by fa_noStepListHandling		Variable pos_ind		//position index: try soma then try ped	String ref,noStepInfoStr, noteStr,noteStr_new,commonNoStepFiles,noStepFiles,noStepKeyString,noStepFileList	String vRefsList,iRefsList, fd_fileName	String loadedList = "",breakInRef,vClampPairStr,paramsSaveRef,fitSaveRef,outParamsRefList="",outFitRefList=""	String breakInTimeStr	Variable timeFromRecStartToBrkIn,count = 0,i,isCC	String iRef,vRef,fd_fileNumStr	Variable fd_fileNum,fd_sweepNum,noStepTrace,outputCreated	String iRefsList_new="",vRefsList_new=""	Variable respChanNum, stimChanNum; String remadeBreakInRefsList = ""	Variable hs1_iRefs_count	String currCmdInfoRef = ""	for (pos_ind=0;pos_ind<(hs1 + hs2);pos_ind+=1)		switch (pos_ind)			case 0:				ref = hs1Ref				noStepKeyString = "hs1"				break			case 1:				ref = hs2Ref				noStepKeyString = "hs2"				break		endswitch				//skip if not passed		if (strlen(ref) < 1)			continue		endif				noteStr = note($ref)				//info from previous run		noStepInfoStr = stringbykey("noStepList",noteStr)		commonNoStepFiles = text_commasToSemiColons(stringbykey("both",noStepInfoStr,":","|"))		noStepFiles = commonNoStepFiles + text_commasToSemiColons(stringbykey(noStepKeyString,noStepInfoStr,":","|"))				iRefsList = text_commasToSemiColons(stringbykey("iRefsList",noteStr))		vRefsList = text_commasToSemiColons(stringbykey("vRefsList",noteStr))		breakInRef = stringbykey("breakInRef",noteStr)				if (pos_ind == 0)			hs1_iRefs_count = itemsinlist(iRefsList)		endif					if (strlen(breakInRef) && !waveexists($breakInRef))		//	da_fd_remakeAvgWave(breakInRef,0)		//	remadeBreakInRefsList += breakInRef + ";"		endif				vClampPairStr = StringFromList(pos_ind, usedClampPairList,";")		Print "usedClampPairList",usedClampPairList,"vClampPairStr",vClampPairStr				variable baseNameEnd = strsearch(ref, "_CP", 0) - 1		baseName = ref[0,baseNameEnd]		paramsSaveRef = baseName + paramsSaveSuffix + stringfromList(0, vClampPairStr,","); outParamsRefList += paramsSaveRef + ";"		fitSaveRef = baseName + fitSaveSuffix + stringfromList(0, vClampPairStr,","); outFitRefList += fitSaveRef + ";"				breakInTimeStr = fd_note_getWaveTimeStr(breakInRef, 1, lastSweepTimingFromAvg=1)		timeFromRecStartToBrkIn = text_fd_getRelTimeSinceFile(breakInRef,firstFileNum_used,5,  lastSweepTimingFromAvg=1)		//5 is unitsStr, specifying time difference is to be returned in seconds		Print "breakInRef", breakInRef, "baseName",baseName,"paramsSaveRef", paramsSaveRef,"fitSaveRef", fitSaveRef, "header", analysis_getNewHeader(), "breakInTimeStr",breakInTimeStr,"timeFromRecStartToBrkIn",timeFromRecStartToBrkIn			count = 0; 	//	for (i= (listRepeats && (pos_ind == 1) ? hs1_iRefs_count : 0) ;i<10;i+=1)		for (i= (listRepeats && (pos_ind == 1) ? hs1_iRefs_count : 0) ;i<itemsinlist(iRefsList);i+=1)		//for each selected trace itemsinlist(iRefsList)			iRef = Stringfromlist(i,iRefsList)			vRef = Stringfromlist(i,vRefsList)			fd_fileName = text_getInfoFromWaveName_S(iRef, 0)			fd_fileNum = fd_getFIndexInFileInfoWave(fd_fileName)			fd_fileNumStr = num2str(fd_fileNum)			fd_fileNumStr = text_getPaddedString(4-strlen(fd_fileNumStr), 4, fd_fileNumStr, "0")			fd_sweepNum = text_getInfoFromWaveName_v(iRef,2)			noStepTrace =  stringmatch(noStepFiles, "*" + fd_fileNumStr + "*")		//true if fd_fileNumStr is present in noStepFiles list for this headstage			if (!waveexists($iRef))			//	da_fd_loadWaveFromWaveName(iRef);loadedList+= iRef + ";"			endif			if (!waveexists($vRef))			//	da_fd_loadWaveFromWaveName(vRef);loadedList+= vRef + ";"			endif						if (stringmatch(WaveUnits($iRef,-1), iUnitsStr) && stringmatch(WaveUnits($vRef,-1), vUnitsStr))		//voltage clamp configuration				outputCreated = analysis_fastCellParams(0, firstFileNum_used, noStepTrace, vRef, iRef, searchStartX_vc, isNegativeStep, breakInRef, breakInTimeStr, "fa_cellParamsTemp", "fa_fitsTemp", currCmdInfoRef , fd_fileNum=fd_fileNum, fd_sweepNum=fd_sweepNum)			elseif (stringmatch(WaveUnits($vRef,-1), iUnitsStr) && stringmatch(WaveUnits($iRef,-1), vUnitsStr))		//current clamp configuration				//check that all headstages are in vClamp (so as not to analyze voltage clamp cell just because one headstage is in current clamp)				outputCreated = analysis_fastCellParams(1, firstFileNum_used, noStepTrace, vRef, iRef, searchStartX_cc, isNegativeStep, breakInRef, breakInTimeStr, "fa_cellParamsTemp", "fa_fitsTemp", currCmdInfoRef, fd_fileNum=fd_fileNum, fd_sweepNum=fd_sweepNum)							endif						if (count == 0)				concatenate/O/NP=1/DL {$"fa_cellParamsTemp"}, $paramsSaveRef		//concatenate along columns			else				concatenate/NP=1/DL {$"fa_cellParamsTemp"}, $paramsSaveRef		//concatenate along columns			endif						if (isCC)				SetDimLabel 1,count,$vRef,$paramsSaveRef			else				SetDimLabel 1,count,$iRef,$paramsSaveRef			endif			iRefsList_new += iRef +","			vRefsList_new += vRef +","			count += 1					//	killwaves/Z $iref,$vref						endfor		dl_headerToLabels(headerRef,paramsSaveRef,0)		noteStr_new = "breakInRef:" +breakInRef +";breakInNote:"+note($breakInRef) +";breakInTimeStr:"+breakInTimeStr+";timeFromRecStartToBrkIn:"+num2str(timeFromRecStartToBrkIn)+";iRefsList:"+iRefsList+";vRefsList:"+vRefsList+";"		noteStr_new += "noStepList:"+Replacestring(";",noStepInfoStr,"|") + ";"		Note/NOCR $paramsSaveRef, noteStr;// Note/NOCR $fitSaveRef, noteStr; 	endfor				Print "outParamsRefList", outParamsRefList, "outFitRefList", outFitRefList	fa_cellParams_updateDisp(reverseParamsWvListAtDisp, paramsWvList = outParamsRefList)			if (savetoStream)		String savePathStr = ""		fio_stream_getListWvRef("cp","",out_usedPathStr=savePathStr)			if (hs1)			save/c/o/p=$savePathStr $Stringfromlist(0,outParamsRefList)		endif		if (hs2)			save/c/o/p=$savePathStr $Stringfromlist(1,outParamsRefList)		endif	else		Print "note: cp_main not saving to stream!"	endif	end	//cp_main_update()function/S fa_noStepListHandling(addSel_clearBothHS1OrHS2)	Variable addSel_clearBothHS1OrHS2	//-2 to print, -1 to clear, 0 both, 1 hs1, 2 hs2		SVAR/Z fa_noStepList	if (!Svar_exists(fa_noStepList))		String/G fa_noStepList = ""	endif		if (addSel_clearBothHS1OrHS2 < 0)		if (addSel_clearBothHS1OrHS2 == -1)			fa_noStepList = ""		else			print "fa_noStepList",fa_noStepList		endif		return fa_noStepList	endif		String keyList = "both;hs1;hs2;"		String currKey = StringFromList(addSel_clearBothHS1OrHS2,keyList)		String currFileStr = ""	Variable i	String fileList = ReplaceString(";",fd_getSelFileInfo("#"),",")		fa_noStepList = text_appendToStringByKey(currKey, fa_noStepList, fileList)		print "fa_noStepList:",fa_noStepList		putscraptext fa_noStepList		return fa_noStepListendfunction fa_hs1_noStepListMacro()	fa_noStepListHandling(1)endfunction fa_hs2_noStepListMacro()	fa_noStepListHandling(2)endfunction fa_both_noStepListMacro()	fa_noStepListHandling(0)endfunction fa_clear_noStepListMacro()	Variable doNoStepListClear = 1	String msgStr = "really clear noStepLists?"	prompt doNoStepListClear, msgStr	doprompt msgStr, doNoStepListClear	if (doNoStepListClear)		fa_noStepListHandling(-1)	endifendfunction fa_print_noStepListMacro()	fa_noStepListHandling(-2)endfunction fa_ssRinIn_Linear()	ModifyGraph/W=fa_cpGr log(L_accessR_noModel)=0	setaxis/A=2 L_accessR_noModel	ModifyGraph/W=fa_cpGr log(L_ssRin)=0	setaxis/A=2 L_ssRinendfunction fa_ssRinIn_Log()		ModifyGraph/W=fa_cpGr log(L_accessR_noModel)=1	setaxis/A=2 L_accessR_noModel	ModifyGraph/W=fa_cpGr log(L_ssRin)=1	setaxis/A=2 L_ssRinendfunction/S text_appendToStringByKey(keyStr, kwListStr, appendStr)	String keyStr, kwListStr, appendStr	String origStr = StringByKey(keyStr, kwListStr)	//returns empty string either if associated string is empty or keyStr isnt in list	origStr += appendStr	return ReplaceStringByKey(keyStr, kwListStr, origStr)		//adds keyStr if not present, in addition to (updated) origStrend//lists file numbers and provides a column for user input, e.g. ref to a command wave to be usedfunction fa_list()	String ref = "fa_file_list"	String win = ref + "_win"	WAVE fileSelListByNums; WAVE/T fileInfoWAve	Make/O/T/N=((DimSize(fileSelListByNums,0)),2) $ref/WAVE=out		out[][0] = fileInfoWave[ fileSelListByNums[p] ][1]	out[][1] = ""	if (wintype(win))		killwindowsbyname(win)	endif		Edit/K=1/N=$win $refend//fa_list()////good size for full page print (from another program, e.g. power point) savetopgraphs(1,"t",w=6.5,h=9)//updates table and graph display of cell params e.g. after fa_cellParams_fromSel()function fa_cellParams_updateDisp(reverseParamsWvList, [paramsWvList])	Variable reverseParamsWvList		//pass to reverse list before use. Useful if soma is HS2 but on wants to plot it as HS1	String paramsWvList			//updates paramsWvList, must be passed for first use		Variable clampsShareAnAxis = 1			//seperate axes for each clamp/headstage if zero, first clamp pair is left, second is right, and the rest are a different right axis	Variable fontSize = 7		String headerRef = analysis_getNewHeader()	String tableN = "fa_cpTab"	String gName = "fa_cpGr"		//individual xy comparisons appended; overlayed in the case of multiple parameter wave inputs (ItemsInList(paramsWvList) > 1)		//pair-wise list of y and x axes for x-y parameter plots (based on analysis_getNewHeader and fa_cellParams params wave)//	String y_paramsList = "IS_VC;baseCurrent;ssRin;accessR_noModel;accessR_mono;timeSinceBrkIn;fileNum;"	String y_paramsList = "", y_axMins = "", y_axMaxes = ""	, y_log = ""		//this list goes from bottom to top, but one could reverse it easily	y_paramsList += "fileNum;"; 				y_axMins += num2str(NaN) + ";" ;		y_axMaxes += num2str(NaN) + ";";		y_log += "0" + ";"	y_paramsList += "IS_VC;"; 				y_axMins += num2str(-.5) + ";" ;		y_axMaxes += num2str(1.5) + ";";		y_log += "0" + ";"	y_paramsList += "vCmd_baseline;"; 		y_axMins += num2str(-0.08) + ";" ; 		y_axMaxes += num2str(-0.06) + ";";		y_log += "0" + ";"//	y_paramsList += "ic_cmd_baseline;"; 		y_axMins += num2str(NaN) + ";" ; 		y_axMaxes += num2str(NaN) + ";";		y_log += "0" + ";"	y_paramsList += "ic_baseVoltage;"; 		y_axMins += num2str(-80*10^-3) + ";" ; 		y_axMaxes += num2str(0) + ";"	;	y_log += "0" + ";"	y_paramsList += "baseCurrent;"; 			y_axMins += num2str(-300*10^-12) + ";" ;		 y_axMaxes += num2str(10*10^-12) + ";";		y_log += "0" + ";"	y_paramsList += "ssRin;";					y_axMins += num2str(.5) + ";" ; 		y_axMaxes += num2str(1.8*10^9) + ";";		y_log += "1" + ";"	y_paramsList += "accessR_noModel;"; 		y_axMins += num2str(0) + ";" ; 		y_axMaxes += num2str(10^8) + ";";		y_log += "0" + ";"//	y_paramsList += "mQCapTot_mono;"; 			y_axMins += num2str(NaN) + ";" ; 		y_axMaxes += num2str(NaN) + ";";		y_log += "0" + ";"//	y_paramsList += "mQcap1_dbl;"; 		y_axMins += num2str(NaN) + ";" ; 		y_axMaxes += num2str(NaN) + ";";		y_log += "1" + ";"//	y_paramsList += "tau1_dbl;"; 		y_axMins += num2str(NaN) + ";" ; 		y_axMaxes += num2str(NaN) + ";";		y_log += "1" + ";"//	y_paramsList += "mQcap2_dbl;"; 		y_axMins += num2str(NaN) + ";" ; 		y_axMaxes += num2str(NaN) + ";";		y_log += "1" + ";"//	y_paramsList += "tau2_dbl;"; 		y_axMins += num2str(NaN) + ";" ; 		y_axMaxes += num2str(NaN) + ";";		y_log += "1" + ";"	y_paramsList += "mQCapTot_dbl;"; 		y_axMins += num2str(NaN) + ";" ; 		y_axMaxes += num2str(NaN) + ";";		y_log += "1" + ";"	//	y_paramsList += "accessR_mono;"; 		y_axMins += num2str(0) + ";" ; 		y_axMaxes += num2str(10^8) + ";"//	y_paramsList += "accessR_dbl;"; 		y_axMins += num2str(0) + ";" ; 		y_axMaxes += num2str(10^8) + ";"//	y_paramsList += "timeSinceBrkIn;"; 		y_axMins += num2str(NaN) + ";" ; 		y_axMaxes += num2str(NaN) + ";"//	String y_axisMins = "-1;NaN;0;0;0;NaN;NaN;"//	String y_axisMaxes = "2;10*10^-12;10^9;200*10^6;200*10^6;NaN;NaN;"	String x_paramName = "timeSinceRecStart"	String y_colors = "0,0,0,;65280,0,0,;"		//should be at least one comma-delimited triplet of rgb values for each item in ParamList, triplets delimited by semicolon		Variable numplots = ItemsInList(y_paramsList)	Variable spacerSize = 0.02//	Variable spacerRange = ceil(100*spacerSize * (numplots-1))/100	Variable spacerRange = spacerSize * (numplots-1)		Variable plotStart = 0, plotEnd = 1, plotRange = plotEnd-plotStart-spacerRange,  axisRange = plotRange/numplots//axisRange = floor(100*plotRange/numplots)/100		//check handling of paramsWvList	Variable writeUserData	if (ParamIsDefault(paramsWvList))		paramsWvList = GetUserData(tableN, "", "paramsWvList" )		Print "paramsWvList", paramsWvList		if (strlen(paramsWvList) < 1)			print "user data not saved. fa_cellParams_updateDisp() aborted."			return 0		endif			writeUserData = 0	else		writeUserData = 1		//first time through, so see if the params need to be reversed (only needs to be done first time through/when writing		if (reverseParamsWvList)			paramsWvList = text_listReverse(paramsWvList)		endif	endif			//table	if (WinType(tableN) != 2)		killwindowsbyName(tableN + "*")		Edit/K=1/N=$tableN; ModifyTable/W=$tableN format(Point)=1	else		table_clear(tableN)	endif		if (writeUserData)		setWindow $tableN userdata(paramsWvList) = paramsWvList	endif		appendTotable/W=$tableN $headerRef;	Variable i; String paramRef	for (i=0;i<ItemsInList(paramsWvList);i+=1)		paramRef = StringFromList(i, paramsWvList)		if (WaveExists($paramRef))			appendtoTable/W=$tableN  $paramRef		endif	endfor	ModifyTable/W=$tableN format(Point)=1, sigDigits=10//sigDigits($paramRef)=10		if (WinType(gName) != 1)		KillwindowsByName(gName + "*")		Display/K=1/N=$gName; doUpdate	else		vis_clearGraph(gName)	endif			Variable j, yRow, xRow = findInHeader(x_paramName, headerRef)	Variable axStart = plotStart, currAxStart, currAxEnd, r,g,b, axRangeMin, axRangeMax	String y_paramN, y_axN, yColor	Variable numClampPairs = ItemsInList(y_paramsList)	//make summary graph for each param input	for (i=0;i<numClampPairs;i+=1)		currAxStart = axStart + i*spacerSize + i*axisRange		currAxend = axStart + i*spacerSize + (i+1)*axisRange		y_paramN = StringFromList(i,y_paramsList)		yRow = findInHeader(y_paramN, headerRef)		for (j=0;j<ItemsInList(paramsWvList);j+=1)			paramRef = StringFromList(j, paramsWvList)			yColor = StringFromList(j,y_colors)			r= varFromList(0,yColor,",");g= varFromList(1,yColor,","); b=varFromList(2,yColor,",")			if ( (j==0) || clampsShareAnAxis)			//0 position gets left axis				if (stringmatch(y_paramN, "fileNum"))		//keep first so axis is always farthest back. Color will be white and would obscure axes behind it					if (!disp_isTraceOnGraph(gName, "guide"))						AppendToGraph/W=$gName/L=guide $paramRef[yRow][]/TN=guide vs $paramRef[xRow][]					endif				endif				y_axN = "L_" + y_paramN				AppendToGraph/W=$gName/L=$y_axN/C=(r,g,b) $paramRef[yRow][]/TN=$(y_paramN+num2str(j)) vs $paramRef[xRow][]				Label/W=$gName $y_axN y_paramN + "\r\\U"				//handles file grid line			else										//other positions get their own right axis (if !clampsShareAnAxis) 				y_axN = "R_" + y_paramN + "_" +num2str(j)				AppendToGraph/W=$gName/R=$y_axN/C=(r,g,b) $paramRef[yRow][]/TN=$(y_paramN+num2str(j)) vs $paramRef[xRow][]				Label/W=$gName $y_axN "\r\\U"				ModifyGraph/W=$gName axRGB($y_axN)=(r,g,b),tlblRGB($y_axN)=(r,g,b);ModifyGraph/W=$gName alblRGB($y_axN)=(r,g,b)				//note use of R instead or L for axis, and only units for axis label			endif			ModifyGraph/W=$gName axisEnab($y_axN) = {currAxStart, currAxEnd}			axRangeMin = varFromList(i, y_axMins, "")			axRangeMax = varFromList(i, y_axMaxes, "")			if (numtype(axRangeMin) && numtype(axRangeMax))				SetAxis/W=$gName $y_axN, *, *			elseif (numtype(axRangeMin))		//auto scale min only				SetAxis/W=$gName $y_axN, *, axRangeMax			elseif (numtype(axRangeMax))				SetAxis/W=$gName $y_axN, axRangeMin, *			else				SetAxis/W=$gName $y_axN, axRangeMin, axRangeMax			endif						if (varFromList(i, y_log,""))				ModifyGraph/W=$gName log($y_axN) = 1			endif		endfor			endfor		Label/W=$gName bottom, x_paramName + "   //" + StringFromList(0,ParamsWvList) +"//"	ModifyGraph/W=$gName freepos = 0, lblpos = 52	ModifyGraph/W=$gName fsize=fontSize, mode=4,marker=16,msize=1,lsize=0.01,lstyle=1			//ModifyGraph mode=2,lsize=1.5		for dots without lines 		//special exception to make file nums visible so simultaneous recordings can be identified 	if ( (numClampPairs > 1) && disp_isTraceOnGraph(gName, "fileNum0") && disp_isTraceOnGraph(gName, "fileNum1") )		ModifyGraph/W=$gName  marker(fileNum0)=10,marker(fileNum1)=10, msize(fileNum0)=3.5,msize(fileNum1)=2	//make sticks, foreground sticks shorter	endif	if ( (numClampPairs > 1) && disp_isTraceOnGraph(gName, "IS_VC0") && disp_isTraceOnGraph(gName, "IS_VC1") )		ModifyGraph/W=$gName  marker(IS_VC0)=10,marker(IS_VC1)=10, msize(IS_VC0)=3.5,msize(IS_VC1)=2	//make sticks, foreground sticks shorter	endif		//mark x axis with time of break in for each paramsWv	Variable yRelStart = 0.8, yRelEnd = 0.96		//units entirety of plot window height from 0 to 1. this is usually around the x axis line for the bottom plot	Variable timeFromRecStartToBrkIn; String noteStr	for (i=0;i<ItemsInList(paramsWvList);i+=1)		paramRef = StringFromList(i, paramsWvList); notestr = note($paramRef)		timeFromRecStartToBrkIn = str2num(stringbykey	("timeFromRecStartToBrkIn",notestr))		Print "i",i,"timeFromRecStartToBrkIn",timeFromRecStartToBrkIn		yColor = StringFromList(i,y_colors); r= varFromList(0,yColor,",");g= varFromList(1,yColor,","); b=varFromList(2,yColor,",")		//color scheme to match that of points		//ShowTools/A arrow		SetDrawEnv/W=$gName xcoord= bottom,ycoord= rel, linefgc= (r,g,b), dash= 3,linethick= 2.00		DrawLine/W=$gName timeFromRecStartToBrkIn,yRelStart,timeFromRecStartToBrkIn,yRelEnd		dl_headerToLabels(headerRef,paramRef,0)	endfor		//make guide trace presentable	setaxis/W=$gName guide, 0,1	ModifyGraph/W=$gName mode(guide)=1, rgb(guide)=(47872,47872,47872), tick(guide)=3,noLabel(guide)=2,axRGB(guide)=(65535,65535,65535), tlblRGB(guide)=(65535,65535,65535),alblRGB(guide)=(65535,65535,65535)		doupdate;setwindow $gName, userdata(paramsWvList) = paramsWvList//	note/nocr $paramRef, "Y_end//fa_cellParams_updateDisp()function fio_stream_dispCellParams_s(rowLblMatchStr,ng,dfl)	String rowLblMatchStr	//match string for row label for cell/file	Variable ng//see fio_stream_dispCellParams	String dfl		//see fio_stream_dispCellParams		WAVE/T cp_refs_main0		String matchList = dl_matchingLabelValues("cp_refs_main0",0,0,rowLblMatchStr,2)		if (itemsinlist(matchList) > 1)		Print "fio_stream_dispCellParams_s(): found multiple matches for input rowLblMatchStr",rowLblMatchStr,"aborting","matchList (rows):",matchList		return 0	endif		Variable/G cpRow = str2num(stringfromlist(0,matchList))	fio_stream_dispCellParams(cpRow,ng,dfl)end	function fio_stream_dispCellParams(row,ng,dfl)	Variable row,ng	String dfl		//display fileNum list		//pass ng = 1 to remove guide wave automatically (easier to put csrs on individual points this way)		WAVE/T cp_refs_main0		variable pedIsHS1 = str2num(stringbykey("pedIsHS1",cp_refs_main0[row]))	String hs1ref,hs2ref	if (pedIsHs1)		hs1ref=stringbykey("pedRef",cp_refs_main0[row])		hs2ref=stringbykey("somaRef",cp_refs_main0[row])			Print "hs2ref",hs1ref,"hs2ref",hs2ref,"pedIsHS1",pedIsHS1		fio_stream_loadIBF("cp_refs_main0",hs1ref+";"+hs2ref+";")		fa_cellParams_updateDisp(0,paramsWvList=hs2ref+";"+hs1ref+";")		//reverse list so that soma is displayed first in black, ped second in red	else		hs1ref=stringbykey("somaRef",cp_refs_main0[row])		hs2ref=stringbykey("pedRef",cp_refs_main0[row])		Print "hs2ref",hs1ref,"hs2ref",hs2ref,"pedIsHS1",pedIsHS1		fio_stream_loadIBF("cp_refs_main0",hs1ref+";"+hs2ref+";")		fa_cellParams_updateDisp(0,paramsWvList=hs1ref+";"+hs2ref+";")	endif		if (ng)		doupdate		bringtotop("fa_cpGr")		ShowInfo/W=fa_cpGr/CP={0,1}		removefromgraph guide	endif			if (strlen(dfl))			Variable i			for (i=0;i<itemsinlist(dfl);i+=1)				fa_cellParams_showFileLoc(str2num(stringfromlisT(i,dfl)))			endfor	endifendfunction fa_cellParams_showFileLoc(fileNum)	Variable fileNum		String winN = winname(0,1)		string paramsWvList = GetUserData(winN, "", "paramsWvList" )	string paramsRef = stringfromlist(0,paramsWvList)		WAVE paramsWv = $paramsRef		if (!strlen(getdimlabel(paramsWv,0,0)))		dl_headerToLabels(analysis_getNewHeader(),paramsRef,0)	endif		Variable searchRow = FindDimLabel(paramsWv, 0, "fileNum" )		Print "searchRow",searchRow		Variable i,filestartTime	for (i=0;i<dimsize(paramsWv,1);i+=1)		if (paramsWv[searchRow][i] >= fileNum)			filestartTime = paramsWv[%timeSinceRecStart][i]			break		endif	endfor			SetDrawEnv/W=$winN xcoord= bottom,linefgc= (1,4,52428,32768),dash= 0,linethick= 2.00;DelayUpdate	DrawLine/W=$winN filestartTime,-1,filestartTime,1endfunction dl_headerToLabels(headerRef,refToLabel,dimtoLabel,[fromHigherDimWv])	String headerRef,refToLabel	Variable dimtoLabel	WAVE fromHigherDimWv		//format so length explains how many dims, for now can only take from highest dim..see code		WAVE/T header = $headerREf	WAVE ref = $refToLabel		variable i,row,col,layer	if (ParamIsDefault(fromHigherDimWv))			for (i=0;i<dimsize(ref,dimtoLabel);i+=1)			SetDimLabel dimtoLabel,i,$header[i][0][0][0],ref		endfor	elseif (dimsize(fromHigherDimWv,0)<2)	//1 item, only rows specified		for (i=0;i<dimsize(ref,dimtoLabel);i+=1)			row=fromHigherDimWv[0]			SetDimLabel dimtoLabel,i,$header[row][i][0][0],ref		endfor	elseif (dimsize(fromHigherDimWv,0)<3)	//2 items, rows and cols specified		for (i=0;i<dimsize(ref,dimtoLabel);i+=1)			row=fromHigherDimWv[0]			col=fromHigherDimWv[1]			SetDimLabel dimtoLabel,i,$header[row][col][i][0],ref		endfor	elseif (dimsize(fromHigherDimWv,0)<4)	//3 items, rows cols and layers specified		for (i=0;i<dimsize(ref,dimtoLabel);i+=1)			row=fromHigherDimWv[0]			col=fromHigherDimWv[1]			layer=fromHigherDimWv[2]			SetDimLabel dimtoLabel,i,$header[row][col][layer][i],ref		endfor	endifendfunction dl_lblsToLbls(fromWvRef,fromDim,from_startIndex,num,toWvRef,toDim,to_startIndex,to_appendLabel,appendBeforeNotAfter,[forceToWv,forceFromWv])	String fromWvRef,toWvRef	Variable fromDim,toDim		//dimension to transfer from and to	Variable num	//num to transfer	Variable from_startIndex, to_startIndex		//index to start at for transferring from and to .. currently no bounds checking except for both start indices = 0, so run time error will occur if out of bounds	String to_appendLabel		//pass to add some text after the label	Variable appendBeforeNotAfter	//pass true to add string in to_appendLabel before rather than after the label	WAVE forceFromWv,forceToWv		//optionally pass a wave instead. useful for free waves	if (ParamIsDefault(forceFromWv))		WAVE fromWv = $fromWvRef	else		WAVE fromWv=forceFromWv	endif	if (ParamIsDefault(forceToWv))		WAVE toWv = $toWvRef	else		WAVE toWv=forceToWv	endif		if (numtype(toDim))		toDim = fromDim	endif		Variable i	if (numtype(num))		num = min(dimsize(fromWv,fromDim)-from_startIndex,dimsize(toWv,toDim)-to_startIndex)	endif		if (appendBeforeNotAfter)		for (i=0;i<num;i+=1)			SetDimLabel toDim,i+to_startIndex,$(to_appendLabel+GetDimLabel(fromWv, fromDim, i+from_startIndex)),toWv		endfor 	else		for (i=0;i<num;i+=1)			SetDimLabel toDim,i+to_startIndex,$(GetDimLabel(fromWv, fromDim, i+from_startIndex)+to_appendLabel),toWv		endfor 	endifendfunction/s dl_getLblsAsList(fromWvRef,fromDim,from_startIndex,from_endIndex[matchingThisMatchStrListOnly,listItemNum,indsOnly,forceFromWv])	String fromWvRef	Variable fromDim,from_startIndex,from_endIndex	String matchingThisMatchStrListOnly		//returns only those matching one or more match strings in this match str list	Variable listItemNum						//optionally just save one list item from each lbl, meant for if labels are comma delim lists	Variable indsOnly	WAVE forceFromWv		//optionally pass a wave that will supercede fromWvRef, which can be left ""	Variable used_listItemNum	if (ParamIsDefault(listItemNum))		used_listITemNum=0	else		used_listITemNum=listItemNum	endif	if (ParamIsDefault(forceFromWv))		WAVE fromWv = $fromWvRef	else		WAVE FromWv = forceFromWv	endif		if (numtype(from_startIndex))		from_startIndex = 0	endif	if (numtype(from_endIndex))		from_endIndex = dimsize(fromWv,fromDim)-1	endif		Variable returnIndsOnly=!paramisdefault(indsOnly) && indsOnly	string out=""		Variable noMatchStringList = ParamIsDefault(matchingThisMatchStrListOnly) || !itemsinlist(matchingThisMatchStrListOnly)		variable i		if (noMatchStringList)		for (i=from_startIndex;i<=from_endIndex;i+=1)			if (returnIndsOnly)				out += num2str(i)+";"			else				out += stringfromlist(used_listITemNum,GetDimLabel(fromWv, fromDim, i ))+";"			endif		endfor	else		String lbl		for (i=from_startIndex;i<=from_endIndex;i+=1)			lbl = GetDimLabel(fromWv, fromDim, i )			if (itemsinlist(text_matchesToListOfMatchStrs(lbl,matchingThisMatchStrListOnly)))				if (returnIndsOnly)					out += num2str(i)+";"				else					out += stringfromlist(used_listITemNum,lbl) +";"				endif			endif		endfor	endif		return outendfunction dl_replaceLblSubstring(replaceThisStr,withStr,wv,dim,startIndex,num)	STring replaceThisStr,withStr	WAVE wv	Variable dim,startIndex,num		variable i,ind,indLimit=dimsize(wv,dim); string dl	for (i=0;i<num;i+=1)		ind=startIndex+i		if (ind>=indLimit)			break		endif		dl = getdimlabel(wv,dim,ind)		dl = replacestring(replaceThisStr,dl,withStr)		SetDimLabel dim,ind,$dl,wv 	endforendfunction/S fa_showRange(refFromCsrB)	Variable refFromCsrB		String list = fa_getRange(refFromCsrB)		Display/K=1		VAriable i; string ref	for (i=0;i<itemsinlist(list);i+=1)		ref = stringfromlist(i,list)		if (!WaveExists($ref))			da_fd_loadWaveFromWaveName(ref)		endif		AppendtoGraph/W=$S_name $ref	endforendfunction/S fa_getRange(refFromCsrB)	Variable refFromCsrB			String winN = winname(0,1)	Variable i,startIndex,endIndex; string ref, dispRef, dispList, out = ""	startIndex = pcsr(A)	if (!strlen(csrwave(B)))		endIndex = startIndex + 1	else		endIndex = pcsr(B) + 1	endif		if (refFromCsrB)		ref = csrwave(B)	else		ref = csrwave(A)	endif		for (i=startIndex;i<endIndex;i+=1)		out += GetDimLabel($ref, 1, i) + ";"	endfor				return outend//csr A at first somatic sweep, csr B at least; csr C at first ped sweep, csr D at last (Remove A or C if no somatic, ped sweep respectively)function fa_store_auto(refForInfo,rowForInfo,cp_row,instanceNum,stability,nonAligned,ccStatus,vc_sim_status,vc_error_status)	String refForInfo	Variable rowForInfo	Variable cp_row	Variable instanceNum		//if saving more than one set of params for a given cell and a given refForInfo, pass instanceNum > 0	Variable stability //-1 for pre, 0 to 1 for post (only stored for post)	Variable nonAligned		// 0 for aligned/adjacent test files at soma and ped, 1 for non-adjacent files for soma and ped tests,2 for no somatic test, 3 for no ped test	Variable ccStatus		//0 for not cc, 1 for cc, 2 for cc and closer than vc sweeps being saved (usually for 1 there are no vc sweeps to choose from)	Variable vc_sim_status	//0 for non-simutaneous VC, 1 for simultaneous VC, 2 for simultaneous vc and this is closer than regular vc / preferred over regular vc, 3 for only option	Variable vc_error_status		//for marking cases where current injection accidentally occured at second site		WAVE/T infoWv = $refForInfo	Variable colForInfo = 0		String postAppendStr = "_po"		String ccAppendStr = "_c"	String vc_sim_appendStr = "_vs"	String overallAppendStr = ""		if (stability >= 0)		overallAppendStr += postAppendStr	endif	if (ccStatus)		overallAppendStr += ccAppendStr		endif		if (vc_sim_status)		overallAppendStr += vc_sim_appendStr		endif		String soma_kStr = "cp_soma" + overallAppendStr	String ped_kStr = "cp_ped"	+overallAppendStr		String ccStatus_kStr = "cc_status"+overallAppendStr	String instanceNum_kStr = "instance"+overallAppendStr	String stability_kStr = "stability"+overallAppendStr	String nonAligned_kStr = "nonAligned"+overallAppendStr	String cp_row_kStr = "cp_row"+overallAppendStr	String rowForInfo_kStr = "rowForInfo"+overallAppendStr	String vc_sim_status_kStr = "vc_sim_status"+overallAppendStr	String vc_error_status_kStr = "vc_error_status"+overallAppendStr		String infoTypeIndentifierAppendStr = Replacestring("_",refForInfo[0,2],"") + num2str(instanceNum)		String saveAppendStr = infoTypeIndentifierAppendStr + overallAppendStr	//check from here		String somaRef = "", pedRef = ""	if (strlen(csrwave(A)))		//has somatic trace		somaRef = fa_store_simple(0,0,saveAppendStr)		Print "fa_store_auto(): somaRef found, ref =",somaRef	endif	if (strlen(csrwave(C)))		//has ped trace		pedRef = fa_store_simple(1,1,saveAppendStr)		Print "fa_store_auto(): pedRef found, ref =",pedRef	endif		Duplicate/O infoWv, $"fa_store_auto_infoWv_bu" 		String str = infoWv[rowForInfo][colForInfo]		str = ReplaceStringByKey(soma_kStr, str, somaRef)	str = ReplaceStringByKey(ped_kStr, str, pedRef)	str = ReplaceStringByKey(ccStatus_kStr, str, num2str(ccStatus))	str = ReplaceStringByKey(instanceNum_kStr, str, num2str(instanceNum))	str = ReplaceStringByKey(stability_kStr, str, num2str(stability))	str = ReplaceStringByKey(nonAligned_kStr, str, num2str(nonAligned))	str = ReplaceStringByKey(cp_row_kStr, str, num2str(cp_row))	str = ReplaceStringByKey(rowForInfo_kStr, str, num2str(rowForInfo))	str = ReplaceStringByKey(vc_sim_status_kStr, str, num2str(vc_sim_status))	str = ReplaceStringByKey(vc_error_status_kStr, str, num2str(vc_error_status))		variable i; string cstr, pcsr_kStr, csrwv_kStr	for (i=0;i<4;i+=1)		switch (i)			case 0:				cstr = "a"				break			case 1:				cstr = "b"				break						case 2:				cstr = "c"				break				case 3:				cstr = "d"				break		endswitch					pcsr_kStr = "pcsr_" + cstr + overallAppendStr		csrwv_kStr = "csrwv_" + cstr + overallAppendStr				if (strlen(csrwave($cstr)))		//csr on graph			str = ReplaceStringByKey(pcsr_kStr, str, num2str(pcsr($cstr)))			str = ReplaceStringByKey(csrwv_kStr, str, csrwave($cstr))		else			str = ReplaceStringByKey(pcsr_kStr, str, "")			str = ReplaceStringByKey(csrwv_kStr, str, "")		endif	endfor		infoWv[rowForInfo][colForInfo] = str	print "fa_store_auto(): infoWv[rowForInfo]=",infoWv[rowForInfo]end//csr A at first somatic sweep, csr B at least; csr C at first ped sweep, csr D at last (Remove A or C if no somatic, ped sweep respectively)function fa_store_auto2(cp_row,vc_sim_status,vc_error_status,instanceNum,overwriteCol)	Variable cp_row	Variable vc_sim_status	//0 for non-simutaneous VC, 1 for simultaneous VC, 2 for simultaneous vc and this is closer than regular vc / preferred over regular vc, 3 for only option	Variable vc_error_status		//for marking cases where current injection accidentally occured at second site	Variable instanceNum	Variable overwriteCol		//pass nan to append to fa_store_ref (most common), or a valid column number to overwrite that column. ignored if fa_store_ref doesnt exist		String fa_store_ref = "fa_cellParams"		String somaRef = "", pedRef = ""	if (strlen(csrwave(A)))		//has somatic trace		somaRef = fa_store_simple(0,0,num2str(instanceNum))		Print "fa_store_auto(): somaRef found, ref =",somaRef	endif	if (strlen(csrwave(C)))		//has ped trace		pedRef = fa_store_simple(1,1,num2str(instanceNum))		Print "fa_store_auto(): pedRef found, ref =",pedRef	endif		fa_store_linearize(somaRef)	fa_store_linearize(pedRef)		Variable hasSoma = strlen(somaRef) > 0	Variable hasPed = strlen(pedref) > 0		Variable numParamsAtSite	if (hasSoma && hasPed)		numParamsAtSite = dimsize($somaRef,0)				WAVE somaWv=$somaRef		WAVE pedWv=$pedRef	elseif (hasSoma)		numParamsAtSite = dimsize($somaRef,0)				WAVE somaWv=$somaRef		Duplicate/O somaWv,$pedRef/wave=pedWv		pedWv = nan	elseif (hasPed)		numParamsAtSite = dimsize($pedRef,0)				WAVE pedWv=$pedRef		Duplicate/O pedWv,$somaRef/wave=somaWv		somaWv=nan	else		Print "fa_store_auto2(): Place csrs to use, no data found for analysis"		return 0	endif	dl_appendToLbls(somaWv,0,"s_",1,-inf,inf)	dl_appendToLbls(pedWv,0,"p_",1,-inf,inf)			concatenate/O/DL/NP=0 {somaWv,pedWv}, combinedWvTemp		Variable numrows=dimsize(combinedWvTemp,0)	redimension/N=(numrows+4) combinedWvTemp	dl_assignAndLbl(combinedWvTemp, numrows+0, cp_row, "cp_row")	dl_assignAndLbl(combinedWvTemp, numrows+1, vc_sim_status, "vc_sim_status")	dl_assignAndLbl(combinedWvTemp, numrows+2, vc_error_status, "vc_error_status")	dl_assignAndLbl(combinedWvTemp, numrows+3, instanceNum, "instanceNum")		String lbl = getdimlabel($"cp_refs_main0",0,cp_row)	lbl = text_getInfoFromWaveName_S(lbl,0)		//get just the cell name instead of cellname_filenum	lbl = replacestring("G",lbl,"")		//remove starting letter	Variable nextCol	if (!WaveExists($fa_store_ref))		Duplicate/O combinedWvTemp, $fa_store_ref/wave=fa_storeWv		redimension/N=(-1,1) fa_storeWv		nextCol = 0	else		WAVE/D fa_storeWv = $fa_store_ref		if (numtype(overwriteCol))			nextCol = dimsize(fa_storeWv,1)			redimension/N=(-1,nextCol+1) fa_storeWv		else			nextCol = overwriteCol		endif		fa_storeWv[][nextCol]=combinedWvTemp[p]	endif		SetDimLabel 1,nextCol,$lbl,fa_storeWv	//killwaves/Z combinedWvTempend//linearizes the output wave of fa_store_simplefunction fa_store_linearize(storeWvRef)		String storeWvRef		Duplicate/O/FREE $storeWvRef, tempStoreWv		variable numrows=dimsize(tempStoreWv,0)	Variable out_pnts = numrows*dimsize(tempStoreWv,1)		WAVE storeWv = $storeWvRef	Redimension/N=(out_pnts) storeWv	String rowlbl,colLbl,outLbl	Variable i,inrow,incol//,maxLblLen = 0	for (i=0;i<out_pnts;i+=1)		inrow = mod(i,numrows)		incol = floor(i/numrows)		rowLbl = GetDimLabel(tempStoreWv, 0, inrow )		colLbl = GetDimLabel(tempStoreWv, 1, incol )		outLbl = ReplaceString("V_",colLbl,"")+"_"+rowLbl		SetDimLabel 0,i,$outLbl,storeWv				//maxLblLen = max(strlen(outLbl),maxLblLen)	endfor		//print "maxLblLen",maxLblLenend//identify a fa_cpSummary wave via csr(A), which also specifies start of analysis region. csr(B) specifies end of analysis regionfunction/S fa_store_simple(isPed,csrSet,nameAppendStr)	Variable isPed			//pass 0 for soma, 1 for ped, 2 for additional...	Variable csrSet		//0 for csr(A)/csr(B),1 for csr(C)/csr(D),2 for csr(E)/csr(F), 3 for csr(G)/csr(H)	String nameAppendStr					String startCsrStr,endCsrStr	switch (csrSet)		case 0:			startCsrStr = "A"			endCsrStr = "B"			break		case 1:			startCsrStr = "C"			endCsrStr = "D"			break		case 2:			startCsrStr = "E"			endCsrStr = "F"			break					case 3:			startCsrStr = "G"			endCsrStr = "H"			break		default:			startCsrStr = "A"			endCsrStr = "B"	endswitch		String headerRef = analysis_getNewHeader()		//param ref for FA_ plots		String paramWvName = csrwave($startCsrStr)		//cellName_CP#	String refName_V = paramWvName + "_" + nameAppendStr	//double value wave. row 0 is value, 1 is N, 2 is stdev, 	if (strlen(refName_V) > 31)		Print "warning refName_V,",refName_V,"may be too long for saving"	endif	String ParamName = StringByKey("TNAME", csrinfo($startCsrStr)	)		//get param name (y axis name)		Variable numAddedStats = 1 //any params after V_skew in for loop	Variable i, currIndex, numParams = DimSize($headerRef,0), numStats = 13 + numAddedStats		//num params stored in refName_V		Make/O/D/N=(numParams,numStats) $refName_V/wave=wv_v	currIndex = 0//	Print "FA_ new instance. isPed, name:", isPed, refName_V		WAVE/D paramWv = $paramWvName	Duplicate/O paramWv, roiWvTemp	Redimension/B/U roiWvTemp; 		//current row will be set to 0 which means it is in the row	Variable paramNum	for (paramNum=0;paramNum<numParams;paramNum+=1)		roiWvTemp = 1; roiWvTemp[paramNum][pcsr($startCsrStr)	, pcsr($endCsrStr)] = 0		//sets the roi to the current row for paramNum		ImageStats/R=roiWvTemp paramWv		wv_V[paramNum][0] = V_adev//	Average deviation of pixel values.		wv_V[paramNum][1] = V_avg	//Average of pixel values.		wv_V[paramNum][2] = V_kurt	//Kurtosis of pixel values.		wv_V[paramNum][3] = V_min	//Minimum pixel value.		wv_V[paramNum][4] = V_minColLoc	//Specifies the location of the column in which the minimum pixel value was found or the first eligible column if no single column was found.		wv_V[paramNum][5] = V_minRowLoc//	specifies the location of the row in which the minimum pixel value was found or the first eligible row if no single minimum was found.		wv_V[paramNum][6] = V_max	//Maximum pixel value.		wv_V[paramNum][7] = V_maxColLoc	//Specifies the location of the column in which the maximum pixel value was found or the first eligible column if no single column was found.		wv_V[paramNum][8] = V_maxRowLoc	//Specifies the location of the row in which the maximum pixel value was found or the first eligible row if no single maximum was found.		wv_V[paramNum][9] = V_npnts//	Number of points in the ROI.		wv_V[paramNum][10] = V_rms//	Root mean squared of pixel values.		wv_V[paramNum][11] = V_sdev//	Standard deviation of pixel values.		wv_V[paramNum][12] = V_skew	//Skewness of pixel values.		wv_V[paramNum][13] = V_sdev/V_avg	//my metric of CV (sdev/mean)	endfor	setdimlabel 1,0,V_adev,wv_V//	Average deviation of pixel values.	setdimlabel 1,1,V_avg,wv_V	//Average of pixel values.	setdimlabel 1,2,V_kurt,wv_V	//Kurtosis of pixel values.	setdimlabel 1,3,V_min,wv_V	//Minimum pixel value.	setdimlabel 1,4,V_minColLoc,wv_V	//Specifies the location of the column in which the minimum pixel value was found or the first eligible column if no single column was found.	setdimlabel 1,5,V_minRowLoc,wv_V//	specifies the location of the row in which the minimum pixel value was found or the first eligible row if no single minimum was found.	setdimlabel 1,6,V_max,wv_V	//Maximum pixel value.	setdimlabel 1,7,V_maxColLoc,wv_V	//Specifies the location of the column in which the maximum pixel value was found or the first eligible column if no single column was found.	setdimlabel 1,8,V_maxRowLoc,wv_V	//Specifies the location of the row in which the maximum pixel value was found or the first eligible row if no single maximum was found.	setdimlabel 1,9,V_npnts,wv_V//	Number of points in the ROI.	setdimlabel 1,10,V_rms,wv_V//	Root mean squared of pixel values.	setdimlabel 1,11,V_sdev,wv_V//	Standard deviation of pixel values.	setdimlabel 1,12,V_skew,wv_V	//Skewness of pixel values.	setdimlabel 1,13,cv,wv_V	//my metric of CV (sdev/mean)		dl_lblsToLbls(paramWvName,0,0,nan,refName_V,0,0,"",0)		Variable fileNum_row = findInHeader("fileNum",headerRef)	Variable sweepNum_row = findInHeader("sweepNum",headerRef)	Variable fd_fileNum_row = findInHeader("fd_fileNum",headerRef)	Variable timeSinceRecStart_row = findInHeader("timeSinceRecStart",headerRef)	Variable ssRin_row = findinHeader("ssRin",headerRef)		Print "fa_store_simple(): output name:",refName_V,"ssRin",wv_v[ssRin_row][1],"sdev",wv_v[ssRin_row][11],"cv (sdev/avg)",wv_V[ssRin_row][13],">10%?",wv_V[ssRin_row][13]>0.1		note/NOCR wv_V,  "isPed:" + num2str(isPed) + ";" +  "paramWv:" + paramWvName + ";" 	note/NOCR wv_V, "act_fileNum_start:"+num2str(paramWv[fileNum_row][pcsr($startCsrStr)	])+";"+"act_fileNum_end:"+num2str(paramWv[fileNum_row][pcsr($endCsrStr)])+";"	note/NOCR wv_V, "fd_fileNum_start:"+num2str(paramWv[fd_fileNum_row][pcsr($startCsrStr)	])+";"+"fd_fileNum_end:"+num2str(paramWv[fd_fileNum_row][pcsr($endCsrStr)])+";"	note/NOCR wv_V, "sweepNum_start:"+num2str(paramWv[sweepNum_row][pcsr($startCsrStr)	])+";"+"sweepNum_end:"+num2str(paramWv[sweepNum_row][pcsr($endCsrStr)])+";"	note/NOCR wv_V, "timeSinceRecStart_start:"+num2str(paramWv[timeSinceRecStart_row][pcsr($startCsrStr)	])+";"+"timeSinceRecStart_end:"+num2str(paramWv[timeSinceRecStart_row][pcsr($endCsrStr)])+";"	note/NOCR wv_V, "pcsr_A:"+num2str(pcsr($startCsrStr)	)+";" + "pcsr_B:"+num2str(pcsr($endCsrStr))+";" + "xcsr_A:"+num2str(xcsr($startCsrStr)	)+";" + "xcsr_B:"+num2str(xcsr($endCsrStr))+";"+ "ParamName:"+ParamName+";"		return refName_Vend//fa_store_simple()function cpPairs_addRinFromFit(buLetter)	String buLetter		Variable trim = 1	WAVE/T wv = $"wn_refs_main_cpPairs"		variable i,j, paramCol = 1		//column of average in param waves of interest		String keysList = "cp_soma;cp_ped;cp_soma_po;cp_ped_po;cp_soma_vs;cp_ped_vs;cp_soma_po_vs;cp_ped_po_vs;"	Double deltaSSCurrent_mono	Double ssRin_mono	Variable numNewParams = 2, startRow	String key,ref,buRef,buList = "", origList = "",ref_orig	for (i=0;i<dimsize(wv,0);i+=1)		if (strlen(wv[i]) < 1)			continue		endif				for (j=0;j<itemsinlist(keysList);j+=1)			key = stringfromlist(j,keysList)			if (!stringmatch(wv[i],"*"+key+"*"))				continue			endif						ref_orig = stringbykey(key,wv[i]) 			ref = ref_orig			if (!strlen(ref) || !waveexists($ref))				continue			endif			WAVE/D cpWv = $ref			if (trim)				redimension/N=(109,-1) cpWv				continue			endif			origList += "ref" + ";"			buRef = ref + "b" + buLetter			buList += buRef + ";"			duplicate/O cpWv, $(buRef)			startRow = dimsize(cpWv,0)			Redimension/N=(startRow + numNewParams,-1) cpWv						deltaSSCurrent_mono = cpWv[%ssCurrent_mono][paramCol] - cpWv[%baseCurrent][paramCol]			ssRin_mono = cpWv[%deltaVoltage][paramCol] / deltaSSCurrent_mono			cpWv[startRow][paramCol] = deltaSSCurrent_mono			cpWv[startRow+1][paramCol] = ssRin_mono			SetDimLabel 0,startRow,deltaSSCurrent_mono,cpWv			SetDimLabel 0,startRow+1,ssRin_mono,cpWv						Duplicate/O cpWv, $buRef		endfor			endfor		Print "buList",buListendfunction cpPairs_reset()	Variable buNum	WAVE/T wv = $"wn_refs_main_cpPairs"		variable i,j, paramCol = 1		//column of average in param waves of interest		String keysList = "cp_soma;cp_ped;cp_soma_po;cp_ped_po;cp_soma_vs;cp_ped_vs;cp_soma_po_vs;cp_ped_po_vs;"	Double deltaSSCurrent_mono	Double ssRin_mono	Variable numNewParams = 2, startRow	String key,ref,buRef,buList = "",ref_orig	for (i=0;i<dimsize(wv,0);i+=1)		if (strlen(wv[i]) < 1)			continue		endif				for (j=0;j<itemsinlist(keysList);j+=1)			key = stringfromlist(j,keysList)			if (!stringmatch(wv[i],"*"+key+"*"))				continue			endif						ref_orig = stringbykey(key,wv[i]) 			ref = ref_orig + "b0"			if (!strlen(ref) || !waveexists($ref))				continue			endif						Duplicate/O $ref, $ref_orig		endfor			endfor		Print "buList",buListend//identify a fa_cpSummary wave via csr(A), which also specifies start of analysis region. csr(B) specifies end of analysis regionfunction fa_store(isPed, instanceNum, startFileNum, endFileNum, fa_changePath, notes)	Variable isPed			//pass 0 for soma, 1 for ped, 2 for additional...	Variable instanceNum, startFileNum, endFileNum		//instanceNum: pass to get same instance or make new one. specify starting ffile num and ending file num for which relevant for note taking purposes	Variable fa_changePath	//pass true to set a new save path for fa info (prompts if no path currently set)	String notes			//save info like "initial_seal_params / preWc_seal_params / wc_params_2site_independent / wc_params_2site_simultaneous		String headerRef = analysis_getNewHeader()		//param ref for FA_ plots		String paramWvName = csrwave(A)		//cellName_CP#	String refName_V = paramWvName + "i"+num2str(instanceNum)	  + "p" + num2str(isPed) + "_" + num2str(pcsr(A)) + "_" + num2str(pcsr(B))	//double value wave. row 0 is value, 1 is N, 2 is stdev, 	if (strlen(refName_V) > 30)		Print "warning refName_V,",refName_V,"may be too long for saving, edit naming procedure in fa_store_f"	endif	String ParamName = StringByKey("TNAME", csrinfo(A))		//get param name (y axis name)		Variable i, currIndex, numParams = DimSize($headerRef,0), numStats = 13		//num params stored in refName_V		Make/O/D/N=(numParams,numStats) $refName_V/WAVE=wv_V	currIndex = 0	Print "FA_ new instance. isPed, name:", isPed, refName_V		WAVE/D paramWv = $paramWvName	Duplicate/O paramWv, roiWvTemp	Redimension/B/U roiWvTemp; 		//current row will be set to 0 which means it is in the row	Variable paramNum	for (paramNum=0;paramNum<numParams;paramNum+=1)		roiWvTemp = 1; roiWvTemp[paramNum][pcsr(A), pcsr(B)] = 0		//sets the roi to the current row for paramNum		ImageStats/R=roiWvTemp paramWv		wv_V[paramNum][0] = V_adev//	Average deviation of pixel values.		wv_V[paramNum][1] = V_avg	//Average of pixel values.		wv_V[paramNum][2] = V_kurt	//Kurtosis of pixel values.		wv_V[paramNum][3] = V_min	//Minimum pixel value.		wv_V[paramNum][4] = V_minColLoc	//Specifies the location of the column in which the minimum pixel value was found or the first eligible column if no single column was found.		wv_V[paramNum][5] = V_minRowLoc//	specifies the location of the row in which the minimum pixel value was found or the first eligible row if no single minimum was found.		wv_V[paramNum][6] = V_max	//Maximum pixel value.		wv_V[paramNum][7] = V_maxColLoc	//Specifies the location of the column in which the maximum pixel value was found or the first eligible column if no single column was found.		wv_V[paramNum][8] = V_maxRowLoc	//Specifies the location of the row in which the maximum pixel value was found or the first eligible row if no single maximum was found.		wv_V[paramNum][9] = V_npnts//	Number of points in the ROI.		wv_V[paramNum][10] = V_rms//	Root mean squared of pixel values.		wv_V[paramNum][11] = V_sdev//	Standard deviation of pixel values.		wv_V[paramNum][12] = V_skew	//Skewness of pixel values.			endfor		Variable fileNum_row = findInHeader("fileNum",headerRef)	Variable sweepNum_row = findInHeader("sweepNum",headerRef)	Variable fd_fileNum_row = findInHeader("fd_fileNum",headerRef)	Variable timeSinceRecStart_row = findInHeader("timeSinceRecStart",headerRef)		note/NOCR wv_V,  "isPed:" + num2str(isPed) + ";" +  "paramWv:" + paramWvName + ";" 	note/NOCR wv_V,  "input_fileNum_start:"+num2str(startFileNum)+";"+"input_fileNum_end:"+num2str(endFileNum)+";"	note/NOCR wv_V, "act_fileNum_start:"+num2str(paramWv[fileNum_row][pcsr(A)])+";"+"act_fileNum_end:"+num2str(paramWv[fileNum_row][pcsr(B)])+";"	note/NOCR wv_V, "fd_fileNum_start:"+num2str(paramWv[fd_fileNum_row][pcsr(A)])+";"+"fd_fileNum_end:"+num2str(paramWv[fd_fileNum_row][pcsr(B)])+";"	note/NOCR wv_V, "sweepNum_start:"+num2str(paramWv[sweepNum_row][pcsr(A)])+";"+"sweepNum_end:"+num2str(paramWv[sweepNum_row][pcsr(B)])+";"	note/NOCR wv_V, "timeSinceRecStart_start:"+num2str(paramWv[timeSinceRecStart_row][pcsr(A)])+";"+"timeSinceRecStart_end:"+num2str(paramWv[timeSinceRecStart_row][pcsr(B)])+";"	note/NOCR wv_V, "pcsr_A:"+num2str(pcsr(A))+";" + "pcsr_B:"+num2str(pcsr(B))+";" + "xcsr_A:"+num2str(xcsr(A))+";" + "xcsr_B:"+num2str(xcsr(B))+";"+ "ParamName:"+ParamName+";"	note/nocr wv_V, "fa_store_notes:" + notes + ";"		PathInfo fa_path		if (!V_flag || fa_changePath)			//if path does not exist or a change is requested, make a new path		NewPath/O fa_path	endif		SAVE/C/O/P=fa_path wv_V, paramWv		Print "fa_store(): new param wave created", refName_Vendfunction/S fa_getStoreColHeader()	String ref = "fa_storeColHeader"		Variable numStats = 13	Make/O/T/N=(numStats) $ref/WAVE=header		header[0] = "V_adev"//	Average deviation of pixel values.	header[1] = "V_avg"	//Average of pixel values.	header[2] = "V_kurt"	//Kurtosis of pixel values.	header[3] = "V_min"	//Minimum pixel value.	header[4] = "V_minColLoc"	//Specifies the location of the column in which the minimum pixel value was found or the first eligible column if no single column was found.	header[5] = "V_minRowLoc"//	specifies the location of the row in which the minimum pixel value was found or the first eligible row if no single minimum was found.	header[6] = "V_max"	//Maximum pixel value.	header[7] = "V_maxColLoc"	//Specifies the location of the column in which the maximum pixel value was found or the first eligible column if no single column was found.	header[8] = "V_maxRowLoc"	//Specifies the location of the row in which the maximum pixel value was found or the first eligible row if no single maximum was found.	header[9] = "V_npnts"//	Number of points in the ROI.	header[10] = "V_rms"//	Root mean squared of pixel values.	header[11] = "V_sdev"//	Standard deviation of pixel values.	header[12] = "V_skew"	//Skewness of pixel values.endfunction varFromList(itemNum, list, sepStr)	Variable itemNum; String list, sepStr		if (strlen(sepStr) < 1)		sepStr = ";"	endif		return str2num(StringFromList(itemNum,list,sepStr))end//duplicates a wave subrange, provides a stereotyped note and namefunction/S fa_duplicate(wv, startX, endX)	WAVE wv; Double startX, endX		String noteKeyStr_startX = "SUBRANGE_startX"	String noteKeyStr_endX = "SUBRANGE_endX"		String outRef = NameOfWave(wv) + "_SR"	String noteStr = note(wv)		String outNoteStr = ReplaceStringByKey(noteKeyStr_startX, noteStr, num2str(startX))		//adds if key not found	outNoteStr = ReplaceStringByKey(noteKeyStr_endX, outNoteStr, num2str(endX))		Duplicate/O wv, $outRef/WAVE=out	Note/K out, outNoteStr		return outRefend//DATA ACCESS (DA_): use Bruxton DataAccess macros to load abf data/metadata//expects sweepNum is 0 to N-1 for N sweeps. //main wave loading function: could probably be made faster but loading directly into the wave name in some cases, avoiding an unnecessary duplicate operationfunction da_makeWaveFromOpenFile(sweepNum, chanNum, nameForWave, [reportError,atRecSampling,skipOverwritePrefCheck])   	Variable sweepNum, chanNum, reportError; String nameForWave   	Variable atRecSampling		//optionally pass to force load at rec sampling despite any settings in filePanel   	Variable skipOverwritePrefCheck	//pass to skip checking of /O checkbox overwrite check preference. If this is not passed or 0, the wave is not loaded if it already exists unless /O is checked		Variable doSkipOverwritePrefCheck = !ParamIsDefault(skipOverwritePrefCheck) && skipOverwritePrefCheck	Variable forceRecSampling=!ParamIsDefault(atRecSampling) && atRecSampling	   	   	Variable sweepLenLimitSamples=150*10000		//	Variable sweepLenLimitSecs = 150		//in secs   	Variable errorOccured = 0        	    	//now make a new wave by loading ABF    	    	da_setOpenFileSweep(sweepNum)		//have to set to +1 because the rest of the user defined (home made) functions number sweeps from 0 to N-1 where N is number of sweeps, whereas Bruxton or clampex names them from 1 to N    	    	Variable sweepLen = da_getOpenFileSweepLen(-1)			//in SAMPLES    	Variable sRate = da_getOpenFileSampleRate()				//in samples / sec    	//Variable sweepLenLimitSamples = sweepLenLimitSecs * sRate		//now in SAMPLES   	String tempWaveVarName = "tempWave_Make"    	Variable/G status_Make; String statusVarName = "status_Make"   	//cannot invoke this before another ABf/Bruxton related function call because that function will kill the status variable after using it itself 	 	ControlInfo/W=filePanel fd_overwriteOnLoadCB 	Variable forceOverwrite = V_value   	String cmd	if (sweepLen <= sweepLenLimitSamples)		Make/O/D/N=(sweepLen) tempWave_Make		sprintf cmd, "ABFEpisodeRead %d, 0, %d, %s, %s", chanNum, sweepLen, tempWaveVarName, statusVarName		//places ABF sweep into tempWave. literal 0 is the start point   		Execute cmd       		fd_normalizeSetSweepStartTime(tempWaveVarName)		//all sweeps start from time zero   		   		if (!forceRecSampling)   			fd_downsampleIfNeeded(tempWaveVarName)					//downsample if desired from filePanel settings .. would be slightly faster to apply to a whole file at once but complicates making one wave at a time			endif		//now copy that wave to the wave reference of nameForWave				if (forceOverwrite > 0)			Duplicate/O tempWave_Make, $nameForWave			else			if (!doSkipOverwritePrefCheck && waveexists($nameforwave))				Print "da_makeWaveFromOpenFile()",nameforwave,"exists but is not being overwritten per user preference"			else				duplicate/o tempWave_Make, $nameforwave			endif		endif						if (paramIsDefault(reportError) && (status_make != 0))			Print "status = " + num2str(status_make)			String/G message			Sprintf cmd, "ABFGetStatusText status_make, message"			Execute/Q cmd			String additionalMsg = ""			if (status_make == 6)				additionalMsg = "\rLikely file is not available at path of original--or most recent--load)\r"				additionalMsg += "Remap to a new parent data folder with fd_changeFileDirParent() or reload the file to map to a new location by adding the file anew"			endif			Print "status text = " + message + additionalMsg			KillStrings message		endif	    		    else		//new long wave handling -- stitch it back together. seems to work well, replaced commented out stuff on 3 27 2017    		String  currWaveSaveName		Variable numPortions = ceil(sweepLen/sweepLenLimitSamples)					Print "SPLITTING wave output for wave = " + nameForWave + ". NUM PORTIONS = " + num2str(numPortions)		Variable i, currStartSample = 0, currLoadedSweepLen = sweepLenLimitSamples		//will remain sample limit until last portion 		Make/O/D/N=(currLoadedSweepLen) tempWave_Make		//placeholder into which portions will be loaded. Length must equal that being loaded, but also must change for the last sweep to the # remaining samples		for (i=0;i<numPortions;i+=1)			if (i == numPortions -1)			//last portion being loaded, change size of tempWave_Make and currLoadedSweepLen				currLoadedSweepLen = sweepLen - currStartSample				Print "finalSweepLen = " + num2str(currLoadedSweepLen)				Make/O/D/N=(currLoadedSweepLen) tempWave_Make			endif	    	sprintf cmd, "ABFEpisodeRead %d, %d, %d, %s, %s", chanNum, currStartSample, currLoadedSweepLen, tempWaveVarName, statusVarName		//places ABF sweep PORTION into tempWave				Execute cmd						//apply downsampling if requested			if (!forceRecSampling)   			fd_downsampleIfNeeded(tempWaveVarName)					//downsample if desired from filePanel settings .. would be slightly faster to apply to a whole file at once but complicates making one wave at a time			endif						//fd_normalizeSetSweepStartTime(tempWaveVarName)			if (i==0)				Duplicate/O tempWave_make, $nameForWave			else				concatenate/NP=0/DL {tempWave_make},$nameForWave			endif						if (paramIsDefault(reportError) && (status_make != 0))    				Print "status = " + num2str(status_make)    				String/G message    				Sprintf cmd, "ABFGetStatusText status_make, message"    				String messageTemp = message    				Print "status text = " + messageTemp    				KillStrings message    		endif			endfor				fd_normalizeSetSweepStartTime(nameForWave)        endif	String noteString = da_generateOpenFileWaveNote(chanNum, sweepNum+1, nameForWave)   	Note $nameForWave, noteString	Variable status_makeTemp = status_Make	KillVariables/Z status_Make	killwaves/z tempwave_make		return status_makeTempend//assumes input of sweep num from 1 to N-1 where N is num sweepsfunction/S da_generateOpenFileWaveNote(chanNum, sweepNum,nameForWave)	Variable chanNum, sweepNum	String nameForWave		da_setOpenFileSweep(sweepNum) 			//in bruxton, abf sweeps are numbered 1 to N	Variable sweepStartTimeX = da_getSetSweepStartTime()   	String noteString = "FILE_TIME:" + da_getOpenFileCreationTime() + ";SWEEP_TIME:" + num2str(sweepStartTimeX) + ";COMMENT:" + da_getOpenFileComment() + ";RATE:" + num2str(da_getOpenFileSampleRate())   	noteString +=";CH_UNITS:" + da_getOpenFileChanUnits(chanNum) + ";CH_NAME:" + da_getOpenFileChanName(chanNum) + ";CH_NUM:" + num2str(chanNum) +";"   	   	//added 12/21/16   	if (strlen(nameForWave))   		noteString = "ORIG_WAVE_NAME:"+nameForWave+";" + noteString   	endif   	noteString += "IGOR_WAVE_CREATION_TIME:"+time()+";IGOR_WAVE_CREATION_DATE:"+date()+";"   	   		return noteStringend//sweepListBoxAction. handles: multiple sweep selections, de-selecting via single click in title, applying selections via double click in titlefunction sweepListBoxAction(sweepListBoxStruct) : ListBoxControl	STRUCT WMListBoxAction &sweepListBoxStruct	guiC_SL_lbSelectionHandling(sweepListBoxStruct, "sweepsSelListByNums", "sweepsSelList")		//allows multiple and disjoint selections with shift		if (!((sweepListBoxStruct.eventCode == 4) || (sweepListBoxStruct.eventCode == 5) || (sweepListBoxStruct.eventCode == 3)))		//only continue if 4, cell selection, 5 cell selection + shift, or 3 double click		return 0	endif			if (sweepListBoxStruct.row == - 1)			//signifies click in title row			WAVE/T sweepsSelWaveTitles			if (stringmatch(sweepsSelWaveTitles[0], "!*SW*"))		//"SW" is the default before a file has been selected				fd_applySweepSelections("sweepsSelList")			endif	endif end//updates sweep selections function fd_applySweepSelections(selListRef)	String selListRef	Duplicate/O $selListRef, sweepSelTemp	WAVE/T sweepsTracker, sweepsListWave		String currString = ""		String currentSweepDispStr, tempSelectionsStr	Variable i, currFileNum, currSweepNum, toSelect, fNumStart, fNumEnd, sweepNumStart	for (i=0;i<DimSize(sweepSelTemp,0);i+=1)		toSelect = sweepSelTemp[i]		currentSweepDispStr = sweepsListWave[i]		if (fd_isSelected(currentSweepDispStr) > 0)			fNumStart = strlen(selectionIndicatorString)		else			fNumStart = 0		endif		fNumEnd = strsearch(currentSweepDispStr,"_",0) - 1		sweepNumStart = fNumEnd + 2		currFileNum = str2num(currentSweepDispStr[fNumStart,fNumEnd])		currSweepNum = str2num(currentSweepDispStr[sweepNumStart,strlen(currentSweepDispStr)-1])		tempSelectionsStr = sweepsTracker[currFileNum]		tempSelectionsStr[2*currSweepNum,2*currSweepNum] = num2str(toSelect)			//apparently the value gets inserted if you just do string[index]. to have replacement need string[index,index]		sweepsTracker[currFileNum] = tempSelectionsStr			endfor	//update the sweep display	fd_updateSweepsDisplay()	fd_syncLoadedFiles()		KillWaves/Z sweepSelTempend//"sychronizes files to match user selections for loading by function fd_syncLoadedFiles()	WAVE/T fileInfoWave		Variable i	for (i=0;i<DimSize(fileInfoWave,0);i+=1)		fd_syncFile(i)	endforendfunction fd_syncFile(fileNum)	Variable fileNum		WAVE/T fileInfoWave		if (fd_isSelected(fd_getFLoadStrInFileInfoWave(fileNum)))		fd_loadFile(fileNum)		fd_loadFile(fileNum)	endifend//channelListBoxAction. Handles: multipe channel selections, de-selecting via single click in title, applying selections TO HIGHLIGHTED FILES via double click in titlefunction channelListBoxAction(channelListBoxStruct) : ListBoxControl	STRUCT WMListBoxAction &channelListBoxStruct		guiC_SL_lbSelectionHandling(channelListBoxStruct, "channelSelListByNums", "channelSelList")		//allows multiple and disjoint selections with shift		if (!((channelListBoxStruct.eventCode == 4) || (channelListBoxStruct.eventCode == 5) || (channelListBoxStruct.eventCode == 3)))		//only continue if 4, cell selection, 5 cell selection + shift, or 3 double click			return 0	endif			if (channelListBoxStruct.row == - 1)			//signifies click in title row			fd_applyChannelSelections("channelSelList")			fd_syncLoadedFiles()			fd_updateSelectionSummaryTB()	//		WAVE channelSelList;	//		channelSelList = 0	//		Make/O/N=1 channelSelListByNums; channelSelListByNums = 0	endif end//handles graph updates upon selecting sweeps for displayfunction sweepsDispBoxAction(sweepsDispBoxStruct) : listBoxControl	STRUCT WMListBoxAction &sweepsDispBoxStruct		guiC_SL_lbSelectionHandling(sweepsDispBoxStruct, "sweepsDispSelWaveByNums", "sweepsDispSelWave")		//allows multiple and disjoint selections with shift		if (!((sweepsDispBoxStruct.eventCode == 4) || (sweepsDispBoxStruct.eventCode == 5) || (sweepsDispBoxStruct.eventCode == 3)))		//only continue if 4, cell selection, 5 cell selection + shift, or 3 double click		return 0	endif					WAVE/Z lastSweepsDispSelWaveByNums, sweepsDispSelWaveByNums	if (WaveExists(lastSweepsDispSelWaveByNums) < 1)		fd_updateGraph()		Duplicate/O sweepsDispSelWaveByNums, lastSweepsDispSelWaveByNums	endif		if (!(equalwaves(lastSweepsDispSelWaveByNums, sweepsDispSelWaveByNums,1) && equalwaves(lastSweepsDispSelWaveByNums, sweepsDispSelWaveByNums,512)))		//updates graph if either the sel wave now has different dimensions or data		fd_updateGraph()	elseif (sweepsDispBoxStruct.eventCode == 3)		//allows update even in the above cases with a double click		fd_updateGraph()	endif	Duplicate/O sweepsDispSelWaveByNums, lastSweepsDispSelWaveByNumsendfunction dispPrefsListBoxAction(dispPrefsLBStruct) : listBoxControl	STRUCT WMListBoxAction &dispPrefsLBStruct			if (dispPrefsLBStruct.eventMod& 2^4)	//right click only		WAVE/T/Z dispPrefsList		if (!Waveexists(dispPrefsList))			fd_makeDispPrefs()		endif		Variable numAxes =  DimSize(dispPrefsList,0)		if ((dispPrefsLBStruct.row < numAxes) && (dispPrefsLBStruct.col == 1))		//only clicks in col 1 and within range of the dispPrefsList			String currOL = text_getPaddedString(0, strlen(dispPrefsList[0][1]), "0", "0")		//list of zeros as long as overlay string from dispPrefsList col 1.			if (dispPrefsLBStruct.row == -1)				Variable i;				for (i=0;i<numAxes;i+=1)					dispPrefsList[i][1] = currOL				endfor			else				dispPrefsList[dispPrefsLBStruct.row][1] = currOL			endif		endif		endifend//takes in a reference to a numerical wave of 0 or 1s and sets  channel selections for highlighted files to these selectionsfunction fd_applyChannelSelections(selListRef)	String selListRef		Duplicate/O $selListRef, channelSelectionsListTemp	Variable fileNum		Variable i, currentFileNum, currentChannelNum, currentChanSelection		WAVE fileSelListByNums		//iterate through each	for (i=0;i<DimSize(fileSelListByNums,0);i+=1)		currentFileNum = fileSelListByNums[i]		for (currentChannelNum = 0;currentChannelNum<fd_getChanNFromFileInfoWave(currentFileNum);currentChannelNum +=1)			currentChanSelection = channelSelectionsListTemp[currentChannelNum]		//gets the current selection from the channelSelectionsList			fd_setChanSelected(currentFileNum,currentChannelNum,currentChanSelection)		endfor			endfor			KillWaves/Z channelSelectionsTempend//Updates textbox to display the file comment for selected file. Could be modified to show the comment for all filesfunction fd_updateCommentDisplay(fileNum)	Variable fileNum		SVAR titleBoxString		//string displayed in comment text box		WAVE/T fileDirectory	titleBoxString = "Cmnt: \f03" + fileDirectory[fileNum][1]			//    /f02 gives italicsendfunction fd_updateSelectionSummaryTB()	SVAR/Z selectionsSummaryString		if (!SVAR_Exists(selectionsSummaryString))		String/G selectionsSummaryString = "Select file(s)."	//instantiate 			//reset textbox		TitleBox selectionSummaryTitleBox, variable = selectionsSummaryString, fixedSize = 1, frame = 0, win=filePanel	endif		WAVE fileSelListByNums		Variable i, currFileNum	Variable currNumSweeps, currNumChans, currNumWaves, currSampleRate, currLenSecs, currLenSamples, currLenBytes	//for calculations	Variable totalNumSweeps = 0, totalNumWaves = 0, totalLenInSecs = 0, totalLenInSamples = 0, totalLenBtypes		//outputs		for (i=0; i<DimSize(fileSelListByNums,0);i+=1)		currFileNum = fileSelListByNums[i]		currNumSweeps = fd_getTotalNumSelSweeps(currFileNum)		currNumChans = fd_getChanNFromFileInfoWave(currFileNum)		currNumWaves = currNumSweeps * currNumChans		currSampleRate = fd_getSRateFromFileInfoWave(currFileNum)		currLenSecs = fd_getLenSFromFileInfoWave(currFileNum) * currNumWaves		currLenSamples = currSampleRate * currLenSecs		//could change this next one to check actual type of wave. fow now assuming the stnadard ABF		currLenBytes = currLenSamples* sizeOfType(4)			totalNumSweeps += currNumSweeps		totalNumWaves += currNumWaves		totalLenInSecs += currLenSecs		totalLenInSamples += currLenSamples		totalLenBtypes += currLenBytes	endfor		//convert bytes to gigabytes	Variable totalLenGb = totalLenBtypes / 1024 / 1024 / 1024	Variable freeMemInGb = getFreeMemoryInGb()		Variable memRemainingAfterLoad = freeMemInGb - totalLenGb	Variable mayNotfitInMem = memRemainingAfterLoad < .1	String ,warningStr1="\f00",warningStr2=""		//normally remaining free mem is just normal	if (mayNotFitInMem)		warningStr1="\f23"									//now bold italics strike through underlined		warningStr2="\f07!WONT FIT!"						//and add exclamation				titlebox selectionSummaryTitleBox fColor=(65535,0,0 )	else		titlebox selectionSummaryTitleBox fColor=(0,0,0 )	endif		sprintf selectionsSummaryString, "#SWs: \f05%d\f00. #WVs: \f05%d\f00. Len: \f05%3.1fs\f00, \f05%3.2fGb\f00. Mem. now: \f05%3.1fGb\f00 post-load: "+warningStr1+"~%3.1fGb"+warningStr2, totalNumSweeps, totalNumWaves, totalLenInSecs, totalLenGb,freeMemInGb	,memRemainingAfterLoad	//used to include fd_getPrimaryFileNum(),end//restores defaults to dispPrefsList if primary file num changesfunction fd_setPrimaryFileNum(fileNum)	Variable fileNum		NVAR/Z numOfPrimaryFile	if (!NVAR_Exists(numOfPrimaryFile))		Variable/G numOfPrimaryFile = fileNum		return 0	endif		if (numOfPrimaryFile == fileNum)		return 0		endif		numOfPrimaryFile = fileNum	fd_restoreDispDefaults()endfunction fd_getPrimaryFileNum()	NVAR/Z numOfPrimaryFile		if (!NVAR_Exists(numOfPrimaryFile))		return -1	endif		return numOfPrimaryFileend//Generates a list of sweeps for display and saves them in sweepsListWave, which is the listwave for sweepsListBox//which sweeps are selected and displayed is saved in sweepsTracker, and this function translates that into a list represetationfunction fd_updateSweepsDisplay()		WAVE/T sweepsTracker	WAVE fileSelListByNums		//for handling of sweep selection for loading		String sweepSelections = ""	String sweepSelectionsDispString = ""	Make/O/T/N=1 sweepsListWave //this is already set as the listwave for the sweepsListBox	WAVE/T sweepsSelWaveTitles 	sweepsSelWaveTitles[0] = ""		WAVE/T fileInfoWave			NVAR numNonChanFileInfoWaveCols	Variable maxNumChans = DimSize(fileInfoWave,1) - numNonChanFileInfoWaveCols		Variable i, currSweepNum, totalNumSweeps, currFileNum, sweepCount = 0	for (i=0;i<DimSize(fileSelListByNums,0);i+=1)			//handling of sweep selection for loading		currFileNum = fileSelListByNums[i]		if ( (currFileNum < 0) || (currFileNum >= dimsize(fileInfoWave,0)) ) 			continue		endif		sweepsSelWaveTitles[0] += num2str(currFileNum) + ";"		sweepSelections = sweepsTracker[currFileNum]		totalNumSweeps = ItemsInList(sweepSelections,";")		if (i==0)			Redimension/N=(totalNumSweeps) sweepsListWave		else				Redimension/N=(DimSize(sweepsListWave,0) + totalNumSweeps) sweepsListWave		endif						for (currSweepNum = 0; currSweepNum<totalNumSweeps;currSweepNum +=1)			if (fd_isSweepSelected(StringFromList(currSweepNum, sweepSelections,";")))				sweepsListWave[sweepCount] = selectionIndicatorString + num2str(currFileNum) + "_" + num2str(currSweepNum)			else				sweepsListWave[sweepCount] = num2str(currFileNum) + "_" + num2str(currSweepNum)			endif			sweepCount +=1			//this is the iterator through sleeps displayed		endfor					endfor		Make/O/N=(DimSize(sweepsListWave,0)) sweepsSelList		//handling of graphing list	//for handling of sweeps for display	Make/O/T/N=(1,3) sweepsDispList	Make/O/N=(1,3) sweepsDispSelWave	Make/O/T sweepsDispTitleWave = {"F:","SW:","W:"}		String currentFileName, listOfWavesMatchingFile,currWavesString, currSweepName, currChanSelList	Variable numSweepsForCurrentFile, totalNumGraphSweepsFound = 0, currentNumGraphSweepsFound, sweepsIterator, currentDispListIndex, channelsIterator, currChannelNum	Variable updateNeeded = 0, numChansExpected, waveFound 	//if expected waves aren't found, runs an update to correct the list for this 				for (i=0;i<DimSize(fileSelListByNums,0);i+=1)			currFileNum = fileSelListByNums[i]		if (fd_isSelected(fd_getFLoadStrInFileInfoWave(currFileNum)))			//checks that wave is loaded. UNSAFE VERSION ASSUMES NO DELETIONS			currentFileName = fd_getFNameFromFileInfoWave(currFileNum,0)			currChanSelList = fd_getChanSelectionList(currFileNum,1)						listOfWavesMatchingFile = wavelist((currentFileName + "_" + "*" + "_AD*"),";","TEXT:0")			sweepSelections = sweepsTracker[currFileNum]			numChansExpected = fd_getNumSelectedChans(currFileNum)			if (numChansExpected > (DimSize(sweepsDispList,1) - 2))			//update display to have 2 columns for file # and sweep # and then as many more columns as channels expected				Redimension/N=(-1,numChansExpected+2) sweepsDispList, sweepsDispSelWave				Redimension/N=(numChansExpected+2) sweepsDispTitleWave			endif			numSweepsForCurrentFile = ItemsInList(listmatch(sweepSelections,"1",";"),";")			//gets number of ones in sweepSelections list			Redimension/N=(totalNumGraphSweepsFound + numSweepsForCurrentFile,-1) sweepsDispList, sweepsDispSelWave			currentNumGraphSweepsFound = 0						for (sweepsIterator = 0; currentNumGraphSweepsFound < numSweepsForCurrentFile; sweepsIterator +=1)		//iterate through sweepSelections, update sweep selections if wave is now absent or display if present				if (fd_isSweepSelected(StringFromList(sweepsIterator, sweepSelections,";")))					currentDispListIndex = totalNumGraphSweepsFound + currentNumGraphSweepsFound					sweepsDispList[currentDispListIndex][0] = num2str(currFileNum)					sweepsDispList[currentDispListIndex][1] = num2str(sweepsIterator)					waveFound = 0					for (channelsIterator = 0; channelsIterator < numChansExpected; channelsIterator +=1)						currChannelNum = str2num(StringFromList(channelsIterator,currChanSelList))						//need to switch to selected channel numbers here!						currSweepName = currentFileName + "_" + num2str(sweepsIterator+1) + "_AD" + num2str(currChannelNum)						if (WhichListItem(currSweepName, listOfWavesMatchingFile, ";") > -1)			//check if this sweep exists							sweepsDispList[currentDispListIndex][2+channelsIterator] = currSweepName							waveFound = 1						else							sweepsDispList[currentDispListIndex][2+channelsIterator] = ""						endif									endfor					if (waveFound ==0)	//then no waves found even though expected						sweepsDispList[currentDispListIndex][0,1] = ""						sweepSelections[2*sweepsIterator,2*sweepsIterator] = "0"						updateNeeded = 1					endif					currentNumGraphSweepsFound +=1				endif			endfor			totalNumGraphSweepsFound += numSweepsForCurrentFile		endif		endfor	//handle when no loaded sweeps are found for display	if (totalNumGraphSweepsFound == 0)		sweepsDispList[0][0] = "Load"		sweepsDispList[0][1] = "some"		sweepsDispList[0][2] = "waves!"	endif		if (updateNeeded)	//	Print "Waves expected not found. Updating selection lists"	//	fd_updateSweepsDisplay()	endif end//clearsFileDispGraph, restores dispPrefsList to defaults as if nothing has been selectedfunction fd_restoreDispDefaults()	fd_clearFileDispGraph()	WAVE/T/Z dispPrefsList	if (!WaveExists(dispPrefsList))		fd_makeDispPrefs()	endif		Variable numChans = DimSize(dispPrefsList,0)		Variable i	for (i=0;i<numChans;i+=1)		dispPrefsList[i][1] = text_getPaddedString(i,numChans,"1","0")		dispPrefsList[i][2] = ""		dispPrefsList[i][3] = ""		endforend//returns 1 for input of "1" or 0 for any other inputfunction fd_isSweepSelected(selString)	String selString	if (stringmatch(selString, "1"))		return 1	else		return 0	endifendfunction fd_isSelected(selString)	String selString	SVAR selectionIndicatorString	return stringmatch(selString, "*" + selectionIndicatorString + "*")end/////////////////////////////////////////////////////////////////////////////////////////Action response functions (button-related)function addABFs(B_Struct) : ButtonControl	STRUCT WMButtonAction &B_Struct	if (B_Struct.eventCode !=1)		//only responds to mouse down (click)		return 0	endif	fd_abfLoad("")endfunction newFileDispGraph(B_Struct) : ButtonControl	STRUCT WMButtonAction &B_Struct		if (B_Struct.eventCode !=1)		//only responds to mouse down (click)		return 0	endif		if ( (B_Struct.eventMod & 2^1) != 0)			//shift click		fd_currGraphToTop()		return 0	endif		if ( (B_Struct.eventMod & 2^3) != 0)			//cntrl click		if ( (B_Struct.eventMod & 2^1) != 0)		//cntrl + shift click			disp_defaultRange(a=2)		else			disp_defaultRange()		endif		return 1	endif		SVAR/Z currFileDispGraphN	if (!svar_Exists(currFileDispGraphN))		String/G currFileDispGraphN =ks_fd_graphNameStart+"0"	else		Variable currentGraphNum = str2num(stringfromlist(2,currFileDispGraphN,"_"))		if (numtype(currentGraphNum))		//NaN, probably not a number at end of graph			currentGraphNum = 0		else			currentGraphNum +=1		endif		currFileDispGraphN = ks_fd_graphNameStart+ num2str(currentGraphNum)	endif		Display/K=1/N=$currFileDispGraphN	currFileDispGraphN=S_name	Setwindow $currFileDispGraphN hook(fd_winHook) = fd_winHook	showinfo/W=$currFileDispGraphNendfunction fd_buttonHandling(B_Struct) : ButtonControl		//eventually should migrate newFileDispGraph and addABFs but might make less backwards compatible 	STRUCT WMButtonAction &B_Struct	if (B_Struct.eventCode !=1)		//only responds to mouse down (click)		return 0	endif			strswitch (B_struct.ctrlName)		case "setAbfFileParentDir":			fd_changefiledirparent()			break					case "setIbwFileParentDir":			fd_changeStoreAbfAsIbwPath("")			break					case "saveAbfsAsIbws":			fd_storeAbfsAsIbws(nan,nan)					break	endswitchendfunction fd_currGraphToTop()	SVAR/Z currFileDispGraphN	if (!svar_Exists(currFileDispGraphN))		String/G currFileDispGraphN =ks_fd_graphNameStart+"0"		Display/K=1/N=$currFileDispGraphN		currFileDispGraphN=S_name		Setwindow $currFileDispGraphN hook(fd_winHook) = fd_winHook		showinfo/W=$currFileDispGraphN	endif	BringToTop(currFileDispGraphN)end//end button-related functions///////////////////////////////////////////////////////////////////////////////////////////Helper functionsfunction/S text_makeStringList(mainListItem, len, delimiterStr,[specialInds,specialListItems])	String mainListItem, delimiterStr; Variable len	String specialInds		//optionally pass list of special indexes to insert specialListItems at	String specialListItems	//optionally pass special list items to insert at the indexes in specialInds											//can pass just a single value if all are the same 		Variable specials=!ParamIsDefault(specialInds) && (strlen(specialInds) > 0)	specials = specials && !ParamIsDefault(specialListItems) && (strlen(specialListItems) > 0)		String output = ""	Variable i,specialPos	String specialListItem,thisListItem	if (specials)		for (i=0;i<len;i+=1)			specialPos = whichlistitem(num2str(i),specialInds)			if (specialPos >= 0)				specialListItem = text_stringfromlist_trunc(specialPos,specialListItems)				thisListItem = specialListItem			else				thisListItem = mainListItem			endif						output = output + thisListItem + delimiterStr						endfor	else		for (i=0;i<len;i+=1)			output = output + mainListItem + delimiterStr			endfor	endif		return outputendfunction/S text_getRepeatedStr(strToRepeat,numRepeats)	String strToRepeat; variable numRepeats		string out = "";variable i	for (i=0;i<numRepeats;i+=1)		out += strToRepeat	endfor		return outendfunction/S text_getPaddedString(indexOfMainStr, totalStrLen, mainStr, padStr)	Variable indexOfMainStr, totalStrLen; String mainStr, padStr	String tempStr = ""	Variable i		for (i=0;i<totalStrLen;i+=strlen(padStr))		tempStr += padStr		endfor		//for multi-character padStr, if strlen is not a multiple of padstr, the for loop will make a string longer than totalStrLen, so cut this down to size	String output = tempStr[0, strlen(tempStr)-1]		//check that indexOfMainStr is within str, and insert if so (when input is an index beyond totalStrLen, mainStr is simply not inserted. If a portion is beyond str len, that remainder is cut off	if (indexOfMainStr < strlen(output))		output[indexOfMainStr, indexOfMainStr + strlen(mainStr)-1] = mainStr	endif			return outputend //function that allows adjacent and disjoint selections in listboxes//also controls right click = clear selections//example settings for listbox that will work with this:		ListBox $lbName,proc=fio_ft_lbAction,win=$S_name,listWave=listWv,selWave=$lb_selWaveName,userdata(selListByNumsRef)=lb_selWaveByNumsName,size={400,400},userColumnResize=1,mode=4,pos={0,0}//call this function with selListByNumsRef, selListRef as "", "" to use default selListRef and selListByNumsReffunction guiC_SL_lbSelectionHandling(lbStruct, selListByNumsRef, selListRef)	Struct WMListBoxAction &lbStruct; String selListByNumsRef, selListRef	if (strlen(selListRef) < 1)		selListRef = NameOfWave(lbStruct.selWave)	endif			if (strlen(selListByNumsRef) < 1)		selListByNumsRef = guiC_lb_getSelWaveByNumsRef(lbStruct)		//gets and, if necessary, sets a selWaveByNumsRef (if one hasn't been set already)	endif			Variable clickType = 0		if (!((lbStruct.eventCode==1) || (lbStruct.eventCode==3) || (lbStruct.eventCode==4) || (lbStruct.eventCode==5)))	//only permits mouse down, double click, cell selection +/- shift to run rest of function		return clickType	endif	//checks to makes sure that the by nums version of the selection list exists and creates one if not	//only likely to enter if statement if selListByNumsRef is passed instead of an empty string (latter handled by guiC_lb_getSelWaveByNumsRef())	if (WaveExists($selListByNumsRef) < 1)		Make/O/N=1 tempSelList		//tracks selections list in number form		Duplicate/O tempSelList, $selListByNumsRef		KillWaves/Z tempSelList	endif		if (lbStruct.row > DimSize($selListRef,0)-1)	//ignores clicks beyond the length of the sel list		return clickType	endif		if (lbStruct.eventCode == 4)		//cell selection		guiC_lb_setListByNumsTo(lbStruct.row, selListByNumsRef)		clickType = 1 //signifies added cell selection (single, new cell chosen)	endif		if (lbStruct.eventCode == 5)		//cell selection with shift key down		//WAVE/Z fileSelListByNums		Duplicate/O $selListByNumsRef, selListByNumsTemp				FindValue/Z/I=(lbStruct.row) selListByNumsTemp		if (V_Value == -1)			//then the new selection is not in the list and should be added			addToListByNums(lbStruct.row, selListByNumsRef)			clickType = 2		//signifies (additional) cell added 		else						//then the selection was already in the list and it's not new so remove it			removeFromListByNums(lbStruct.row, selListByNumsRef)			clickType = 3		//signifies (additional) cell removed 		endif				KillWaves/Z selListByNumsTemp		endif	if ((lbStruct.eventMod & 2^3) && (lbStruct.eventMod & 2^0) && (lbStruct.eventMod & 2^1))		//first two indicates a click with cntrl button down, but user MUST also have shift key down for the function to work (won't clear the previous selection this way)		selectInclusiveSubsetNew(selListByNumsRef, selListRef)		clickType = 4	//signifies one or more cells added	endif		if (lbStruct.eventMod & 2^4)		//right click, select all or, If shift right click, deselect all. 		WAVE selListTemp = $selListRef		if (lbStruct.eventCode != 5)		//shift not down -- select all			selListTemp=0			selListTemp[0][0] = 1			selListTemp[DimSize(selListTemp,0)-1][0] = 1			updateSelListByNums(selListRef, selListByNumsRef)			selectInclusiveSubsetNew(selListByNumsRef, selListRef)			clickType = 5		//signifies all cells added		else								//shift down -- deselect all			selListTemp = 0			make/o/n=1  $selListByNumsRef/wave=selListTempByNums			selListTempByNums = -1			Make/O/N=1 selListTempByNums			clickType = -1	//signifies all cells removed		endif	endif	return clickTypeendfunction/S guiC_lb_getSelWaveByNumsRef(s) : ListboxControl	STRUCT WMListboxAction &s		return guiC_lb_getSelWaveByNumsRef_g(s.win, s.ctrlname)	//	String selListByNumsRef = GetUserData(s.win, s.ctrlName, "selListByNumsRef" )//	if (strlen(selListByNumsRef) < 1)		//add a selListByNums if needed//		selListByNumsRef = NameOfwave(s.selWave) + "n"		//"n" as default append string//		Print "creating selListByNumsRef (ref=", selListByNumsRef,"for listbox named", s.ctrlName, "in window named",s.win,"with selWave named", NameOfwave(s.selWave)//		Make/O/N=1 $selListByNumsRef//		Listbox $s.ctrlName win=$s.win, userdata(selListByNumsRef) = selListByNumsRef//	endif	//	//	return selListByNumsRef	endfunction/S guiC_lb_getSelWaveByNumsRef_g(winN, ctrlName)	String winN, ctrlName		String selWaveRef = guiC_lb_getSelWaveRef_g(winN, ctrlName)		String selListByNumsRef = GetUserData(winN, ctrlName, "selListByNumsRef" )	if (strlen(selListByNumsRef) < 1)		//add a selListByNums if needed		selListByNumsRef = selWaveRef + "n"		//"n" as default append string		Print "creating selListByNumsRef (ref=", selListByNumsRef,"for listbox named", ctrlName, "in window named",winN,"with selWave named", selWaveRef		Make/O/N=1 $selListByNumsRef		Listbox $ctrlName win=$winN, userdata(selListByNumsRef) = selListByNumsRef	endif			return selListByNumsRef endfunction/S guiC_lb_getSelWaveRef_g(winN, ctrlName)	String winN, ctrlName		ControlInfo/W=$winN $ctrlName		return S_valueendfunction/S guiC_lb_getSelWaveList_g(winN, ctrlName, colNum)	String winN	//window of listbox	String ctrlName	//name of listbox	Variable colNum	//column to get info from based on selList		WAVE/T selWv = $guiC_lb_getSelWaveRef_g(winN, ctrlName)	WAVE selWvByNums = $guiC_lb_getSelWaveByNumsRef_g(winN, ctrlName)		Variable i, index; String out = ""	if (colNum == -1)		for (i=0;i<Dimsize(selWvByNums,0);i+=1)			index = selWvByNums[i]			out += GetDimLabel(selWv, 0, index ) + ";"		endfor		else		for (i=0;i<Dimsize(selWvByNums,0);i+=1)			index = selWvByNums[i]			out += selWv[index][colNum] + ";"		endfor	endif		return outend//implements a find prompt to move to files in a listbox -- currently requires listbox to have a header row//(though this could be modified by remivng the lbStruct.row part of the first if statement//then searches through shift double clicked header row//returns -1 for no find command occured (allows calling functions to continue as usual)//return count of matches otherwise//Note: can scroll through selections with shift+scroll downfunction guiC_lb_findText(lbStruct)	STRUCT WMListBoxAction &lbStruct		//listbox structure passed from listbox procedure		Variable newSearch=(lbStruct.eventCode == 3)&&(lbStruct.row == -1)&&((lbStruct.eventMod & 2^1) > 0)//shift + double click in header row	if (!newSearch)		return -1	endif			Variable keepSelsOrClearNewMatches	if  ((lbStruct.eventMod & 2^3) > 0)			if ((lbStruct.eventMod & 2^2) > 0) 	//shift+ctrl+alt click -- remove new matches from pre-existing			keepSelsOrClearNewMatches = 2		else										//shift+ctrl click		-- add new matches to pre-existing			keepSelsOrClearNewMatches = 1		endif	else		//just shift click		keepSelsOrClearNewMatches = 0			//just shift   	-- set selections just to new matches	endif	String columnLastMatchStrUserDataN = guiC_lb_getMatchStrColUserDataN("matchStr",lbStruct.col)	String columnLastStartRowUserDataN = guiC_lb_getMatchStrColUserDataN("startRow",lbStruct.col)	String columnLastDoWCsUserDataN = guiC_lb_getMatchStrColUserDataN("DoWCs",lbStruct.col)		//tracks wild card preference		//Print "columnLastMatchStrUserDataN",columnLastMatchStrUserDataN	//check for previous search in this column	String listOfMatchStrs = GetUserData(lbStruct.win, lbStruct.ctrlname,columnLastMatchStrUserDataN )	Variable searchStartRow = str2num(GetUserData(lbStruct.win, lbStruct.ctrlname,columnLastStartRowUserDataN ))	if (numtype(searchStartRow) == 2)		//nan .. likely first use, default to using first		searchStartRow = 0	endif	Variable appendWild = str2num(GetUserData(lbStruct.win, lbStruct.ctrlname,columnLastDoWCsUserDataN ))	if (numtype(appendWild) > 0)		//na inf .. likely first use, default to 3		appendWild = 3	endif		Prompt listOfMatchStrs, "Find:"	prompt searchStartRow, "Search from row (or -1 for search from top of current view):"	prompt appendWild, "Append Wild Cards? (0-no,1-@start,2-@end,3-both)"	DoPrompt "Find matches in col# " + num2str(lbStruct.col), listOfMatchStrs,searchStartRow,appendWild		if (V_flag)		//ignore user cancels		return 0	endif	if (itemsinlist(listOfMatchStrs) < 1)		//ignore blanks		return 0	endif		//store this search as last previous	listbox $lbStruct.ctrlname, userdata($columnLastMatchStrUserDataN) = listOfMatchStrs	listbox $lbStruct.ctrlname, userdata($columnLastStartRowUserDataN) = num2str(searchStartRow)	listbox $lbStruct.ctrlname, userdata($columnLastDoWCsUserDataN) = num2str(appendWild)		//deal with special case of row -1:	if (searchStartRow < 0)		controlinfo/w=$lbstruct.win $lbstruct.ctrlname		searchStartRow = V_startRow	endif		//MODIFY TO APPEND TO EACH ITEM	switch (appendWild)		//do this after saving prefs so the added wild cards arent stored with listOfMatchStrs		case 0:		//no additions			break		case 1: 	//1 append to front			listOfMatchStrs = text_appendToStrsInList(listOfMatchStrs,"*",1,";")			break		case 2: 			listOfMatchStrs = text_appendToStrsInList(listOfMatchStrs,"*",0,";")			break		default: //3 or anything else			listOfMatchStrs = text_appendToStrsInList(listOfMatchStrs,"*",1,";")			listOfMatchStrs = text_appendToStrsInList(listOfMatchStrs,"*",0,";")	endswitch		guiC_lb_goToMatchingRows(lbStruct,listOfMatchStrs,lbstruct.col,keepSelsOrClearNewMatches,searchStartRow)	return 1end	//guiC_lb_findTextfunction guiC_lb_goToMatchingRows(lbStruct,listOfMatchStrs,textCol,keepSelsOrClearNewMatches,searchStartRow)	STRUCT WMListBoxAction &lbStruct		//listbox structure passed from listbox procedure	String listOfMatchStrs	Variable textCol			//column to search in	Variable keepSelsOrClearNewMatches	//0: selections will only be matches; 1: selections will be matches + pre-existing matches; 2: selections will be pre-existing matches - new matches	Variable searchStartRow		//zero to search all rows		WAVE/T listwv = lbstruct.listwave	WAVE selWv = lbStruct.selWave			Variable rows = dimsize(listWv,0),newtopRow	Controlinfo/w=$lbStruct.win $lbStruct.ctrlname	Variable origRow = V_startRow		if (!keepSelsOrClearNewMatches)		selWv = 0	endif		Variable i,count = 0,num=DimSize(listwv,0)	for (i=searchStartRow;i<num;i+=1)		if (text_matchToListStrs(listwv[i][textCol], listOfMatchStrs)	)			//(StringMatch(listwv[i][textCol], matchStr))			selWv[i] = (keepSelsOrClearNewMatches == 2) ? 0 : 1			if (count==0)				newtopRow = i				Listbox fileListBox row = newtopRow, win = filePanel			endif			count+=1		endif		endfor		//Print "guiC_lb_goToMatchingRows() moved to newtopRow",newtopRow,"origRow",origRow,"searchStartRow",searchStartRow,"matching count",count		return countendfunction/s guiC_lb_getMatchStrColUserDataN(paramName,colNum)	Variable colNum; string paramName	return "lastGoToRow"+paramName+"_" + num2str(colNum)endfunction/S getDimLabels(wv,dim,indicesListOrBlankForAll)	WAVE wv	Variable dim	STring indicesListOrBlankForAll		VAriable getAllLabels = !strlen(indicesListOrBlankForAll)		variable i, ind; string out = ""		if (getAllLabels)		for (i=0;i<dimsize(wv,dim);i+=1)			out += GetDimLabel(wv, dim, i) + ";"				endfor		else		for (i=0;i<itemsinlist(indicesListOrBlankForAll);i+=1)			ind = str2num(stringfromlist(i,indicesListOrBlankForAll))			out += GetDimLabel(wv, dim, ind) + ";"		endfor	endif			return outend///////////////////////////////////////////////////////////////////////////////////////////Wave display functions//dispPrefsListfunction fd_updateGraph()	SVAR/Z currFileDispGraphN			Variable forceBlackTracesOnly = 0		Variable opacProp = 0.6	Variable opac = opacProp * (-1+2^16)				Variable bottomRangeStart = NaN	Variable bottomRangeEnd = NaN	Variable i	String currOL	WAVE/T/Z dispPrefsList	if (!Waveexists(dispPrefsList) || (dimsize(dispPrefsList,0) < 1) || numtype(strlen(dispPrefsList[0][0])) || !strlen(dispPrefsList[0][0]) )		fd_makeDispPrefs()	endif		//check if graph yet exists		String axisListOf, leftAxisNames, leftAxisMins, leftAxisMaxs	if (!SVAR_Exists(currFileDispGraphN))		String/G currFileDispGraphN =ks_fd_graphNameStart+"0"		Display/K=1/N=$currFileDispGraphN		currFileDispGraphN=S_name		Setwindow $currFileDispGraphN hook(fd_winHook) = fd_winHook		showinfo/W=$currFileDispGraphN	endif	if (WinType(currFileDispGraphN) < 1)		Display/K=1/N=$currFileDispGraphN		currFileDispGraphN=S_name		Setwindow $currFileDispGraphN hook(fd_winHook) = fd_winHook		showinfo/W=$currFileDispGraphN	else		//recover old axis settings		GetAxis/Q/W=$currFileDispGraphN bottom		bottomRangeStart = V_min		bottomRangeEnd = V_max				axisListOf = AxisList(currFileDispGraphN)		leftAxisNames = listmatch(axisListOF,"L_*",";")		leftAxisMins = ""		//stores values, in order of leftAxisNames, of min of each axis		leftAxisMaxs = ""		//same for max			String currLeftAxisName,temp; Variable overlayIterator = -1, overlayFound = 1		for (i=0;i<ItemsInList(leftAxisNames);i+=1)			currLeftAxisName = StringFromList(i, leftAxisNames,";")			GetAxis/Q/W=$currFileDispGraphN $currLeftAxisName						sprintf temp, "%g;", V_min			//prints V_min in automatically selected format, followed by a semicolor			leftAxisMins += temp			sprintf temp, "%g;", V_max		//prints V_max in automatically selected format, followed by a semicolor			leftAxisMaxs += temp		endfor				//then clear the graph		fd_clearFileDispGraph()			endif		//always show first file in file selelection list		Variable axisSpacer = .03		WAVE/Z fileSelListByNums		//check that first file is loaded, and abort if not	if (!waveexists(fileSelListByNums) || (fd_isSelected(fd_getFLoadStrInFileInfoWave(fileSelListByNums[0])) < 1)  )	//	Print "Cannot display unloaded files. Use load all for a smooth preview"		return 0	endif		WAVE sweepsDispSelWaveByNums	WAVE/T fileInfoWave,sweepsDispList		Variable numTotalChans = DimSize(sweepsDispList,1) - 2		if (numTotalChans > dimsize(dispPrefsList,0) )		fd_makeDispPrefs()	endif		Variable channelIterator, axisIterator	String plotChanOnAxisOrColor		Make/O/T/N=(numTotalChans, 2) axesForEachPlottedChannel		//col one is semi-colon delimited list of axes on which each channel is plotted. Col 2 is a semi-colon delimited list of the color choices for each channel (single letter codes, user input	axesForEachPlottedChannel = ""		//find number of Axes needed based on channel overlays	String axisPlotString = ""		//contains the numbers of all axes to plot, semi-colon delimited	Variable totalNumAxes = 0	String listOfAxisNums = "", currColorStr	String nullAxisSelectionStr = text_getPaddedString(0, strlen(dispPrefsList[0][1]), "0", "0")		//list of zeros as long as overlay string from dispPrefsList col 1. If axis is unused, this string will match the axis string	for (channelIterator=0;channelIterator<numTotalChans;channelIterator+=1)		//for each channel (e.g. each wave-listing column in sweepsDispList)		for (axisIterator = 0; axisIterator < numTotalChans; axisIterator +=1)		//go through each axis and see if it should be plotted there 			currOL = dispPrefsList[axisIterator][1]		//	Print "channel overlay = " + currOL			//first, for just one (any would do, so we'll use the first) channel, check which axes are going to be used			if ((channelIterator == 0) && (!stringmatch(currOL,nullAxisSelectionStr)))				listOfAxisNums += num2str(axisIterator) + ";"			endif			plotChanOnAxisOrColor = currOL[channelIterator]			if (!stringmatch(plotChanOnAxisOrColor,"0"))				axesForEachPlottedChannel[channelIterator][0] += num2str(axisIterator) + ";"					axesForEachPlottedChannel[channelIterator][1] += plotChanOnAxisOrColor + ";"			endif		endfor	endfor		totalNumAxes = ItemsInList(listOfAxisNums,";")		//calculate axis scaling	Variable totalBetweenAxisSpace = (totalNumAxes - 1) * axisSpacer	Variable totalSpaceForPlotting = 1 - totalBetweenAxisSpace	Variable spacePerAxis = totalSpaceForPlotting / totalNumAxes				//handle display of actual graph	String currentWaveName, currAxisName,currentFileName; Variable currFileNum, currentAxisNum, currentChanNum, sweepDispSelection, currentSweepNum ,currSweepNum	String axisColorString, currAxisColorAbbreviaton	Variable sweepIterator, waveIterator, currChannel, currRedVal, currGreenVal, currBlueVal		String currentChanStr, noteString; Variable chanNum_forUpdate, sweepNum_forUpdate		//Jan 2016		for (sweepIterator = 0; sweepIterator < DimSize(sweepsDispSelWaveByNums,0); sweepIterator +=1)		currSweepNum = sweepsDispSelWaveByNums[sweepIterator]		for (waveIterator = 2; waveIterator < DimSize(sweepsDispList,1); waveIterator +=1)			if (currSweepNum > Dimsize(sweepsDispList,0) - 1 )				continue			endif			//get channel names which are (now) stored in wave notes. If not found in wave note (assumed due to old note formatting), go back to file and update wave note to this new format			currentWaveName = sweepsDispList[currSweepNum][waveIterator]			if (!WaveExists($currentWaveName))				continue			endif			currChannel = waveIterator - 2			currentChanStr = fd_note_getChanStr(currentWaveName)			if ( (strlen(currentChanStr) == 0) && !igor_is64())				Print "In fd_updateGraph, updating wave note for wave " + currentWaveName				da_fd_openABFByFileNum(fd_getFIndexInFileInfoWave(StringFromList(0,getFileNameFromWaveName(currentWaveName, 0)) + "*"))				chanNum_forUpdate = da_l_getChanNumFromWaveName(currentWaveName)				sweepNum_forUpdate = da_l_getSweepNumFromWaveName(currentWaveName)				currentChanStr = da_getOpenFileChanName(chanNum_forUpdate)		   		noteString = "TIME:" + da_getOpenFileCreationTime() + ";COMMENT:" + da_getOpenFileComment() + ";RATE:" + num2str(da_getOpenFileSampleRate()) + ";UNITS:" + da_getOpenFileChanUnits(chanNum_forUpdate) + ";"   				noteString += "CH_NAME:" + da_getOpenFileChanName(chanNum_forUpdate) + ";CH_NUM:" + num2str(chanNum_forUpdate) +";"   				Note/K $currentWaveName, noteString   				da_closeABF()			endif			axisPlotString = axesForEachPlottedChannel[currChannel][0]			axisColorString = axesForEachPlottedChannel[currChannel][1]			for (axisIterator = 0; axisIterator < ItemsInList(axisPlotString,";"); axisIterator+=1)				currAxisName = "L_" + stringFromList(axisIterator, axisPlotString,";")				currAxisColorAbbreviaton = StringFromList(axisIterator, axisColorString,";")				vis_getColorForGraph(currAxisColorAbbreviaton, currRedVal, currGreenVal, currBlueVal)			//proper color values based on currAxisColorAbbreviaton are stored in currRedVal, currGreenVal, currBlueVal				AppendToGraph/W=$currFileDispGraphN/L=$currAxisName/C=(currRedVal, currGreenVal, currBlueVal,opac) $currentWaveName				Label/W=$currFileDispGraphN $currAxisName, "\Z07" +currentChanStr + "\r(\\U)"			endfor		endfor	endfor		String updated_axisList = AxisList(currFileDispGraphN)		Variable currAxisEnd = 1		//going from top produces order I'm used to	Variable currAxisNum	String currAxisNumStr		//actual row of axis on dispPrefsList	String currAxisMinStr, currAxisMaxStr	for (axisIterator = 0 ;axisIterator < totalNumAxes ;axisIterator +=1)		currAxisNumStr = StringFromList(axisIterator, listOfAxisNums,";")		currAxisNum = str2num(currAxisNumStr)		currAxisName = "L_" + currAxisNumStr				//only complete if axis really exists on graph		if (WhichListItem(currAxisName, updated_axisList) < 0)			continue		endif			//handles axis sizing, either automatic based on # axes or based on user input in dispPrefsList				//if statement checks that display prefs are formatted appropriately		if ((str2num(dispPrefsList[currAxisNum][2]) >= 0) &&   (str2num(dispPrefsList[currAxisNum][2]) <=100 ) &&  (str2num(dispPrefsList[currAxisNum][3]) > str2num(dispPrefsList[currAxisNum][2])) && (str2num(dispPrefsList[currAxisNum][3]) <= 100))			ModifyGraph/W=$currFileDispGraphN axisEnab($currAxisName) = {str2num(dispPrefsList[currAxisNum][2])/100, str2num(dispPrefsList[currAxisNum][3])/100}, lblpos($currAxisName) = 52, freepos = 0		else			if (axisIterator == totalNumAxes - 1)			//for the last axis, currAxisEnd - spacePerAxis can sometimes give very slightly less than 0 and cause trouble				ModifyGraph/W=$currFileDispGraphN axisEnab($currAxisName) = {0, currAxisEnd}, lblpos($currAxisName) = 52, freepos = 0			else				ModifyGraph/W=$currFileDispGraphN axisEnab($currAxisName) = {currAxisEnd - spacePerAxis, currAxisEnd}, lblpos($currAxisName) = 52, freepos = 0			endif		endif				currAxisEnd = currAxisEnd - spacePerAxis - axisSpacer				//check whether yAxScalingOn (allows memory for yAxScaling) 		NVAR yAxScalingOn		if (NVAR_Exists(yAxScalingOn) && yAxScalingOn)			//set axis as previously, assuming orders were maintained 			currAxisMinStr = StringFromList(axisIterator, leftAxisMins,";")			currAxisMaxStr = StringFromList(axisIterator, leftAxisMaxs,";")			//check that axis inputs exist and are real numbers (will be "nan" if, for instance, axis was just deleted			if (!stringmatch(currAxisMinStr,"nan") && (strlen(currAxisMinStr)>0) && !stringmatch(currAxisMaxStr,"nan") && (strlen(currAxisMaxStr)>0))				SetAxis/W=$currFileDispGraphN $currAxisName, str2num(currAxisMinStr), str2num(currAxisMaxStr)				endif		else			SetAxis/W=$currFileDispGraphN/A=2 $currAxisName		//autoscale for given baseline			endif	endfor		//adjust bottom axis to old user settings if these settings are appropriate	NVAR xAxScalingOn	if (NVAR_Exists(xAxScalingOn) && xAxScalingOn && (numtype(bottomRangeStart)==0) && (numtype(bottomRangeEnd)==0) && (bottomRangeEnd > bottomRangeStart) && (itemsinlist(ListMatch(AxisList(currFileDispGraphN),"bottom")) > 0) )		setaxis/W=$currFileDispGraphN bottom, bottomRangeStart, bottomRangeEnd	endif		if (forceBlackTracesOnly)		modifygraph/W=$currFileDispGraphN rgb=(0,0,0,opac) 	endifend//Modified from Igor Exchange post by username hrodstein. In: http://www.igorexchange.com/node/1535. more like original is stored in vis_getColor(...)Function vis_getColorForGraph2(colorStr, red, green, blue)	String colorStr	Variable &red, &green, &blue				// Outputs. GB added: passes by reference. Input variables red green and blue will have the output values stored in them 	if (stringmatch(colorStr,"green")	)//green		vis_getColor(2, red, green, blue)	elseif (stringmatch(colorStr,"blue"))	//blue		vis_getColor(3, red, green, blue)	elseif (stringmatch(colorStr,"black"))	//black		vis_getColor(0, red, green, blue)			elseif (stringmatch(colorStr,"purple"))	//Purple		vis_getColor(4, red, green, blue)		elseif (stringmatch(colorStr,"grey"))	//grey		vis_getColor(5, red, green, blue)	elseif (stringmatch(colorStr,"salmon"))		//salmon		vis_getColor(6, red, green, blue)	elseif (stringmatch(colorStr,"lime"))	//Lime		vis_getColor(7, red, green, blue)			elseif (stringmatch(colorStr,"turqoise"))		//Turquoise		vis_getColor(8, red, green, blue)		elseif (stringmatch(colorStr,"lpurple"))			//light puplse		vis_getColor(9, red, green, blue)		elseif (stringmatch(colorStr,"brown"))	//Brown		vis_getColor(10, red, green, blue)		elseif (stringmatch(colorStr,"lbrown"))	//Light brown		vis_getColor(11, red, green, blue)		elseif (stringmatch(colorStr,"orange"))	//Orange		vis_getColor(12, red, green, blue)		elseif (stringmatch(colorStr,"teal"))	//Teal		vis_getColor(13, red, green, blue)		elseif (stringmatch(colorStr,"dblue"))	//Dark blue		vis_getColor(14, red, green, blue)		elseif (stringmatch(colorStr,"pink"))	//Pink		vis_getColor(15, red, green, blue)		elseif  (stringmatch(colorStr,"lblue"))	//Light blue		vis_getColor(16, red, green, blue)		else		vis_getColor(1, red, green, blue)		//default red		endifEnd//Modified from Igor Exchange post by username hrodstein. In: http://www.igorexchange.com/node/1535. more like original is stored in vis_getColor(...)Function vis_getColorForGraph(colorAbbreviation, red, green, blue)	String colorAbbreviation	Variable &red, &green, &blue				// Outputs. GB added: passes by reference. Input variables red green and blue will have the output values stored in them 	if (strsearch(colorAbbreviation,"R",0) > -1) 		//red 		vis_getColor(1, red, green, blue)	elseif (strsearch(colorAbbreviation,"1",0) > -1)	//"1" use black (current default)		vis_getColor(0, red, green, blue)			elseif (strsearch(colorAbbreviation,"G",0) > -1)	//green		vis_getColor(2, red, green, blue)	elseif (strsearch(colorAbbreviation,"B",0) > -1)	//blue		vis_getColor(3, red, green, blue)	elseif (strsearch(colorAbbreviation,"b",0) > -1)	//black		vis_getColor(0, red, green, blue)			elseif (strsearch(colorAbbreviation,"P",0) > -1)	//Purple		vis_getColor(4, red, green, blue)		elseif (strsearch(colorAbbreviation,"g",0) > -1)	//grey		vis_getColor(5, red, green, blue)	elseif (strsearch(colorAbbreviation,"S",0) > -1)	//salmon		vis_getColor(6, red, green, blue)	elseif (strsearch(colorAbbreviation,"L",0) > -1)	//Lime		vis_getColor(7, red, green, blue)			elseif (strsearch(colorAbbreviation,"T",0) > -1)	//Turquoise		vis_getColor(8, red, green, blue)		elseif (strsearch(colorAbbreviation,"p",0) > -1)	//Light purplse		vis_getColor(9, red, green, blue)		elseif (strsearch(colorAbbreviation,"C",0) > -1)	//Brown		vis_getColor(10, red, green, blue)		elseif (strsearch(colorAbbreviation,"c",0) > -1)	//Light brown		vis_getColor(11, red, green, blue)		elseif (strsearch(colorAbbreviation,"o",0) > -1)	//Orange		vis_getColor(12, red, green, blue)		elseif (strsearch(colorAbbreviation,"t",0) > -1)	//Teal		vis_getColor(13, red, green, blue)		elseif (strsearch(colorAbbreviation,"A",0) > -1)	//Dark blue		vis_getColor(14, red, green, blue)		elseif (strsearch(colorAbbreviation,"Z",0) > -1)	//Pink		vis_getColor(15, red, green, blue)		endifEndfunction/WAVE vis_getCBColorForGraph(colorStr,colorRef,opacityVal)	string colorStr;string colorRef;variable opacityVal//opac value 0-1		if (!strlen(colorRef))		colorRef = "colorsTemp"	endif		if (!waveExists($colorRef))		make/O/N=4 $colorRef/wave=c		WAVE c = $colorRef	else		WAVE c = $colorRef	endif		Variable sf = (2^16-1)/(2^8-1)		//2		strswitch (colorStr)		case "black":	//1			c[0] = 0			c[1] = 0			c[2] = 0			break		case "red":		//11			c[0] = 146			c[1] = 0			c[2] = 0			break		case "green":		//14			c[0] = 36			c[1] = 255			c[2] = 36			break		case "blue":			//7			c[0] = 0			c[1] = 109			c[2] = 219			break			case "orange":		//13			c[0] = 219			c[1] = 209			c[2] = 0			break		case "light purple":			//8			c[0] = 182			c[1] = 109			c[2] = 255			break		case "purple":		//6			c[0] = 73			c[1] = 0			c[2] = 146			break		case "brown":		//12			c[0] = 146			c[1] = 73			c[2] = 0		case "light blue":		//9			c[0] = 109			c[1] = 182			c[2] = 255		case "teal":		//2			c[0] = 0			c[1] = 73			c[2] = 73		default: 	//black			c[0] = 0			c[1] = 0			c[2] = 0			break				endswitch					c *= sf		c[3] = opacityVal * 2^16-1				return c	end//for use with vis_getColor, allows one not to pass red green and blue by referencefunction vis_vis_getColorComponent(colorIndex, redGreenOrBlue)	Variable colorIndex, redGreenOrBlue		//for the latter, pass 0 for colorIndex red value, 1 for green, 2 for blue		Variable red, green, blue	vis_getColor(colorIndex, red, green, blue)		if (redGreenOrBlue == 0)		return red	elseif (redGreenOrBlue == 1)		return green	else		return blue	endifend//from Igor Exchange post by username hrodstein. In: http://www.igorexchange.com/node/1535. Function vis_getColor(colorIndex, red, green, blue)	Variable colorIndex	Variable &red, &green, &blue				// Outputs. GB added: passes by reference. Input variables red green and blue will have the output values stored in them 	colorIndex = mod(colorIndex, 17)			// Wrap around if necessary	switch(colorIndex)		case 0:		// Time wave			red = 0; green = 0; blue = 0;								// Black			break 		case 1:			red = 65280; green = 0; blue = 0;			// Red			break 		case 2:			red = 2; green = 39321; blue = 1;						// Green			break 		case 3:			red = 0; green = 0; blue = 65535;						// Blue			break 		case 4:			red = 39321; green = 1; blue = 31457;					// Purple			break 		case 5:			red = 39321; green = 39321; blue = 39321;			// Gray			break 		case 6:			red = 65535; green = 32768; blue = 32768;			// Salmon			break 		case 7:			red = 0; green = 65535; blue = 0;						// Lime			break 		case 8:			red = 16385; green = 65535; blue = 65535;			// Turquoise			break 		case 9:			red = 65535; green = 32768; blue = 58981;			// Light purple			break 		case 10:			red = 39321; green = 26208; blue = 1;					// Brown			break 		case 11:			red = 52428; green = 34958; blue = 1;					// Light brown			break 		case 12:			red = 65535; green = 32764; blue = 16385;			// Orange			break 		case 13:			red = 1; green = 52428; blue = 26586;					// Teal			break 		case 14:			red = 1; green = 3; blue = 39321;						// Dark blue			break 		case 15:			red = 65535; green = 49151; blue = 55704;			// Pink			break		case 16:			red = 0; green = 65280; blue = 65280				//light blue, similar turqoise			break	endswitchEndfunction fd_clearFileDispGraph()	SVAR/Z currFileDispGraphN		vis_clearGraph(currFiledispGraphN)end//clear all tracesfunction vis_clearGraph(gName, [secondAttempt])	String gName	Variable secondAttempt		if (strlen(gName) < 1)		gName = StringFromList(0,winlist("*",";",""))	endif		if (WinType(gName) < 1)		return 0	elseif (WinType(gName) == 2)		//table		return table_clear(gName)			endif		String traceNameTemp	String graphContains = TraceNameList(gName,";",1) //	Print graphContains	Variable numGraphs = ItemsInList(graphContains,";")//	Print numGraphs		Variable i	for(i=numGraphs;i>-1;i-=1)		//going down seems better than going up? something about trace name numbering		traceNameTemp = StringFromList(i,graphContains)	//	RemoveFromGraph/Z/W=$gName $traceNameTemp		RemoveFromGraph/Z/W=$gName $traceNameTemp	endfor		graphContains = TraceNameList(gName,";",1) 	numGraphs = ItemsInList(graphContains,";")		//erase drawings	setdrawlayer/W=$gName/k UserBack	setdrawlayer/W=$gName/k UserFront		if (ParamIsDefault(secondAttempt) && (numGraphs > 0))		vis_clearGraph(gName, secondAttempt = 1)		//do it again just in case	endif//	Print i	return 1end//clear all traces from top graphfunction vis_clear()	vis_clearGraph("")endfunction table_clear(tName)	string tName		if (strlen(tName) < 1)		tName = winname(0,2)		//top table	endif		if (wintype(tName) != 2)	// not a table		Print "In table_clear(), attempt to clear non-table (aborted)"		return 0	endif		String tWaves = table_getTableWaves(tName)		Variable i	for (i=0;i<ItemsInList(tWaves);i+=1)		RemoveFromTable/W=$tName $StringFromList(i, tWaves)	endforendfunction/S table_getTableWaves(tName)	String tName	if (wintype(tName) != 2)	// not a table		Print "In vis_getTableWaves(), a non-table was passed, function aborted"		return ""	endif		String info = tableInfo(tName, -2)		Variable numCols = str2num(StringByKey("COLUMNS", info))		Variable i; String list ="", colWave	for (i=0;i<numCols;i+=1)		colWave = table_getTableWave(tName, i)		if ( (strlen(colWave) > 0) && WaveExists($colWave) && (WhichListItem(colWave, list) < 0) )			list += colWave + ";"		endif	endfor		return listendfunction/S table_getTableWave(tName, tCol)		//returns name of wave in table column tCol	String tName; Variable tCol	if (wintype(tName) != 2)	// not a table		Print "In getTableWave(), a non-table was passed, function aborted"		return ""	endif	if (tCol < -1)		return ""	endif	String info = tableInfo(tName, tCol)		return StringByKey("WAVE", info)	end//////////////////FileInfoWave helper functionsfunction fd_goToFile(matchStr)	String matchStr		WAVE/T fileInfoWave	WAVE fileSelList		Duplicate/O/R=[][2] fileInfoWave, tempWave 		FindValue/TEXT=matchStr/Z tempWave		if (V_Value != -1)		Listbox fileListBox row = V_Value, win = filePanel		fileSelList[V_value] = 1		updateSelListByNums("fileSelList", "fileSelListByNums")	endif		KillWaves/Z tempWaveendfunction fd_toSelTable(rowNum)	Variable rowNum		WAVE/T hsList, fileSelFields	String cellName = "G" + hsList[rowNum][0] + "*"	fileSelFields[2] = cellNameendfunction fd_selLoaded()	WAVE/T fileSelFields	//	String currText = fileSelField	if (strlen(fileSelFields[0]) > 0)		fileSelFields[0] = ""	else		fileSelFields[0] = "L"	endifendfunction fd_searchFiles(matchStr)	STring matchStr		fd_selectMatchingFiles(1, matchStr = matchStr)	end//not ideal could be faster since sorted, but its complicated since we want to allow for wild card *s in the matchStrfunction fd_selectMatchingFiles(clearFirst, [matchStr,ignoreFields,doNotIgnoreBlankMatchStrs,startN,endN,cmtMatchStr])	Variable clearFirst	//clear first = -1, brings to top fileSelTable	String matchStr		//optionally pass 	Variable ignoreFields		//optionally pass to ignore fields in fileSelTable	Variable doNotIgnoreBlankMatchStrs	//optionally pass to pay attention to blank match strings; otherwise all blanks are replaced by "*" except file load strings which are treated differently	Variable startN,endN		//optionally pass to specify first and last numbers	String cmtMatchStr		//optionally pass a required commment match string		if (!WaveExists($"fileSelFields"))		fd_showSelTable()	endif		if (clearFirst < 0)		Bringtotop("fileSelTable")		return 0	endif			Variable doIgnoreFields = !ParamIsDefault(ignoreFields) && ignoreFields		NVAR numNonChanFileInfoWaveCols	WAVE/T/Z fileSelFields			WAVE/T fileInfoWave	WAVE fileSelList		String finalMatchStr		if (ParamIsDefault(matchStr))			finalMatchStr = "*"	else										finalMatchStr = matchStr	endif	if (strlen(finalMatchStr) == 0)		finalMatchStr = "*"	endif		if (clearFirst > 0)		fileSelList = 0	endif		String cmtMatchStr_used; variable doC	if (ParamIsDefault(cmtMatchStr))		cmtMatchStr_used="*"	//anything goes		doC=0	else		cmtMatchStr_used=cmtMatchStr		doC=1	endif					Duplicate/O/T fileSelFields, fileSelFieldsTemp			Variable i; String currString	if (ParamIsDefault(startN) || numtype(startN))		startN = 0	endif	if (ParamIsDefault(endN) || numtype(endN))		endN=DimSize($"fileInfoWave",0)		endif		Variable numFields=dimsize(fileSelFields,0)	for (i=0;i<numFields;i+=1)		if (ParamIsDEfault(doNotIgnoreBlankMatchStrs) && !doNotIgnoreBlankMatchStrs)			if (strlen(fileSelFieldsTemp[i]) == 0)				if (i > numNonChanFileInfoWaveCols-1)	//chan selections need to have wildacrd preappended						fileSelFieldsTemp[i] = "*" + fileSelFieldsTemp[i]				endif			endif			endif	endfor		Variable count = 0,firstfileNum=nan		for (i=startN;i<endN;i+=1)		if (StringMatch(fd_getFNameFromFileInfoWave(i,0), finalMatchStr) && ( doIgnoreFields || fd_isFieldMatch(i, fileSelFieldsTemp,doC,cmtMatchStr_used)) )			fileSelList[i] = 1			if (count==0)				Listbox fileListBox row = i, win = filePanel				firstfileNum = i			endif			count+=1		endif		endfor		Print "fd_selectMatchingFiles() count",count,"firstfileNum",firstfileNum		updateSelListByNums("fileSelList", "fileSelListByNums")	//update by nums list	fd_updateSweepsDisplay()	//listbox		KillWaves/Z fileSelFieldsTemp	return firstfileNumendfunction fd_isFieldMatch(fileNum,fieldsIn,requireCommentMatch,cmtMatchStr)	Variable fileNum; WAVE/T fieldsIn	Variable requireCommentMatch		//pass 1 to also check comment	String cmtMatchStr					//comment match string, ignored unless requireCommentMatch is true		Variable fileDirCommentCol = 1			WAVE/T fileInfoWave,fileDirectory		Make/O/N=(DimSize(fieldsIn,0)) matchesTemp	//for each row, determine if it has a value when it should not or vis versa	matchesTemp=(  strlen(fileInfoWave[fileNum][p])&&(str2num(fieldsIn[p][1])==-1) ) || (  !strlen(fileInfoWave[fileNum][p])&&(str2num(fieldsIn[p][1])==1)  )			//matchesTemp=(strlen(fileInfoWave[fileNum][p])&&strlen(fieldsIn[p]))||(!strlen(fileInfoWave[fileNum][p])&&!strlen(fieldsIn[p]))	matchesTemp = matchesTemp[p] || !text_matchToListStrs(fileInfoWave[fileNum][p], fieldsIn[p][0])	// second half is 1 for a non-match																//then ones and zeros are reversed by !		Variable isMatch = sum(matchesTemp)		==0						// sum(matchesTemp) is 0 if no non-matches, 1 otherwise. !sum is 1 if no non-matches		if (isMatch && requireCommentMatch)		isMatch =  text_matchToListStrs(fileDirectory[fileNum][fileDirCommentCol], cmtMatchStr)	endif		KillWaves/Z matchesTemp	return isMatch	endfunction fd_clearSelTable()	WAVE/T fileSelFields		fileSelFields = ""endfunction fd_showSelTable()	String tableN = "fileSelTable"	Variable numFields = DimSize($"fileInfoWave",1)		KillWindowsByName("*" + tableN + "*")		WAVE/T/Z fileSelFields	if (!WaveExists(fileSelFields))		Duplicate/O/T $"fileInfoWaveColumnTitles", fileSelFields		Make/T/O/N=(DimSize($"fileInfoWaveColumnTitles",0),2) fileSelFields		fileSelFields = ""		dl_headerToLabels("fileInfoWaveColumnTitles","fileSelFields",0)		SetDimLabel 1,0,matchStr,fileSelFields 		SetDimLabel 1,1,valueRequired,fileSelFields 		fileSelFields[][1] = "0"	endif		Edit/K=1/N=$tableN fileSelFields.ldendfunction fd_getFIndexInFileInfoWave(fNameOrOtherStr)	String fNameOrOtherStr	WAVE/T fileInfoWave		Variable i,num=DimSize(fileInfoWave,0)	for (i=0;i<num;i+=1)		if (stringmatch(fileInfoWave[i][2], fNameOrOtherStr))			return i		endif	endforend//from a selected set of files in fileInfoWave filePanel, sets cols 7,8,9function cp_updateVCTestList(currHSRow)	Variable currHSRow		WAVE/T hsList		WAVE/T hsList		String sSep = ",", fSep = ";"		//essentially "inputs" (hs specific, not soma/ped specific)	Variable cellNameCol = 0, isSomaHS1Col = 2, hs1BrkInFileCol = 3, hs1BrkInSweepCol = 4, hs2BrkInFileCol = 5, hs2BrkInSweepCol = 6, fileListCol = 7, chanListCol = 8, chanTypeCol = 9		//INPUT IS VCLAMP COMMAND. OUTPUT IS CURRENT RESPONSE	Variable hs1ChInput = 1, hs1ChOutput = 0, hs2ChInput = 3, hs2ChOutput = 2		//brk in info	Variable somaBrkInFileAndSweepCol = 10		//semi colon delim list: somabrkInFile; somaBrkInSweep;	Variable somaExampleCmdCol = 11	Variable somaSealListForAvgCol =12 		Variable somaSealAvgRefCol = 13			Variable pedBrkInFileAndSweepCol = 14	Variable pedExampleCmdCol = 15				Variable pedSealListForAvgCol = 16				Variable pedSealAvgRefCol = 17					//cell parameters	Variable somaAnalyzedFilesListCol = 18			//analyzedFileList	list of file nums analyzed (semicolon between files	Variable somaAnalyzedSweepsListCol = 19		//analyzedSweepList	list of sweeps analyzed for each file (semi colon between files, comma between sweeps)	Variable somaGenParamsCol = 20				//genParamsList	one for each file that was analyzed. all sweeps 	Variable somaFitParamsCol = 21				//fitParamsList	one for each file that was analyzed	Variable somaCoefWaveCol = 22				//coefWaveList	one for each file that was analyzed		Variable somaDispSweepsList = 23				//dispSweepsList	list of sweep nums saved for display, semicolon between files, if none for a given file then ";;", if multiple for given file then comma delimited	Variable somaDispOrigCurrentsRef	= 24			//origCurrentsDispList	with same organization as last, list of originalCurrentRefs that were saved and can be displayed		Variable somaDispFinCurrentsRef =25			//finCurrentsDispList	final (subtracted, actually used in analysis) currents for display	Variable somaFitListRef = 26					//listOfFitsList	ref to fit saved text wave with list of full fits and components for each wave (can get names of saved fit waves from here)	Variable somaFullFitDispN	=27					//fullFitDispNList	""	Variable somaCmpntsDispN	=28				//compntsDispNList	""	Variable numSomaCellParamsCols = 11			//conversion factor for soma to ped		WAVE/T fileInfoWave	WAVE fileSelListByNums		String fileListStr = ""	String channelListStr = ""	String channelTypeStr = ""		Variable i, j, currFileNum, currNumChans	for (i=0;i<DimSize(fileSelListByNums,0);i+=1)		currFileNum = fileSelListByNums[i]		fileListStr += num2str(currfileNum) + ";"		currNumChans = fd_getChanNFromFileInfoWave(currFileNum)		for (j=0;j<currNumChans;j+=1)			channelListStr += num2str(fd_getChanNumFromFileInfoWave(currFileNum, j)) + ","			channelTypeStr += fd_getChanDigInFromFileInfoWave(currFileNum, j) + ","		endfor		channelListStr += ";"		channelTypeStr += ";"	endfor		hsList[currHSRow][fileListCol] = fileListStr	hsList[currHSRow][chanListCol] =  channelListStr	hsList[currHSRow][chanTypeCol] = channelTypeStr	end//finds matching file names to input name and adds 0 if HS1 = soma. 1 if HS1 = pedfunction cp_updateHeadstages()	WAVE/T fileDirectory	WAVE/T hsList		//contains file/cell name and S for soma HS1, P for ped HS1		Variable hsCol = 7	Variable fNameCol = 5		Variable hsListIter, fileDirIter, currPedHS1, count = 0	String currCellName	for (hsListIter=0;hsListIter<DimSize(hsList,0);hsListIter+=1)		currCellName = hsList[hsListIter][0]		currPedHS1 = stringmatch(hsList[hsListIter][1],"*P*")		for (fileDirIter = 0; fileDirIter < DimSize(fileDirectory,0); fileDirIter +=1)			if (stringmatch(fileDirectory[fileDirIter][fNameCol] , "*" + currCellName + "*"))				count +=1				fileDirectory[fileDirIter][hsCol] = num2str(currPedHS1)			endif		endfor	endfor	Print "count",countendfunction hs_setComment(row, commentStr, [clear])	Variable row, clear; String commentStr	WAVE/T hsList		if (!ParamIsDefault(clear))		hsList[row][40] = commentStr +";"	else		hsList[row][40] += commentStr +";"	endifendfunction/S hs_getComment(row)	Variable row	WAVE/T hsList	return hsList[row][40]endfunction hs_clearRow(row)	Variable row	WAVE/T hsList	hsList[row][7,39] = ""end//orders and scales hsList based on excel_cellnamesfunction excel_updateHSList()	WAVE/T hsList, excel_cellNames, excel_hs1Sites	Make/O/N=(dimsize(hslist,0)) hslist_matched	hslist_matched = 0		Variable expectedHSListRows = 0	Variable currExcelIndex, currHsListRow	for (currHsListRow = 0; currHsListRow < DimSize(hsList,0); currHsListRow +=1)		expectedHSListRows += strlen(hsList[currHsListRow][0]) > 0 ? 1 : 0	endfor	Print "pre-existing hsList rows = " + num2str(expectedHSListRows)				variable foundRows = 0, addedRows = 0	Variable totalCells = DimSize(excel_cellNames,0)	Make/O/T/N=(totalCells,DimSize(hsList,1))  hsList_excel	hsList_excel = ""	for (currExcelIndex= 0; currExcelIndex < totalCells; currExcelIndex +=1)		String currCellName = excel_cellNames[currExcelIndex]		FindValue/TEXT=(currCellName) hsList		currHsListRow =  V_Value		if (currHsListRow < 0)			hsList_excel[currExcelIndex][0] = currCellName			hsList_excel[currExcelIndex][1] = excel_hs1Sites[currExcelIndex]			if (stringmatch(excel_hs1Sites[currExcelIndex],"P"))				hsList_excel[currExcelIndex][2] = "1"			endif			addedRows +=1					else			hsList_excel[currExcelIndex][] = hsList[currHsListRow][q]			//just transfer all over 			hslist_matched[currHsListRow] = 1			foundRows +=1		endif	endfor		Print "total excel rows = " + num2str(totalCells)	Print "Found rows = " + num2str(foundRows)	Print "added rows = " + num2str(addedRows)	Print "total rows placed in new hsList =  " + num2str(foundRows + addedRows)end//select row in which hs info will be stored for cellfunction b0([row])	Variable row		WAVE/T hsList		if (ParamIsDefault(row))		NVAR rowNum		rowNum +=1	else		Variable/G rowNum = row	endif	Duplicate/O $"hsList", hsListbackup	fd_toSelTable(rowNum)	Print "hsList[rowNum][0]",hsList[rowNum][0]	fd_selectMatchingFiles(1)//	ModifyTable/W=Table0 selection=(rowNum,0,rowNum,39,rowNum,0)endfunction ba()	disp_defaultRange(a=1)end//have selected in sweeps display list box just the sweep immediately after break in (first sweep where the capacity transient is visible for the small step of interest//Make sure that before this rowNum is set to hsList row for new cell, hsList[rowNum] col 0 = cell name, col 1 = "S" and col 2 = 0 if soma HS1; col 1="P" and col 2= 1 if ped HS1function b1(hsNum, [noSealSweeps])	Variable hsNum	//hsNum = 1 or 2, 1 for left 2 for right	Variable noSealSweeps		//can be any value	NVAR rowNum		//	Duplicate/O $"cpSummaryIndex", cpSummaryIndex_BU	if (ParamIsDefault(noSealSweeps))		setBrkIn(rowNum, hsNum)	else		setBrkIn(rowNum, hsNum, noSealSweeps= noSealSweeps)	endifend//have files still loaded. Assesses clamp conditions during each file, selects sweeps from which to make seal averagefunction b2()	NVAR rowNum	cp_updateVCTestList(rowNum)	cp_analyzeBrkIn(rowNum)	cp_setupForCellParams(rowNum)endfunction b3([vCmdVal])	Variable vCmdVal	NVAR rowNum	if (ParamIsDefault(vCmdVal))		cp_doCellParams(rowNum)	else		cp_doCellParams(rowNum, vCmdVal = vCmdVal)	endifendfunction b4()	NVAR rowNum	walkFits(rowNum,0,.2)	walkFits(rowNum,1,.2)endfunction b5()	killwindowsbyName("brkInFitsWalkThru*")endfunction f(rowNum)	Variable rowNum	WAVE/T hsList	hsList[rowNum][7,] = ""end//stores break in file and sweep for a given headstage and a given cellfunction setBrkIn(hsRow, hsNum, [noSealSweeps])	Variable hsRow, hsNum	//1 or 2	Variable noSealSweeps	//optional parameter. will set seal sweep to -1. value doesnt matter		Variable hs1BrkInCol_fNum = 8	Variable hs2BrkInCol_fNum = 10	Variable hs1BrkInCol_sweepNum = 9	Variable hs2BrkInCol_sweepNum = 11		WAVE/T hsList		Variable cellNameCol = 0, isSomaHS1Col = 2, hs1BrkInFileCol = 3, hs1BrkInSweepCol = 4, hs2BrkInFileCol = 5, hs2BrkInSweepCol = 6, fileListCol = 7, chanListCol = 8, chanTypeCol = 9		//INPUT IS VCLAMP COMMAND. OUTPUT IS CURRENT RESPONSE	Variable hs1ChInput = 1, hs1ChOutput = 0, hs2ChInput = 3, hs2ChOutput = 2		//brk in info	Variable somaBrkInFileAndSweepCol = 10		//semi colon delim list: somabrkInFile; somaBrkInSweep;	Variable somaExampleCmdCol = 11	Variable somaSealListForAvgCol =12 		Variable somaSealAvgRefCol = 13			Variable pedBrkInFileAndSweepCol = 14	Variable pedExampleCmdCol = 15				Variable pedSealListForAvgCol = 16				Variable pedSealAvgRefCol = 17				//cell parameters	Variable somaGenParamsCol = 18			Variable somaFitParamsCol = 19	Variable somaCoefWaveCol = 20					Variable pedGenParamsCol = 21	Variable pedFitParamsCol = 22			Variable pedCoefWaveCol = 23				Variable fileCol, sweepCol, hsListFileCol, hsListSweepCol	if (hsNum == 1)		fileCol = hs1BrkInCol_fNum		sweepCol = hs1BrkInCol_sweepNum		hsListFileCol = hs1BrkInFileCol		hsListSweepcol = hs1BrkInSweepCol	else		fileCol = hs2BrkInCol_fNum		sweepCol = hs2BrkInCol_sweepNum		hsListFileCol = hs2BrkInFileCol		hsListSweepcol = hs2BrkInSweepCol	endif				//get selected row from sweepsDispList	WAVE sweepsDispSelWaveByNums	WAVE/T sweepsDispList	Variable dispListSelRow = sweepsDispSelWaveByNums[0]	String fNum = sweepsDispList[dispListSelRow][0]	String sweepNum = sweepsDispList[dispListSelRow][1]		hsList[hsRow][hsListFileCol] = fNum			//SET TO ZERO IF NO SEAL SWEEPS	if (ParamIsDefault(noSealSweeps))		hsList[hsRow][hsListSweepCol] = sweepNum	else		hsList[hsRow][hsListSweepCol] = "-1"	endif		//store selection in fileDirectory//	WAVE/T fileDirectory//	//	variable a = 1//	String currCellName = fd_getFNameFromFileInfoWave(str2num(fNum),1)//	Print currCellName//	//	Variable i//	for (i=0;i<DimSize(fileDirectory,0);i+=1)//		if (stringmatch(fileDirectory[i][5] , "*" + currCellName + "*"))//			fileDirectory[i][fileCol] = fNum//			fileDirectory[i][sweepCol] = sweepNum//		endif//	endforend//assumes waves already loadedfunction cp_analyzeBrkIn(rowNum)	Variable rowNum		WAVE/T hsList		String sSep = ",", fSep = ";"		//essentially "inputs" (hs specific, not soma/ped specific)	Variable cellNameCol = 0, isSomaHS1Col = 2, hs1BrkInFileCol = 3, hs1BrkInSweepCol = 4, hs2BrkInFileCol = 5, hs2BrkInSweepCol = 6, fileListCol = 7, chanListCol = 8, chanTypeCol = 9		//INPUT IS VCLAMP COMMAND. OUTPUT IS CURRENT RESPONSE	Variable hs1ChInput = 1, hs1ChOutput = 0, hs2ChInput = 3, hs2ChOutput = 2		//brk in info	Variable somaBrkInFileAndSweepCol = 10		//semi colon delim list: somabrkInFile; somaBrkInSweep;	Variable somaExampleCmdCol = 11	Variable somaSealListForAvgCol =12 		Variable somaSealAvgRefCol = 13			Variable pedBrkInFileAndSweepCol = 14	Variable pedExampleCmdCol = 15				Variable pedSealListForAvgCol = 16				Variable pedSealAvgRefCol = 17						//cell params	Variable somaAnalyzedFilesListCol = 18			//analyzedFileList	list of file nums analyzed (semicolon between files	Variable somaAnalyzedSweepsListCol = 19		//analyzedSweepList	list of sweeps analyzed for each file (semi colon between files, comma between sweeps)	Variable somaGenParamsCol = 20				//genParamsList	one for each file that was analyzed. all sweeps 	Variable somaFitParamsCol = 21				//fitParamsList	one for each file that was analyzed	Variable somaCoefWaveCol = 22				//coefWaveList	one for each file that was analyzed		Variable somaDispSweepsList = 23				//dispSweepsList	list of sweep nums saved for display, semicolon between files, if none for a given file then ";;", if multiple for given file then comma delimited	Variable somaDispOrigCurrentsRef	= 24			//origCurrentsDispList	with same organization as last, list of originalCurrentRefs that were saved and can be displayed		Variable somaDispFinCurrentsRef =25			//finCurrentsDispList	final (subtracted, actually used in analysis) currents for display	Variable somaFitListRef = 26					//listOfFitsList	ref to fit saved text wave with list of full fits and components for each wave (can get names of saved fit waves from here)	Variable somaFullFitDispN	=27					//fullFitDispNList	""	Variable somaCmpntsDispN	=28				//compntsDispNList	""	Variable numSomaCellParamsCols = 11			//conversion factor for soma to ped			//cell name, file list (ordered), chanListString (order with fileList), chanType string (also ordered same)	String cellName = hsList[rowNum][cellNameCol]	String fileList = hsList[rowNum][fileListCol]	String chanListStr = hsList[rowNum][chanListCol]	String chanTypeStr = hsList[rowNum][chanTypeCol]			//is soma the first headstage? Using this we will make everything soma and ped specific rather than HS1 and HS2	Variable somaHS1 = stringmatch("0", hsList[rowNum][isSomaHS1Col])		String somaBrkInFile, somaBrkInSweep, pedBrkInFile, pedBrkInSweep		//from whether soma and ped are HS1 or HS2		Variable somaInputChNum, somaOutputChNum, pedInputChNum, pedOutputChNum		if (somaHS1)		somaBrkInFile = hsList[rowNum][hs1BrkInFileCol]		somaBrkInSweep = hsList[rowNum][hs1BrkInSweepCol]		pedBrkInFile = hsList[rowNum][hs2BrkInFileCol]		pedBrkInSweep = hsList[rowNum][hs2BrkInSweepCol]				somaInputChNum = hs1ChInput		somaOutputChNum = hs1ChOutput		pedInputChNum = hs2ChInput		pedOutputChNum = hs2ChOutput	else		//ped is HS1		somaBrkInFile = hsList[rowNum][hs2BrkInFileCol]		somaBrkInSweep = hsList[rowNum][hs2BrkInSweepCol]		pedBrkInFile = hsList[rowNum][hs1BrkInFileCol]		pedBrkInSweep = hsList[rowNum][hs1BrkInSweepCol]				somaInputChNum = hs2ChInput		somaOutputChNum = hs2ChOutput		pedInputChNum = hs1ChInput		pedOutputChNum = hs1ChOutput					endif		hsList[rowNum][somaBrkInFileAndSweepCol] = somaBrkInFile + ";" + somaBrkInSweep + ";"	hsList[rowNum][pedBrkInFileAndSweepCol] = pedBrkInFile + ";" + pedBrkInSweep + ";"		//which file number in the file list are the break ins? Then we can get the file strings for each	Variable somaBrkInFileIndex = WhichListItem(somaBrkInFile, fileList)	Variable pedBrkInFileIndex = WhichListItem(pedBrkInFile, fileList)		//channelType and channelList are semi colon delimited lists of comma deliimited lists	String channelTypesDuringSomaBrkIn = StringFromList(somaBrkInFileIndex,chanTypeStr)	String channelTypesDuringPedBrkIn = StringFromList(pedBrkInFileIndex, chanTypeStr)		//now that we have the channel arrangement during break in, we can get the channels from the channel list for each (	PRint "Channel types during break in:" 	String somaOutputChType_sBrkIn = StringFromList(somaOutputChNum,channelTypesDuringSomaBrkIn,","); Print somaOutputChType_sBrkIn	String somaInputChType_sBrkIn = StringFromList(somaInputChNum,channelTypesDuringSomaBrkIn,","); Print somaInputChType_sBrkIn	String pedOutputChType_sBrkIn = StringFromList(pedOutputChNum,channelTypesDuringSomaBrkIn,","); Print pedOutputChType_sBrkIn	String pedInputChType_sBrkIn =  StringFromList(pedInputChNum,channelTypesDuringSomaBrkIn,","); Print pedInputChType_sBrkIn	String somaOutputChType_pBrkIn = StringFromList(somaOutputChNum,channelTypesDuringPedBrkIn,","); Print somaOutputChType_pBrkIn	String somaInputChType_pBrkIn = StringFromList(somaInputChNum,channelTypesDuringPedBrkIn,","); Print somaInputChType_pBrkIn	String pedOutputChType_pBrkIn = StringFromList(pedOutputChNum,channelTypesDuringPedBrkIn,","); Print pedOutputChType_pBrkIn	String pedInputChType_pBrkIn =  StringFromList(pedInputChNum,channelTypesDuringPedBrkIn,","); Print pedInputChType_pBrkIn		//check for incorrect units for either break in file //INPUT IS VCLAMP COMMAND. OUTPUT IS CURRENT RESPONSE	if (!stringmatch(somaOutputChType_sBrkIn,"A") && !stringmatch(somaInputChType_sBrkIn,"V"))		Print "soma not in Vclamp during brk in! In cp_analyzeBrkIn(). Cell = " + cellName		return 0	endif		if (!stringmatch(pedOutputChType_pBrkIn,"A") && !stringmatch(pedInputChType_pBrkIn,"V"))		Print "ped not in Vclamp during brk in! In cp_analyzeBrkIn(). Cell = " + cellName		return 0	endif		//check for simultaneous clamp		Variable somaBeforePed, pedBeforeSoma										// FOR SOMA: 0 = ped before soma, 1 = soma before ped or simultaneous 	if (str2num(somaBrkInFile) < str2num(somaBrkInFile))		somaBeforePed = 1		pedBeforeSoma = 0	elseif (str2num(somaBrkInFile) > str2num(somaBrkInFile))		somaBeforePed = 0		pedBeforeSoma = 1	else		//same file, check brk in sweep		if (str2num(somaBrkInSweep) < str2num(pedBrkInSweep))			somaBeforePed = 1			pedBeforeSoma = 0		elseif (str2num(somaBrkInSweep) > str2num(pedBrkInSweep))			somaBeforePed = 0			pedBeforeSoma = 1		else			somaBeforePed = 1	//same file and sweep!			pedBeforeSoma = 1	//counted as both before the other			Print "warning: in cp_analyzeBrkIn() looks as if soma and ped had simultaneous brk in on same sweep"		endif	endif		Print "soma before ped? " + num2str(somaBeforePed)	Print "ped before soma? " + num2str(pedBeforeSoma)			Variable pedInVCDuringSomaBrkIn//INPUT IS VCLAMP COMMAND. OUTPUT IS CURRENT RESPONSE	if (stringmatch(pedOutputChType_sBrkIn,"A") && stringmatch(pedInputChType_sBrkIn,"V"))		pedInVCDuringSomaBrkIn = 1	elseif (stringmatch(pedOutputChType_sBrkIn,"V") && stringmatch(pedInputChType_sBrkIn,"A"))		pedInVCDuringSomaBrkIn = 0	else			//ped has two matching units, likely mis-telegraph, which has almost always happened when in vclamp		pedInVCDuringSomaBrkIn = 1	endif		Variable somaInVCDuringPedBrkIn	if (stringmatch(somaOutputChType_pBrkIn,"A") && stringmatch(somaInputChType_pBrkIn,"V"))		somaInVCDuringPedBrkIn = 1	elseif (stringmatch(somaOutputChType_pBrkIn,"V") && stringmatch(somaInputChType_pBrkIn,"A"))		somaInVCDuringPedBrkIn = 0	else			//soma has two matching units, likely mis-telegraph, which has almost always happened when in vclamp		somaInVCDuringPedBrkIn = 1	endif			//rules: 2 = simultaneous clamp AND broken in; 1 = simultaneous clamp not broken in; -1 = broken in but not clamped; -2 = neither broken in nor clamped	Variable somaSecondSiteStatus_brkIn = getSimultaneousClampScore(pedInVCDuringSomaBrkIn, !somaBeforePed)	Variable pedSecondSiteStatus_brkIn = getSimultaneousClampScore(somaInVCDuringPedBrkIn, !pedBeforeSoma)	Print "Soma status = " + num2str(somaSecondSiteStatus_brkIn)	Print "Ped status = " + num2str(pedSecondSiteStatus_brkIn)		Variable somaNoSeals = (str2num(somaBrkInSweep) == -1)	Variable pedNoSeals = (str2num(pedBrkInSweep) == -1)		Variable addToFindFirstFile_S = somaNoSeals ? 1 : 0	Variable addToFindFirstFile_P = pedNoSeals ? 1 : 0		String somaSealSweeps = "", pedSealSweeps = "", somaExemplarCmdSweep = "", pedExemplarCmdSweep = ""		//latter 2 are meant to hold one cmd sweep for finding size and timing of cmd	Variable numSweepsToAvg = 8		//CHANGED FOR CELLS RECORDED/ANALYZED after December 2015 from 10 to 8			Variable gapBeforeBrkInSweep = 2	Variable somaStartSweep = str2num(somaBrkInSweep) - numSweepsToAvg - gapBeforeBrkInSweep	Variable somaFile = str2num(somaBrkInFile)	Variable pedStartSweep = str2num(pedBrkInSweep) - numSweepsToAvg - gapBeforeBrkInSweep	Variable pedFile = str2num(pedBrkInFile)	//somaBrkInInputChanNum, somaBrkInOutputChanNum		Print "soma break in sweep = " + somaBrkInSweep 	Print "ped break in sweep = " + pedBrkInSweep 		Variable i, somaCount = 0, pedCount = 0	String currSomaSweep	String currPedSweep	if (!somaNoSeals)		for (i=somaStartSweep;i < somaStartSweep + numSweepsToAvg;i+=1)			currSomaSweep = getHS_Sweep(somaFile, i, somaOutputChNum)			if (strlen(currSomaSweep) > 0)				somaCount +=1				somaSealSweeps +=  currSomaSweep + ";"			endif 		endfor	endif	if (!pedNoSeals)		for (i=pedStartSweep;i < pedStartSweep + numSweepsToAvg;i+=1)			currPedSweep = getHS_Sweep(pedFile, i, pedOutputChNum)			if (strlen(currPedSweep) > 0)				pedCount +=1				pedSealSweeps +=  currPedSweep + ";"			endif		endfor		endif	hsList[rowNum][somaExampleCmdCol] = getHS_Sweep(somaFile, str2num(somaBrkInSweep) +addToFindFirstFile_S, somaInputChNum)		//add to find first file is zero unless no seals, then brkinsweep = -1	hsList[rowNum][pedExampleCmdCol] = getHS_Sweep(pedFile, str2num(pedBrkInSweep) +addToFindFirstFile_P, pedInputChNum)		hsList[rowNum][somaSealListForAvgCol] = somaSealSweeps	hsList[rowNum][pedSealListForAvgCol] = pedSealSweeps		String somaAvgName = "", pedAvgName = ""	if (!somaNoSeals)		somaAvgName = getWaveNameBySweeps(StringFromList(0, somaSealSweeps), StringFromList(ItemsInList(somaSealSweeps)-1, somaSealSweeps))		wave_avgFromStrList(somaSealSweeps,";", somaAvgName,0,nan,nan)	endif	if (!pedNoSeals)		pedAvgName = getWaveNameBySweeps(StringFromList(0, pedSealSweeps), StringFromList(ItemsInList(pedSealSweeps)-1, pedSealSweeps))		wave_avgFromStrList(pedSealSweeps,";", pedAvgName,0,nan,nan)	endif			hsList[rowNum][somaSealAvgRefCol] = somaAvgName	hsList[rowNum][pedSealAvgRefCol] = pedAvgName	  	Print "somaSealSweeps",somaSealSweeps,"pedSealSweeps",pedSealSweepsendfunction cp_setupForCellParams(rowNum)	Variable rowNum		WAVE/T hsList		Variable numModels = 5	String sSep = ",", fSep = ";"		//essentially "inputs" (hs specific, not soma/ped specific)	Variable cellNameCol = 0, isSomaHS1Col = 2, hs1BrkInFileCol = 3, hs1BrkInSweepCol = 4, hs2BrkInFileCol = 5, hs2BrkInSweepCol = 6, fileListCol = 7, chanListCol = 8, chanTypeCol = 9		//INPUT IS VCLAMP COMMAND. OUTPUT IS CURRENT RESPONSE	Variable hs1ChInput = 1, hs1ChOutput = 0, hs2ChInput = 3, hs2ChOutput = 2		//brk in info	Variable somaBrkInFileAndSweepCol = 10		//semi colon delim list: somabrkInFile; somaBrkInSweep;	Variable somaExampleCmdCol = 11	Variable somaSealListForAvgCol =12 		Variable somaSealAvgRefCol = 13			Variable pedBrkInFileAndSweepCol = 14	Variable pedExampleCmdCol = 15				Variable pedSealListForAvgCol = 16				Variable pedSealAvgRefCol = 17					//cell parameters prep	Variable somaNumFilesCol = 18				//total num files analyzable	Variable somaNumSweepsCol = 19				//total num sweeps analyzable	Variable somaFileAndSweepCol = 20			//"number of each analyzable file, number of associated analyzable sweeps for file;nextfile..."	Variable somaAnalysisSweepsCol = 21			//list of all sweeps that are analyzable (e.g. in Vclamp at site, after brk in sweep/file). PedCol = 26	Variable somaSweepNotesCol = 22				//notes for all sweeps (for this reason waves must be loaded when filling in this column!	Variable somaSweepClampStatusCol = 23		//(other site) clamp status related to each file	Variable somaGenParamsRefCol = 24		//generalParamsRef for file. 2D one row per sweep (all sweeps together), one column per param	Variable somaCompParamsRefCol = 25		//component params ref for file. 2D one row per sweep (all sweeps together), one column per param	Variable somaCoefWaveParamsRefCol = 26	//coef wave for file. 2D one row per sweep (all sweeps together), one column per coef	Variable somaSweepIsSavedCol = 27			//if copy of original wave, (subtracted wave), model, model components, etc. are (to be) saved for this sweep (0 or 1)	Variable somaDisplayInfoSweeps = 28			//semi colon delimited for each displayed sweep. Ref to display wave		Variable conv =  somaDisplayInfoSweeps - somaNumFilesCol + 1		String fileList = hsList[rowNum][fileListCol]	Variable numFiles = ItemsInList(fileList)	Print "fileList",fileList,"numFiles",numFiles	String somaCmdRef = hsList[rowNum][somaExampleCmdCol]	String pedCmdRef = hsList[rowNum][pedExampleCmdCol]	Variable somaBrkInFile =  str2num(StringFromList(0, hsList[rowNum][somaBrkInFileAndSweepCol]))	Variable pedBrkInFile =  str2num(StringFromList(0, hsList[rowNum][pedBrkInFileAndSweepCol]))	Variable somaBrkInSweep =  str2num(StringFromList(1, hsList[rowNum][somaBrkInFileAndSweepCol]))	Variable pedBrkInSweep =  str2num(StringFromList(1, hsList[rowNum][pedBrkInFileAndSweepCol]))	String somaSealFileRef = hsList[rowNum][somaSealAvgRefCol]	String pedSealFileRef = hsList[rowNum][pedSealAvgRefCol]	String chanList = hsList[rowNum][chanListCol]		//iterate through each file, if file num >= brk in file num, then load each sweep > brk in sweep	Variable isSoma = 0, isPed = 1	Variable currFileIndex,  currFileNum, currSweepNum, currNumSweepsInFile, currSomaOutputCh, currPedOutputCh	Variable soma_isVClamp, pedcp_isVClamp , pedBrokenIn, somaBrokenIn	Variable loadSomaSweeps, loadPedSweeps, currSomaSimultaneousClampScore, currPedSimultaneousClampScore	String currChanList		String currFileInfo	Variable somaSweepsIndex = 0, pedSweepsIndex = 0, somaFilesIndex = 0, pedFilesIndex = 0	//tracks overall sweep index, matches between lists and data waves	Variable somaOutputChIndex,pedOutputChIndex,currSomaSweepsCount, currPedSweepsCount	String currSomaRef, currPedRef	String cellName = "G" + hsList[rowNum][cellNameCol]	String redisplayWaveAppendStr = "ccD"	String genParamsWaveAppendStr = "ccG"	String compParamsWaveAppendStr = "ccC"	String coefWaveAppendStr = "ccW"	String somaIDStr = "S"	String pedIDStr = "P"	String savedSubbedWaveAppendStr = "ccS"	String modelSaveAppendStr = "ccM"	String componentSaveAppendStr = "c"	String currRedisplayRef	Variable i, c, somaDisplaySweepsIndex = 0, pedDisplaySweepsIndex = 0, currNumComponents	Variable isLastFile = 0;		for (currFileIndex = 0; currFileIndex < numFiles; currFileIndex +=1)		if (currFileIndex == numFiles - 1)			isLastFile = 1		endif		currFileNum = str2num(StringFromList(currFileIndex, fileList))		Print "currFileNum",currFileNum		currChanList = StringFromList(currFileIndex, chanList)		loadSomaSweeps = 0; loadPedSweeps = 0		soma_isVClamp = cp_isVClamp(rowNum, currFileIndex, 0)		pedcp_isVClamp = cp_isVClamp(rowNum, currFileIndex, 1)		somaOutputChIndex = cp_getChanIndex(rowNum, 0,0)		pedOutputChIndex = cp_getChanIndex(rowNum, 1, 0)				if (currFileNum >= somaBrkInFile)			if (soma_isVClamp)				Print "loading soma"				loadSomaSweeps = 1			endif		endif		if (currFileNum >= pedBrkInFile)			if (pedcp_isVClamp)				Print "loading ped"				loadPedSweeps = 1			endif		endif		if (!(loadSomaSweeps || loadPedSweeps))			Print "continue occured in cp_analyzeCellParams(). File from before break in listed in hsList fileList?"			continue		endif		//		Variable lastFileSweepLimit = inf//		if (strlen(hsList[rowNum][41]) > 0)//			String fullList = hsList[rowNum][41]//			Print fullList//			lastFileSweepLimit = str2num(stringfromlist(1,fullList, ","))//		endif//		Print "Sweep limit = " + num2str(lastFileSweepLimit)		currNumSweepsInFile = fd_getSweepNFromFileInfoWave(currFileNum)		Print "num sweeps in file = " + num2str(currNumSweepsInFile)		currSomaSweepsCount = 0; currPedSweepsCount = 0				String fileSweepLimitsStr = hsList[rowNum][41]		String currFileNumStr		Variable currFileLimitsStrPos, currSweepLimitStartPos, currSweepLimitEndPos, uCurrNumSweeps		for (currSweepNum = 0; currSweepNum < currNumSweepsInFile; currSweepNum +=1)			//check how many sweeps are wanted, if specified			if (strlen(fileSweepLimitsStr) > 0)				currFileNumStr = num2str(currFileNum)				currFileLimitsStrPos = strsearch(fileSweepLimitsStr, currFileNumStr,0)				if (currFileLimitsStrPos > -1)					currSweepLimitStartPos = currFileLimitsStrPos + strlen(currFileNumStr) + 1					currSweepLimitEndPos = strsearch(fileSweepLimitsStr, ";", currSweepLimitStartPos) - 1				//	Print fileSweepLimitsStr[currSweepLimitStartPos, currSweepLimitEndPos]					uCurrNumSweeps = str2num(fileSweepLimitsStr[currSweepLimitStartPos, currSweepLimitEndPos])				//	Print num2str(uCurrNumSweeps)				endif			endif						if (loadSomaSweeps &&  ( (currSweepNum > somaBrkInSweep) || (currFileNum > somaBrkInFile) ) && (currSweepNum > uCurrNumSweeps) ) 				currSomaRef = getHS_Sweep(currFileNum, currSweepNum, somaOutputChIndex) 				pedBrokenIn = ((currFileNum == pedBrkInFile) && (currSweepNum > pedBrkInSweep)) || (currFileNum > pedBrkInFile)				currSomaSimultaneousClampScore = getSimultaneousClampScore(pedcp_isVClamp, pedBrokenIn)				currSomaSweepsCount +=1				somaSweepsIndex += 1				if (currSweepNum == currNumSweepsInFile - 1)			//save last sweep in each file					//prep for display					hsList[rowNum][somaSweepIsSavedCol] += num2str(somaDisplaySweepsIndex) + ";"					currRedisplayRef = currSomaRef + redisplayWaveAppendStr					hsList[rowNum][somaDisplayInfoSweeps] += num2str(somaSweepsIndex) + "," + currSomaRef + "," + currRedisplayRef + ","	+ ";"					//make re-display wave					Make/O/T/N=(numModels) redisplayTemp					for (i=0;i<numModels;i+=1)						currNumComponents = i+1						redisplayTemp[i] = num2str(i)+ ";"+num2str(somaSweepsIndex)+ ";"+ num2str(somaDisplaySweepsIndex)+ ";"+currSomaRef+";"+somaCmdRef+";"+somaSealFileRef+";"						redisplayTemp[i]+= currSomaRef+savedSubbedWaveAppendStr+";"+currSomaRef + modelSaveAppendStr+ num2str(i)+";"+num2str(currNumComponents)+";"	//last is # components						for (c=0;c<currNumComponents;c+=1)							redisplayTemp[i]+= currSomaRef + modelSaveAppendStr+ num2str(i)+ componentSaveAppendStr + num2str(c) + ";"						endfor					endfor					Duplicate/O redisplayTemp, $currRedisplayRef					somaDisplaySweepsIndex +=1				else						//fill in relevant files					hsList[rowNum][somaSweepIsSavedCol] += "-1;"				endif				hsList[rowNum][somaAnalysisSweepsCol] += currSomaRef + ";"				hsList[rowNum][somaSweepNotesCol] += note($currSomaRef) + ";"				hsList[rowNum][somaSweepClampStatusCol] += num2str(currSomaSimultaneousClampScore) +";"			endif			if (loadPedSweeps &&  ( (currSweepNum > PedBrkInSweep) || (currFileNum > pedBrkInFile)  ) && (currSweepNum > uCurrNumSweeps) ) 				currPedRef = getHS_Sweep(currFileNum, currSweepNum, pedOutputChIndex) 				somaBrokenIn = ((currFileNum == somaBrkInFile) && (currSweepNum > somaBrkInSweep)) || (currFileNum > somaBrkInFile)				currPedSimultaneousClampScore = getSimultaneousClampScore(soma_isVClamp, somaBrokenIn)				currPedSweepsCount +=1				pedSweepsIndex += 1				if (currSweepNum == currNumSweepsInFile - 1)			//save last sweep in each file					//prep for display					hsList[rowNum][somaSweepIsSavedCol+conv] += num2str(pedDisplaySweepsIndex) + ";"					currRedisplayRef = currPedRef + redisplayWaveAppendStr					hsList[rowNum][somaDisplayInfoSweeps+conv] += num2str(pedSweepsIndex) + "," + currPedRef + "," + currRedisplayRef + ","	+ ";"					//make re-display wave					Make/O/T/N=(numModels) redisplayTemp					for (i=0;i<numModels;i+=1)						currNumComponents = i+1						redisplayTemp[i] = num2str(i)+ ";"+num2str(pedSweepsIndex)+ ";"+ num2str(pedDisplaySweepsIndex)+ ";"+currPedRef+";"+pedCmdRef+";"+pedSealFileRef+";"						redisplayTemp[i]+= currPedRef+savedSubbedWaveAppendStr+";"+currPedRef + modelSaveAppendStr+ num2str(i)+";"+num2str(currNumComponents)+";"	//last is # components						for (c=0;c<currNumComponents;c+=1)							redisplayTemp[i]+= currPedRef + modelSaveAppendStr+ num2str(i)+ componentSaveAppendStr + num2str(c) +";"						endfor					endfor					Duplicate/O redisplayTemp, $currRedisplayRef					pedDisplaySweepsIndex +=1							else						//fill in relevant files					hsList[rowNum][somaSweepIsSavedCol + conv] += "-1;"				endif				hsList[rowNum][somaAnalysisSweepsCol + conv] += currPedRef + ";"				hsList[rowNum][somaSweepNotesCol + conv] += note($currPedRef) + ";"				hsList[rowNum][somaSweepClampStatusCol + conv] += num2str(currPedSimultaneousClampScore) +";"			endif					endfor	//sweeps iteration				if (currSomaSweepsCount > 0)		//then theres at least one sweep for this file			Print "soma sweeps found = " + num2str(currSomaSweepsCount)			hsList[rowNum][somaFileAndSweepCol] += num2str(currFileNum) + "," + num2str(currSomaSweepsCount) + ";"			somaFilesIndex += 1		endif		if (currPedSweepsCount > 0)		//then theres at least one sweep for this file			Print "ped sweeps found = " + num2str(currPedSweepsCount)			hsList[rowNum][somaFileAndSweepCol + conv] += num2str(currFileNum) + "," + num2str(currPedSweepsCount) + ";"			pedFilesIndex += 1		endif	endfor	//file iteration	if (somaFilesIndex > 0)		//then at least one file found to analyze for soma		hsList[rowNum][somaNumFilesCol] += num2str(somaFilesIndex)		hsList[rowNum][somaNumSweepsCol] += num2str(somaSweepsIndex)		hsList[rowNum][somaGenParamsRefCol] = cellName + somaIDStr + genParamsWaveAppendStr		hsList[rowNum][somaCompParamsRefCol] = cellName + somaIDStr + compParamsWaveAppendStr		hsList[rowNum][somaCoefWaveParamsRefCol] = cellName + somaIDStr + coefWaveAppendStr	endif	if (pedFilesIndex > 0)			//then at least one file found to analyze for ped		hsList[rowNum][somaNumFilesCol + conv] += num2str(pedFilesIndex)		hsList[rowNum][somaNumSweepsCol + conv] += num2str(pedSweepsIndex)		hsList[rowNum][somaGenParamsRefCol + conv] = cellName + pedIDStr + genParamsWaveAppendStr		hsList[rowNum][somaCompParamsRefCol + conv] = cellName + pedIDStr + compParamsWaveAppendStr		hsList[rowNum][somaCoefWaveParamsRefCol + conv] = cellName + pedIDStr + coefWaveAppendStr	endifend		//cp_setupForCellParams()function cp_doCellParams(rowNum, [vCmdVal])	Variable rowNum, vCmdVal		WAVE/T hsList		String sSep = ",", fSep = ";"		//essentially "inputs" (hs specific, not soma/ped specific)	Variable cellNameCol = 0, isSomaHS1Col = 2, hs1BrkInFileCol = 3, hs1BrkInSweepCol = 4, hs2BrkInFileCol = 5, hs2BrkInSweepCol = 6, fileListCol = 7, chanListCol = 8, chanTypeCol = 9		//INPUT IS VCLAMP COMMAND. OUTPUT IS CURRENT RESPONSE	Variable hs1ChInput = 1, hs1ChOutput = 0, hs2ChInput = 3, hs2ChOutput = 2		//brk in info	Variable somaBrkInFileAndSweepCol = 10		//semi colon delim list: somabrkInFile; somaBrkInSweep;	Variable somaExampleCmdCol = 11	Variable somaSealListForAvgCol =12 		Variable somaSealAvgRefCol = 13			Variable pedBrkInFileAndSweepCol = 14	Variable pedExampleCmdCol = 15				Variable pedSealListForAvgCol = 16				Variable pedSealAvgRefCol = 17					//cell parameters prep	Variable somaNumFilesCol = 18				//total num files analyzable	Variable somaNumSweepsCol = 19				//total num sweeps analyzable	Variable somaFileAndSweepCol = 20			//"number of each analyzable file, number of associated analyzable sweeps for file;nextfile..."	Variable somaAnalysisSweepsCol = 21			//list of all sweeps that are analyzable (e.g. in Vclamp at site, after brk in sweep/file). PedCol = 26	Variable somaSweepNotesCol = 22				//notes for all sweeps (for this reason waves must be loaded when filling in this column!	Variable somaSweepClampStatusCol = 23		//(other site) clamp status related to each file	Variable somaGenParamsRefCol = 24		//generalParamsRef for file. 2D one row per sweep (all sweeps together), one column per param	Variable somaCompParamsRefCol = 25		//component params ref for file. 2D one row per sweep (all sweeps together), one column per param	Variable somaCoefWaveParamsRefCol = 26	//coef wave for file. 2D one row per sweep (all sweeps together), one column per coef	Variable somaSweepIsSavedCol = 27			//if copy of original wave, (subtracted wave), model, model components, etc. are (to be) saved for this sweep (0 or 1)	Variable somaDisplayInfoSweeps = 28			//semi colon delimited for each displayed sweep. Ref to display wave	Variable conv =  somaDisplayInfoSweeps - somaNumFilesCol + 1			//redisplay	Variable redisplayRefIndex = 2		//function body	String somaAnalysisSweepsList = hsList[rowNum][somaAnalysisSweepsCol]	String somaSweepsDisplayStatusList = hsList[rowNum][somaSweepIsSavedCol]	String somaDisplayInfoList = hsList[rowNum][somaDisplayInfoSweeps]	String pedAnalysisSweepsList = hsList[rowNum][somaAnalysisSweepsCol + conv]	String pedSweepsDisplayStatusList = hsList[rowNum][somaSweepIsSavedCol + conv]	String pedDisplayInfoList = hsList[rowNum][somaDisplayInfoSweeps + conv]	Variable numSomaSweeps = ItemsInList(somaAnalysisSweepsList)	Variable numPedSweeps = ItemsInList(pedAnalysisSweepsList)	String somaSubRef = hsList[rowNum][somaSealAvgRefCol]	String pedSubRef  = hsList[rowNum][pedSealAvgRefCol]	String somaVcmdRef = hsList[rowNum][somaExampleCmdCol] 	String pedVcmdRef = hsList[rowNum][pedExampleCmdCol]	String somaGenParamsRef = hsList[rowNum][somaGenParamsRefCol], somaCompParamsRef = hsList[rowNum][somaCompParamsRefCol],  somaCoefWaveRef = hsList[rowNum][somaCoefWaveParamsRefCol]	String pedGenParamsRef = hsList[rowNum][somaGenParamsRefCol+conv], pedCompParamsRef = hsList[rowNum][somaCompParamsRefCol+conv], pedCoefWaveRef = hsList[rowNum][somaCoefWaveParamsRefCol+conv]		//get step info for each headstage	Variable  vCmd_t0_S, vCmd_t1_S, vCmd_baseline_S, vCmd_step_S		//for soma	analysis_cellParams_S_vCmd(somaVcmdRef,  vCmd_t0_S, vCmd_t1_S, vCmd_baseline_S, vCmd_step_S)		Variable  vCmd_t0_P, vCmd_t1_P, vCmd_baseline_P, vCmd_step_P		//for ped	analysis_cellParams_S_vCmd(pedVcmdRef,  vCmd_t0_P, vCmd_t1_P, vCmd_baseline_P, vCmd_step_P)			String presetVCmdBaseline = hsList[rowNum][42]	String presetVCmdStep = hsList[rowNum][43]	String presetStepStartTime = hsList[rowNum][44]	String prestStepEndTime = hsList[rowNum][45]	String presetCapPeakTime = hsList[rowNum][46]		if (strlen(presetVCmdBaseline) > 0)		vCmd_baseline_S = str2num(presetVCmdBaseline)		vCmd_step_S = str2num(	presetVCmdStep)		//MUST PASS NEGATIVE IF NEGATIVE. does not assume a negative step! Also V not mV		vCmd_t0_S = str2num(presetStepStartTime)		vCmd_t1_S = str2num(prestStepEndTime)		vCmd_baseline_P = vCmd_baseline_S		vCmd_step_P = vCmd_step_S		vCmd_t0_P = vCmd_t0_S		vCmd_t1_P = vCmd_t1_S	endif		Variable enforcedCapPeakTimeX = -1	if (strlen(presetCapPeakTime) > 0)		enforcedCapPeakTimeX = str2num(presetCapPeakTime)	endif	Print "!From soma vCmd: " + somaVcmdRef + "," + num2str(vCmd_t0_S) + ";" + num2str(vCmd_t1_S) + ";" + num2str(vCmd_baseline_S) + ";" + num2str(vCmd_step_S)			Print "!From ped vCmd: " + pedVcmdRef + "," + num2str(vCmd_t0_P) + ";" + num2str(vCmd_t1_P) + ";" + num2str(vCmd_baseline_P) + ";" + num2str(vCmd_step_P)		Make/O/D/N=1 genParamsTemp, compParamsTemp, coefWaveTemp			Variable currSweepIndex, displayCurrSweep, sweepDisplayStatusAndIndex	String currSomaRef, currPedRef, currRedisplayList, currRedisplayRef		//CALC SOMA SUMMARY DATA	for (currSweepIndex = 0; currSweepIndex < numSomaSweeps; currSweepIndex +=1)		currSomaRef = StringFromList(currSweepIndex, somaAnalysisSweepsList)		sweepDisplayStatusAndIndex = str2num(StringFromList(currSweepIndex, somaSweepsDisplayStatusList))		if (sweepDisplayStatusAndIndex > -1)			currRedisplayList = StringFromList(sweepDisplayStatusAndIndex, somaDisplayInfoList)			currRedisplayRef = StringFromList(redisplayRefIndex, currRedisplayList,",")		else		//do not have raw data waves saved, only summaries			currRedisplayRef = ""		endif				analysis_cellParams_S3(currSomaRef, vCmd_t0_S, vCmd_t1_S, vCmd_baseline_S, vCmd_step_S, "genParamsTemp", "compParamsTemp",  "coefWaveTemp", somaSubRef, currRedisplayRef, enforcedCapPeakTimeX,somaSubRef)			//save gen params, comp params, coefwaves:		if (currSweepIndex == 0)	//have to make save waves			Make/O/D/N=(numSomaSweeps, DimSize(genParamsTemp,0)) somaGenParamsOut			Make/O/D/N=(numSomaSweeps, DimSize(compParamsTemp,0)) somaCompParamsOut			Make/O/D/N=(numSomaSweeps, DimSize(coefWaveTemp,0)) somaCoefWaveOut		endif		somaGenParamsOut[currSweepIndex][] = genParamsTemp[q]			//convert the whole column to one row, row index = currSweepIndex		somaCompParamsOut[currSweepIndex][] = compParamsTemp[q]			somaCoefWaveOut[currSweepIndex][] = coefWaveTemp[q]		endfor	Duplicate/O somaGenParamsOut, $somaGenParamsRef; Duplicate/O somaCompParamsOut, $somaCompParamsRef; Duplicate/O  somaCoefWaveOut, $somaCoefWaveRef		//CALC PED SUMMARY DATA	for (currSweepIndex = 0; currSweepIndex < numPedSweeps; currSweepIndex +=1)		currPedRef = StringFromList(currSweepIndex, pedAnalysisSweepsList)		sweepDisplayStatusAndIndex = str2num(StringFromList(currSweepIndex, pedSweepsDisplayStatusList))		if (sweepDisplayStatusAndIndex > -1)			currRedisplayList = StringFromList(sweepDisplayStatusAndIndex, pedDisplayInfoList)			currRedisplayRef = StringFromList(redisplayRefIndex, currRedisplayList,",")		else		//do not have raw data waves saved, only summaries			currRedisplayRef = ""		endif		analysis_cellParams_S3(currPedRef, vCmd_t0_P, vCmd_t1_P, vCmd_baseline_P, vCmd_step_P, "genParamsTemp", "compParamsTemp",  "coefWaveTemp", pedSubRef, currRedisplayRef, enforcedCapPeakTimeX,somaSubRef)			//save gen params, comp params, coefwaves:		if (currSweepIndex == 0)	//have to make save waves			Make/O/D/N=(numPedSweeps, DimSize(genParamsTemp,0)) pedGenParamsOut			Make/O/D/N=(numPedSweeps, DimSize(compParamsTemp,0)) pedCompParamsOut			Make/O/D/N=(numPedSweeps, DimSize(coefWaveTemp,0)) pedCoefWaveOut		endif		pedGenParamsOut[currSweepIndex][] = genParamsTemp[q]			//convert the whole column to one row, row index = currSweepIndex		pedCompParamsOut[currSweepIndex][] = compParamsTemp[q]			pedCoefWaveOut[currSweepIndex][] = coefWaveTemp[q]		endfor	Duplicate/O pedGenParamsOut, $pedGenParamsRef; Duplicate/O pedCompParamsOut, $pedCompParamsRef; Duplicate/O  pedCoefWaveOut, $pedCoefWaveRef	KillWaves/Z pedGenParamsOut, pedCompParamsOut, pedCoefWaveOutend	//cp_doCellParams()function hs_getAvg(rowNum, numSweepsToAvg, numSweepsPostBrkIn, doSubregion)	Variable rowNum, numSweepsToAvg, numSweepsPostBrkIn, doSubregion		Variable startPAd = -0.01	Variable endPad = 0		WAVE/T hsList			//essentially "inputs" (hs specific, not soma/ped specific)	Variable cellNameCol = 0, isSomaHS1Col = 2, hs1BrkInFileCol = 3, hs1BrkInSweepCol = 4, hs2BrkInFileCol = 5, hs2BrkInSweepCol = 6, fileListCol = 7, chanListCol = 8, chanTypeCol = 9		//INPUT IS VCLAMP COMMAND. OUTPUT IS CURRENT RESPONSE	Variable hs1ChInput = 1, hs1ChOutput = 0, hs2ChInput = 3, hs2ChOutput = 2		//brk in info	Variable somaBrkInFileAndSweepCol = 10		//semi colon delim list: somabrkInFile; somaBrkInSweep;	Variable somaExampleCmdCol = 11	Variable somaSealListForAvgCol =12 		Variable somaSealAvgRefCol = 13			Variable pedBrkInFileAndSweepCol = 14	Variable pedExampleCmdCol = 15				Variable pedSealListForAvgCol = 16				Variable pedSealAvgRefCol = 17				//cell parameters prep	Variable somaNumFilesCol = 18				//total num files analyzable	Variable somaNumSweepsCol = 19				//total num sweeps analyzable	Variable somaFileAndSweepCol = 20			//"number of each analyzable file, number of associated analyzable sweeps for file;nextfile..."	Variable somaAnalysisSweepsCol = 21			//list of all sweeps that are analyzable (e.g. in Vclamp at site, after brk in sweep/file). PedCol = 26	Variable somaSweepNotesCol = 22				//notes for all sweeps (for this reason waves must be loaded when filling in this column!	Variable somaSweepClampStatusCol = 23		//(other site) clamp status related to each file	Variable somaGenParamsRefCol = 24		//generalParamsRef for file. 2D one row per sweep (all sweeps together), one column per param	Variable somaCompParamsRefCol = 25		//component params ref for file. 2D one row per sweep (all sweeps together), one column per param	Variable somaCoefWaveParamsRefCol = 26	//coef wave for file. 2D one row per sweep (all sweeps together), one column per coef	Variable somaSweepIsSavedCol = 27			//if copy of original wave, (subtracted wave), model, model components, etc. are (to be) saved for this sweep (0 or 1)	Variable somaDisplayInfoSweeps = 28			//semi colon delimit		//wave average storage	Variable somaPostBrkInAvgsListCol = 47	Variable somaPostBrkInAvgsRefCol = 48	Variable pedPostBrkInAvgsListCol = 49	Variable pedPostBrkInAvgsRefCol = 50	hsList[rowNum][somaPostBrkInAvgsListCol,pedPostBrkInAvgsRefCol] = ""	Variable conv =  somaDisplayInfoSweeps - somaNumFilesCol + 1		String BrkInList_S = hsList[rowNum][somaBrkInFileAndSweepCol]	String BrkInList_P = hsList[rowNum][pedBrkInFileAndSweepCol]	Variable BrkInFile_S = str2num(StringFromList(0,BrkInList_S,","))	Variable BrkInSweep_S = str2num(StringFromList(1,BrkInList_S,";"))	Print "BrkInList_S",BrkInList_S,"BrkInFile_S",BrkInFile_S,"BrkInSweep_S",BrkInSweep_S	Variable BrkInFile_P = str2num(StringFromList(0,BrkInList_P,","))	Variable BrkInSweep_P = str2num(StringFromList(1,BrkInList_P,";"))		String firstFileSweepStr_S = StringFromList(0, hsList[rowNum][somaFileAndSweepCol])	Print "firstFileSweepStr = " + firstFileSweepStr_S	Variable numSweepsInBrkInFile_S = str2num(StringFromList(1, firstFileSweepStr_S,",")) + BrkInSweep_S	Print "numSweepsInBrkInFile_S",numSweepsInBrkInFile_S	String firstFileSweepStr_P = StringFromList(0, hsList[rowNum][somaFileAndSweepCol+conv])	Variable numSweepsInBrkInFile_P = str2num(StringFromList(1, firstFileSweepStr_P,","))	 + BrkInSweep_P	String brkInFileDir_S = fd_getFilePathFromFileDir(BrkInFile_S)	String brkInFileDir_P = fd_getFilePathFromFileDir(BrkInFile_P)	String waveListToAvg_S = "", waveListToAvg_P = ""		String appendStr	if (doSubregion)		appendStr = "c"	else		appendStr = ""	endif		Variable outputChNum_S = cp_getChanIndex(rowNum, 0, 0)	Variable outputChNum_P = cp_getChanIndex(rowNum, 1, 0)		Variable i,currSweepNum; String loadName, firstSweepName, lastSweepName	Variable t0, t1		da_closeABF()	Print "brkInFileDir_S",brkInFileDir_S	//for soma	hs_getStartAndEnd(rowNum,0, t0,t1)	for (i=0;i<numSweepsToAvg;i+=1)		currSweepNum = BrkInSweep_S + numSweepsPostBrkIn + i + 1		if (currSweepNum < numSweepsInBrkInFile_S)			loadName = fd_getWaveLoadName(BrkInFile_S, currSweepNum, outputChNum_S) + appendStr			da_openABF(brkInFileDir_S, reportFailure = 1)					da_makeWaveFromOpenFile(currSweepNum, outputChNum_S, loadName, reportError = 1)				da_closeABF()			Duplicate/O/R=(t0+startPad, t1+endPad) $loadName, temp_avgthing			Duplicate/O temp_avgthing, $loadName			waveListToAvg_S += loadName + ","			if (i==0)				firstSweepName = loadName[0,strlen(loadName)-strlen(appendStr)-1]	//take off ch if present			endif			lastSweepName = loadName[0,strlen(loadName)-strlen(appendStr)-1]	//take off ch if present		else			Print "Not enough sweeps for avg. Sweep unsuccessful. Soma. Sw = " + num2str(currSweepNum)		endif			endfor	String avgName = getWaveNameBySweeps(firstSweepName, lastSweepName) + appendStr	wave_avgFromStrList(waveListToAvg_S,",", avgName,0,nan,nan)	hsList[rowNum][somaPostBrkInAvgsListCol] += waveListToAvg_S + ";"	hsList[rowNum][somaPostBrkInAvgsRefCol] += avgName + ";"	//for ped	hs_getStartAndEnd(rowNum,1, t0,t1)	for (i=0;i<numSweepsToAvg;i+=1)		currSweepNum = BrkInSweep_P + numSweepsPostBrkIn + i		if (currSweepNum < numSweepsInBrkInFile_P)			loadName = fd_getWaveLoadName(BrkInFile_P, currSweepNum, outputChNum_P) + appendStr			da_openABF(brkInFileDir_P)					da_makeWaveFromOpenFile(currSweepNum, outputChNum_P, loadName)						Duplicate/O/R=(t0+startPad, t1+endPad) $loadName, temp_Avgthing2			Duplicate/O temp_Avgthing2, $loadName			waveListToAvg_P += loadName + ","			if (i==0)				firstSweepName = loadName[0,strlen(loadName)-strlen(appendStr)-1]	//take off ch if present			endif			lastSweepName = loadName[0,strlen(loadName)-strlen(appendStr)-1]	//take off ch if present		else			Print "Not enough sweeps for avg. Sweep unsuccessful. Ped. Sw = " + num2str(currSweepNum)		endif			endfor	avgName = getWaveNameBySweeps(firstSweepName, lastSweepName) + appendStr	wave_avgFromStrList(waveListToAvg_P,",", avgName,0,nan,nan)	hsList[rowNum][pedPostBrkInAvgsListCol] += waveListToAvg_P + ";"	hsList[rowNum][pedPostBrkInAvgsRefCol] += avgName + ";"end//subtract a seal sweep from a response when the response step is offset in time from the seal step//could be improveD: doesnt take into account possible differences in baseline or input resistancefunction/S analysis_subCmd(sealRef,sealCmdRef,sealStepSearchStartX,respRef,respCmdRef,respStepSearchStartX,respOutRef)	String sealRef		//seal sweep to sub	String sealCmdRef	//cmd for seal sweep (used to determine step timing)	Variable sealStepSearchStartX	//time to search for step from (allows steps ahead of the actual step to be ignored)	String respRef		//response to sub seal sweep from	String respCmdRef	//cmd for that response	Variable respStepSearchStartX	//time to search for step from (allows steps ahead of the actual step to be ignored)	String respOutRef		//ref to save subtraction result into		Variable meanDurX = 0.004	//length of time preceding seal step start to use in seal response baseline avg (From that point to sealStepSearchStartX)		if ( dimdelta($sealRef,0) != dimdelta($respREf,0) )		Print "analysis_subCmd(): SealRef and respRef (",sealref,",",respref,") have non-equal sampling rates and subCmd may not work correctly!)"	endif			Variable isNegativeSealStep=1,isNegativeRespStep=1		//could make these input parameters if needed	analysis_cmd_stepChange($sealCmdRef,0,sealStepSearchStartX,isNegativeSealStep,"sci_seal_info_temp","")	analysis_cmd_stepChange($respCmdRef,0,respStepSearchStartX,isNegativeRespStep,"sci_resp_info_temp","")	WAVE/D sci_seal_info_temp,sci_resp_info_temp	//created by analysis_cmd_stepChange		//determine scale factor for seal and resp cmds	Double sealScaleFactor = sci_resp_info_temp[%deltaMean] / sci_seal_info_temp[%deltaMean]		//how much larger is resp step than seal step?	Variable polarityChange = (isNegativeSealStep > 0) != (isNegativeRespStep > 0)	if (polarityChange)		sealScaleFactor *= -1	endif	//apply any scaling	Duplicate/O/D $sealRef, sci_seal_temp	Double sci_seal_temp_baseline = mean(sci_seal_temp,sci_seal_info_temp[%t0_start_X] - meanDurX,sci_seal_info_temp[%t0_start_X])	sci_seal_temp -= sci_seal_temp_baseline		//baseline subtract seal to isolate change during step	sci_seal_temp *= sealScaleFactor				//if resp step was larger (or smaller) than seal step, scale seal step accordingly		//determine offset of seal step relative to resp step	Double offset = sci_seal_info_temp[%t0_start_X] - sci_resp_info_temp[%t0_start_X]	setscale/P x, dimoffset(sci_seal_temp,0) - offset, dimdelta(sci_seal_temp,0), sci_seal_temp		//determine length of steps so we know how far subtraction can go	Variable edgePadding_x = 0.008		//steps should be at least slightly longer than this value..also this value must be greater than (default) meanDurX in analysis_cmd_stepChange, currently 0.004	Variable sealStepEndSearchStartX = sci_seal_info_temp[%t0_end_X] + edgePadding_x	Variable respStepEndSearchStartX = sci_resp_info_temp[%t0_end_X] + edgePadding_x	analysis_cmd_stepChange($sealCmdRef,0,sealStepEndSearchStartX,!isNegativeSealStep,"sci_seal_fall_info_temp","")	analysis_cmd_stepChange($respCmdRef,0,respStepEndSearchStartX,!isNegativeRespStep,"sci_resp_fall_info_temp","")	WAVE/D sci_seal_fall_info_temp,sci_resp_fall_info_temp		Double sealStepLen =  sci_seal_fall_info_temp[%t0_start_X] - sci_seal_info_temp[%t0_start_X]	Double respStepLen =  sci_resp_fall_info_temp[%t0_start_X] - sci_resp_info_temp[%t0_start_X]	Double minStepLen = min(sealStepLen,respStepLen)		//perform subtraction during step region	Double respStepStart_p = sci_resp_info_temp[%t0_start_P] + 1		//start one point after step start	Double respStepEnd_p = respStepStart_p - 1 + minStepLen / dimdelta($respref,0)	Duplicate/O/D $respRef, $respOutRef/wave=out	out[respStepStart_p,respStepEnd_p] -= sci_seal_temp(x) 		return respOutRefend//analysis_subCmd()	r+=1;dl_assignAndLbl(out, r, isCC,preAppendLbl+ "isCC")	r+=1;dl_assignAndLbl(out, r, searchStartX,preAppendLbl+ "searchStartX")	r+=1;dl_assignAndLbl(out, r, ParamIsDefault(storeAndOrForceMinStepSize) ? NaN : storeAndOrForceMinStepSize,preAppendLbl+ "storeAndOrForceMinStepSize")	r+=1;dl_assignAndLbl(out, r, meanDurX,preAppendLbl+ "meanDurX")	r+=1;dl_assignAndLbl(out, r, numSDsForMinStepSize,preAppendLbl+ "numSDsForMinStepSize")	r+=1;dl_assignAndLbl(out, r, preCheckForStep,preAppendLbl+ "preCheckForStep")	r+=1;dl_assignAndLbl(out, r, edgeBaseAveraging,preAppendLbl+ "edgeBaseAveraging")	r+=1;dl_assignAndLbl(out, r, edgePadding,preAppendLbl+ "edgePadding")	r+=1;dl_assignAndLbl(out, r, baselineMean,preAppendLbl+ "baselineMean")	r+=1;dl_assignAndLbl(out, r, baselineSD,preAppendLbl+ "baselineSD")	r+=1;dl_assignAndLbl(out, r, minStepSize,preAppendLbl+ "minStepSize")	r+=1;dl_assignAndLbl(out, r, cmd_t0Threshold,preAppendLbl+ "cmd_t0Threshold")	r+=1;dl_assignAndLbl(out, r, stepStart,preAppendLbl+ "stepStart")	r+=1;dl_assignAndLbl(out, r, stepEnd,preAppendLbl+ "stepEnd")	r+=1;dl_assignAndLbl(out, r, t0_start_P,preAppendLbl+ "t0_start_P")	r+=1;dl_assignAndLbl(out, r, t0_mid_P,preAppendLbl+ "t0_mid_P")	r+=1;dl_assignAndLbl(out, r, t0_end_P,preAppendLbl+ "t0_end_P")	r+=1;dl_assignAndLbl(out, r, t0_start_X,preAppendLbl+ "t0_start_X")	r+=1;dl_assignAndLbl(out, r, t0_mid_X,preAppendLbl+ "t0_mid_X")	r+=1;dl_assignAndLbl(out, r, t0_end_X,preAppendLbl+ "t0_end_X")	r+=1;dl_assignAndLbl(out, r, V_EdgeLvl0,preAppendLbl+ "V_EdgeLvl0")	r+=1;dl_assignAndLbl(out, r, V_EdgeLvl4,preAppendLbl+ "V_EdgeLvl4")	r+=1;dl_assignAndLbl(out, r, stepMean,preAppendLbl+ "stepMean")	r+=1;dl_assignAndLbl(out, r, deltaMean,preAppendLbl+ "deltaMean")	function analysis_multiply(listOfWaves, multiplier)	String listOfWaves; Variable multiplier		Variable i; String currRef	for (i=0;i<ITemsInList(listOfwaves);i+=1)		currRef = StringFromList(i, listOfWaves)		WAVE/D tempW = $currRef		tempW *= multiplier	endfor		return iend//header waves for outputs (using cellParams_S3): analysis_getCoefWaveHeader(); analysis_getCompParamsHeader(5); analysis_getGenParamsHeader(0)function analysis_simplerCellParams(currentRef, cmdRef, subRef, isPed, genParamsRef, compParamsRef, coefRef, redisplayRef, dispResults)	String currentRef, cmdRef, subRef, genParamsRef, compParamsRef, coefRef, redisplayRef		//subRef is subtracted from currentRef	Variable isPed	Variable dispResults		//each results wave is displayed in a table with its header, if non-zero passed					Print "ref = " + currentRef	Print "subRef = " + subRef	Print "cmdRef = " +  cmdRef		Variable  vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step		//for soma	analysis_cellParams_S_vCmd(cmdRef,  vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step)		debug_checkRTErrState(msg="11111111111111AAAAAAAAA")	cp_makeRedisplayRef(redisplayRef, -1, -1, currentRef, cmdRef, subRef)		debug_checkRTErrState(msg="1111111111111111")			analysis_cellParams_S3(currentRef, vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step, "genParamsTemp", "compParamsTemp",  "coefWaveTemp", subRef, redisplayRef, -1,cmdRef)		//cmdRef if chosen for time of brk in 		Duplicate/O $"genParamsTemp", $genParamsRef	Duplicate/O  $"compParamsTemp" , $compParamsRef	Duplicate/O  $"coefWaveTemp" ,$coefRef			if (dispResults)		Edit/k=1/N=coefRef $analysis_getCoefWaveHeader(), $coefRef		Edit/k=1/N=compParamsRef $analysis_getCompParamsHeader(5), $compParamsRef		Edit/k=1/N=genParamsRef $analysis_getGenParamsHeader(0), $genParamsRef	endifendfunction analysis_simpleCellParams(currentRef, cmdRef, hsListRow, isPed, genParamsRef, compParamsRef, coefRef, redisplayRef)	String currentRef, cmdRef, genParamsRef, compParamsRef, coefRef, redisplayRef	Variable hsListRow, isPed				WAVE/T hsList		Print "ref = " + currentRef	String subRef = hs_getSealAvgRef(hsListRow, isPed)	Print "subRef = " + subRef	Print "cmdRef = " +  cmdRef		Variable  vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step		//for soma	analysis_cellParams_S_vCmd(cmdRef,  vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step)		debug_checkRTErrState(msg="11111111111111AAAAAAAAA")	cp_makeRedisplayRef(redisplayRef, -1, -1, currentRef, cmdRef, subRef)		debug_checkRTErrState(msg="1111111111111111")			analysis_cellParams_S3(currentRef, vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step, "genParamsTemp", "compParamsTemp",  "coefWaveTemp", subRef, redisplayRef, -1,cmdRef)		//cmdRef if chosen for time of brk in 		Duplicate/O $"genParamsTemp", $genParamsRef	Duplicate/O  $"compParamsTemp" , $compParamsRef	Duplicate/O  $"coefWaveTemp" ,$coefRef	endfunction quickCellParams(ref, rowNum, doPed,  genParamsRef, compParamsRef, coefRef	)	String ref	Variable rowNum, doPed	String  genParamsRef, compParamsRef, coefRef			//not saved if empty strings			analysis_getCoefWaveHeader()	; analysis_getGenParamsHeader(0) ;analysis_getCompParamsHeader(5) 	//make sure these exist as it's used throughout	debug_checkRTErrState(msg="00000000000")		Variable improperCmdScaling = 1				//set and then edit section below		WAVE/T hsList		Variable redisplayInfoListCol_S = 28			//sweepNumInList, currentRef, displayRef; ... 	; 			displayRef = currentRef + ccD	Variable analyzedSweepListCol_S = 21		variable conv = doPed ? 11 : 0		debug_checkRTErrState(msg="111111100000000000")		String displayRefAppendStr = "ccD"	Print "ref = " + ref	String subRef = hs_getSealAvgRef(rowNum, doPed)	Print "subRef = " + subRef	String cmdRef = hs_getVcmdRef(rowNum, doPed)	Print "cmdRef = " +  cmdRef		Variable  vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step		//for soma		debug_checkRTErrState(msg="11111111111111AAAAAAAAA")		if (improperCmdScaling)		//better in future to implement this by checking against table of values, if values are blank do nothing, if filled use. Leaves record that way		vCmd_t0 = 0.0734545		vCmd_t1 = 0.223435		vCmd_baseline = -0.0703857		vCmd_step = -0.0804443	else		analysis_cellParams_S_vCmd(cmdRef,  vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step)	endif	String currRedisplayRef = ref + displayRefAppendStr	Print "redisplay ref = " + currRedisplayRef	cp_makeRedisplayRef(currRedisplayRef, -1, -1, ref, cmdRef, subRef)		debug_checkRTErrState(msg="1111111111111111")			analysis_cellParams_S3(ref, vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step, "genParamsTemp", "compParamsTemp",  "coefWaveTemp", subRef, currRedisplayRef, -1,cmdRef)		//cmdRef if chosen for time of brk in 		Duplicate/O $"genParamsTemp", $genParamsRef	Duplicate/O  $"compParamsTemp" , $compParamsRef	Duplicate/O  $"coefWaveTemp" ,$coefRefend	//use of cpSummaryIndex://add to hsList using (b0, optionally), b1 and b2 (puts proper names in hsList and computes average break in sweep)//set row = cpSummaryIndex of interest. Do //  	cpSummaryIndex[row][0] = hsList[rowOfCellInHsList][0]//	one row for P, one row for S//fd_selectMatchingFiles(1, matchStr = "*" + cpSummaryIndex[row][0] + "*") to find quickly//select sweeps to average for analysis at each site, and then do for each site, what follows://	String currSoma = graph_getWaveList("","*AD2","",0)			allows you to pick traces for soma and terminal...//	row=13; cpSummaryIndex[row][1] = wave_avgFromStrList(currSoma, "","")//	cp_insertRefs(row)//	SI_quickCellParams(row, rowOfCellInHsList)//function cpa(cpSummaryIndexRow, hsListRow)	Variable cpSummaryIndexRow, hsListRow		WAVE/T cpSummaryIndex, hsList		Print "HS1 is = " + hsList[hsListRow][1]		//sets terminal	cpSummaryIndex[cpSummaryIndexRow][0] = hsList[hsListRow][0]	cpSummaryIndex[cpSummaryIndexRow][14] = num2str(hsListRow)	cpSummaryIndex[cpSummaryIndexRow][2] = "P"		//sets soma	cpSummaryIndex[cpSummaryIndexRow+1][0] = hsList[hsListRow][0]	cpSummaryIndex[cpSummaryIndexRow+1][14] = num2str(hsListRow)	cpSummaryIndex[cpSummaryIndexRow+1][2] = "S"		//set additional	cpSummaryIndex[cpSummaryIndexRow+2][0] = hsList[hsListRow][0]	cpSummaryIndex[cpSummaryIndexRow+2][14] = num2str(hsListRow)	cpSummaryIndex[cpSummaryIndexRow+2][2] = "S"		fd_selectMatchingFiles(1, matchStr="*" + hsList[hsListRow][0] + "*")	endfunction cpb(cpSummaryIndexRow, doPed, beforeOtherSiteBrkIn)	Variable cpSummaryIndexRow, doPed, beforeOtherSiteBrkIn	//	WAVE/T cpSummaryIndex, hsList	Variable hsListRow = str2num(cpSummaryIndex[cpSummaryIndexRow][14])	Variable pedHS1 = stringmatch(hsList[hsListRow][1],"P")		Variable hsEndNum	if (pedHS1)		hsEndNum = doPed ? 0 : 2	else		hsEndNum = doPed ? 2 : 0	endif		String recogStr = "*AD" + num2str(hsEndNum)	String refs =  graph_getWaveList("",recogStr,"",0)		cpSummaryIndex[cpSummaryIndexRow][1] = wave_avgFromStrList(refs, "","",0,nan,nan)	Print "avg ref added = " + cpSummaryIndex[cpSummaryIndexRow][1]	SI_insertRefs(cpSummaryIndexRow)	SI_quickCellParams(cpSummaryIndexRow)		if (beforeOtherSiteBrkIn)		cpSummaryIndex[cpSummaryIndexRow][12] = "b"	else		cpSummaryIndex[cpSummaryIndexRow][12] = "a"	endifendfunction/S wave_dupWavesInWin(matchStr,replaceThisStr,withThisStr)	String matchStr	String replaceThisStr,withThisStr		String list = wavelist(matchStr,";","WIN:")		//top window		String changedList = wave_dupWithStrReplacedName(list,replaceThisStr,withThisStr)		Variable i,numWvs = itemsinlist(changedList)		for (i=0;i<numWvs;i+=1)		ReplaceWave/W=$winName(0,1) trace=$StringFromList(i,list) $stringfromlist(i,changedlist)	endforendfunction/S wave_dupWithStrReplacedName(listOfWaves,replaceThisStr,withThisStr)	String listOfWaves	String replaceThisStr, withThisStr			String outList = ""		Variable i; String newName, oldName	for (i=0;i<ItemsInList(listOfWaves);i+=1)		oldName = StringFromList(i, listOfWaves)		newName = ReplaceString(replaceThisStr, oldName, withThisStr)		outList += newName + ";"		if (!stringmatch(oldName,newName))			Duplicate/O $oldName, $newName		endif	endfor		Print "wave_dupWithStrReplacedName(): COPIED WAVES IN LIST TO NEW REFS AS (original names then new names follow):" 	Print "listOfWaves",listOfWaves,"outList",outList	return outListendfunction SI_insertRefs(rowNum)	Variable rowNum	WAVE/T cpSummaryIndex	String displayRefAppendStr = "ccD"		cpSummaryIndex[rowNum][3] = cpSummaryIndex[rowNum][1] + "ccG"	cpSummaryIndex[rowNum][4] = cpSummaryIndex[rowNum][1] + "ccC"	cpSummaryIndex[rowNum][5] = cpSummaryIndex[rowNum][1] + "ccW"	cpSummaryIndex[rowNum][6] = cpSummaryIndex[rowNum][1] + displayRefAppendStr	cpSummaryIndex[rowNum][7] = cpSummaryIndex[rowNum][1] + "cap"	cpSummaryIndex[rowNum][8] = cpSummaryIndex[rowNum][1] + "rad"	cpSummaryIndex[rowNum][11] = cpSummaryIndex[rowNum][1] + "psub"endfunction cp_makeRedisplayRef(displayRefSaveName, sweepIndex, displaySweepIndex, origRef, cmdRef, sealFileRef)	String displayRefSaveName,origRef, cmdRef, sealFileRef	Variable sweepIndex, displaySweepIndex		String redisplayWaveAppendStr = "ccD"	String genParamsWaveAppendStr = "ccG"	String compParamsWaveAppendStr = "ccC"	String coefWaveAppendStr = "ccW"	String somaIDStr = "S"	String pedIDStr = "P"	String savedSubbedWaveAppendStr = "ccS"	String modelSaveAppendStr = "ccM"	String componentSaveAppendStr = "c"		Variable numModels = 5,i, c,currNumComponents	Make/O/T/N=(numModels) redisplayTemp	for (i=0;i<numModels;i+=1)		currNumComponents = i+1					//		0				1							2							3		4			5		redisplayTemp[i] = num2str(i)+ ";"+num2str(sweepIndex)+ ";"+ num2str(displaySweepIndex)+ ";"+origRef+";"+CmdRef+";"+sealFileRef+";"					//		6												7											8		redisplayTemp[i]+= origRef+savedSubbedWaveAppendStr+";"+origRef + modelSaveAppendStr+ num2str(i)+";"+num2str(currNumComponents)+";"	//last is # components		for (c=0;c<currNumComponents;c+=1)									//9....			redisplayTemp[i]+= origRef + modelSaveAppendStr+ num2str(i)+ componentSaveAppendStr + num2str(c) +";"		endfor	endfor	Duplicate/O redisplayTemp, $displayRefSaveName	KillWaves redisplayTempendfunction hs_getStartAndEnd(rowNum, doPed, vcmd_t0, vcmd_t1)	Variable &vcmd_t0,&vcmd_t1, doPed, rowNum		WAVE/T hsList		//cell parameters prep	Variable somaNumFilesCol = 18				//total num files analyzable	Variable somaNumSweepsCol = 19				//total num sweeps analyzable	Variable somaFileAndSweepCol = 20			//"number of each analyzable file, number of associated analyzable sweeps for file;nextfile..."	Variable somaAnalysisSweepsCol = 21			//list of all sweeps that are analyzable (e.g. in Vclamp at site, after brk in sweep/file). PedCol = 26	Variable somaSweepNotesCol = 22				//notes for all sweeps (for this reason waves must be loaded when filling in this column!	Variable somaSweepClampStatusCol = 23		//(other site) clamp status related to each file	Variable somaGenParamsRefCol = 24		//generalParamsRef for file. 2D one row per sweep (all sweeps together), one column per param	Variable somaCompParamsRefCol = 25		//component params ref for file. 2D one row per sweep (all sweeps together), one column per param	Variable somaCoefWaveParamsRefCol = 26	//coef wave for file. 2D one row per sweep (all sweeps together), one column per coef	Variable somaSweepIsSavedCol = 27			//if copy of original wave, (subtracted wave), model, model components, etc. are (to be) saved for this sweep (0 or 1)	Variable somaDisplayInfoSweeps = 28			//semi colon delimit	Variable conv =  somaDisplayInfoSweeps - somaNumFilesCol + 1			if (strlen(hsList[rowNum][44]) > 0)		vcmd_t0 = str2num(hsList[rowNum][44])		vcmd_t1 = str2num(hsList[rowNum][45])	else//		Variable vCmd_baseHolder, vCmd_stepHolder, waveLoaded = 0//		String cmdRef = hsList[rowNum][somaExampleCmdCol + doPed ? 4 : 0]//		if (WaveExists($cmdRef) == 0)//			da_fd_loadWaveFromWaveName(cmdReF)//			waveLoaded = 1//		endif//		analysis_cellParams_S_vCmd(cmdRef,  vcmd_t0, vcmd_t1, vCmd_baseHolder, vCmd_stepHolder)//		if (waveLoaded)//			KillWaves/Z $cmdRef//		endif		Duplicate/O $hsList[rowNum][somaGenParamsRefCol + (conv*doPed)], genPTemp		vcmd_t0 = genPTemp[0][14]		vcmd_t1 = genPTemp[0][15]				KillWaves/Z genPTemp	endifendfunction/S da_fd_loadFile(fileName,numSweeps,doDisplay,addKillHook[fNum])	String fileName;variable doDisplay,numSweeps	Variable fNum		//optionally pass fNum which will supercede any file name passed	Variable addKillHook		//pass to add kill window hook -- used is prompted to ask whether waves should be killed when window is		if (numSweeps == 0)		numSweeps = inf	endif	Variable fileIndex	if (ParamIsDefault(fNum) || numtype(fNum))		fileIndex = fd_getFIndexInFileInfoWave(fileName + "*")	else		fileIndex = fNum	endif		String loadedSweepsList = fd_loadFile(fileIndex,bypassLoadCheck=1, maxNumSweeps=numSweeps)		if (doDisplay)		da_fd_displayWaveListByChans(loadedSweepsList,addKillHook)	endif		Print "loadedSweepsList",loadedSweepsListendfunction da_fd_displayWaveListByChans(sweepsList,addKillHook)	String sweepsList;variable addKillHook//pass to add kill window hook -- used is prompted to ask whether waves should be killed when window is		Variable vertAxSpacing = 0.02		Variable numSweeps = itemsinlist(sweepsList)		Display/k=1	String win = S_name		String axPreAppendStr = "L_"		variable i,chanNum;string chanNumList = "",sweepRef,chanNumStr,axN	for (i=0;i<numSweeps;i+=1)		sweepRef = stringfromlist(i,sweepsList)		chanNum = text_getInfoFromWaveName_V(sweepRef, 3)		chanNumStr = num2str(chanNum)		if (WhichListItem(chanNumStr,chanNumList) < 0)			chanNumList += chanNumStr + ";"		endif		axN = axPreAppendStr+chanNumStr		Appendtograph/W=$win/L=$axN $sweepRef	endfor	variable numChans = itemsinlist(chanNumList)	Variable totalAxSpacing = vertAxSpacing * (numChans-1)	Variable totalAxRoom = 1-totalAxSpacing	variable roomPerAx = totalAxRoom/numChans	Variable axStart,axEnd	for (i=0;i<numChans;i+=1)		axEnd = 1-(i*roomPerAx + i*vertAxSpacing)		axStart = axEnd - roomPerAx		chanNumStr = stringfromlist(i,chanNumList)		axN = axPreAppendStr + chanNumStr		Modifygraph/w=$win axisenab($axN) = {axStart,axEnd}	endfor	if (addKillHook)		setwindow $win hook(winHook_killWaves)=winHook_killWaves	endif		Modifygraph/w=$win freepos = 0,lblpos=55endfunction/s da_fd_loadWavesFromWaveName(refList,onlyNonExistent,[out_loadedWvList,atRecSampling])	STring refList	variable onlyNonExistent		//pass true to skip waves that already exist, false to load no matter what	STring &out_loadedWvList		//pass to get list of waves that were loaded (helps if would like to just kill those that were newly loaded in this function)	Variable atRecSampling			//pass to load at recording sampling rate rather than any downsampling requested in filePanel		if (igor_is64())		return fd_loadAbfFrom32DuringExecution(refList,onlyNonExistent,1,justRequestedWvs=1)//fd_callLoadAbfAndStore(refList,skipLoadIfIbwExists,1,justRequestedWvs=1)	endif		Variable forceRecSampling=!PAramIsDefault(atRecSampling) && atRecSampling		String loadedWvList="",failures=""		variable i,num=itemsinlist(refList);string ref		for (i=0;i<num;i+=1)		ref=stringfromlist(i,refList)		if (onlyNonExistent && WaveExists($ref))		//if onlyNonexistent are to be loaded and the wave exists, skip			continue		endif		da_fd_loadWaveFromWaveName(ref,atRecSampling=forceRecSampling)		loadedWvList+=ref+";"		if (!WaveExists($ref))			failures+=ref+";"		endif	endfor		if (!paramIsdefault(out_loadedWvList))		out_loadedWvList=loadedWvList	endif		return failuresendfunction da_fd_loadWaveFromWaveName(waveRef,[atRecSampling])	String waveRef	Variable atRecSampling		//optionally pass to force load at rec sampling despite any settings in filePanel		Variable forceRecSampling=!ParamIsDefault(atRecSampling) && atRecSampling	String wholeFileName = text_getInfoFromWaveName_S(waveRef, 9)	Variable fileIndex = fd_getFIndexInFileInfoWave(wholeFileName)	Variable chan = text_getInfoFromWaveName_V(waveRef,3)	Variable sweep = text_getInfoFromWaveName_V(waveRef,2)			da_fd_openABFByFileNum(fileIndex)	da_makeWaveFromOpenFile(sweep, chan, waveRef,reportError = 1,atRecSampling=forceRecSampling)	da_closeABF()		String juncPotStr_mV=fd_getJuncPotStrForFile(fileIndex,chan,waveRef)	fd_applyJuncPotToLoadedWv(waveRef,juncPotStr_mV)endfunction da_fd_remakeAvgWaves(waveRefList,onlyloadIfWaveDoesNotExist,killWavesLoadedForAvging)	String waveRefList	Variable onlyloadIfWaveDoesNotExist,killWavesLoadedForAvging	variable i	for (i=0;i<itemsinlist(wavereflist);i+=1)		da_fd_remakeAvgWave(stringfromlist(i,wavereflist),onlyloadIfWaveDoesNotExist,killWavesLoadedForAvging)	endforendfunction da_fd_remakeAvgWave(waveRef,onlyloadIfWaveDoesNotExist,killWavesLoadedForAvging)	string waveRef	Variable killWavesLoadedForAvging	Variable onlyloadIfWaveDoesNotExist		if (!strlen(waveRef))		return 0	endif	String noteStr,avgdWaveList = ""; variable i	if (waveexists($waveRef))		if (onlyloadIfWaveDoesNotExist)			return 0		endif			noteStr = note($waveRef)		avgdWaveList = text_commasToSemiColons(stringbykey("avg",noteStr))	else		Variable sPos = strsearch(waveRef, "S", 0)		Variable lastFileNameChar = sPos - 1		String wholeFileName = waveRef[0,lastFileNameChar]				Variable fileIndex = fd_getFIndexInFileInfoWave(wholeFileName)				String placeholderStr		Variable chan		String chanSearchStr = ReplaceString("AD",waveRef," ")		sscanf chanSearchStr, "%s %i",placeholderStr,chan					Variable maxSweepNum = fd_getSweepNFromFileInfoWave(fileIndex)				Variable firstSweepNum,lastSweepNum		firstSweepNum = str2num(waveRef[sPos+1,sPos+3]) - 1		lastSweepNum = str2num(waveRef[sPos+4,sPos+6]) - 1		Variable numSweeps = lastSweepNum - firstSweepNum + 1				Print "da_fd_remakeAvgWave(): remaking avg wave=",waveref,"firstSweepNum",firstSweepNum,"lastSweepNum",lastSweepNum,"maxSweepNum",maxSweepNum				if (numSweeps > maxSweepNum)			Print "da_fd_remakeAvgWave(): warning, attempting remake (based on wave name) of avgwave=",waveRef,"but avgWave appears to span two or more files. avgWave will be remade based on first file sweeps only"		endif				variable count = 0		for (i=firstSweepNum;(i<=lastSweepNum) && (count<maxSweepNum);i+=1)			avgdWaveList += fd_getWaveLoadName(fileIndex, i, chan) + ";"			count += 1		endfor		endif		String ref,toKillList=""	Variable waveWasLoaded	for (i=0;i<itemsinlist(avgdWaveList);i+=1)		ref = stringfromlist(i,avgdWaveList)		waveWasLoaded = WaveExists($ref)				da_fd_loadWaveFromWaveName(stringfromlist(i,avgdWaveList))				if (!waveWasLoaded)			toKillList += ref + ";"		endif	endfor		wave_avgFromStrList(avgdWaveList,";", waveRef,0,nan,nan)		if (killWavesLoadedForAvging)		killWavesByName(toKillList)	endifendfunction/S da_avgUnloadedWaves(waveRefsList, saveWaves)	String waveRefsList; Variable saveWaves		Print "waveRefsList",waveRefsList		Variable i; String currWaveN	for (i=0;i<ItemsInList(waveRefsList);i+=1)		currWaveN = StringFromList(i, waveRefsList)		Print currWaveN		da_fd_loadWaveFromWaveName(currWaveN)				Print waveExists($currWaveN)	endfor		String saveN = wave_avgFromStrList(waveRefsList,";", "",0,nan,nan)		if(!saveWaves)		for (i=0;i<ItemsInList(waveRefsList);i+=1)			KillWaves $StringFromList(i, waveRefsList)		endfor	endif				return saveNendfunction hs_showSealSweep(rowNum, somaOrPed)	Variable rowNum	Variable somaOrPed		//0 both, 1 soma, 2 ped		String windowN = "sealDisplay"	if (WinType(windowN) == 0)		Display/K=1/N=$windowN	else		vis_clearGraph(windowN)	endif	if (somaOrPed == 1)		AppendToGraph/W=$windowN/C=(0,0,0) $hs_getSealAvgRef(rowNum, 0)	elseif(somaOrPed ==2)		AppendToGraph/W=$windowN/C=(50000,0,0) $hs_getSealAvgRef(rowNum, 1)	else		AppendToGraph/W=$windowN/C=(0,0,0) $hs_getSealAvgRef(rowNum, 0)		AppendToGraph/W=$windowN/C=(50000,0,0) $hs_getSealAvgRef(rowNum, 1)	endif		disp_defaultRange()endfunction/S hs_getSealAvgRef(rowNum, isPeD)	Variable rowNum, isPed	WAVE/T hsList	Variable somaSealAvgRefCol = 13		Variable pedSealAvgRefCol =17		Variable outCol = isPed ?  pedSealAvgRefCol : somaSealAvgRefCol		String ref = hsList[rowNum][outCol]		Variable waveFound = WaveExists($ref) && ( DimSize($ref,0) > 1 )		if (!waveFound)		make	endif		return refend	function/S fd_l_makeAvgWaveFromAvgNote(avgRef)	String avgRef		Print "in ref to fd_l_makeAvgWaveFromAvgNote() = " +Avgref		String listOfWavesForAvg = getWaveListFromAvgNote(avgRef)		String savedAsName =  wave_avgFromStrList(listOfWavesForAvg, "","",0,nan,nan)		if (!stringmatch(savedAsName, listOfWavesForAvg))		Print avgRef + ": wave not found. Remade from file in fd_l_makeAvgWaveFromAvgNote(). Failed to keep exact name. Wave instead saved as: "+ savedAsName	endif	Print "new avg wave saved as " + savedAsName	return savedAsNameendfunction/S hs_getVcmdRef(rowNum, isPed)	Variable rowNum, isPed	WAVE/T hsList		Variable somaExampleCmdCol = 11		Variable col = somaExampleCmdCol + (isPed ? 4 : 0)		String ref = hsList[rowNum][col]		Variable waveFound = WaveExists($ref) && ( DimSize($ref,0) > 1 )		if (!waveFound)		Print "Here in vcmd ref get make thing"		da_fd_loadWaveFromWaveName(ref)	endif	return refendfunction cp_reloadRelevantFiles(rowNum, unload)	Variable unload, rowNum			WAVE/T hsList		String sSep = ",", fSep = ";"		//essentially "inputs" (hs specific, not soma/ped specific)	Variable cellNameCol = 0, isSomaHS1Col = 2, hs1BrkInFileCol = 3, hs1BrkInSweepCol = 4, hs2BrkInFileCol = 5, hs2BrkInSweepCol = 6, fileListCol = 7, chanListCol = 8, chanTypeCol = 9		//INPUT IS VCLAMP COMMAND. OUTPUT IS CURRENT RESPONSE	Variable hs1ChInput = 1, hs1ChOutput = 0, hs2ChInput = 3, hs2ChOutput = 2		//brk in info	Variable somaBrkInFileAndSweepCol = 10		//semi colon delim list: somabrkInFile; somaBrkInSweep;	Variable somaExampleCmdCol = 11	Variable somaSealListForAvgCol =12 		Variable somaSealAvgRefCol = 13			Variable pedBrkInFileAndSweepCol = 14	Variable pedExampleCmdCol = 15				Variable pedSealListForAvgCol = 16				Variable pedSealAvgRefCol = 17					//cell parameters prep	Variable somaNumFilesCol = 18				//total num files analyzable	Variable somaNumSweepsCol = 19				//total num sweeps analyzable	Variable somaFileAndSweepCol = 20			//"number of each analyzable file, number of associated analyzable sweeps for file;nextfile..."	Variable somaAnalysisSweepsCol = 21			//list of all sweeps that are analyzable (e.g. in Vclamp at site, after brk in sweep/file). PedCol = 26	Variable somaSweepNotesCol = 22				//notes for all sweeps (for this reason waves must be loaded when filling in this column!	Variable somaSweepClampStatusCol = 23		//(other site) clamp status related to each file	Variable somaGenParamsRefCol = 24		//generalParamsRef for file. 2D one row per sweep (all sweeps together), one column per param	Variable somaCompParamsRefCol = 25		//component params ref for file. 2D one row per sweep (all sweeps together), one column per param	Variable somaCoefWaveParamsRefCol = 26	//coef wave for file. 2D one row per sweep (all sweeps together), one column per coef	Variable somaSweepIsSavedCol = 27			//if copy of original wave, (subtracted wave), model, model components, etc. are (to be) saved for this sweep (0 or 1)	Variable somaDisplayInfoSweeps = 28			//semi colon delimited for each displayed sweep. Ref to display wave	Variable conv =  somaDisplayInfoSweeps - somaNumFilesCol + 1			//redisplay	Variable redisplayRefIndex = 2		String fileAndSweepList = hsList[rowNum][somaFileAndSweepCol] + hsList[rowNum][somaFileAndSweepCol + conv]	String fileSweepLimitsStr = hsList[rowNum][41]	Variable maxNumFiles = ItemsInList(fileAndSweepList)		Variable i, currFileNum,currNumSweeps, currFileLimitsStrIndex, currFileLimitsStrPos, currSweepLimitStartPos, currSweepLimitEndPos; String currFileStr, currFileAndSweep, filesLoaded = "", currFileLimitStr	for (i=0;i<maxNumFiles;i+=1)		currFileAndSweep = StringFromList(i, fileAndSweepList)		currFileStr = StringFromList(0,currFileAndSweep,",")		if (WhichListItem(currFileStr, filesLoaded) == -1)			currFileNum = str2num(currFileStr)			currFileLimitsStrPos = strsearch(fileSweepLimitsStr, currFileStr,0)			if (currFileLimitsStrPos > -1)				currSweepLimitStartPos = currFileLimitsStrPos + strlen(currFileStr) + 1				currSweepLimitEndPos = strsearch(fileSweepLimitsStr, ";", currSweepLimitStartPos) - 1				Print "fileSweepLimitsStr[currSweepLimitStartPos, currSweepLimitEndPos]",fileSweepLimitsStr[currSweepLimitStartPos, currSweepLimitEndPos]				currNumSweeps = str2num(fileSweepLimitsStr[currSweepLimitStartPos, currSweepLimitEndPos])				Print" num2str(currNumSweeps)", num2str(currNumSweeps)				if (unload)					fd_loadFile(currFileNum)				else					fd_loadFile(currFileNum, bypassLoadCheck=1, maxNumSweeps=currNumSweeps)				endif			else				if (unload)					fd_loadFile(currFileNum)				else					fd_loadFile(currFileNum, bypassLoadCheck=1)				endif			endif		filesLoaded += currFileStr + ";"		endif	endforendfunction cp_analyzeCellParams(rowNum)	Variable rowNum		WAVE/T hsList		String sSep = ",", fSep = ";"		//essentially "inputs" (hs specific, not soma/ped specific)	Variable cellNameCol = 0, isSomaHS1Col = 2, hs1BrkInFileCol = 3, hs1BrkInSweepCol = 4, hs2BrkInFileCol = 5, hs2BrkInSweepCol = 6, fileListCol = 7, chanListCol = 8, chanTypeCol = 9		//INPUT IS VCLAMP COMMAND. OUTPUT IS CURRENT RESPONSE	Variable hs1ChInput = 1, hs1ChOutput = 0, hs2ChInput = 3, hs2ChOutput = 2		//brk in info	Variable somaBrkInFileAndSweepCol = 10		//semi colon delim list: somabrkInFile; somaBrkInSweep;	Variable somaExampleCmdCol = 11	Variable somaSealListForAvgCol =12 		Variable somaSealAvgRefCol = 13			Variable pedBrkInFileAndSweepCol = 14	Variable pedExampleCmdCol = 15				Variable pedSealListForAvgCol = 16				Variable pedSealAvgRefCol = 17					//cell parameters	Variable somaAnalyzedFilesListCol = 18			//analyzedFileList	list of file nums analyzed (semicolon between files	Variable somaAnalyzedSweepsListCol = 19		//analyzedSweepList	list of sweeps analyzed for each file (semi colon between files, comma between sweeps)	Variable somaGenParamsCol = 20				//genParamsList	one for each file that was analyzed. all sweeps 	Variable somaFitParamsCol = 21				//fitParamsList	one for each file that was analyzed	Variable somaCoefWaveCol = 22				//coefWaveList	one for each file that was analyzed		Variable somaDispSweepsList = 23				//dispSweepsList	list of sweep nums saved for display, semicolon between files, if none for a given file then ";;", if multiple for given file then comma delimited	Variable somaDispOrigCurrentsRef	= 24			//origCurrentsDispList	with same organization as last, list of originalCurrentRefs that were saved and can be displayed		Variable somaDispFinCurrentsRef =25			//finCurrentsDispList	final (subtracted, actually used in analysis) currents for display	Variable somaFitListRef = 26					//listOfFitsList	ref to fit saved text wave with list of full fits and components for each wave (can get names of saved fit waves from here)	Variable somaFullFitDispN	=27					//fullFitDispNList	""	Variable somaCmpntsDispN	=28				//compntsDispNList	""	Variable numSomaCellParamsCols = 11			//conversion factor for soma to ped				String fileList = hsList[rowNum][fileListCol]	Variable numFiles = ItemsInList(fileList)	String somaCmdRef = hsList[rowNum][somaExampleCmdCol]	String pedCmdRef = hsList[rowNum][pedExampleCmdCol]	Variable somaBrkInFile =  str2num(StringFromList(0, hsList[rowNum][somaBrkInFileAndSweepCol]))	Variable pedBrkInFile =  str2num(StringFromList(0, hsList[rowNum][pedBrkInFileAndSweepCol]))	Variable somaBrkInSweep =  str2num(StringFromList(1, hsList[rowNum][somaBrkInFileAndSweepCol]))	Variable pedBrkInSweep =  str2num(StringFromList(1, hsList[rowNum][pedBrkInFileAndSweepCol]))	String somaSealFileRef = hsList[rowNum][somaSealAvgRefCol]	String pedSealFileRef = hsList[rowNum][pedSealAvgRefCol]	String chanList = hsList[rowNum][chanListCol]		//iterate through each file, if file num >= brk in file num, then load each sweep > brk in sweep	Variable isSoma = 0, isPed = 1	Variable currFileIndex,  currFileNum, currSweepNum, currNumSweepsInFile, currSomaOutputCh, currPedOutputCh	Variable soma_isVClamp, pedcp_isVClamp , pedBrokenIn, somaBrokenIn	Variable loadSomaSweeps, loadPedSweeps, currSomaSimultaneousClampScore, currPedSimultaneousClampScore	String currChanList	for (currFileIndex = 0; currFileIndex < numFiles; currFileIndex +=1)		currFileNum = str2num(StringFromList(currFileIndex, fileList))		currChanList = StringFromList(currFileIndex, chanList)		loadSomaSweeps = 0; loadPedSweeps = 0		soma_isVClamp = cp_isVClamp(rowNum, currFileIndex, 0)		pedcp_isVClamp = cp_isVClamp(rowNum, currFileIndex, 1)				if (currFileNum >= somaBrkInFile)			if (soma_isVClamp)				loadSomaSweeps = 1			endif		endif		if (currFileNum >= pedBrkInFile)			if (pedcp_isVClamp)				loadPedSweeps = 1			endif		endif		if (!(loadSomaSweeps || loadPedSweeps))			Print "continue occured in cp_analyzeCellParams(). File from before break in listed in hsList fileList?"			continue		endif				currNumSweepsInFile = fd_getSweepNFromFileInfoWave(currFileNum)				for (currSweepNum = 0; currSweepNum < currNumSweepsInFile; currSweepNum +=1)			if (loadSomaSweeps && (currSweepNum > somaBrkInSweep))				pedBrokenIn = ((currFileNum == pedBrkInFile) && (currSweepNum > pedBrkInSweep)) || (currFileNum > pedBrkInFile)				currSomaSimultaneousClampScore = getSimultaneousClampScore(pedcp_isVClamp, pedBrokenIn)				if (currSweepNum == currNumSweepsInFile - 1)			//save last sweep in each file					cp_doCPAnalysis(!isPed, currSomaSimultaneousClampScore, 1, rowNum, currFileIndex, currFileNum, currSweepNum, somaCmdRef,  somaSealFileRef)					Print "(S) display on sweep = " + num2str(currSweepNum)				else					cp_doCPAnalysis(!isPed, currSomaSimultaneousClampScore, 0, rowNum, currFileIndex, currFileNum, currSweepNum, somaCmdRef,  somaSealFileRef)				endif			endif			if (loadPedSweeps && (currSweepNum > PedBrkInSweep))				somaBrokenIn = ((currFileNum == somaBrkInFile) && (currSweepNum > somaBrkInSweep)) || (currFileNum > somaBrkInFile)				currPedSimultaneousClampScore = getSimultaneousClampScore(soma_isVClamp, somaBrokenIn)				if (currSweepNum == currNumSweepsInFile - 1)			//save last sweep in each file					cp_doCPAnalysis(isPed, currPedSimultaneousClampScore, 1, rowNum, currFileIndex, currFileNum, currSweepNum, PedCmdRef,  PedSealFileRef)					Print "(P) display on sweep = " + num2str(currSweepNum)				else					cp_doCPAnalysis(isPed, currPedSimultaneousClampScore, 0, rowNum, currFileIndex, currFileNum, currSweepNum, PedCmdRef,  PedSealFileRef)				endif			endif		endfor		endforendfunction cp_doCPAnalysis(isPed, simultaneousClampScore, saveRawData, rowNum, fileIndex, fileNum,sweepNum, vCmdRef, sealFileRef)	Variable isPed, simultaneousClampScore, saveRawData, rowNum, fileIndex, fileNum, sweepNum; String vCmdRef, sealFileRef		WAVE/T hsList		String sSep = ",", fSep = ";"		//essentially "inputs" (hs specific, not soma/ped specific)	Variable cellNameCol = 0, isSomaHS1Col = 2, hs1BrkInFileCol = 3, hs1BrkInSweepCol = 4, hs2BrkInFileCol = 5, hs2BrkInSweepCol = 6, fileListCol = 7, chanListCol = 8, chanTypeCol = 9		//INPUT IS VCLAMP COMMAND. OUTPUT IS CURRENT RESPONSE	Variable hs1ChInput = 1, hs1ChOutput = 0, hs2ChInput = 3, hs2ChOutput = 2		//brk in info	Variable somaBrkInFileAndSweepCol = 10		//semi colon delim list: somabrkInFile; somaBrkInSweep;	Variable somaExampleCmdCol = 11	Variable somaSealListForAvgCol =12 		Variable somaSealAvgRefCol = 13			Variable pedBrkInFileAndSweepCol = 14	Variable pedExampleCmdCol = 15				Variable pedSealListForAvgCol = 16				Variable pedSealAvgRefCol = 17					//cell parameters	Variable somaAnalyzedFilesListCol = 18			//analyzedFileList	list of file nums analyzed (semicolon between files	Variable somaAnalyzedSweepsListCol = 19		//analyzedSweepList	list of sweeps analyzed for each file (semi colon between files, comma between sweeps)	Variable somaGenParamsCol = 20				//genParamsList	one for each file that was analyzed. all sweeps 	Variable somaFitParamsCol = 21				//fitParamsList	one for each file that was analyzed	Variable somaCoefWaveCol = 22				//coefWaveList	one for each file that was analyzed		Variable somaDispSweepsList = 23				//dispSweepsList	list of sweep nums saved for display, semicolon between files, if none for a given file then ";;", if multiple for given file then comma delimited	Variable somaDispOrigCurrentsRef	= 24			//origCurrentsDispList	with same organization as last, list of originalCurrentRefs that were saved and can be displayed		Variable somaDispFinCurrentsRef =25			//finCurrentsDispList	final (subtracted, actually used in analysis) currents for display	Variable somaFitListRef = 26					//listOfFitsList	ref to fit saved text wave with list of full fits and components for each wave (can get names of saved fit waves from here)	Variable somaFullFitDispN	=27					//fullFitDispNList	""	Variable somaCmpntsDispN	=28				//compntsDispNList	""		Variable numSomaCellParamsCols = 11			//conversion factor for soma to ped	Variable conv = numSomaCellParamsCols * isPed	Variable breakInConv = (pedBrkInFileAndSweepCol - somaBrkInFileAndSweepCol) * isPed	Make/O/N=(numSomaCellParamsCols) cpColsIndex	Make/O/T/N=(numSomaCellParamsCols) newEntries			//sweep information to be added, first row is blank because its about the file	cpColsIndex = p + somaAnalyzedFilesListCol		//used to quickly iterate through columns. cols must remain contiguous (though there can be gap between soma and ped)		//lists associated with this file //	String analyzedSweepList, genParamsList, fitParamsList, coefWaveList, dispSweepsList, dispSealsList,origCurrentsDispList, finCurrentsDispList//	String listOfFitsList, fullFitDispNList, compntsDispNList	//names of inputs/outputs	String indicatorStr	if (isPed)		indicatorStr = "P"	else		indicatorStr = "S"	endif		String currentRef = getHS_Sweep(fileNum, sweepNum, cp_getChanIndex(rowNum, isPed, 0))	String cellName = hsList[rowNum][cellNameCol]	String sealRef = hsList[rowNum][somaSealAvgRefCol + breakInConv] 			//waves that won't be saved directly	String genParamsTempRef = "genParamsTemp_P"		//placeholder, real names used below. Combined into real names at end of file	String compParamsTempRef = "compParamsTemp_P"	String coefWaveTempRef = "coefWaveTemp_P"		String compositNameBase	= fd_getFNameFromFileInfoWave(fileNum ,0) 	+ 	indicatorStr	//for waves that will store info on all sweeps		newEntries[1] = num2str(sweepNum)	newEntries[2] = compositNameBase+ "ccG"		//general (2D)	newEntries[3] = compositNameBase+ "ccF"		//components	(2D)	newEntries[4] = compositNameBase+ "ccC"		//coefs	(2D)		if (saveRawData)		//only passed if waves are to be saved (saveRawData = 1)		String origCurrentRef = currentRef + indicatorStr + "ccO"			//original saved for display, only most recent is saved ( for a given file (?) )		String finCurrentRef = currentRef + indicatorStr  + "ccS"				//subtracted		String fitRef = currentRef + indicatorStr  + "ccF"						//full fit ccF#		String cmpntsAppendStr = "c"								//components are ccF#c#		String fitListRef = currentRef + indicatorStr  + "ccD"				//display		String fullFitDispN = currentRef  + indicatorStr + "ccF"			//full displays		String cmpntsDispRef = currentRef  + indicatorStr + "ccC"		//component displays				newEntries[5] = num2str(sweepNum)		newEntries[6] = origCurrentRef		newEntries[7] = finCurrentRef		newEntries[8] = fitListRef		newEntries[9] = fullFitDispN		newEntries[10] = cmpntsDispRef	else		newEntries[5] = ""		newEntries[6] = ""		newEntries[7] = ""		newEntries[8] = ""		newEntries[9] = ""		newEntries[10] = ""		endif		//handle storage	String analyzedFileList = hsList[rowNum][somaAnalyzedFilesListCol+conv]	Variable analyzedFileIndex = WhichListItem(num2str(fileNum), analyzedFileList)	Variable analyzedSweepIndex	Variable isNewAnalysisFile = (analyzedFileIndex < 0) ? 1 : 0	Variable isNewSweep			//don't have to check for new analysis file, do have to check for old ones		String currList, currSubList, replacementSubList, tempStr	Variable i	if (isNewAnalysisFile)		//if not, add to list and find out its place in order of analyzed files. Add in alphabetical order to keep organized!		analyzedFileList += num2str(fileNum) + ";"		analyzedFileList = SortList(analyzedFileList)			//keeps alphabetaical (could be inserted into the list with better efficiency since known to be pre-sorted)		analyzedFileIndex = WhichListItem(num2str(fileNum), analyzedFileList)			//find new position of new file		hsList[rowNum][somaAnalyzedFilesListCol+conv] = analyzedFileList					//update remaining lists to maintain file order. leave placeholder to add in the info of new sweep		for (i=1;i<DimSize(cpColsIndex, 0);i+=1)			currList = hsList[rowNum][cpColsIndex[i] + conv] 		//semicolon delim			if ((i < 2) || (i > 4))				currSubList = newEntries[i] + sSep			else				currSubList = newEntries[i]			endif			if (i==1)				analyzedSweepIndex = WhichListItem(newEntries[1], currSubList, sSep)			endif			currList = AddListItem(currSubList,  currList, fSep, analyzedFileIndex)			hsList[rowNum][cpColsIndex[i] + conv] = currList		endfor			else			//not a new file, but what we do next depends on if new sweep		newEntries[2] = StringFromList(analyzedFileIndex, hsList[rowNum][somaGenParamsCol + conv])		//confirm that gen params etc. are of expected name		newEntries[3] = StringFromList(analyzedFileIndex, hsList[rowNum][somaFitParamsCol + conv])	 		newEntries[4] = StringFromList(analyzedFileIndex, hsList[rowNum][somaCoefWaveCol + conv])	 		currList = hsList[rowNum][cpColsIndex[1] + conv] 			//full sweeps list		currSubList = StringFromList(analyzedFileIndex, currList)		//get sweep list for this file index		//check if sweep has been analyzed:		analyzedSweepIndex = WhichListItem(newEntries[1], currSubList, sSep)		Print "sublist = " + currSubList		isNewSweep = analyzedSweepIndex < 0 ? 1 : 0		if (isNewSweep)		//add to sweep list, re-sort sweep list to maintain order, then add to all other SUB lists at same position, add each sublist back into their main lists			replacementSubList = currSubList +  newEntries[1] + sSep			replacementSubList = SortList(replacementSubList, sSep)			currList = ReplaceString(currSubList, currList, replacementSubList)			hsList[rowNum][cpColsIndex[1] + conv] = currList			analyzedSweepIndex = WhichListItem(newEntries[1], replacementSubList, sSep)			//iterate through each list and add in proper position. Start at 5 because 2 to 4 are not this type of list and there's only one per file!			for (i=5; i<DimSize(cpColsIndex, 0);i+=1)				currList = hsList[rowNum][cpColsIndex[i] + conv]		//full list				currSubList = StringFromList(analyzedFileIndex, currList)	//sweep list				replacementSubList = AddListItem(newEntries[i], currSubList, sSep, analyzedSweepIndex)				currList = ReplaceString(currSubList, currList, replacementSubList)				hsList[rowNum][cpColsIndex[i] + conv] = currList			endfor		else		//assume that sweep list matches and position is OK, but for all other lists, go in and find whatever is currently stored in SUB list at expected position and replace with what will now be saved			for (i=5; i<DimSize(cpColsIndex, 0);i+=1) // Start at 5 because 2 to 4 are not this type of list and there's only one per file!				currList = hsList[rowNum][cpColsIndex[i] + conv]		//full list				currSubList = StringFromList(analyzedFileIndex, currList)	//sweep list				currSubList = RemoveListItem(analyzedFileIndex, currSubList, sSep)				replacementSubList = AddListItem(newEntries[i], currSubList, sSep, analyzedSweepIndex)				currList = ReplaceString(currSubList, currList, replacementSubList)				hsList[rowNum][cpColsIndex[i] + conv] = currList			endfor		endif		endif		//actual analysis	Variable vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step		//will be set by analysis_cellParams_S_vCmd		analysis_cellParams_S_vCmd(vCmdRef,  vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step)		if (saveRawData)		analysis_cellParams_S2(currentRef, vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step, genParamsTempRef, compParamsTempRef,  coefWaveTempRef, waveToSubRef=sealRef, subbedWaveSaveRef=finCurrentRef, modelSaveRef=fitRef,cmpntntsAppendStr=cmpntsAppendStr, modelsListWaveSaveRef=fitListRef, modelsDispN=fullFitDispN, cmpntntsDispN=cmpntsDispRef)	else		analysis_cellParams_S2(currentRef, vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step, genParamsTempRef, compParamsTempRef,  coefWaveTempRef, waveToSubRef=sealRef, subbedWaveSaveRef=finCurrentRef)	endif		WAVE genParamsTemp_P, compParamsTemp_P, coefWaveTemp_P		//created by analysis_cellPArams_S		Print "analyzedSweepIndex = " + num2str(analyzedSweepIndex)		if (isNewAnalysisFile)		//gen params: convert from one row to one row per wave, each original row now a column		//new file: just make a new gen params wave				Duplicate/O genParamsTemp_P, $newEntries[2]		//duplicate to save loc		MatrixTranspose $newEntries[2]					//flip				Duplicate/O compParamsTemp_P, $newEntries[3]		MatrixTranspose $newEntries[3]				Duplicate/O coefWaveTemp_P, $newEntries[4]			MatrixTranspose $newEntries[4]		else		Duplicate/O $newEntries[2], genParamsRoot		Duplicate/O $newEntries[3], compParamsRoot		Duplicate/O $newEntries[4], coefWaveRoot		if (isNewSweep)			//add new row to each			Insertpoints/M=0 analyzedSweepIndex, 1, genParamsRoot, compParamsRoot, coefWaveRoot		endif					genParamsRoot[analyzedSweepIndex][] = genParamsTemp_P[q]		compParamsRoot[analyzedSweepIndex][] = compParamsTemp_P[q]		coefWaveRoot[analyzedSweepIndex][] = coefWaveTemp_P[q]				Duplicate/O genParamsRoot, $newEntries[2]		Duplicate/O compParamsRoot,	$newEntries[3]		Duplicate/O coefWaveRoot, 	$newEntries[4]	endif	endfunction cp_isVClamp(rowNum, fileIndex, returnForPed)	Variable rowNum, fileIndex, returnForPed		WAVE/T hsList			//essentially "inputs" (hs specific, not soma/ped specific)	Variable cellNameCol = 0, isSomaHS1Col = 2, hs1BrkInFileCol = 3, hs1BrkInSweepCol = 4, hs2BrkInFileCol = 5, hs2BrkInSweepCol = 6, fileListCol = 7, chanListCol = 8, chanTypeCol = 9		//INPUT IS VCLAMP COMMAND. OUTPUT IS CURRENT RESPONSE	Variable hs1ChInput = 1, hs1ChOutput = 0, hs2ChInput = 3, hs2ChOutput = 2		//brk in info	Variable somaBrkInFileAndSweepCol = 10		//semi colon delim list: somabrkInFile; somaBrkInSweep;	Variable somaExampleCmdCol = 11	Variable somaSealListForAvgCol =12 		Variable somaSealAvgRefCol = 13			Variable pedBrkInFileAndSweepCol = 14	Variable pedExampleCmdCol = 15				Variable pedSealListForAvgCol = 16				Variable pedSealAvgRefCol = 17				//cell parameters	Variable somaGenParamsCol = 18			Variable somaFitParamsCol = 19	Variable somaCoefWaveCol = 20					Variable pedGenParamsCol = 21	Variable pedFitParamsCol = 22			Variable pedCoefWaveCol = 23			String outputType = cp_getChanType(rowNum, fileIndex, returnForPed, 0)	String inputType = cp_getChanType(rowNum, fileIndex, returnForPed, 1)		if (stringmatch(outputType,"A") && stringmatch(inputType,"V"))		return 1			//Vclamp	elseif (stringmatch(outputType,"V") && stringmatch(inputType,"A"))		return 0			//Iclamp	else		Print "in cp_isVClamp(), scaling was neither consistent with Iclamp or Vclamp"		return -1			//incorrect scaling or other error	endifendfunction/S cp_getChanType(rowNum, fileIndex, returnForPed, returnInput)	Variable rowNum, fileIndex, returnForPed, returnInput	Variable returnType			//instead returns given input and site units			String sSep = ","	WAVE/T hsList			//essentially "inputs" (hs specific, not soma/ped specific)	Variable cellNameCol = 0, isSomaHS1Col = 2, hs1BrkInFileCol = 3, hs1BrkInSweepCol = 4, hs2BrkInFileCol = 5, hs2BrkInSweepCol = 6, fileListCol = 7, chanListCol = 8, chanTypeCol = 9		//INPUT IS VCLAMP COMMAND. OUTPUT IS CURRENT RESPONSE	Variable hs1ChInput = 1, hs1ChOutput = 0, hs2ChInput = 3, hs2ChOutput = 2		//brk in info	Variable somaBrkInFileAndSweepCol = 10		//semi colon delim list: somabrkInFile; somaBrkInSweep;	Variable somaExampleCmdCol = 11	Variable somaSealListForAvgCol =12 		Variable somaSealAvgRefCol = 13			Variable pedBrkInFileAndSweepCol = 14	Variable pedExampleCmdCol = 15				Variable pedSealListForAvgCol = 16				Variable pedSealAvgRefCol = 17			Variable chanIndex = cp_getChanIndex(rowNum, returnForPed, returnInput)		String chanTypeList = StringFromList(fileIndex, hsList[rowNum][chanTypeCol])		return StringFromList(chanIndex, chanTypeList, sSep)endfunction cp_getChanIndex(rowNum, returnForPed, returnInput)		//0,0 = soma output chan, 0,1 = soma input chan; 1, 0  = pedoutput chan, 1,1 = ped inut chan	Variable rowNum, returnForPed, returnInput	Variable returnType			//instead returns given input and site units		WAVE/T hsList			//essentially "inputs" (hs specific, not soma/ped specific)	Variable cellNameCol = 0, isSomaHS1Col = 2, hs1BrkInFileCol = 3, hs1BrkInSweepCol = 4, hs2BrkInFileCol = 5, hs2BrkInSweepCol = 6, fileListCol = 7, chanListCol = 8, chanTypeCol = 9		//INPUT IS VCLAMP COMMAND. OUTPUT IS CURRENT RESPONSE	Variable hs1ChInput = 1, hs1ChOutput = 0, hs2ChInput = 3, hs2ChOutput = 2		//brk in info	Variable somaBrkInFileAndSweepCol = 10		//semi colon delim list: somabrkInFile; somaBrkInSweep;	Variable somaExampleCmdCol = 11	Variable somaSealListForAvgCol =12 		Variable somaSealAvgRefCol = 13			Variable pedBrkInFileAndSweepCol = 14	Variable pedExampleCmdCol = 15				Variable pedSealListForAvgCol = 16				Variable pedSealAvgRefCol = 17				//cell parameters	Variable somaGenParamsCol = 18			Variable somaFitParamsCol = 19	Variable somaCoefWaveCol = 20					Variable pedGenParamsCol = 21	Variable pedFitParamsCol = 22			Variable pedCoefWaveCol = 23			Variable somaHS1 = stringmatch(hsList[rowNum][isSomaHS1Col],"0")		Variable somaInputCh, somaOutputCh, pedInputCh, pedOutputCh	if (somaHS1)		somaInputCh= hs1ChInput		somaOutputCh = hs1ChOutput		pedInputCh = hs2ChInput		pedOutputCh = hs2ChOutput	else		somaInputCh= hs2ChInput		somaOutputCh = hs2ChOutput		pedInputCh = hs1ChInput		pedOutputCh = hs1ChOutput	endif		if (returnForPed)		if (returnInput)			return pedInputCh		else			return pedOutputCh		endif	else		if (returnInput)			return somaInputCh		else			return somaOutputCh		endif		endif	end//rules: 2 = simultaneous clamp AND broken in; 1 = simultaneous clamp not broken in; -1 = broken in but not clamped; -2 = neither broken in nor clampedfunction getSimultaneousClampScore(isOtherHSInVC, isOtherHSBrokenIn)	Variable isOtherHSInVC, isOtherHSBrokenIn			if (isOtherHSInVC && isOtherHSBrokenIn)		return 2	elseif (isOtherHSInVC)		return 1	elseif (isOtherHSBrokenIn)		return -1	endif		return -2	endfunction fd_showFileLoc(fileNum)	Variable fileNum	WAVE/T fileDirectory		String fullPath = fileDirectory[fileNum][3] +  fileDirectory[fileNum][4] + ":"	NewPath/O/Q tempPath, fullPath	PathInfo/SHOW tempPathendfunction/S getHS_Sweep(fileNum, sweepNum, chNum)	Variable fileNum, sweepNum, chNum		WAVE/T hsList, fileInfoWave		Variable numSweeps = fd_getSweepNFromFileInfoWave(fileNum)	if (sweepNum < 0)		Print "sweep below 0 in getHS_Sweep(). FileNum = " +num2str(fileNum) +  "; MaxNumSweeps = " + num2str(numSweeps) + "; Sweep num = " + num2str(sweepNum) + "; Ch num = " + num2str(chNum)		return ""	endif	if (sweepNum >= numSweeps)		Print "sweep above max num sweeps in getHS_Sweep().  FileNum = " +num2str(fileNum) +  "; MaxNumSweeps = " + num2str(numSweeps) + "; Sweep num = " + num2str(sweepNum) + "; Ch num = " + num2str(chNum)		return ""	endif		String out = getWaveName(fd_getFilePathFromFileDir(fileNum), sweepNum, chNum)//fd_getFNameFromFileInfoWave(fileNum,0)		return outend//file directory-dependent abstracted data-access functionsfunction/S fd_da_getWaveNote_ref(waveRef)	String waveRef		Variable fNum = fd_getFIndexInFileInfoWave(StringFromList(0, getFileNameFromWaveName(waveRef, 0)))		Variable sweepNum = text_getInfoFromWaveName_V(waveRef, 2)	Variable chanNum = text_getInfoFromWaveName_V(waveRef, 3)		return fd_da_getWaveNote(fNum, chanNum, sweepNum)endfunction/S fd_da_getWaveNote(fNum, chanNum, sweepNum)	Variable fNum, chanNum, sweepNum		String fPath = fd_getFilePathFromFileDir(fNum)		return daa_getWaveNote(fPath, chanNum, sweepNum)endfunction/S fd_da_getStrFileInfo_ref(waveRef,option)	String waveRef; Variable option		Variable fNum = fd_getFIndexInFileInfoWave(StringFromList(0, getFileNameFromWaveName(waveRef, 0)))		return fd_da_getStrFileInfo(fNum, option)endfunction fd_da_getNvarFileInfo_ref(waveRef,option)	String waveRef; Variable option		Variable fNum = fd_getFIndexInFileInfoWave(StringFromList(0, getFileNameFromWaveName(waveRef, 0)))		return fd_da_getNvarFileInfo(fNum, option)endfunction/S fd_da_getStrFileInfo(fNum, option)	Variable fNum, option		String fPath = fd_getFilePathFromFileDir(fNum)		return daa_getStrFileInfo(fPath, option)endfunction fd_da_getNvarFileInfo(fNum, option)	Variable fNum, option		String fPath = fd_getFilePathFromFileDir(fNum)		return daa_getNvarFileInfo(fPath, option)end//Abstracted data-access functions: these use data access functions in a somewhat more convenient way//works on unloaded wavesfunction/S daa_getWaveNote(fPath, chanNum, sweepNum)	String fPath; Variable chanNum, sweepNum		da_openABF(fPath)			String out = da_generateOpenFileWaveNote(chanNum, sweepNum, "")		//note does not include wave name as it would as of 12/21/16 for normally loaded waves		da_closeABF()		return outendfunction/S daa_getStrFileInfo(fPath, option)	String fPath		//input any working file path to an abf file	Variable option	//choose output type		da_openABF(fPath)		String out	switch (option)		case 0:			out = da_getOpenFileCreationTime()			break		case 1: 			out = da_getOpenFileComment()			break	endswitch	da_closeABF()		return outendfunction daa_getNvarFileInfo(fPath, option)	String fPath	Variable option		da_openABF(fPath)		Variable out	switch (option)		case 0:			out = da_getOpenFileSweepLen(0)			break		case 1: 			out = da_getOpenFileNumSweeps()			break		case 2:			out = da_getOpenFileNumChans()			break		case 3:			out = da_getOpenFileSampleRate()			break		case 4:			out = da_getOpenFileRecType()			break		case 5:			out = da_getOpenFileRecMode()			break		endswitch	da_closeABF()		return out		end///////////////////////////////////////////////////////////////////////////////////////////Data access-relient functions//not present:  da_makeWaveFromOpenFile(sweepNum, chanNum, nameForWave, isForPreview)//takes in a full file path and opens the abf file stored in that path. Does not check that the file is actually an abf filefunction da_openABF(filePath, [reportFailure])    String filePath    Variable reportFailure        da_closeABF()        //always closes as a precaution           String/G tempPath = filePath; String tempPathVarName = "tempPath"    Variable/G status; String statusVarName = "status"    String cmd        sprintf cmd, "ABFFileOpen %s, %s", tempPathVarName,statusVarName            //open the ABF file for use via the Bruxton add on    Execute cmd            Variable statusTemp = status    //KillVariables/Z status    //KillStrings/Z tempPath        if (!ParamIsDefault(reportFailure))    	if (statusTemp != 0)    		Variable/G status = statusTemp    		String/G msg    		sprintf cmd, "ABFGetStatusText status,msg"    		Execute cmd    		Print "load Failed!!! msg:",msg    		killstrings/Z msg    		killvariables/z status    	endif    endif        return statusTemp            //returns the status value, wihch is non-zero if an error has occuredendfunction da_fd_openABFByFileNum(fNum)	Variable fNum		String fDir = fd_getFilePathFromFileDir(fNum)	da_openABF(fDir)end//attempts to close the currently opened ABF file in the bruxton interface, if one is open function da_closeABF()    String cmd        sprintf cmd, "ABFFileClose"    Execute cmdendfunction da_getSetSweepStartTime()		//function requires that a sweep be already set by da_setOpenFileSweep()	Variable/G status; String statusVarName = "status"	Variable/G absSweepStartTime; String absSweepStartTimeVarName = "absSweepStartTime"		String cmd	sprintf  cmd,"ABFEpisodeGetStart %s, %s", absSweepStartTimeVarName, statusVarName	Execute cmd		Variable absSweepStartTimeTemp = absSweepStartTime	KillVariables/Z status, absSweepStartTime		return absSweepStartTimeTempend    function da_getOpenFileSweepLen(sweepNum)		//setEpisode of 0 or greater will indicate that this function should set the episode itself    Variable sweepNum           if (sweepNum > -1)		//if sweepNum = -1, assumes that other functions have set this value ahead of time   //    	Print "HERE SET sweepNum in da_getOpenFileSweepLen()"    		da_setOpenFileSweep(sweepNum)			//if calling, must call ahead of making global variables for use here because da_setOpenFileSweep() kills them   	 endif        Variable/G status; String statusVarName = "status"    Variable/G sweepLen; String sweepLenVarName = "sweepLen"   	     String cmd    sprintf cmd, "ABFEpisodeGetSampleCount %s, %s", sweepLenVarName, statusVarName    Execute cmd        Variable sweepLenTemp = sweepLen            KillVariables/Z status, sweepLen            return sweepLenTempendfunction da_getOpenFileNumSweeps()    Variable/G status; String statusVarName = "status"    Variable/G numSweeps; String numSweepsVarName = "numSweeps"        String cmd        sprintf cmd, "ABFEpisodeGetCount %s, %s", numSweepsVarName, statusVarName    Execute cmd            Variable numSweepsTemp = numSweeps    KillVariables/Z status, numSweeps    KillStrings/Z statusVarName, numSweepsVarName        return numSweepsTempendfunction da_getOpenFileNumChans()    Variable/G status; String statusVarName = "status"    Variable/G numChans; String numChansVarName = "numChans"        String cmd    sprintf cmd, "ABFChannelGetCount %s, %s", numChansVarName, statusVarName    Execute cmd        Variable numChansTemp = numChans    KillVariables/Z status, numChans    KillStrings/Z statusVarName, numChansVarName            return numChansTempendfunction da_getOpenfileSampleInterval()    Variable/G status; String statusVarName = "status"    Variable/G sampleInterval; String sampleIntVarName = "sampleInterval"        String cmd    sprintf cmd, "ABFFileGetSampleInterval %s, %s",sampleIntVarName,statusVarName    Execute cmd        Variable sampleInterval_temp = sampleInterval        KillVariables/Z status, sampleInterval    KillStrings/Z statusVarName, sampleIntVarName        return sampleInterval_tempend//note: sample rate could change within a file. One might be able to determine whether this change occured using the bruxton macro ABFFileGetSecondInterval.. not currently implementedfunction da_getOpenFileSampleRate()     return 1/da_getOpenfileSampleInterval()endfunction/S da_getOpenFileCreationTime()			//not functioning. Need to test whether this can ever work by hand	Variable/G status; String statusVarName = "status"	String/G timeString; String timeStringVarName = "timeString"			String cmd	sprintf cmd, "ABFFileGetTime %s, %s", timeStringVarName, statusVarName	Execute cmd	String timeStringTemp = timeString	Variable statusTemp = status		KillVariables/Z status	KillStrings/Z timeString			return timeStringTempend//doesnt work, always returns 5000function da_getOpenFileFilterInfo(highPassNotLowPassInfo,chanNum [filterTypeNum,filterTypeStr])	Variable highPassNotLowPassInfo	//pass 1 for high pass info, 0 for low pass info	Variable chanNum		//usually 0 to 3	Variable &filterTypeNum	//to get filter type num as well (automatically received anyway but not returned by this function by default): optionally pass a valid variable reference (pass a number variable, not a number literal, only usable in functions)	String &filterTypeStr		//convert type number to a string with its meaning. does not require passing filterTypeNum	Variable/G da_openFileLPCutoff	Variable/G da_openFileLPStatus	Variable/G da_openFileFilterTypeNum	String/G da_openFileFilterType		String macroStr	if (highPassNotLowPassInfo)		macroStr = "ABFChannelGetFilterHigh"	else		macroStr = "ABFChannelGetFilterLow"	endif		string cmd	sprintf cmd,"%s %d,da_openFileFilterTypeNum,da_openFileLPCutoff,da_openFileLPStatus",macroStr,chanNum	Execute/Z cmd		Variable cutoffTemp = da_openFileLPCutoff			if (!ParamIsDefault(filterTypeNum))		filterTypeNum = da_openFileFilterTypeNum	endif	if (!ParamIsDefault(filterTypeStr))		filterTypeStr = stringfromlist(da_openFileFilterTypeNum,"None;External;Simple;Bessel;Butterworth;")	endif		Print "da_openFileFilterTypeNum",da_openFileFilterTypeNum,stringfromlist(da_openFileFilterTypeNum,"None;External;Simple;Bessel;Butterworth;")		killstrings/Z da_openFileFilterType;killvariables/z da_openFileLPCutoff,da_openFileLPStatus	return cutoffTempend//Clampex adds an unfixed number of points before the start of the first epoch in episodic recording/stimulation mode//the number of points seems to be consistent with a given file length, or maybe total epoch length? never checked//the macro used in this function appears to return that number, based on files where I've measured the delay to the first sweep//one can check that this holds by getting a reconstruction of the stimulus with ABFEpisodeReadStimulus//note that the macro documentation by bruxton appears incorrect//it says the output is in seconds, when it appears to be in points//it also says its the same across episodes (sweeps) and doesnt mention setting the sweep ahead of time, unlike functions involving specific sweeps//however, an error message occurs "no sweep is selected" when a sweep has not been, suggesting a set sweep is required//this value may be the same across all possible stimulus channels (0-3) but I haven't checked for exceptionsfunction da_getOpenFilePreEpisodePoints(stimChanNum,sweepNum)	Variable stimChanNum		//usually between 0-3 for channels 1 to 4	Variable sweepNum			//not sure if a this value actually changes between sweeps, but a sweep must be set for access to use this function		da_setOpenFileSweep(sweepNum)		//note: pass -1 or less to keep access on whatever sweep is already accessed	if (numtype(stimChanNum))		//default to check channel 0 if non-real number was passed, hopefully chan 0 is representative		stimChanNum = 0	endif		Variable/G da_getPreEpPoints_duration	Variable/G da_getPreEpPoints_status		String cmd	sprintf cmd, "ABFHoldingInitialGetDuration %s,da_getPreEpPoints_duration,da_getPreEpPoints_status",num2str(stimChanNum)	//non-integer stimChaNum values could cause issues	execute/Z cmd	variable duration = da_getPreEpPoints_duration	killvariables/z da_getPreEpPoints_duration,da_getPreEpPoints_status		return durationendfunction/S da_getOpenFileComment()		//returns the comment for the file currently open in the Bruxton interface	Variable/G status; String statusVarName = "status"	String/G commentString; String commentStringVarName = "commentString"		String cmd	sprintf cmd, "ABFFileGetComment %s, %s", commentStringVarName, statusVarName	Execute cmd	String commentStringTemp = commentString		KillVariables/Z status	KillStrings/Z commentString		return commentStringTempend function da_getOpenFileRecType()		//returns the recording mode for the file currently open in the Bruxton interface. As far as I can tell will return 3 if gap free and 5 otherwise?	Variable/G status; String statusVarName = "status"	Variable/G recType; String recTypeVarName = "recType"		String cmd	sprintf cmd, "ABFFileGetOperationMode %s, %s", recTypeVarName, statusVarName	Execute cmd	Variable recTypeTemp = recType		KillVariables/Z status, recType		return recTypeTempend function da_getOpenFileRecMode()	//seems not to work, always returns 2 when Bruxton claims it will return one or zero	Variable/G status; String statusVarName = "status"	Variable/G recMode; String recModeVarName = "recMode"			String cmd	sprintf cmd, "ABFFileGetExperimentType %s, %s", recModeVarName, statusVarName	Execute cmd	Variable recModeTemp = recMode		KillVariables/Z status, recMode	return recModeTempend//possibly important pre-check for how stimulus (there are two, numbered 0 or 1) was generated//0 is no stimulus..checking for a stimulus in that case may be causing crashesfunction da_getOpenFileStimSource(chanNum)	Variable chanNum	if ( (chanNum < 0) || (chanNum > 1) )		return 0	endif		Variable/G status,da_stimTypeTempVar	String cmd	sprintf cmd,"ABFStimulusGetSource %u,da_stimTypeTempVar,status",chanNum	execute/q cmd		Variable statusLocal=status,stimTypeLocal=da_stimTypeTempVar	killvariables/z status,da_stimTypeTempVar		return da_stimTypeTempVarend//return stimulus command name e.g., "Cmd 0" or "Cmd 1"//not used by other functions at presentfunction/S da_getOpenFileStimName(chanNum)	Variable chanNum		//must be 0 or 1	if ( (chanNum < 0) || (chanNum > 1) )		return ""	endif		Variable/G status	String/G da_stimNameTempVar	String cmd	sprintf cmd,"ABFStimulusGetName %u,da_stimNameTempVar,status",chanNum	execute/q cmd		Variable statusLocal=status	String stimNameLocal=da_stimNameTempVar	killvariables/z status	killstrings/z da_stimNameTempVar		return stimNameLocalend//EPISODES/SWEEPS Are numbered 1 to N in bruxton, this function is now designed as of 8/9/17 to take 0 to N-1, it adds 1 before a callfunction da_setOpenFileSweep(sweepNum)	Variable sweepNum		sweepNum += 1	//	Print "in ABF Episode set, sweepNum = " + num2str(sweepNum)	    	Variable/G status; String statusVarName = "status"    	    	String cmd    	sprintf cmd, "ABFEpisodeSet %d, %s", sweepNum, statusVarName    	Execute cmd    	    	Variable statusTemp = status    	KillVariables/Z status    	return statusend	function/S da_getOpenFileChanUnits(chanNum)		//returns the units for an input channel number assuming a file is open with the Bruxton interface	Variable chanNum			Variable sweepLenLimitSamples = 50		//no need to load many samples    	    	Variable sweepLen = da_getOpenFileSweepLen(-1)    	if (sweepLen > sweepLenLimitSamples)    		sweepLen = sweepLenLimitSamples    	endif    	    	   	Make/O/D/N=(sweepLen) channelUnitsTempWave; String channelUnitsTempWaveVarName = "channelUnitsTempWave"    	Variable/G status; String statusVarName = "status"    	    		String cmd    	sprintf cmd, "ABFEpisodeRead %d, 0, %d, %s, %s", chanNum, sweepLen, channelUnitsTempWaveVarName, statusVarName		//places ABF sweep into tempWave. literal 0 is the start point   	Execute/Z cmd       	If (V_flag)   		Print "Error flag in getOpneFileChanUnits" + num2str(V_flag)   		Print "Cmd = " + cmd   	endif   	   	   	String chanUnits = WaveUnits(channelUnitsTempWave,1)   	   	KillVariables/Z sweepLen, status   	KillWaves channelUnitsTempWave	return chanUnitsend//newer functionsfunction da_getOpenFileChanDigIn(chanNum)	Variable chanNum		Variable/G status; String statusVarName = "status"	Variable/G digInNum; String digInNumVarName = "digInNum"		//digInNum will store the number of the digital input for this channel		String cmd	sprintf cmd, "ABFChannelGetADC %d, %s, %s", chanNum, digInNumVarName, statusVarName	Execute/Z cmd	if (V_flag)   		Print "Error flag in getOpneFileChanUnits" + num2str(V_flag)   		Print "Cmd = " + cmd   	endif   	   	Variable digInNumTemp = digInNum   	KillVariables/Z status, digInNum   	   	return digInNumTempendfunction/S da_getOpenFileChanName(chanNum)	Variable chanNum		String/G name	Variable/G status		String cmd	sprintf cmd, "ABFChannelGetName %d, %s, %s", chanNum, "name", "status"	Execute cmd	String nameTemp = name	KillVariables/Z $"name", $"status"	return nameTempend//THIS APPEARS TO BE A USELESS OUTPUT THAT DOESNT REFLECT ANYTHING MEANINGFULfunction da_getOpenFileChanLP(chanNum, type_out, cutoff_out)	Variable chanNum	Variable &type_out, &cutoff_out		String typeVarName = "type", cutoffVarName = "cutoff", statusVarName = "status"	Variable/G type, cutoff, status	//stores outputs	String cmd	sprintf cmd, "ABFChannelGetFilterLow %d, %s, %s, %s" chanNum, typeVarName, cutoffVarName, statusVarName	Execute/Z cmd		Variable statusTemp = status	type_out = type	cutoff_out = cutoff		KillVariables/Z type, cutoff, status		return statusTempend//THIS APPEARS TO BE A USELESS OUTPUT THAT DOESNT REFLECT ANYTHING MEANINGFULfunction da_getOpenFileChanHP(chanNum, type_out, cutoff_out)	Variable chanNum	Variable &type_out, &cutoff_out		String typeVarName = "type", cutoffVarName = "cutoff", statusVarName = "status"	Variable/G type, cutoff, status	//stores outputs	String cmd	sprintf cmd, "ABFChannelGetFilterHigh %d, %s, %s, %s" chanNum, typeVarName, cutoffVarName, statusVarName	Execute/Z cmd		Variable statusTemp = status	type_out = type	cutoff_out = cutoff		KillVariables/Z type, cutoff, status		return statusTempend//Use this function as the basis for reading from a wave note; it attempts to function/S fd_note_getStrByKey(waveRef,keyStr, [lastSweepTimingFromAvg])	String waveRef, keyStr; Variable lastSweepTimingFromAvg	//	Print "in fd_note_getStrByKey, waveref, keyStr =", waveRef, keyStr			Variable loadAttempted = 0		String noteStr = note($waveRef)		//special case of average wave looking for last sweep time rather than first	if (!ParamIsDefault(lastSweepTimingFromAvg) && stringmatch(noteStr, "*AVG*") && stringmatch(keyStr, "AVG_LAST_SWEEP_TIME"))		return StringByKey("AVG_LAST_SWEEP_TIME", notestr)	endif		// if an average wave, find first ref used for average, and check the timing for this wave instead//	if (stringmatch(noteStr, "*AVG:*"))//		String findStr = "AVG:"//		Variable firstRefStart = strsearch(noteStr, findStr, 0) + strlen(findStr)//		Variable firstRefEnd = strsearch(noteStr, ",", firstRefStart)//		waveRef =  noteStr[firstRefStart, firstRefEnd-1]//		if (WaveExists($WaveRef))//			noteStr = note($waveRef)//		endif//	endif		//	String errStr = debug_checkRTErrState(msg="Will attempt wave load on wave = " + waveRef)//	//	if (Stringmatch(errStr, "*note*") && Stringmatch(errStr, "*expected wave*"))//		noteStr = fd_da_getWaveNote_ref(waveRef)	//		loadAttempted = 1		//avoids unnecessary second check if stringbykey fails//	endif//	//	String out = StringByKey(keyStr, noteStr)//	//	if (strlen(out) == 0)	//likely did not find key, which will happen for some keys under the new comment format, so try using the new comment format//	//		noteStr = fd_da_getWaveNote_ref(waveRef)	//		noteStr = ReplaceString(": ", noteStr, ":")		//unfortunately earlier form of note had useless annoying spacing; if it's a note of new form none of these are found and the note is left as passed//		noteStr = ReplaceString("; ", noteStr, ";")//		loadAttempted = 1		//avoids unnecessary second check if stringbykey fails//		out = StringByKey(keyStr, noteStr)	//	endif	//	Print "in fd_note_getStrByKey. waveRef = " + waveRef + ". Note = " + NoteStr + ". output of stringbykey = " + out	return StringByKey(keyStr, notestr)endfunction/S fd_note_getWaveTimeStr(waveRef, includeSweepTime, [lastSweepTimingFromAvg])	String waveRef;Variable includeSweepTime		//returns a second string value (semi-color delimited list) [fileTimeStr];[sweepTimeStr, a number with units of seconds];. Otherwise just the former with no semi-colon	Variable lastSweepTimingFromAvg		//pass in special case of average wave where you'd like the tming of the last sweep rather than the first. Could mplement similar handling of file timing but havent had need yet	if (!strlen(waveRef) || !WaveExists($waveRef) )		return ""	endif	String out  = fd_note_getStrByKey(waveRef, "FILE_TIME")	if (includeSweepTime)		if (!ParamIsDefault(lastSweepTimingFromAvg))			out +=  ";" +  fd_note_getStrByKey(waveRef,"AVG_LAST_SWEEP_TIME", lastSweepTimingFromAvg=1)	+ ";"	//keyStr of sweep_time will be superceded in fd_note_getStrByKey		else			out += ";" + fd_note_getStrByKey(waveRef, "SWEEP_TIME") + ";"		endif	endif			return outendfunction/S fd_note_getChanStr(waveRef)		//da_l_ specifies functions for waves loaded from (GB's) data access functions)	String waveRef		return fd_note_getStrByKey(waveRef, "CH_NAME") endfunction da_l_getChanNumFromWaveName(waveRef)	String waveRef		return text_getInfoFromWaveName_V(waveRef, 3)	//	String findStr = "AD"			//OLD VERSION//	Variable pos = strsearch(waveRef, findStr, 0)//	//	if (pos < 0)//		return -1//	endif//	pos += strlen(findStr)//	return str2num(waveRef[pos])endfunction da_l_getSweepNumFromWaveName(waveRef)	String waveRef	text_getInfoFromWaveName_V(waveRef, 2)endfunction da_l_getFileNumFromWaveName(waveRef)	String waveRef	text_getInfoFromWaveName_V(waveRef, 1)end		//add channel digital input display to fileInfoWave, in case fileInfoWave predates this function. Make sure file paths are up to date or this will failfunction fd_updateChannelDisplays()	NVAR  numNonChanFileInfoWaveCols		WAVE/T fileInfoWave	String currChanString	Variable fileNum, chanNum	for (fileNum=0;fileNum<DimSize(fileInfoWave,0);fileNum+=1)		for (chanNum=0; chanNum< fd_getChanNFromFileInfoWave(fileNum);chanNum+=1)			currChanString = fileInfoWave[fileNum][numNonChanFileInfoWaveCols+chanNum]			da_openABF(fd_getFilePathFromFileDir(fileNum))			currChanString +=  num2str(da_getOpenFileChanDigIn(chanNum))			fileInfoWave[fileNum][numNonChanFileInfoWaveCols+chanNum] = currChanString		endfor	endfor	//update size of filePanel listbox to account for added length (not sure this is still needed?)	ListBox fileListBox widths={22,30,95,112,38,30,20,15,25},  win=filePanel	end//scans through the string saving the units and digital input number for each channel, returning a string list with the set of channel numbers that use that digital inputfunction fd_getChanNumForDigIn(fileNum, digInNum)	Variable fileNum, digInNum		Variable numChans = fd_getChanNFromFileInfoWave(fileNum)		String out = ""		Variable i; String placeholder, currChanStr 		//latter will store channel string without selection indicator	Variable currDigInNum	for (i=0;i<numChans;i+=1)		currChanStr = fd_getChanStrFromFileInfoWave(fileNum, i, 1)		sscanf currChanStr, "%[^1234567890]", placeholder		//this method avoids trouble with digital channel #11 matching channel #1 if using for example string match by finding only the non-digit portion, then removing that portion, then converting remainder to a num (next 2 lines)		currChanStr = currChanStr[strlen(placeholder),Inf]		currDigInNum = str2num(currChanStr)		if (currDigInNum == digInNum)			out += num2str(i) + ";"		endif	endfor		switch (ItemsInLisT(out))		case 0:			return -1		case 1:			return str2num(stringfromlist(0,out))		default:		//more than one			return -2	endswitchend//returns a reversed version of a strngfunction/S text_stringReverse(inStr)	String inStr		//String outStr = inStr	String outStr = ""		Variable i	for (i=0;i<strlen(inStr);i+=1)		//outStr[i] = inStr[strlen(inStr)-1-i,strlen(inStr)-1-i]		outStr += inStr[strlen(inStr)-1-i,strlen(inStr)-1-i]	endfor		return outStrendfunction/S text_listReverse(inList)	String inList		String outList = ""	Variable i, numItems = ItemsInList(inList)		for (i=numItems-1;i>-1;i-=1)		outList += StringFromList(i, inList) + ";"	endfor		return outList	endfunction/S fd_getChanStrFromFileInfoWave(fileNum, chanNum, removeIndicatorStrIfPresent)	Variable fileNum, chanNum, removeIndicatorStrIfPresent		NVAR  numNonChanFileInfoWaveCols		WAVE/T fileInfoWave		String out  =  fileInfoWave[fileNum][numNonChanFileInfoWaveCols+chanNum]		if (removeIndicatorStrIfPresent)		out = fd_removeIndicatorString(out)	endif		return outendfunction/S fd_getChanDigInFromFileInfoWave(fileNum, chanNum)	Variable fileNum, chanNum		String chanStr = fd_getChanStrFromFileInfoWave(fileNum, chanNum, 1)	String out = chanStr[0]		return outendfunction fd_getChanNumFromFileInfoWave(fileNum, chanNum)	Variable fileNum, chanNum		String chanStr = fd_getChanStrFromFileInfoWave(fileNum, chanNum, 1)		chanStr = chanStr[1,inf]		return str2num(chanStr)endfunction/S fd_removeIndicatorString(inStr)	String inStr		SVAR selectionIndicatorString			if (stringmatch(inStr, "*" + selectionIndicatorString + "*"))		inStr = inStr[strlen(selectionIndicatorString), Inf]		//removes selection indicator string region	endif		return inStrendfunction/S fd_getFilePathFromFileDir(fileNum)	Variable fileNum		WAVE/Z/T fileDirectory		if (WAVEExists(fileDirectory))		if (numtype(fileNum) || (fileNum>=dimsize(fileDirectory,0)))			print "fd_getFilePathFromFileDir() error, fileNum",fileNum,"out of range of filedirectory, aborting!"			return ""		endif					string a = fileDirectory[fileNum][0]				return a	else		Print "Error in call to fd_getFilePathFromFileDir(). Failed to find fileDirectory!"		return ""	endifend//ACTION BUTTONS//selects all files in the file Sel Listfunction guiC_selList_selectAllFiles(ctrlName) : ButtonControl    	String ctrlName  	  	WAVE fileSelList    	fileSelList = 1    	updateSelListByNums(nameOfWave(fileSelList), "fileSelListByNums")		//updates selection list for filesend//selects subset of files between first and last selection function guiC_SL_selectInclFileSubset(ctrlName) : ButtonControl    	String ctrlName		WAVE fileSelListByNums, fileSelList	selectInclusiveSubsetG(nameOfWave(fileSelList), nameOfWave(fileSelListByNums)) //function is saved in Proc_ItemHandlingend//selects subset of sweeps between first and last selection function guiC_SL_selectInclSweepSubset(ctrlName) : ButtonControl    	String ctrlName    	    	WAVE sweepSelList, sweepSelListByNums    	selectInclusiveSubsetG(nameOfWave(sweepSelList), nameOfWave(sweepSelListByNums))	//function is saved in Proc_ItemHandlingend//selects all channels in channel list boxfunction fd_selectAllChannels(BStruct) : ButtonControl   	 STRUCT WMButtonAction &BStruct    	If (BStruct.eventCode != 1)  //only continues if mouse down    		return 0    	endif        	WAVE chanSelList    	chanSelList = 1end//selects all sweeps in sweeps list boxfunction fd_selectAllSweeps(BStruct) : ButtonControl   	 STRUCT WMButtonAction &BStruct    	If (BStruct.eventCode != 1)  //only continues if mouse down    		return 0    	endif        	WAVE sweepSelList	sweepSelList = 1		 updateSelListByNums(nameOfWave(sweepSelList), "sweepSelListByNums")								//passes the wave reference to this wave into a function that updates the selection list for any list box and copies it into the passed wave refend//tries to kill eveything related to ABF loader. May need updatingfunction da_closeabfLoadPanel(BStruct) : ButtonControl   	 STRUCT WMButtonAction &BStruct    	If (BStruct.eventCode != 1)  //only continues if mouse down    		return 0    	endif    	      if (WinType("filePanel") != 0)        	KillControl/W=filePanel fileListBox        	KillControl/W=filePanel channelSelBox        	KillControl/W=filePanel sweepListBox    		KillWindow filePanel    	endif    	    	Variable i	WAVE/T fileSweepListDir	killWavesInListGeneral("fileSweepListDir",1)	killabfLoadGeneratedWaves(2)	//kills all abf loader generated waves    	    	KillWaves/Z fileSelList,fileDirectory,fileSweepListDir,fileInfoWave,fileInfoWaveColumnTitles, sweepListWaveTitles,chanSelList,chanSelWaveTitles, chanSelListTitles    	KillWaves/Z fileSelListByNums, sweepSelList, sweepSelListByNums, sweepsPreviewListFileOrder, sweepsPreviewList    	KillVariables/Z maxChanNum, numNonChanFileInfoWaveCols    	KillStrings/Z titleBoxString    	da_closeABF()end///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////UPDATE FUNCTIONS////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////General functions for loading and working with ABFsfunction/S fd_getFLoadStrInFileInfoWave(fileNum)	Variable fileNum		Variable relevantCol = 2;		WAVE/T fileInfoWave	if ( (fileNum < 0) || (fileNum >= dimsize(fileInfoWave,0)) ) 		return ""	endif		return fileInfoWave[fileNum][0]endfunction/S fd_getFNameFromFileInfoWave(fileNum ,cellNameOnly)	Variable fileNum, cellNameOnly		Variable relevantCol = 2;		WAVE/T fileInfoWave		if (cellNameOnly > 0)		String temp = fileInfoWave[fileNum][relevantCol]		return StringFromList(0,temp,"_")	//cuts out "_" and beyond	endif		return fileInfoWave[fileNum][relevantCol]endfunction/S fd_getRecStartTFromFileInfoWave(fileNum)		Variable fileNum	Variable relevantCol = 3		WAVE/T fileInfoWave		if ( (fileNum < 0) || (fileNum >= dimsize(fileInfoWave,0)) ) 		return ""	endif	return fileInfoWave[fileNum][relevantCol]endfunction fd_getSRateFromFileInfoWave(fileNum)		Variable fileNum	Variable relevantCol = 4		WAVE/T fileInfoWave	if ( (fileNum < 0) || (fileNum >= dimsize(fileInfoWave,0)) ) 		return 0	endif	return str2num(fileInfoWave[fileNum][relevantCol])endfunction fd_getLenSFromFileInfoWave(fileNum)	Variable fileNum		Variable relevantCol = 5		WAVE/T fileInfoWave	if ( (fileNum < 0) || (fileNum >= dimsize(fileInfoWave,0)) ) 		return 0	endif	return str2num(fileInfoWave[fileNum][relevantCol])endfunction fd_getSweepNFromFileInfoWave(fileNum)		//this is more efficient than the by file analogue of the function	Variable fileNum		Variable relevantCol = 6		WAVE/T fileInfoWave	if ( (fileNum < 0) || (fileNum >= dimsize(fileInfoWave,0)) ) 		return 0	endif	return str2num(fileInfoWave[fileNum][relevantCol])endfunction fd_getChanNFromFileInfoWave(fileNum)		//gives the number of channels for a file based on info stored in fileInfoWave. If file info wave structure is altered, this function must be altered!	Variable fileNum		Variable relevantCol = 7		WAVE/T fileInfoWave	if ( (fileNum < 0) || (fileNum >= dimsize(fileInfoWave,0)) ) 		return 0	endif		return str2num(fileInfoWave[fileNum][relevantCol])endfunction fd_getFileInfoWaveMaxChanN()	NVAR numNonChanFileInfoWaveCols	WAVE/T fileInfoWave		return DimSize(fileInfoWave,1) - numNonChanFileInfoWaveColsendfunction fd_isChanSelected(fileNum, chanNum)		//returns 1 if a given channel number for a given file is selected (bold in fileInfoWave) or 0 if it is not	Variable fileNum, chanNum		WAVE/T fileInfoWave		if (fileNum >= dimsize(fileinfowave,0))		return 0	endif		NVAR/Z numNonChanFileInfoWaveCols	if (!NVAR_Exists(numNonChanFileInfoWaveCols))		VAriable/G numNonChanFileInfoWaveCols = 8	endif		String chanString = fileInfoWave[fileNum][numNonChanFileInfoWaveCols+chanNum]		SVAR selectionIndicatorString	return stringmatch(chanString,"*" + selectionIndicatorString + "*")endfunction fd_getNumSelectedChans(fileNum)	Variable fileNum		return ItemsInList(fd_getChanSelectionList(fileNum,1))end//returns list of 0s or ones depending on whether each channel for a file is selectedfunction/S fd_getChanSelectionList(fileNum,doByNumbersNotOrder)	Variable fileNum, doByNumbersNotOrder	Variable numTotalChans = fd_getChanNFromFileInfoWave(fileNum)	Variable i	String outputByOrder = "", outputByNumbers = ""	for (i=0;i<numTotalChans;i+=1)		if (fd_isChanSelected(fileNum,i))			outputByOrder += "1;"			outputByNumbers += num2str(i) + ";"		else			outputByOrder += "0;"		endif	endfor		if (doByNumbersNotOrder)		return outputByNumbers	endif			return outputByOrderendfunction fd_getChanSelectionBitwise(fileNum,[waveNameList])	Variable fileNum	String waveNameList		//optionally pass a list of wave names; instead of looking at file Panel for selections,will return a bitwise that includes the channels these waves represent	Variable out = 0	Variable numTotalChans = fd_getChanNFromFileInfoWave(fileNum)	Variable i	Variable noWaveNameList=ParamIsDefault(waveNameList) || (itemsinlist(waveNameList) < 1)		if (noWaveNameList)		//default		for (i=0;i<numTotalChans;i+=1)			if (fd_isChanSelected(fileNum,i))				out += 2^i			endif		endfor	else		out=0		//all bits off		Variable isCorrectFile,numWaves=itemsinlist(waveNameList),waveFileNum,waveChanNum,validChan		String name		for (i=0;i<numWaves;i+=1)			name=stringfromlist(i,waveNameList)			waveFileNum=fd_getFIndexInFileInfoWave(text_getInfoFromWaveName_S(name, 9))			isCorrectFile=waveFileNum==fileNum			if (isCorrectFile)				waveChanNum=text_getInfoFromWaveName_V(name,3)				validChan = waveChanNum < numTotalChans				if ( validChan && ( (out & 2^waveChanNum) < 1) )		//valid channel with its bit not set, then set it					out+=2^waveChanNum			//set bit				endif			endif		endfor		endif		return outendfunction fd_setChanSelsBitwise(fileNum,bitVar)	Variable fileNum,bitVar		Variable numChans=fd_getChanNFromFileInfoWave(fileNum),i,select	for (i=0;i<numChans;i+=1)		select = ( (bitVar & 2^i) > 0 )		fd_setChanSelected(fileNum,i,select)	endfor		end//takes in a file number, channel number, and boolean. If passed boolean is true, passed channel number of passed file number is "Selected"//"Selected" means that bold escape character is appended before the channel reference function fd_setChanSelected(fileNum,chanNum,setToSelected)	Variable fileNum,chanNum,setToSelected		SVAR selectionIndicatorString			//string used to indicate selection, e.g. \f01	WAVE/T fileInfoWave	NVAR numNonChanFileInfoWaveCols		String selectedString = selectionIndicatorString	String currentChanString = fileInfoWave[fileNum][numNonChanFileInfoWaveCols+chanNum]	if (setToSelected > fd_isChanSelected(fileNum,chanNum)) //then channel is not selected and needs to be selected		currentChanString = selectedString + currentChanString 	elseif (setToSelected < fd_isChanSelected(fileNum,chanNum))	//then channel is selected and need to be unselected		currentChanString = currentChanString[strlen(selectedString),strlen(currentChanString)]	//takes portion of currentChanString that is after the selection string	endif		//does nothing to currentChanString if setToSelected == fd_isChanSelected	fileInfoWave[fileNum][numNonChanFileInfoWaveCols+chanNum] = currentChanString		fd_syncFile(fileNum)		//keeps up to date if loadedendfunction setUserAddedNote(userNote)	String userNote		String/G userAddedNote = userNote + ";"endfunction setUserAddedNoteOff()	KillStrings/Z userAddedNoteendfunction addToMasterWaveList(waveRefName, isForPreview)	String waveRefName; Variable isForPreview		String listDelimiter = ";"		if (isForPreview)		//add only to preview list		SVAR/Z masterPreviewWaveList		if (!svar_exists(masterPreviewWaveList)) //instanteate global string from preview list if not already existing			String/G masterPreviewWaveList = ""		endif		if (FindListItem(waveRefName, masterPreviewWaveList, listDelimiter)==-1)		//if true, waveRef is not already in list			masterPreviewWaveList = AddListItem(waveRefName, masterPreviewWaveList, listDelimiter)		endif	else 		SVAR/Z masterWaveList		if (!svar_exists(masterWaveList)) //instanteate global string from preview list if not already existing			String/G masterWaveList = ""		endif		if (FindListItem(waveRefName, masterWaveList, listDelimiter)==-1)		//if true, waveRef is not already in list			masterWaveList = AddListItem(waveRefName, masterWaveList, listDelimiter)		endif	 	endifend//Kills loaded waves. 0 = all waves, 1 = preview waves, 2 = only actual file selection loaded waves (loaded by GUI button)//when whichWaves = 1, will save preview waves that have been loaded by file selectionfunction killabfLoadGeneratedWaves(whichWaves)	Variable whichWaves	String listDelimiter = ";"	SVAR/Z masterPreviewWaveList, masterWaveList	Variable masterWaveListExists = SVAR_Exists(masterWaveList)	Variable masterPreviewWaveListExists = SVAR_Exists(masterPreviewWaveList)		Variable i		if (whichWaves == 0)		if (masterWaveListExists)			for (i=0;i<ItemsInList(masterWaveList, listDelimiter);i+=1)				Print "Killing wave = " + StringFromList(i,masterWaveList,listDelimiter)				KillWaves/Z $StringFromList(i,masterWaveList,listDelimiter)			endfor			masterWaveList = ""		endif		if (masterPreviewWaveListExists)			for (i=0;i<ItemsInList(masterPreviewWaveList, listDelimiter);i+=1)				KillWaves/Z $StringFromList(i,masterPreviewWaveList,listDelimiter)			endfor			masterPreviewWaveList = ""		endif			endif	if ((whichWaves == 1) && masterPreviewWaveListExists)		if (masterWaveListExists && ItemsInList(masterWaveList, listDelimiter) > 0)			//see if any waves have been loaded			String currentPreviewRef			for (i=0;i<ItemsInList(masterPreviewWaveList, listDelimiter);i+=1)				currentPreviewRef = StringFromList(i,masterPreviewWaveList,listDelimiter)				if (FindListItem(currentPreviewRef, masterWaveList, listDelimiter) == -1)		//check to see if wave has been "actually" loaded					KillWaves/Z $StringFromList(i,masterPreviewWaveList,listDelimiter)					masterPreviewWaveList = RemoveFromList(currentPreviewRef, masterPreviewWaveList, listDelimiter)				endif			endfor		else			for (i=0;i<ItemsInList(masterPreviewWaveList, listDelimiter);i+=1)				KillWaves/Z $StringFromList(i,masterPreviewWaveList,listDelimiter)			endfor			masterPreviewWaveList = ""		endif	endif		if ((whichWaves == 2) && (masterWaveListExists))		for (i=0;i<ItemsInList(masterWaveList, listDelimiter);i+=1)			Print "Killing wave = " + StringFromList(i,masterWaveList,listDelimiter)			KillWaves/Z $StringFromList(i,masterWaveList,listDelimiter)		endfor		masterWaveList = ""	endif			endfunction fd_normalizeSetSweepStartTime(waveRefName)		//a function that takes in a wave reference for a wave correspdonding to the set episode in the bruxton interface and adjusts the timebase so that the sweep starts at 0	String waveRefName		wave wv=$waveRefName	Variable currentWaveStartX = pnt2x(wv,0)	Variable absoluteWaveStartX = da_getSetSweepStartTime()	Variable relativeWaveStartX = currentWaveStartX - absoluteWaveStartX	SetScale/P x, relativeWaveStartX, DimDelta(wv, 0), WaveUnits(wv,0), wvendfunction fd_downsampleIfNeeded(waveRefName)	String waveRefName		SVAR/Z fd_downSampleStr	if (!Svar_exists(fd_downSampleStr) || (strlen(fd_downSampleStr) < 1) )		return 0	endif		String noteStr=note($waveRefName)	Variable prevDownSampleRate=str2num(stringbykey("fd_downsampleIfNeeded_dsRate",notestr))	if (numtype(prevDownSampleRate)==0)		//real number, so has been downsampled .. would want to reload original wave rather than re-downsampling a downsampled wave, so never re-apply		return 0	endif			Variable tol=0.4		//rate equality tolerance (in Hz) to avoid float point issue (not certain its a concern but just in case)	Variable wvRate=1/dimdelta($waveRefName,0)	Variable i,numRules=itemsinlist(fd_downSampleStr)	string rule,ruleOrigRateStr,ruleNewRateStr	Variable ruleOrigRate,ruleNewRate,downSampleFactor	for (i=0;i<numRules;i+=1)		rule=stringfromlist(i,fd_downSampleStr)		ruleOrigRateStr=stringfromlist(0,rule,",")		ruleOrigRate=str2num(ruleOrigRateStr)		if ( abs(ruleOrigRate-wvRate) < tol)			ruleNewRateStr=stringfromlist(1,rule,",")			ruleNewRate=str2num(ruleNewRateStr)			downSampleFactor = wvRate / ruleNewRate		//e.g. 3 leaves only every 3rd pnt			if (downSampleFactor > 1)				resample/down=(downSampleFactor) $waveRefName				noteStr=replacestringbykey("fd_downsampleIfNeeded_dsRate",noteStr,ruleNewRateStr)				noteStr=replacestringbykey("fd_downsampleIfNeeded_recRate",noteStr,num2str(wvRate))				note/k/nocr $waveRefName,noteStr			endif		endif	endforend//this function returns the appropriate name for a given wave, which is currently [file name]_[sweepNum + 1]_AD[chanNum]function/S getWaveName(filePath, sweepNum, chanNum)	String filePath; Variable sweepNum, chanNum		String waveNameTemp = getSweepName(filePath, sweepNum) + "_" + "AD" + num2str(chanNum)		return waveNameTempend//this function returns the appropriate name for a given sweep, which is currently [file name -- as set by that get function]_[sweepNum+1]function/S getSweepName(filePath, sweepNum)		//adds one for consistancy with Bruxton GUI ABF loader	String filePath; Variable sweepNum		String sweepNameTemp = getFileNameFromPath(filePath) + "_" + num2str(sweepNum+1)		return sweepNameTempend//this function returns the name of a file from a file path by returning the text between the last colon and the last period sifunction/S getFileNameFromPath(filePath)        //may have to alter with mis-named files!    String filePath        Variable fileNameFirstPos = strsearch(filePath,":",strlen(filePath)-1,3) + 1		//searches backwards through filePath to find position of last colon, adds one to give first character of file name    Variable fileNameLastPos = strsearch(filePath,".",strlen(filePath)-1,3) - 1		//searches backwards to find last period, subtracts one to get last character position        return filePath[fileNameFirstPos,fileNameLastPos]end//ignores channel and sweep selections unless selectedNotAll==1function/S fd_getFileSweepNames(fileNum,selectedNotAll)	Variable fileNum,selectedNotAll		STring chans=""	Variable numChans,i	if (selectedNotAll)		chans=fd_getChanSelectionList(fileNum,0)			numChans=itemsinlist(chans)	else		numChans=fd_getChanNFromFileInfoWave(fileNum)		chans=text_getRepeatedStr("1;",numChans)	endif		string out="",chanSelStr	for (i=0;i<numChans;i+=1)		chanSelStr=stringfromlist(i,chans)		if (!selectedNotAll || stringmatch(chanSelStr,"1"))			out+=fd_getFileChanSweepNames(fileNum,i,selectedNotAll)		endif	endfor	return outendfunction/S fd_getFileChanSweepNames(fileNum, chanNum,selectedNotAll)	Variable fileNum, chanNum,selectedNotAll		Variable numSweeps = fd_getSweepNFromFileInfoWave(fileNum)	String out = ""	Variable i		if (selectedNotAll)		String selSweepNums=fd_getSelSweepsListByNums(fileNum)		Variable numSel=itemsinlist(selSweepNums)		for (i=0;i<numSel;i+=1)			out += fd_getWaveLoadName(fileNum, str2num(stringfromlist(i,selSweepNums)), chanNum)+ ";"		endfor	else		for (i=0;i<numSweeps;i+=1)			out += fd_getWaveLoadName(fileNum, i, chanNum)+ ";"		endfor	endif		return outendfunction/S wave_listFromWin(matchStr)	String matchStr	String winN=winname(0,1)		//top graph .. not table etc.	return sortlist(wavelist(matchStr, ";","WIN:"+winN),";",16)		//sorts from low numbers to highest and works well with wave namesendfunction/S wave_cat1DFromWin(matchStr,doSort,outRef)	String matchStr	String outRef	//store result here	Variable doSort	//pass to alphanumerically sort list of waves to cat: helps get sweeps in order, though it may not work for multi-digit sweep numbers		String list = wave_listFromWin(matchStr)	list = sortlist(list)		variable i,num=itemsinlist(list)	concatenate/np=0/dl/o list, $outRef	note/nocr $outref, "wave_cat1DFromWin_list:"+replaceString(";",list,"|")+";"	return listendfunction/s gcs(chanNum,sweepNum)	Variable chanNum	Variable sweepNum	//sweep num starting from 0!		String list = gcl(chanNum)	String matchStr = "*_" + num2str(sweepNum+1) + "_AD"+num2str(chanNum) + "*"	list = listmatch(list, matchStr)	return stringfromlist(0,list)endfunction/S gcl(chanNum)	Variable chanNum		String matchStr = gc_matchStr(chanNum)		return wave_listfromwin(matchStr)end//fast call to wave_avgFromWin .. gc stands for get channel//will use default namingfunction/S gc(chanNum,[outRef,allStats,startX,endX,bsx,bex,np])	Variable chanNum	STring outRef		//optionally pass a name to store average in; otherwise it is automatically generated (for waves from filePanel or following the standard naming scheme)	Variable allStats	//optionally pass true for a wave containing all stats for each point that is averaged (e.g., sem)	Variable startX,endX		//optionally specify a range for averaging (all waves must have the same length or contain this range; in either case must have same sampling!)	Variable bsx,bex			//optionally specify a baseline average window [ONLY SUPPORTED FOR allStats=1 AT PRESENT] 	Variable np		//suppress printing of output wave name		Variable noPrint = !paramIsDefault(np) && np	Variable doAllStats=!paramisDefault(allStats) && allSTats	Variable usedStartX=ParamIsDefault(startX) ? nan : startX	Variable usedEndX=PAramIsDefault(endX) ? nan : endx	Variable usedBsx=PAramIsDefault(bsx) ? nan : bsx	Variable usedBex=PAramIsDefault(bsx) ? nan : bex	String matchStr = gc_matchStr(chanNum)	if (strlen(matchStr))		return wave_avgFromWin(matchStr,selectstring(ParamIsDefault(outRef),outRef,""),doAllStats,usedStartX,usedEndX,bsx=usedBsx,bex=usedBex,np=noPrint)	endif		return ""end//get match strings for channel numbersfunction/S gc_matchStr(chanNum)	Variable chanNum		if ( numtype(chanNum) || (chanNum < 0) )		return ""	endif			return "*AD" + num2str(chanNum)end//(fa) preferred wave average function as of May 2016function/S wave_avgFromWin(matchStr, outputRef,allStats,startX,endX[bsx,bex,np])	String matchStr, outputRef	Variable allStats  //pass true for a wave containing all stats for each point that is averaged (e.g., sem)	VAriable startx,endx		//range for average	Variable bsx,bex			//optionally specify a baseline average window [ONLY SUPPORTED FOR allStats=1 AT PRESENT] 	Variable np		//optionally suppress printing output		Variable noPrint = !paramisdefault(np) && np		Variable usedBsx=PAramIsDefault(bsx) ? nan : bsx	Variable usedBex=PAramIsDefault(bsx) ? nan : bex	String list = wavelist(matchStr, ";","WIN:"+winname(0,1))		return wave_avgFromStrList(list, ";",outputRef,allStats,startX,endX,bsx=usedBex,bex=usedBex,np=noPrint)endfunction wave_avgFromStrList_simple(list)	string list		Double avg=0	Variable i,num=itemsinlist(list)	string ref	for (i=0;i<num;i+=1)		ref=stringfromlist(i,list)		avg+=mean($ref)	endfor		avg/=num		return avgend//(fa) preferred wave average function as of May 2016//preserves wave note, appends list of waves avg'd to note, and auto generates a sensible name if outputRef is ""//all waves should have same range or contain startx,endxfunction/S wave_avgFromStrList(strListOfWavesToAvg,delimiterStr, outputRef, allStats,startX,endX,[killAfterAvg, loadViaFD,np,bsx,bex,normalize])	String strListOfWavesToAvg,delimiterStr, outputRef	Variable killAfterAvg			//optionally kill the list of original waves after averaging. Helpful when averaging from unloaded waves	Variable loadViaFD			//will attempt to via file directory index in case wave doesn't exist. If ==2, then loads regardless of whether it already exists	Variable np		//optionally pass to suppress printing	Variable allStats  //pass true for a wave containing all stats for each point that is averaged (e.g., sem)	VAriable startx,endx		//range for average	Variable bsx,bex			//optionally specify a baseline average window [ONLY SUPPORTED FOR allStats=1 AT PRESENT] 	Variable	normalize	//with allSTats=1, pass this to pre-normalize waves to their peak befre averaging		if (itemsinlist(strListOfWavesToAvg) < 1)		return ""	endif		Variable doNorm = !paramISDefault(normalize) && normalize		Variable usedBsx=PAramIsDefault(bsx) ? nan : bsx	Variable usedBex=PAramIsDefault(bsx) ? nan : bex			if (strlen(delimiterStr) == 0)		delimiterStr = ";"	endif	String ref = StringFromList(0, strListOfWavesToAvg, delimiterStr)		//grab an example	if (numtype(startX)>0)		startx=dimoffset($ref,0)	endif	if (numtype(endX)>0)		//Variable pnts=dimsize($ref,0)		//endx=pnt2x($ref,pnts-1)		//end at last point		endx=inf		//should be fine	endif		Variable noInputName = 0	if (strlen(outputRef) == 0)		outputRef = getWaveNameBySweeps( StringFromList(0, strListOfWavesToAvg, delimiterStr),StringFromList(ItemsInList(strListOfWavesToAvg,delimiterStr)-1, strListOfWavesToAvg, delimiterStr))		noInputName = 1	endif		if (allStats)		//call function that uses wave stats etc to compute many things		Variable startRow=x2pnt($ref,startX),endRow=x2pnt($ref,endX)		if (!stringmatch(delimiterStr,";"))		//wave_colStats expects ";" delim			strListOfWavesToAvg=replacestring(delimiterStr,strListOfWavesToAvg,";")		endif		wave_colStats({nan},startRow,endRow,0,inf,outputRef,list=strListOfWavesToAvg,bsx=usedBsx,bex=usedBex,normalize=doNorm)			else 		//compute the simple average			//leave unchanged if numWaves < 2		Variable numWaves = ItemsInList(strListOfWavesToAvg, delimiterStr)		ref = StringFromList(0, strListOfWavesToAvg, delimiterStr)		if (!ParamIsDefault(loadViaFD) && loadViaFD)			da_fd_loadWavesFromWaveName(strListOfWavesToAvg,loadViaFD==2)		endif				duplicate/o $ref,$outputRef/wave=outW_avg					//save in case useful		Variable firstSweep_fdFileNum = fd_getFIndexInFileInfoWave(text_getInfoFromWaveName_S(ref, 9))		Variable firstSweep_fdSweepNum = text_getInfoFromWaveName_V(ref, 2)					Variable i, count = 1		for (i=1;i<numWaves;i+=1)			ref =  StringFromList(i, strListOfWavesToAvg, delimiterStr)			WAVE currW_temp = $ref			outW_avg += currW_temp		endfor		outW_avg /= numWaves			endif			Variable lastSweep_fdFileNum = fd_getFIndexInFileInfoWave(text_getInfoFromWaveName_S(ref, 9))	Variable lastSweep_fdSweepNum = text_getInfoFromWaveName_V(ref, 2)	Note/NOCR $outputRef, "AVG:" + replacestring(delimiterStr, strListOfWavesToAvg, ",") + ";" 	String lastSweepTime = StringByKey("SWEEP_TIME", note($ref))	Note/NOCR $outputRef, "AVG_LAST_SWEEP_TIME:"+lastSweepTime+";"		Note/NOCR $outputRef, "AVG_FIRST_SWEEP_FD_FILENUM:"+num2str(firstSweep_fdFileNum)+";"	Note/NOCR $outputRef, "AVG_FIRST_SWEEP_FD_SWEEPNUM:"+num2str(firstSweep_fdSweepNum)+";"	Note/NOCR $outputRef, "AVG_LAST_SWEEP_FD_FILENUM:"+num2str(lastSweep_fdFileNum)+";"	Note/NOCR $outputRef, "AVG_LAST_SWEEP_FD_SWEEPNUM:"+num2str(lastSweep_fdSweepNum)+";"	Note/NOCR $outputRef, ";\rAVG_LAST_SWEEP_NOTE:" + note($StringFromList(0, strListOfWavesToAvg, delimiterStr))			//AVG_FIRST_SWEEP_FD_FILENUM AVG_FIRST_SWEEP_FD_SWEEPNUM AVG_LAST_SWEEP_FD_FILENUM AVG_LAST_SWEEP_FD_SWEEPNUM	if (noInputName && (PAramIsDefault(np) || !np) )		Print "outputRef",outputRef	endif		if (!ParamIsDefault(killAfterAvg))		killWavesInStrList(strListOfWavesToAvg)	endif	//	KillWaves/Z outW_avg,currW_avg	return outputRefendfunction tWave_bsRowOrCol(tWave, rowNotCol, colIndex, baseStartX, baseEndX)	WAVE/T tWave; Variable baseStartX, baseEndX, rowNotCol, colIndex		Variable i, lenp	if (rowNotCol)		lenp = DimSize(tWave,1)		for (i=0;i<lenp;i+=1)			waveList_bs(tWave[colIndex][i],baseStartX, baseEndX)		endfor	else		lenp = DimSize(tWave,0)		for (i=0;i<lenp;i+=1)			waveList_bs(tWave[i][colIndex],baseStartX, baseEndX)		endfor	endifendfunction tWave_bs(tWave, baseStartX, baseEndX)	WAVE/T tWave; Variable baseStartX, baseEndX		Variable i	for (i=0;i<numpnts(tWave);i+=1)		waveList_bs(tWave[i],  baseStartX, baseEndX)	endforendfunction waveList_bs(list,  baseStartX, baseEndX)	String list; Variable baseStartX, baseEndX		Variable i, currMean	for (i=0;i<ItemsInList(list);i+=1)		WAVE/D temp = $StringFromList(i,list)		currMean = mean(temp, baseStartX, baseEndX)		temp -= currMean	endforend	function/S Duplicate2(inRef,outRef, startX,endX)	STring inRef, outRef; Variable startX, endX		Duplicate/O/R=(startX, endX) $inRef, $outRef		return outRefendfunction/S Duplicate_FD(waveOrWavesToDup, [dupSaveRefOrRefs, x1,x2])			//calls duplicate but, if wave is NOT found also tries to load wave . FD stands for fileDirectory	String waveOrWavesToDup	String dupSaveRefOrRefs	//optionally save the wave to a different name as well (usually for temporary use in a function)	Variable x1, x2	//optionally specify a range of x vals  -- NOT SUPPORTED FOR LOADING FROM IGOR64 (thoug it would be easy to implement)	//	Print "items to dup = " + num2str(ItemsInList(waveOrWavesToDup))	if (igor_is64())		String loaded=""		da_fd_loadWavesFromWaveName(waveOrWavesToDup,1,out_loadedWvList=loaded)		return stringfromlist(0,loaded)	endif		Variable i; String waveToDup, outStr = ""; Variable numToLoad =0, numAttempts = 0, numFailures = 0, numLikelyFailures = 0	for (i=0;i<ItemsInList(waveOrWavesToDup);i+=1)		waveToDup = StringFromList(i, waveOrWavesToDup)//		Print num2str(i) + " " + waveToDup 		numToLoad += 1		//		if (stringmatch(waveToDup, "G15120201_0006_1_AD2"))//			Print "IN DUPLICATE_FD, SKIPPING G15120201_0006_1_AD2"//			//		endif						if (!WaveExists($waveToDup) || (numpnts($waveToDup) < 2))				//Print "in Duplicate_FD (fileDirectory). Loading currently unloaded wave. Name of wave = " + waveToDup			outStr += waveToDup + ";"			da_fd_loadWaveFromWaveName(waveToDup)			numAttempts+=1			if (!WaveExists($waveToDup))					//Print "da_fd_loadWaveFromWaveName failed on wave name = " + waveToDup				return ""				numFailures +=1			endif			if (numpnts($waveToDup) < 2)				//Print "da_fd_loadWaveFromWaveName likely failed on wave name = " + waveToDup +". output numpnts = " + num2str(numpnts($waveToDup)) + "."				numLikelyFailures +=1			endif		endif						if (ParamIsDefault(dupSaveRefOrRefs))		//if only loading an original wave, stop here			continue		endif				if (stringmatch(waveToDup, dupSaveRefOrRefs))	//if doing essentially that, step here too			continue		endif							//if duplcating a sub region of waveToDup into dupSaveRef		String dupSaveRef = StringFromList(0, dupSaveRefOrRefs)//		Print "dupSaveRef = " + dupSAveRef + "wave to dup = " + waveToDup						Variable startX, endX						//if duplcating a sub region of waveToDup into dupSaveRef		if (!ParamIsDefault(x1))			startX = x1		else			startX = DimOffset($waveToDup, 0)		//default is start time of wave		endif		if (!ParamIsDefault(x2))			endX = x2		else			endX = DimOffset($waveToDup, 0) + ( DimSize($waveToDup, 0 ) * DimDelta($waveToDup,0) )		//default is end time of wave		endif					Duplicate/O/R=(startX,endX) $waveToDup, $dupSaveRef				debug_checkRTErrState(msg="cccccccccccc")	endfor		if (ParamIsDefault(dupSaveRefOrRefs))		return waveOrWavesToDup	else		return dupSaveRefOrRefs	endif	Print "Duplicate_FD() completed. #checked=" + num2str(numToLoad)+" #numLoadsAttempted=" +  num2str(numAttempts)+" #numFailed=" +  num2str(numFailures)+" #numLikelyFailed=" +  num2str(numLikelyFailures)end//requires slightly more redundant code, but allows for better troubleshooting! Perhaps avoid in loops etcfunction/S DupSafe(waveToDup, dupSaveRef)	String waveToDup, dupSaveRef		Variable ignoreRTErrors = 0		//replace with 1 to ignore. See documentation	if (!WaveExists($waveToDup))			Print "Warning, attempting to duplicate with DupSave(). Wave to dup not found. Ref = " + waveToDup		Print "use Duplicate_FD to load waves that were originally from abf files."				return ""	endif		Variable err= GetRTError(1)			//clears error state	if (err != 0)		Print "warning, run time error already on stack before duplicate in DupSafe. continuing with DupSafe on = " + waveToDup		Print "error message = " + GetErrMessage(err)  		Print "Function stack = " + GetRTStackInfo(3)	endif		Duplicate/O $waveToDup, $dupSaveRef	err= GetRTError(0)			//does not clear error state	if (err != 0)		Print "Run Time error following duplicate in DupSafe while duplicating = " + waveToDup + " to " + dupSaveRef + ". Contiuing (num above 0 for yes) =  " + num2str(ignoreRTErrors)		Print "Error message = " + GetErrMessage(err)  		Print "Function stack = " +GetRTStackInfo(3)		err = GetRTError(ignoreRTErrors)		//optionally clears error state depending on ignoreRTErrors	endif		return dupSaveRef	end#include <FunctionProfiling>function/S debug_checkRTErrState([msg])	String msg			//optional message to print; only prints if error occurs	Variable clearErrState = 1		Variable err0 = GetRTError(0)		//does not clear error state 	Variable err1		//stores result of GETRTError(1) when error is cleared, if clearErrstate = 0	if (err0 != 0)		Print "Run Time error before checkErrState() call in function stack: " + GetRTStackInfo(3)		if (!ParamIsDefault(msg))			Print "Msg passed with function throwing error: " + msg		endif		Print "Error message = " + GetErrMessage(err0,3)  	//3 is for errors in used defined functions if I am reading correctly		if (clearErrState == 1)			Print "Error cleared (may cause additional errors)."			err1 = GetRTError(clearErrState)		//optionally clears error state depending on ignoreRTErrors		endif	endif		return GetErrMessage(err0,3)endfunction/S debug_getProcInfo()	return getRTLocInfo(getrtlocation(0))endfunction debug_printCallStack()	Print "debug_printCallStack(), result: " + GetRTStackInfo(3)end//returns string list of waves in named column, rows specified by list stored in or referred to by selStrOrByNumsReffunction/S getWaveList_LBCol_SelListByNums(selStrOrByNumsRef, delimiterStr, selListRef, colNum, outputDelimiterStr)	String delimiterStr, selStrOrByNumsRef		//can be either string or wave reference (specified by strlen(delimiterStr) >0 implying selStr	String selListRef					//listbox selWave reference	Variable colNum				//column number in which wave refs of interest are stored in listbox	String outputDelimiterStr		WAVE/T	lbTemp = $selListRef	Variable i, currIndex	String output = ""		if (!WaveExists(lbTemp))		return ""	endif		if (strlen(delimiterStr) > 0)		//expects selStrOrByNumsRef is a string list of selected indices		for (i=0;i<ItemsInList(selStrOrByNumsRef,delimiterStr);i+=1)			currIndex = str2num(StringFromList(i,selStrOrByNumsRef,delimiterStr))			output += lbTemp[currIndex][colNum] + outputDelimiterStr		endfor	else		if (!WaveExists($selStrOrByNumsRef))			return ""		endif				WAVE selListTemp_getWaveListLBCol = $selStrOrByNumsRef		for (i=0;i<DimSize(selListTemp_getWaveListLBCol,0);i+=1)			currIndex = selListTemp_getWaveListLBCol[i]			output += lbTemp[currIndex][colNum] + outputDelimiterStr		endfor	endif		return outputend//column averagefunction getColAvgForSel_FC(colNum, outputRef)	Variable colNum; String outputRef		String waveListForAvg = getWaveList_LBCol_SelListByNums("sweepsDispSelWaveByNums", "", "sweepsDispList", colNum, ";")		wave_avgFromStrList(waveListForAvg, ";", outputRef,0,nan,nan)end//SSVI Analysis// CURRENTLY FUNCTIONING CC VI ANALYSIS. Only handles pre-step from soma to ped. For now run a separate function to compare pre-step from soma and ped, if performed from both sites//stepInfoWaves: {testPulse_baselineStartX, step_baselineStartX, step_lastNegSweep, step_zeroCurrentSweep}. Pass NaN for all relevant values if any particular aspect is not present.//these all refer to the location that the stimulus is delivered FROM. analysis is performed at both sites in either casefunction VI_repsAndFamily2Site(rFam_S_fS,sFam_S_fS,rFam_P_fS,sFam_P_fs,rFam_S_fP,sFam_S_fP,rFam_P_fP,sFam_P_fP,somaStepInfo,pedStepInfo,fName,cellName,cellFileNum,numBridgeVals_proximal,numBridgeVals_distal,doDisplay,streamTags)	String rFam_S_fS,sFam_S_fS,rFam_P_fS,sFam_P_fs,rFam_S_fP,sFam_S_fP,rFam_P_fP,sFam_P_fP	WAVE/D somaStepInfo, pedStepInfo			//pass as waves (can be declared and instantiated at function call)	String fName		//baseName for saving outputs	String cellName; Variable cellFileNum			//optional, pass to store	Variable numBridgeVals_proximal,numBridgeVals_distal	//number of points included in bridge bal correction at each sight (zero has no effect on waves)	Variable doDisplay	//pace to auto display results with VI_disp_overlays_g	String streamTags	Print "rFam_S_fS:", rFam_S_fS, "sFam_S_fS:",sFam_S_fS,"rFam_P_fS:",rFam_P_fS,"sFam_P_fS:",sFam_P_fS	Print "rFam_S_fP:", rFam_S_fP, "sFam_S_fP:",sFam_S_fP,"rFam_P_fP:",rFam_P_fP,"sFam_P_fP:",sFam_P_fP		//documentation for future additional and/or population analysis	String analysisStreamStr = ""		//key-word list for future / population analysis. saved with fio_stream_saveToStream in a row devoted to somatic file cell	String analysisSaveRefs = ""			//refs to save following analysis (param waves mostly)	String analysisStreamLabel	if (numtype(somaStepInfo[0]))		//no recording at soma at all.. use ped for naming		analysisStreamLabel = text_getInfoFromWaveName_S(StringFromLisT(0,rFam_P_fP), 10)		//get all from cell except channelStr	else									//rec from soma (and possibly also ped) .. use soma for naming		analysisStreamLabel = text_getInfoFromWaveName_S(StringFromLisT(0,rFam_S_fS), 10)		//get all from cell except channelStr	endif		//input info		analysisStreamStr+= "analysisStreamLabel:"+analysisStreamLabel+";"	analysisStreamStr+= "callingFunction:VI_repsAndFamily2Site;"	analysisStreamStr+= "rFam_S_fS:"+ReplaceString(";",rFam_S_fS,",")+";"	analysisStreamStr+= "sFam_S_fS:"+ReplaceString(";",sFam_S_fS,",")+";"	analysisStreamStr+= "rFam_P_fS:"+ReplaceString(";",rFam_P_fS,",")+";"	analysisStreamStr+= "sFam_P_fS:"+ReplaceString(";",sFam_P_fS,",")+";"	analysisStreamStr+= "rFam_S_fP:"+ReplaceString(";",rFam_S_fP,",")+";"	analysisStreamStr+= "sFam_S_fP:"+ReplaceString(";",sFam_S_fP,",")+";"	analysisStreamStr+= "rFam_P_fP:"+ReplaceString(";",rFam_P_fP,",")+";"	analysisStreamStr+= "sFam_P_fP:"+ReplaceString(";",sFam_P_fP,",")+";"	string stepInfoStr_s; sprintf stepInfoStr_s, "%.8f,%.8f,%.8f,%.8f", somaStepInfo[0], somaStepInfo[1], somaStepInfo[2], somaStepInfo[3]	string stepInfoStr_p; sprintf stepInfoStr_p, "%.8f,%.8f,%.8f,%.8f", pedStepInfo[0], pedStepInfo[1], pedStepInfo[2], pedStepInfo[3]	analysisStreamStr+= "stepInfoStr_s:"+stepInfoStr_s+";"	analysisStreamStr+= "stepInfoStr_p:"+stepInfoStr_p+";"	analysisStreamStr+= "fName:"+fName+";"	analysisStreamStr+= "cellName:"+cellName+";"	analysisStreamStr+= "cellFileNum:"+num2str(cellFileNum)+";"	analysisStreamStr+= "numBridgeVals_proximal:"+num2str(numBridgeVals_proximal)+";"	analysisStreamStr+= "numBridgeVals_distal:"+num2str(numBridgeVals_distal)+";"		//make output names	String rs_as = "_rs"		//rep steps (constant level)	String ts_as = "_ts"		//test steps (variable levels)	String at_S= "_S", at_P = "_P"	String fromS = "fS", fromP = "fP"	String diffsStr = "_dr"	String fDiffsStr = "_fr"	String stepInfo = "_vsi"			//v step info	String repStep_outRef_SfS = fName + rs_as + at_S + fromS, repStep_outRef_PfS = fName + rs_as + at_P + fromS	String testStep_outRef_SfS  = fName + ts_as + at_S + fromS, testStep_outRef_PfS  = fName + ts_as + at_P + fromS	String testSteps_outRef_diffs_fS =  fName + ts_as + diffsStr + fromS	String testSteps_outRef_fDiffs_fS =  fName + ts_as + fDiffsStr + fromS	String repStep_outRef_SfP = fName + rs_as + at_S + fromP, repStep_outRef_PfP = fName + rs_as + at_P + fromP	String testStep_outRef_SfP  = fName + ts_as + at_S + fromP, testStep_outRef_PfP  = fName + ts_as + at_P + fromP	String testSteps_outRef_diffs_fP =  fName + ts_as + diffsStr + fromP	String testSteps_outRef_fDiffs_fP =  fName + ts_as + fDiffsStr + fromP	String stepInfoRef = fName + stepInfo	Variable doBridgeBal_SfS,doBridgeBal_PfS,doBridgeBal_PfP,doBridgeBal_SfP	String reps_bridgeRef_SfS="",reps_bridgeRef_PfS="",reps_bridgeRef_PfP="",reps_bridgeRef_SfP=""	String steps_bridgeRef_SfS="",steps_bridgeRef_PfS="",steps_bridgeRef_PfP="",steps_bridgeRef_SfP=""	//expected position of different pieces of information in stepInfoWaves	Variable repStep_bsx = 0, testStep_bsx = 1, testStep_lastNegSweep=2, testStep_zeroCurrSweep=3		Variable reps_isNegativeGoing = 1		//assuming negative repSteps at present	analysisStreamStr += "reps_isNegativeGoing:"+num2str(reps_isNegativeGoing)+";"			//save info waves	Duplicate/O  pedStepInfo, pedStepInfoTemp	Redimension/N=(numpnts(pedStepInfoTemp)+1) pedStepInfoTemp	pedStepInfoTemp[numpnts(pedStepInfoTemp)-1] = cellFileNum	Concatenate/O {somaStepInfo,pedStepInfoTemp},  $stepInfoRef	analysisSaveRefs += stepInfoRef + ";"	analysisStreamStr += "stepInfoRef:"+stepInfoRef+";"	killwaves pedStepInfoTemp		//start analysis	Variable reps_fS=0,reps_fP=0,reps_PfS=0,reps_SfP=0,steps_fS=0,steps_fP=0,resp_PfS=0,resp_SfP=0;//tracks if stored info from eithe site, so that we know if from soma or from ped params waves should be saved	String outStr		//outStr is temporary, recs output of VI_stepFamily2site			//test steps first -- bridge balance done to traces at this stage	if (!numtype(somaStepInfo[testStep_bsx]))		//if there's a real number in there		steps_fS = 1		doBridgeBal_SfS=numBridgeVals_proximal		doBridgeBal_PfS=numBridgeVals_distal		outStr=VI_stepFamily2site(rFam_S_fS,rFam_P_fS,sFam_S_fS,somaStepInfo[testStep_bsx],0,somaStepInfo[testStep_lastNegSweep],somaStepInfo[testStep_zeroCurrSweep],testStep_outRef_SfS,testStep_outRef_PfS,doBridgeBal_SfS,doBridgeBal_PfS,cellName=cellName,cellFileNum=cellFileNum)		resp_PfS=str2num(stringfromlist(1,outStr))		//outStr is hasRespFromS;hasRespFromP;hasRespFromBoth;bridgeInfoRef_S;bridgeInfoRef_P		steps_bridgeRef_SfS=stringfromlist(3,outStr)		steps_bridgeRef_PfS=stringfromlist(4,outStr)				//save at soma		analysisStreamStr+="testStep_outRef_SfS:"+testStep_outRef_SfS+";steps_bridgeRef_SfS:"+steps_bridgeRef_SfS+";doBridgeBal_SfS:"+num2str(doBridgeBal_SfS)+";"		analysisSaveRefs+=testStep_outRef_SfS+";"+steps_bridgeRef_SfS+";"				if (resp_PfS)			//save at ped			analysisStreamStr+="testStep_outRef_PfS:"+testStep_outRef_PfS+";steps_bridgeRef_PfS:"+steps_bridgeRef_PfS+";doBridgeBal_PfS:"+num2str(doBridgeBal_PfS)+";"			analysisSaveRefs+=testStep_outRef_PfS+";"+steps_bridgeRef_PfS+";"						//calc difference wave			WAVE testSteps_atS = $testStep_outRef_SfS			WAVE testSteps_atP = $testStep_outRef_PfS			Duplicate/O testSteps_atS, $testSteps_outRef_diffs_fS/WAVE=diffs_fS, $testSteps_outRef_fDiffs_fS/WAVE=fDiffs_fS			diffs_fS = testSteps_atP - testSteps_atS  //change at distal from proximal			fDiffs_fS = testSteps_atP / testSteps_atS	//fold change at distal from proximal						//save difference wave			analysisStreamStr+= "testSteps_outRef_diffs_fS:"+testSteps_outRef_diffs_fS+";"			analysisStreamStr+= "testSteps_outRef_fDiffs_fS:"+testSteps_outRef_fDiffs_fS+";"						analysisSaveRefs+=testSteps_outRef_diffs_fS+";"			analysisSaveRefs+=testSteps_outRef_fDiffs_fS+";"		endif	endif		//get testSteps from ped?	if (!numtype(pedStepInfo[testStep_bsx]))		//if there's a real number in there		steps_fP = 1		doBridgeBal_PfP=numBridgeVals_proximal;doBridgeBal_SfP=numBridgeVals_distal		outStr = VI_stepFamily2site(rFam_S_fP, rFam_P_fP, sFam_P_fP,  pedStepInfo[testStep_bsx],  1,  pedStepInfo[testStep_lastNegSweep],  pedStepInfo[testStep_zeroCurrSweep], testStep_outRef_SfP,testStep_outRef_PfP,doBridgeBal_SfP,doBridgeBal_PfP,cellName=cellName, cellFileNum=cellFileNum)		resp_SfP=str2num(stringfromlist(0,outStr))		//outStr is hasRespFromS;hasRespFromP;hasRespFromBoth;bridgeInfoRef_S;bridgeInfoRef_P		steps_bridgeRef_SfP=stringfromlist(3,outStr)		steps_bridgeRef_PfP=stringfromlist(4,outStr)		//save at ped		analysisStreamStr+="testStep_outRef_PfP:"+testStep_outRef_PfP+";steps_bridgeRef_PfP:"+steps_bridgeRef_PfP+";doBridgeBal_PfP:"+num2str(doBridgeBal_PfP)+";"		analysisSaveRefs+=testStep_outRef_PfP+";"+steps_bridgeRef_PfP+";"				if (resp_SfP)			//save at ped			analysisStreamStr+="testStep_outRef_SfP:"+testStep_outRef_SfP+";steps_bridgeRef_SfP:"+steps_bridgeRef_SfP+";doBridgeBal_SfP:"+num2str(doBridgeBal_SfP)+";"			analysisSaveRefs+=testStep_outRef_SfP+";"+steps_bridgeRef_SfP+";"						//calc difference wave			WAVE testSteps_atS = $testStep_outRef_SfP			WAVE testSteps_atP = $testStep_outRef_PfP			Duplicate/O testSteps_atP, $testSteps_outRef_diffs_fP/WAVE=diffs_fP, $testSteps_outRef_fDiffs_fP/WAVE=fDiffs_fP			diffs_fP = testSteps_atS - testSteps_atP  //change at distal from proximal			fDiffs_fP = testSteps_atS / testSteps_atP	//fold change at distal from proximal						//save difference wave			analysisStreamStr+= "testSteps_outRef_diffs_fP:"+testSteps_outRef_diffs_fP+";"			analysisStreamStr+= "testSteps_outRef_fDiffs_fP:"+testSteps_outRef_fDiffs_fP+";"						analysisSaveRefs+=testSteps_outRef_diffs_fP+";"			analysisSaveRefs+=testSteps_outRef_fDiffs_fP+";"		endif	endif			analysisStreamStr += "steps_fs:"+num2str(steps_fs)+";"	analysisStreamStr += "steps_fP:"+num2str(steps_fP)+";"	analysisStreamStr += "resp_PfS:"+num2str(resp_PfS)+";"	analysisStreamStr += "resp_SfP:"+num2str(resp_SfP)+";"		//get testPulse / repSteps from soma?  -- change 180427 no more bridge correction here, since that was already done during testSteps	if (!numtype(somaStepInfo[repStep_bsx]))		//if there's a real number in there		reps_fS = 1		doBridgeBal_SfS=0		//bridge bal already done to traces best on step responses		doBridgeBal_PfS=0		outStr=VI_stepReps2Site(rFam_S_fS,rFam_P_fS,sFam_S_fS,reps_isNegativeGoing,somaStepInfo[repStep_bsx],0,repStep_outRef_SfS,repStep_outRef_PfS,0,0,0)		reps_PfS = str2num(stringfromlist(1,outStr))			reps_bridgeRef_SfS=stringfromlist(3,outstr)		reps_bridgeRef_PfS=stringfromlist(4,outstr)				//for saving		analysisSaveRefs+=repStep_outRef_SfS+";"+reps_bridgeRef_SfS+";"		analysisStreamStr+="repStep_outRef_SfS:"+repStep_outRef_SfS+";reps_bridgeRef_SfS:"+reps_bridgeRef_SfS		if (reps_PfS)			analysisSaveRefs+=repStep_outRef_PfS+";"+reps_bridgeRef_PfS+";"			analysisStreamStr+="repStep_outRef_PfS:"+repStep_outRef_PfS+";reps_bridgeRef_PfS:"+reps_bridgeRef_PfS+";"		endif	endif		//get testPulse / repSteps from ped?	if (!numtype(pedStepInfo[repStep_bsx]))		//if there's a real number in there		reps_fP = 1			doBridgeBal_PfP=0		//bridge bal already done to traces best on step responses		doBridgeBal_SfP=0		outStr=VI_stepReps2Site(rFam_S_fP,rFam_P_fP,sFam_P_fP,reps_isNegativeGoing,pedStepInfo[repStep_bsx],1,repStep_outRef_SfP,repStep_outRef_PfP,0,0,0)		reps_SfP = str2num(stringfromlist(0,outStr))			reps_bridgeRef_SfP=stringfromlist(3,outstr)		reps_bridgeRef_PfP=stringfromlist(4,outstr)				//for saving		analysisSaveRefs+=repStep_outRef_PfP+";"+reps_bridgeRef_PfP+";"		analysisStreamStr+="repStep_outRef_PfP:"+repStep_outRef_PfP+";reps_bridgeRef_PfP:"+reps_bridgeRef_PfP+";"		if (reps_SfP)			analysisSaveRefs+=repStep_outRef_SfP+";"+reps_bridgeRef_SfP+";"			analysisStreamStr+="repStep_outRef_SfP:"+repStep_outRef_SfP+";reps_bridgeRef_SfP:"+reps_bridgeRef_SfP+";"		endif		endif		analysisStreamStr+="reps_fS:"+num2str(reps_fS)+";"	analysisStreamStr+="reps_fP:"+num2str(reps_fP)+";"	analysisStreamStr+="reps_PfS:"+num2str(reps_PfS)+";"	analysisStreamStr+="reps_SfP:"+num2str(reps_SfP)+";"			//add notes	wave_note(analysisSaveRefs,analysisStreamStr,1,0)		//store analysis stream summary info	fio_stream_saveToStream("vi", analysisStreamLabel,analysisStreamStr,streamTags,"",0,analysisSaveRefs,0)		//handle display option last	if (steps_fS)				if (doDisplay) 			if (resp_PfS)		//dual site				VI_disp_overlays_g(0, 1, testStep_outRef_SfS, testStep_outRef_PfS, rFam_S_fS,sFam_S_fS,rFam_P_fS,sFam_P_fS)				vi_disp_summaries_all($testStep_outRef_SfS,cellName)			else					//single site				vi_disp_summaries($testStep_outRef_SfS,$testStep_outRef_SfS,0,cellName+"_SfS","b")			endif		endif					endif	if (steps_fP)		if (doDisplay)			if (resp_SfP)				VI_disp_overlays_g(1, 1, testStep_outRef_SfP, testStep_outRef_PfP, rFam_S_fP,sFam_S_fP,rFam_P_fP,sFam_P_fP)				vi_disp_summaries_all($testStep_outRef_PfP,cellName)			else				vi_disp_summaries($testStep_outRef_PfP,$testStep_outRef_PfP,0,cellName+"_PfP","b")			endif		endif			endif			Print "analysisStreamStr",analysisStreamStrend	//VI_repsAndFamily2Sitefunction/S VI_stepFamily2site(respFamily_S,respFamily_P,stimFamily,searchStartX,stepAtTerminal,lastNegativeSweep,zeroCurrentSweep,outRef_S,outRef_P,doBridgeBal_S,doBridgeBal_P[cellName, cellFileNum])//, combinedOutRef)	String respFamily_S, respFamily_P, stimFamily		//string list with refs to families	Variable searchStartX								//where to start looking for step start from	Variable stepAtTerminal, zeroCurrentSweep			//stepAtTerminal, 1 for main stimulus from terminal. zeroCurrentStim, pass NaN if none	Variable lastNegativeSweep	String outRef_S, outRef_P			//saves outputs, stimulus info is folded into output from each site		Variable doBridgeBal_S,doBridgeBal_P				//pass to automatically subtract bridge, 0 has no effect but parameters are calculated, 1 or more sets # r vals to use -- 2 is a good number at 20 kHz	String cellName	Variable cellFileNum		Variable attemptWaveReload = 0			//attempt to load waves anew in case of previous modification (e.g. bridge balance).. requires an original load via fileDirectory/filePanel		Variable respAt_S = strlen(respFamily_S) > 0, respAt_P = strlen(respFamily_P) > 0	Variable dualSite = respAT_S && respAt_P		Variable bridge_baselineAvgSizeX = 0.004		//avg needed to determine bridge baseline .. length of window	Variable bridge_baselineAvgEndX = searchStartX	//end of average window determined by search for step startX (search start point used for bridge and I(V) analysis)	Variable bridge_baselineAvgStartX = searchStartX - bridge_baselineAvgSizeX		String bridgeInfoRef_S = outRef_S + "B"		//place to save bridge info (if doBridgeBal < 1, still calculates parameters but without effect on wave)	String bridgeInfoRef_P = outRef_P + "B"			if (ParamIsDefault(cellName))		cellName = ""	endif	cellFileNum = ParamIsDefault(cellFileNum) ? NaN : cellFileNum		Variable hasZeroCurrentStim = (numType(zeroCurrentSweep) == 0) && (zeroCurrentSweep > -1) ? 1 : 0	Variable totalNumSweeps = ItemsInList(stimFamily)	Variable numNonZeroSweeps = totalNumSweeps - hasZeroCurrentStim	String bridgeRef_S="",bridgeRef_P="",bridgeStimRef_S="",bridgeStimRef_P=""	//one ref to be used in bridge calc .. values then applied to all	Variable bridgeRefListPos_S,bridgeRefListPos_P		//for selecting bridgeRef bridgeStimRef	if (respAt_S)		Make/O/D/N=1 $outRef_S/wave=outWv_S	//placeholders for now				if (zeroCurrentSweep != 0)	//then ok to use first and assume its most negative-going			bridgeRefListPos_S = 0		else			bridgeRefListPos_S = totalNumSweeps-1		//use most-positive going instead		endif		bridgeRef_S = stringfromlist(bridgeRefListPos_S,respFamily_S)		bridgeStimRef_S = stringfromlist(bridgeRefListPos_S,stimFamily)				print "VI_stepFamily2site() doBridgeBal_S",doBridgeBal_S,"bridge_baselineAvgStartX",bridge_baselineAvgStartX,"bridge_baselineAvgEndX",bridge_baselineAvgEndX\		,"lastNegativeSweep",lastNegativeSweep,"zeroCurrentSweep",zeroCurrentSweep,"attemptWaveReload",attemptWaveReload,"bridgeRef_S",bridgeRef_S,"bridgeStimRef_S",bridgeStimRef_S		//apply bridge balance -- if doBridgeBal_S == 0, there's no effect on the waves, but some parameters are calcualted						//altering to calc on just negative-most or, if unavailable, positive-most		analysis_bridge_calc(bridgeStimRef_S,bridgeRef_S,bridge_baselineAvgEndX,inf,nan,bridgeInfoRef_S,"analysis_bridge_calcApp_r",attemptWaveReload && (doBridgeBal_S > 0))	//this wave is reloaded, if attemptWaveReload		analysis_bridge_apply($"analysis_bridge_calcApp_r",doBridgeBal_S,stimFamily,respFamily_S,bridge_baselineAvgStartX,bridge_baselineAvgEndX,attemptWaveReload && (doBridgeBal_S > 0))		//all waves are reloaded,  if attemptWaveReload				//OLD: analysis_bridge_calcApply(doBridgeBal_S,stimFamily,respFamily_S,bridge_baselineAvgStartX,bridge_baselineAvgEndX,bridge_baselineAvgEndX,lastNegativeSweep,zeroCurrentSweep,bridgeInfoRef_S,attemptWaveReload)	endif		if (respAt_P)		Make/O/D/N=1 $outRef_P/wave=outWv_P				if (zeroCurrentSweep != 0)	//then ok to use first and assume its most negative-going			bridgeRefListPos_P = 0		else			bridgeRefListPos_P = totalNumSweeps-1		//use most-positive going instead		endif		bridgeRef_P = stringfromlist(bridgeRefListPos_P,respFamily_P)		bridgeStimRef_P = stringfromlist(bridgeRefListPos_P,stimFamily)				print "VI_stepFamily2site() doBridgeBal_P",doBridgeBal_P,"bridge_baselineAvgStartX",bridge_baselineAvgStartX,"bridge_baselineAvgEndX",bridge_baselineAvgEndX\		,"lastNegativeSweep",lastNegativeSweep,"zeroCurrentSweep",zeroCurrentSweep,"attemptWaveReload",attemptWaveReload,"bridgeRef_P",bridgeRef_P,"bridgeStimRef_P",bridgeStimRef_P		//apply bridge balance -- if doBridgeBal_P == 0, there's no effect on the waves, but some parameters are calcualted						//altering to calc on just negative-most or, if unavailable, positive-most		analysis_bridge_calc(bridgeStimRef_P,bridgeRef_P,bridge_baselineAvgEndX,inf,nan,bridgeInfoRef_P,"analysis_bridge_calcApp_r",attemptWaveReload && (doBridgeBal_P > 0))	//this wave is reloaded, if attemptWaveReload		analysis_bridge_apply($"analysis_bridge_calcApp_r",doBridgeBal_P,stimFamily,respFamily_P,bridge_baselineAvgStartX,bridge_baselineAvgEndX,attemptWaveReload && (doBridgeBal_P > 0))		//all waves are reloaded,  if attemptWaveReload		//OLD:		analysis_bridge_calcApply(doBridgeBal_P,stimFamily,respFamily_P,bridge_baselineAvgStartX,bridge_baselineAvgEndX,bridge_baselineAvgEndX,lastNegativeSweep,zeroCurrentSweep,bridgeInfoRef_P,attemptWaveReload)	endif		Variable i, outputIndex=0			//i is sweep num, outputIndex is the column in which the sweep will be stored; these will differ when there is a zero current sweep that is not analyzed	String currRespR_S, currRespR_P, currStim; Variable isNegativeGoing	Make/O/D/N=(1) oneSiteTemp		//rewritten with output params by analysis_stepAndStimulus()	for (i=0;i<totalNumSweeps;i+=1)		//will skip zero sweep if present		if (i != zeroCurrentSweep)			currStim = StringFromList(i, stimFamily)			isNegativeGoing = (i <= lastNegativeSweep)						//soma			if (respAt_S)				currRespR_S = StringFromList(i, respFamily_S)	//zzzzzzzzzzzzzzzz				analysis_stepAndStimulus(currRespR_S,currStim,"oneSiteTemp",isNegativeGoing,searchStartX,"",cellName=cellName,cellFileNum=cellFileNum,sweepNum=i)				if (outputIndex == 0)					Duplicate/O oneSiteTemp, outWv_S	//copies with dim labels				endif				Redimension/N=(-1,outputIndex+1) outWv_S	//outputIndex ==0 :make into a 1 column 2-d wave instead of a (0 column) 1-d wave, otherwise makes room for new column				outWv_S[][outputIndex] = oneSiteTemp[p]						SetDimLabel 1,outputIndex,$currRespR_S,outWv_S			endif						//terminal			if (RespAT_P)				currRespR_P = StringFromList(i, respFamily_P)				analysis_stepAndStimulus(currRespR_P,currStim,"oneSiteTemp",isNegativeGoing,searchStartX,"",cellName=cellName,cellFileNum=cellFileNum,sweepNum=i)				if (outputIndex == 0)					Duplicate/O oneSiteTemp, outWv_P				endif				Redimension/N=(-1,outputIndex+1) outWv_P					outWv_P[][outputIndex] = oneSiteTemp[p]					SetDimLabel 1,outputIndex,$currRespR_P,outWv_P			endif						//advance output			outputIndex += 1			//this is NOT performed if i == zeroCurrentSweep, so after a zero current sweep is encountered outputIndex lags by 1		endif	endfor		if (respAt_S)		note/nocr outWv_S,"respAt_S:"+num2str(respAt_S)+";respAt_P:"+num2str(respAt_P)+";dualSite:"+num2str(dualSite)+";outRef_S:"+outRef_S+";outRef_P:"+outRef_P+";"		note/nocr outWv_S "bridgeInfoRef_S:"+bridgeInfoRef_s+";bridgeInfoRef_P"+bridgeInfoRef_P+";"	endif	if (respAt_P)		note/nocr outWv_P,"respAt_S:"+num2str(respAt_S)+";respAt_P:"+num2str(respAt_P)+";dualSite:"+num2str(dualSite)+";outRef_S:"+outRef_S+";outRef_P:"+outRef_P+";"		note/nocr outWv_P "bridgeInfoRef_S:"+bridgeInfoRef_s+";bridgeInfoRef_P"+bridgeInfoRef_P+";"	endif			return num2str(respAt_S) + ";" + num2str(respAt_P) + ";" + num2str(dualSite) + ";" + bridgeInfoRef_S + ";" + bridgeInfoRef_P + ";"end//VI_stepFamily2site()function/S VI_stepReps2Site(respFamily_S,respFamily_P,stimFamily,isNegativeGoing,baselineSearchStartX,stepAtTerminal,outRef_S,outRef_P,doBridgeBal_S,doBridgeBal_P,doWaveReload)	String respFamily_S, respFamily_P, stimFamily		//string list with refs to families	Variable isNegativeGoing	Variable baselineSearchStartX							//in case of pre-step preceding stimulus, use other functions to find ahead of time	Variable stepAtTerminal	String outRef_S, outRef_P			//saves outputs, stimulus info is folded into output from each site	Variable doBridgeBal_S,doBridgeBal_P				//pass to automatically subtract bridge, 0 has no effect but parameters are calculated, 1 or more sets # r vals to use -- 2 is a good number at 20 kHz	Variable doWaveReload		Variable respAt_S = strlen(respFamily_S)	Variable respAt_P = strlen(respFamily_P)	Variable dualSite = respAT_S && respAt_P		Variable bridge_baselineAvgSizeX = 0.004		//avg needed to determine bridge baseline .. length of window	Variable bridge_baselineAvgEndX = baselineSearchStartX	//end of average window determined by search for step startX (search start point used for bridge and I(V) analysis)	Variable bridge_baselineAvgStartX = baselineSearchStartX - bridge_baselineAvgSizeX		String bridgeInfoRef_S = outRef_S + "B"		//place to save bridge info (if doBridgeBal < 1, still calculates parameters but without effect on wave)	String bridgeInfoRef_P = outRef_P + "B"		Variable minStepSizeMag = 3*10^-12		Variable totalNumSweeps = ItemsInList(stimFamily)		//make output place holders	if (respAT_S)		Make/O/D/N=(1) $outRef_S/WAVE=out_S		analysis_bridge_calcApply(doBridgeBal_S,stimFamily,respFamily_S,bridge_baselineAvgStartX,bridge_baselineAvgEndX,bridge_baselineAvgEndX,inf,NaN,bridgeInfoRef_S,doWaveReload)	endif	if (respAT_P)		Make/O/D/N=(1) $outRef_P/WAVE=out_P		analysis_bridge_calcApply(doBridgeBal_P,stimFamily,respFamily_P,bridge_baselineAvgStartX,bridge_baselineAvgEndX,bridge_baselineAvgEndX,inf,NaN,bridgeInfoRef_P,doWaveReload)	endif 		//just calculate for stimulus once	String outParamsTempRef = "analysis_stimParamsTemp"	analysis_cmd_pulse($StringFromList(0, stimFamily),1,baselineSearchStartX,isNegativeGoing,outParamsTempRef,"stim_")//	analysis_stepChangeStats(StringFromList(0, stimFamily), outParamsTempRef, isNegativeGoing, minStepSizeMag, baselineSearchStartX)		Variable i			//i is sweep num, outputIndex is the column in which the sweep will be stored; these will differ when there is a zero current sweep that is not analyzed	String currRespR_S, currRespR_P, currStim;	Make/O/D/N=1 oneSiteTemp		//rewritten with output params by analysis_stepAndStimulus()	for (i=0;i<totalNumSweeps;i+=1)		//will skip zero sweep if present		currStim = StringFromList(i, stimFamily)		//soma		if (respAt_S)			currRespR_S = StringFromList(i, respFamily_S)			analysis_step1site(currRespR_S, "oneSiteTemp", outParamsTempRef, 0, 0.3, 19, 1, 3, "", noKillStimParams=1)			if (i==0)				Duplicate/O oneSiteTemp,out_S		//fills 0th column			else				Redimension/N=(-1,i+1) out_S				out_S[][i] = oneSiteTemp[p]			endif		endif		//terminal		if (respAT_P)			currRespR_P = StringFromList(i, respFamily_P)			analysis_step1site(currRespR_P, "oneSiteTemp", outParamsTempRef, 0, 0.3, 19, 1, 3, "", noKillStimParams=1)			if (i==0)				Duplicate/O oneSiteTemp,out_P		//fills 0th column			else				Redimension/N=(-1,i+1) out_P				out_P[][i] = oneSiteTemp[p]			endif		endif	endfor		if (respAt_S)		note/nocr out_S,"respAt_S:"+num2str(respAt_S)+";respAt_P:"+num2str(respAt_P)+";dualSite:"+num2str(dualSite)+";outRef_S:"+outRef_S+";outRef_P:"+outRef_P+";"		note/nocr out_S "bridgeInfoRef_S:"+bridgeInfoRef_s+";bridgeInfoRef_P"+bridgeInfoRef_P+";"	endif	if (respAt_P)		note/nocr out_P,"respAt_S:"+num2str(respAt_S)+";respAt_P:"+num2str(respAt_P)+";dualSite:"+num2str(dualSite)+";outRef_S:"+outRef_S+";outRef_P:"+outRef_P+";"		note/nocr out_P "bridgeInfoRef_S:"+bridgeInfoRef_s+";bridgeInfoRef_P"+bridgeInfoRef_P+";"	endif			return num2str(respAt_S)+";"+num2str(respAT_P)+";"+num2str(dualSite)+";"+bridgeInfoRef_S+";"+bridgeInfoRef_P+";"endfunction analysis_stepAndStimulus(respRef, stimRef, outRef, isNegativeGoing,searchStartX, polyFitSaveRef,[cellName, cellFileNum,sweepNum])	String respRef, stimRef, outRef	Variable  isNegativeGoing, searchStartX	String polyFitSaveRef 	String cellName	Variable cellFileNum,sweepNum		Variable minStepSizeMag = .15*10^-12		if (strlen(cellName) == 0)		cellName = ""	endif	cellFileNum = ParamIsDefault(cellFileNum) ? NaN : cellFileNum	sweepNum = ParamIsDefault(cellFileNum) ? NaN : sweepNum			String outParamsTempRef = "analysis_stimParamsTemp", bridgeParamsTempRef = "analysis_bridgeParamsTemp"	analysis_cmd_pulse($stimRef,1,searchStartX,isNegativeGoing,outParamsTempRef,"stim_")	analysis_step1site(respRef,outRef,outParamsTempRef,0,1.5,19,0,3,polyFitSaveRef,cellName=cellName,cellFileNum=cellFileNum,sweepNum=sweepNum)end	function analysis_step1site(respRef,outRef,stimParamsRef,inputOnly,fitWinSize,numPolyFitParams,defaultBaselineProportion,defaultStepProportion,polyFitSaveRef,[noKillStimParams,cellName,cellFileNum,sweepNum])	String respRef	//ref to response to analyze pulse from	String outRef		//ref to store responses in	String stimParamsRef	//ref to output generated by analysis_findStepChange on stimulus that evoked wave of interest. final level is only parameter NOT used here	Variable inputOnly	//stops once Rin has been calculated and returns Rin (saves variables as it would otherwise up that point)	Variable fitWinSize			// =0.3	//size of fit window for polynomial fit  -- NOW CHANGED TO 1.5 S because determines how far out a peak can be found	Variable numPolyFitParams	// = 19	Variable defaultBaselineProportion		// = 1. Determines what length (relative to the total step length) should be avgd for a baseline	Variable defaultStepProportion		//	 = 3	same for step as for baseline: determines length of window that will be assumed to be steady state	String polyFitSaveRef		//ref to store polynomial fit in, if not wanted to save fit, pass 0 len string ""	Variable noKillStimParams		//pass to assure stim params ref wave is not killed	String cellName				//stored in param note if passed	Variable cellFileNum, sweepNum			//pass to keep track of a sweep num, for use when passing multiple sweeps of steps		Variable linearFitStartDelay = 0.0005	Variable linearFitLen = 0.01		//label stimParamRef as from stimulus, if not already done so	String testlbl = GetDimLabel($stimParamsRef, 0, 0 )	String stimLblAppendStr = "stim_"	if (!stringmatch(testlbl, stimLblAppendStr+"*"))		dl_appendToLbls($stimParamsRef,0,stimLblAppendStr,1,-inf,inf)	endif	Make/D/O/N=(numPolyFitParams) ssFitCoefWave	Make/D/O/N=1 W_fitconstants	//named place where curvefit stores x0 constant		//define proportion of max thresholds/ Used for both rising and falling, but falling is calculated for both from peak to SS and from peak to base	Variable numThresholdProportions = 9	Variable sdMultiplier0 = 2	Variable sdMultiplier1 = 4	Make/O/D/N=(numThresholdProportions) thresholdProportions	dl_lblByInd("thresholdProportions",0,"resp_threshProps_",1)		Variable lineStartProp = 2		//slope start point	Variable lineEndProp = 4		//slope end point	Variable r	r=0;thresholdproportions[r]=0.01	r=1;thresholdproportions[r]=0.02	r=2;thresholdproportions[r]=0.05	r=3;thresholdproportions[r]=0.1	r=4;thresholdproportions[r]=0.5*(1-(1/exp(1)))	r=5;thresholdproportions[r]=0.5	r=6;thresholdproportions[r]=1-(1/exp(1))	r=7;thresholdproportions[r]=sdMultiplier0;SetDimLabel 0,r,$"resp_threshProps_"+num2str(sdMultiplier0)+"sdev",thresholdproportions		//multiplied by baseline SD below	r=8;thresholdproportions[r]=sdMultiplier1;SetDimLabel 0,r,$"resp_threshProps_"+num2str(sdMultiplier1)+"sdev",thresholdproportions		//multiplied by baseline SD below			//use dim labels from this for related waves -- values in these related waves to be overwritten below	Duplicate/O thresholdProportions, thresholdVals_peakToBase, thresholdVals_peakToSS	dl_appendToLbls(thresholdVals_peakToBase,0,"_pB_V",0,-inf,inf)	dl_appendToLbls(thresholdVals_peakToSS,0,"_ssB_V",0,-inf,inf)		//ssB really should be pSS	Duplicate/O thresholdProportions,thresholdTimes_peakToBase_Rise,thresholdTimes_peakToBase_Fall,thresholdTimes_peakToSS_Rise,thresholdTimes_peakToSS_Fall	dl_appendToLbls(thresholdTimes_peakToBase_Rise,0,"_pB_rX",0,-inf,inf)	dl_appendToLbls(thresholdTimes_peakToBase_Fall,0,"_pB_fX",0,-inf,inf)	dl_appendToLbls(thresholdTimes_peakToSS_Rise,0,"_ssB_rX",0,-inf,inf)	dl_appendToLbls(thresholdTimes_peakToSS_Fall,0,"_ssB_fX",0,-inf,inf)	Duplicate/O thresholdProportions,widthAtThresh_peakToBase,widthAtThresh_pB_pSS//latter stores using baseline to peak on rise and peak to SS on fall	Duplicate/o thresholdProportions,timeToThresh_peakToBase_Rise,timeToThresh_peakToBase_Fall,timeToThresh_peakToSS_Rise,timeToThresh_peakToSS_Fall	dl_appendToLbls(widthAtThresh_peakToBase,0,"_pB_W",0,-inf,inf)	dl_appendToLbls(widthAtThresh_pB_pSS,0,"_ssB_W",0,-inf,inf)	dl_appendToLbls(timeToThresh_peakToBase_Rise,0,"_pB_rDX",0,-inf,inf)	dl_appendToLbls(timeToThresh_peakToBase_Fall,0,"_pB_fDX",0,-inf,inf)	dl_appendToLbls(timeToThresh_peakToSS_Rise,0,"_ssB_rDX",0,-inf,inf)	dl_appendToLbls(timeToThresh_peakToSS_Fall,0,"_ssB_fDX",0,-inf,inf)		Variable numBaselineProportions = 5, numStepProportions = 5	Make/O/D/N=(numBaselineProportions) baselineProportions, baselineLens, baselineAvgs	//assign baseline proportions and label dimensions	r=0;baselineProportions[r] = 0.00025;	//0.025% of 2s is 0.5 ms, 500 us	r=1;baselineProportions[r] = 0.001;		//0.1% of 2s is 2 ms	(default)	r=2;baselineProportions[r] = 0.01;		//1% of 2s is 20 ms	r=3;baselineProportions[r] = 0.05;		//5% of 2s is 100 ms  -- default for step steady state 100 ms	r=4;baselineProportions[r] = 0.1	;	//10% of 2s is 200 ms	//label dimensions for other waves	dl_lblByInd("baselineProportions",0,"resp_"+nameofwave(baselineProportions),1)	dl_lblByInd("baselineLens",0,"resp_"+nameofwave(baselineLens),1)	dl_lblByInd("baselineAvgs",0,"resp_"+nameofwave(baselineAvgs),1)		//set stepProportions = baselineProportions, but could have them differ	Duplicate/O baselineProportions, stepProportions	dl_lblByInd("stepProportions",0,"resp_"+nameofwave(stepProportions),1)	//dim labels from baselineProportions overwritten in function		Make/O/D/N=(numStepProportions) stepLens, stepAvgs, deltas, Rins			//proportions of step considered SS in avg for ss. deltas and Rins use defaultBaselineProportionForRin	dl_lblByInd("stepLens",0,"resp_"+nameofwave(stepLens),1)	dl_lblByInd("stepAvgs",0,"resp_"+nameofwave(stepAvgs),1)	dl_lblByInd("deltas",0,"resp_"+nameofwave(deltas),1)	dl_lblByInd("Rins",0,"resp_"+nameofwave(Rins),1)	WAVE/D resp = $respRef	WAVE/D stimParams = $stimParamsRef		Variable t0_X = stimParams[%stim_ri_t0_end_X], t1_X=stimParams[%stim_fa_t0_end_X], negativeGoing = stimParams[%stim_ri_deltaMean] < 0 	Variable stepLen = t1_X - t0_X		baselineLens = baselineProportions[p] * stepLen	stepLens = stepProportions[p] * stepLen	baselineAvgs = mean(resp, t0_X - baselineLens[p], t0_X)	stepAvgs = mean(resp, t1_X-stepLens[p], t1_X)		WaveStats/Q/R=(t0_X-baselineLens[defaultBaselineProportion], t0_X) resp	Variable baselineSD = V_sdev	thresholdProportions[7] *= baselineSD	thresholdProportions[8] *= baselineSD		deltas = stepAvgs[p] - baselineAvgs[defaultBaselineProportion]		//uses baseline from default baseline proportion	Rins = deltas[p] / stimParams[%stim_ri_deltaMean]		if (inputOnly)		//fast return mode		return Rins[defaultStepProportion]	endif	//make curve fit with polynomial and save this wave, store reference to name in reference to fit save wave	CurveFit/Q/N=1 poly_XOffset numPolyFitParams, kwCWave=ssFitCoefWave, resp(t0_X,t0_X+ fitWinSize)	Duplicate/O/R=(t0_X,t0_X + fitWinSize) resp, VI_step1sitePolyFitTemp	//label ssFitCoefWave dims	dl_lblByInd("ssFitCoefWave",0,"polyfit_coef_",1); SetDimLabel 0,0,polyfit_constant_x0,W_fitconstants	VI_step1sitePolyFitTemp = poly(ssFitCoefWave,x-W_fitconstants[0])	Note VI_step1sitePolyFitTemp, "Polynomial fit after step for voltage wave. Originals: V:" + respRef		//Find peak of polynomial fit, if current step is negative, look for negative peak, positive, positive peak	Wavestats/Q/R=(t0_X,  t0_X +  fitWinSize) VI_step1sitePolyFitTemp		//not set up to handle 0 mean stimulus	Variable peakVal, peakLoc	if (negativeGoing)		//DeltaCurrent < 0, so look for min		peakVal = V_min		peakLoc = V_minloc	else		peakVal = V_max		peakLoc = V_maxloc	endif		//calculate threshold value (relative to peak)	Double defaultBaselineVal = baselineAvgs[defaultBaselineProportion]	Double defaultSSVal = stepAvgs[defaultStepProportion]	Double peakBaselineDiff = peakVal - defaultBaselineVal	Double peakSSDiff = peakVal - defaultSSVal	Double ssBaselineDiff = defaultSSVal - defaultBaselineVal	thresholdVals_peakToBase[] =  defaultBaselineVal + (peakBaselineDiff*thresholdProportions[p])	thresholdVals_peakToSS[] = defaultSSVal + (peakSSDiff*thresholdProportions[p])		Double peakSSFoldDiff=peakVal/defaultSSVal			//Use threshold alue to find times when y = half max, and the width between these points (for threshold 0)	Variable i	WAVE/D tresholdFindWv = resp	//uses actual wave, poly fit only used to determine peak val	for (i=0;i<DimSize(thresholdProportions,0);i+=1)	//first for peak to baseline		//rising phase		FindLevel/Q/R=(t0_X,peakLoc) tresholdFindWv, thresholdVals_peakToBase[i]		thresholdTimes_peakToBase_Rise[i] = V_LevelX				//falling phase (may sometimes be NaN if SS is above sought value)		FindLevel/Q/R=(peakLoc, t0_X+fitWinSize) tresholdFindWv, thresholdVals_peakToBase[i]		thresholdTimes_peakToBase_Fall[i] = V_LevelX		//then for peak to SS		FindLevel/Q/R=(t0_X,peakLoc) tresholdFindWv, thresholdVals_peakToSS[i]		thresholdTimes_peakToSS_Rise[i] = V_LevelX				FindLevel/Q/R=(peakLoc, t0_X+fitWinSize) tresholdFindWv, thresholdVals_peakToSS[i]		thresholdTimes_peakToSS_Fall[i] = V_LevelX		endfor		//calculate widths	widthAtThresh_peakToBase[] = thresholdTimes_peakToBase_Fall[p] - thresholdTimes_peakToBase_Rise[p]		widthAtThresh_pB_pSS[] = thresholdTimes_peakToSS_Fall[p] - thresholdTimes_peakToBase_Rise[p]	//time to rising and falling thresholds	Variable timeToPeak = peakLoc - t0_X	timeToThresh_peakToBase_Rise[] = thresholdTimes_peakToBase_Rise[p] - t0_X	timeToThresh_peakToBase_Fall[] = thresholdTimes_peakToBase_Fall[p] - t0_X	timeToThresh_peakToSS_Rise[] = thresholdTimes_peakToSS_Rise[p] - t0_X	timeToThresh_peakToSS_Fall[] = thresholdTimes_peakToSS_Fall[p] - t0_X	//	//calculate line through slope start and end points	Variable lineStartX = t0_X + linearFitStartDelay				//thresholdTimes_peakToBase_Rise[lineStartProp]	Variable lineEndX = lineStartX + linearFitLen			// thresholdTimes_peakToBase_Rise[lineEndProp]	Make/O/D/N=2 lineCoefsWv	CurveFit/Q/N=1 line, kwCWave=lineCoefsWv, resp(lineStartX,lineEndX)	Variable lineSlope = lineCoefsWv[1]	Variable lineZeroCross = lineCoefsWv[0]	Variable lineBaselineCross = (defaultBaselineVal - lineZeroCross) / lineSlope	Variable lineStartX_relStep = lineStartX - t0_X	Variable lineEndX_relStep = lineEndX - t0_X	Variable lineZeroCross_relStep = lineZeroCross-t0_X	Variable lineBaselineCross_relStep = lineBaselineCross - t0_X		Variable lineEndVal = thresholdVals_peakToBase[lineEndProp]	Variable lineStartVal = thresholdVals_peakToBase[lineStartProp]		//find "trough", lowest point following peak	Variable troughVal, troughX,peakMinusTrough, timeToTrough	Wavestats/Q/R=(peakLoc,t0_X+fitWinSize) VI_step1sitePolyFitTemp	if (negativeGoing)		troughVal = V_max		troughX = V_maxLoc	else		troughVal = V_min		troughX = V_minLoc	endif	peakMinusTrough = peakVal - troughVal	timeToTrough = 	troughX - t0_X		//ADDED 180428 constant threshold crossings	FindLevel/Q/R=(t0_X,t1_x) tresholdFindWv, defaultBaselineVal+0.01*(negativeGoing ? -1 : 1)*0.001	Double mVcrossX_p01 = V_LevelX - t0_x	FindLevel/Q/R=(t0_X,t1_x) tresholdFindWv, defaultBaselineVal+0.02*(negativeGoing ? -1 : 1)*0.001	Double mVcrossX_p02 = V_LevelX - t0_x	FindLevel/Q/R=(t0_X,t1_x) tresholdFindWv, defaultBaselineVal+0.05*(negativeGoing ? -1 : 1)*0.001	Double mVcrossX_p05 = V_LevelX - t0_x	FindLevel/Q/R=(t0_X,t1_x) tresholdFindWv, defaultBaselineVal+0.1*(negativeGoing ? -1 : 1)*0.001	Double mVcrossX_p1 = V_LevelX - t0_x	FindLevel/Q/R=(t0_X,t1_x) tresholdFindWv, defaultBaselineVal+0.2*(negativeGoing ? -1 : 1)*0.001	Double mVcrossX_p2 = V_LevelX - t0_x	FindLevel/Q/R=(t0_X,t1_x) tresholdFindWv, defaultBaselineVal+0.5*(negativeGoing ? -1 : 1)*0.001	Double mVcrossX_p5 = V_LevelX - t0_x	FindLevel/Q/R=(t0_X,t1_x) tresholdFindWv, defaultBaselineVal+1*(negativeGoing ? -1 : 1)*0.001	Double mVcrossX_1 = V_LevelX - t0_x	FindLevel/Q/R=(t0_X,t1_x) tresholdFindWv, defaultBaselineVal+2*(negativeGoing ? -1 : 1)*0.001	Double mVcrossX_2 = V_LevelX	 - t0_x	FindLevel/Q/R=(t0_X,t1_x) tresholdFindWv, defaultBaselineVal+5*(negativeGoing ? -1 : 1)*0.001	Double mVcrossX_5 = V_LevelX - t0_x			Variable storedSweepNum = ParamIsDefault(sweepNum) ? NaN : sweepNum	Variable storedCellFileNum = ParamIsDefault(cellFileNum) ? NaN : cellFileNum	Variable actualFileNum = text_getInfoFromWaveName_V(respRef, 1)	Variable actualSweepNum = text_getInfoFromWaveName_V(respRef, 2)			Variable numInitialParams = 8	Variable numDerivedParams = 40	Make/O/D/N=(numInitialParams) outTemp_initial		//stores initial fit info, e.g. fit win size	Make/O/D/N=(numDerivedParams) outTemp_derived	//stores derived values		r=0;dl_assignAndLbl(outTemp_derived,r,peakVal,"peakVal")		r+=1;dl_assignAndLbl(outTemp_derived,r,peakLoc,"peakLoc")	r+=1;dl_assignAndLbl(outTemp_derived,r,timeToPeak,"timeToPeak")	r+=1;dl_assignAndLbl(outTemp_derived,r,defaultBaselineVal,"defaultBaselineVal")	r+=1;dl_assignAndLbl(outTemp_derived,r,defaultSSVal,"defaultSSVal")	r+=1;dl_assignAndLbl(outTemp_derived,r,peakBaselineDiff,"peakBaselineDiff")	r+=1;dl_assignAndLbl(outTemp_derived,r,peakSSDiff,"peakSSDiff")	r+=1;dl_assignAndLbl(outTemp_derived,r,ssBaselineDiff,"ssBaselineDiff")	r+=1;dl_assignAndLBl(outTemp_derived,r,peakSSFoldDiff,"peakSSFoldDiff")		r+=1;dl_assignAndLbl(outTemp_derived,r,troughVal,"troughVal")	r+=1;dl_assignAndLbl(outTemp_derived,r,troughX,"troughX")	r+=1;dl_assignAndLbl(outTemp_derived,r,peakMinusTrough,"peakMinusTrough")	r+=1;dl_assignAndLbl(outTemp_derived,r,timeToTrough,"timeToTrough")		r+=1;dl_assignAndLbl(outTemp_derived,r,baselineSD,"baselineSD")	r+=1;dl_assignAndLbl(outTemp_derived,r,lineStartProp,"lineStartProp")			r+=1;dl_assignAndLbl(outTemp_derived,r,lineEndProp	,"lineEndProp")	r+=1;dl_assignAndLbl(outTemp_derived,r,lineEndX	,"lineEndX")		r+=1;dl_assignAndLbl(outTemp_derived,r,lineStartX,"lineStartX")	r+=1;dl_assignAndLbl(outTemp_derived,r,lineEndVal,"lineEndVal")	r+=1;dl_assignAndLbl(outTemp_derived,r,lineStartVal,"lineStartVal")	r+=1;dl_assignAndLbl(outTemp_derived,r,lineSlope		,"lineSlope")	r+=1;dl_assignAndLbl(outTemp_derived,r,lineZeroCross,"lineZeroCross")	r+=1;dl_assignAndLbl(outTemp_derived,r,lineBaselineCross,"lineBaselineCross")	r+=1;dl_assignAndLbl(outTemp_derived,r,lineStartX_relStep,"lineStartX_relStep")// = lineStartX - t0_X	r+=1;dl_assignAndLbl(outTemp_derived,r,lineEndX_relStep,"lineEndX_relStep")// = lineEndX - t0_X	r+=1;dl_assignAndLbl(outTemp_derived,r,lineZeroCross_relStep,"lineZeroCross_relStep")// = lineZeroCross-t0_X	r+=1;dl_assignAndLbl(outTemp_derived,r,lineBaselineCross_relStep,"lineBaselineCross_relStep")// = lineBaselineCross - t0_X				r+=1;dl_assignAndLbl(outTemp_derived,r,storedSweepNum,"storedSweepNum")	r+=1;dl_assignAndLbl(outTemp_derived,r,storedCellFileNum,"storedCellFileNum")	r+=1;dl_assignAndLbl(outTemp_derived,r,actualSweepNum,"actualSweepNum")	r+=1;dl_assignAndLbl(outTemp_derived,r,actualFileNum,"actualFileNum")			r+=1;dl_assignAndLbl(outTemp_derived,r,mVcrossX_p01,"mVcrossX_p01")	//new 180428	r+=1;dl_assignAndLbl(outTemp_derived,r,mVcrossX_p02,"mVcrossX_p02")	 	r+=1;dl_assignAndLbl(outTemp_derived,r,mVcrossX_p05,"mVcrossX_p05")		r+=1;dl_assignAndLbl(outTemp_derived,r,mVcrossX_p1,"mVcrossX_p1")		r+=1;dl_assignAndLbl(outTemp_derived,r,mVcrossX_p2,"mVcrossX_p2")		r+=1;dl_assignAndLbl(outTemp_derived,r,mVcrossX_p5,"mVcrossX_p5")		r+=1;dl_assignAndLbl(outTemp_derived,r,mVcrossX_1,"mVcrossX_1")		r+=1;dl_assignAndLbl(outTemp_derived,r,mVcrossX_2,"mVcrossX_2")	r+=1;dl_assignAndLbl(outTemp_derived,r,mVcrossX_5,"mVcrossX_5")				dl_assignAndLbl(outTemp_initial,0,stepLen,"stepLen")	dl_assignAndLbl(outTemp_initial,1,fitWinSize,"fitWinSize")	dl_assignAndLbl(outTemp_initial,2,numPolyFitParams,"numPolyFitParams")	dl_assignAndLbl(outTemp_initial,3,numBaselineProportions,"numBaselineProportions")	dl_assignAndLbl(outTemp_initial,4,numStepProportions,"numStepProportions")	dl_assignAndLbl(outTemp_initial,5,defaultBaselineProportion,"defaultBaselineProportion")	dl_assignAndLbl(outTemp_initial,6,defaultStepProportion,"defaultStepProportion")	dl_assignAndLbl(outTemp_initial,7,numPolyFitParams,"numPolyFitParams")		dl_appendToLbls(outTemp_initial,0,"resp_",1,-inf,inf)	dl_appendToLbls(outTemp_derived,0,"resp_",1,-inf,inf)		String originalDataWaveRef = StringByKey("DATAWAVE", note(stimParams))	if (!ParamIsDefault(noKillStimParams))		Duplicate/O stimParams, stimNoKillTemp	endif		Concatenate/NP/O/D/Kill/DL {stimParams,outTemp_initial,outTemp_derived,baselineProportions,baselineLens,baselineAvgs,stepProportions,stepLens,stepAvgs,deltas,Rins}, VI_parOut0	Concatenate/NP/O/D/Kill/DL {VI_parOut0,thresholdProportions,thresholdVals_peakToBase,thresholdVals_peakToSS,thresholdTimes_peakToBase_Rise,thresholdTimes_peakToBase_Fall,thresholdTimes_peakToSS_Rise,thresholdTimes_peakToSS_Fall}, VI_parOut1	Concatenate/NP/O/D/Kill/DL {VI_parOut1,widthAtThresh_peakToBase,widthAtThresh_pB_pSS,timeToThresh_peakToBase_Rise,timeToThresh_peakToBase_Fall,timeToThresh_peakToSS_Rise,timeToThresh_peakToSS_Fall}, VI_parOut2	Concatenate/NP/O/D/Kill/DL {VI_parOut2, W_fitconstants,ssFitCoefWave}, $outRef		//W_fitconstants,ssFitCoefWave}, $outRef//	Concatenate /NP /O /D /Kill {stimParams,outTemp_initial,outTemp_derived,baselineProportions,baselineLens,baselineAvgs,stepProportions,stepLens,stepAvgs,deltas,Rins,W_fitconstants,ssFitCoefWave}, $outRef		Note $outRef, "analysis_step1site();DATAWAVE:" + outRef + ";STIMPARAMSWAVE:" + stimParamsRef + ";STIMWAVE:" + originalDataWaveRef +";"	if (!ParamIsDefault(noKillStimParams))		Duplicate/O stimNoKillTemp, $stimParamsRef	endif	if (strlen(polyFitSaveRef) > 0)		Duplicate/O VI_step1sitePolyFitTemp, $polyFitSaveRef	endif		if (!ParamIsDefault(cellName))		Note $outRef "CELLNAME:" + cellName +";"	endif	end//analysis_step1site()//main bridge function. but you could just use the subfunction analysis_bridge_apply to apply the same bridge resistance values to other wavesfunction analysis_bridge_calcApply(num_pipette_vals,stimFam,respFam,baselineStartX,baselineEndX,bridgeStepChangeStartX,lastNegativeStep,zeroCurrentStep,outRef,attemptWaveReload,[bridgeValsSaveRef])	Variable num_pipette_vals	//how many r values to use (how many points should be adjusted).. usually 2 is a good choice (at least for 20 kHz sample rate)	String stimFam,respFam	Variable baselineStartX,baselineEndX	//region over which stimulus baseline is measured (by an average)	Variable bridgeStepChangeStartX		//same start X as for analysis_cmd_stepChange..where to search for the step change that will be the basis for bridge balance	Variable lastNegativeStep,zeroCurrentStep		//position in stim family of last negative current step and step with no step change (if present.. pass +/-inf for no positive/negative steps, NaN for no zero current step	String outRef		//all stats in calculation .. kind of interesting to see spread of Rvals	Variable attemptWaveReload		//attempt wave reload from file (Requires loading via fileDirectory)	String bridgeValsSaveRef	//optionally pass a ref into which just the bridge ("R" for resistance / impedence) vals are to be saved		String rVals_temp = "analysis_bridge_calcApp_r"		analysis_bridge_calc(stimFam,respFam,bridgeStepChangeStartX,lastNegativeStep,zeroCurrentStep,outRef,rVals_temp,attemptWaveReload)	wave printwv=$rVals_temp//	print "rVals_temp",rVals_temp,printwv,"respFam1",stringfromlist(0,respFam)	analysis_bridge_apply($rVals_temp,num_pipette_vals,stimFam,respFam,baselineStartX,baselineEndX,attemptWaveReload)	if ( !ParamIsDefault(bridgeValsSaveRef) && (strlen(bridgeValsSaveRef) > 0) )		duplicate/o $rVals_temp,$bridgeValsSaveRef		Print "analysis_bridge_calcApply() bridgeVals saved in",bridgeValsSaveRef	endifendfunction analysis_bridge_apply(r_pipette_vals,num_pipette_vals,stimFam,respFam,baselineStartX,baselineEndX,attemptWaveReload)	WAVE/d r_pipette_vals		//as generated by analysis_bridge_calc	Variable num_pipette_vals	//how many r values to use (how many points should be adjusted).. usually 2 is a good choice	String stimFam,respFam	Variable baselineStartX,baselineEndX		//region over which stimulus baseline is measured (by an average)	Variable attemptWaveReload		//attempt wave reload from file (Requires loading via fileDirectory)		//da_fd_loadWaveFromWaveName(waveRef)		if (numtype(num_pipette_vals))		num_pipette_vals = 2	endif		String noteStr="analysis_bridge_apply_vals:",temp	variable i	for (i=0;i<num_pipette_vals;i+=1)		sprintf temp,"%3.10e,",r_pipette_vals[i]		notestr+=temp	endfor	notestr+=";analysis_bridge_apply_num_pipette_vals:"+num2str(num_pipette_vals)+";analysis_bridge_apply_baselineStartX:"+num2str(baselineStartX)+";analysis_bridge_apply_baselineEndX:"+num2str(baselineEndX)+";"	noteStr+="analysis_bridge_apply_attemptWaveReload:"+num2str(attemptWaveReload)+";"		Variable j; string respRef	double stim_baseline,resp_baseline, total_r = 0	for (j=0;j<num_pipette_vals;j+=1)		for (i=0;i<itemsinlist(stimfam);i+=1)			WAVE/D stim = $stringfromlist(i,stimFam)			stim_baseline = mean(stim,baselineSTartX,baselineEndX)			respRef = stringfromlist(i,respFam)			if (attemptWaveReload)				da_fd_loadWaveFromWaveName(respRef)		//one can check whether the reload was successful by looking at IGOR_WAVE_CREATION_TIME and IGOR_WAVE_CREATION_DATE in wave note			endif			WAVE/D resp = $respRef			resp_baseline = mean(resp,baselineSTartX,baselineEndX)						resp -= (stim-stim_baseline) * (r_pipette_vals[j]) //- total_r)						if (j==0)				note/nocr resp,noteStr			endif		endfor		total_r += r_pipette_vals[j]	endforendfunction analysis_bridge_apply_wn(r_pipette_vals,num_pipette_vals,stimFam,respFam,baselineStartX,baselineEndX,attemptWaveReload,addBackInstead)	WAVE/d r_pipette_vals		//as generated by analysis_bridge_calc	Variable num_pipette_vals	//how many r values to use (how many points should be adjusted).. usually 2 is a good choice	String stimFam,respFam	Variable baselineStartX,baselineEndX		//region over which stimulus baseline is measured (by an average)	Variable attemptWaveReload		//attempt wave reload from file (Requires loading via fileDirectory)	Variable addBackInstead		if (numtype(num_pipette_vals))		num_pipette_vals = dimsize(r_pipette_vals,0)			//different from standard for vi, wn only generates as many as requested (for better or worse	endif		Variable i; string respRef	for (i=0;i<itemsinlist(stimfam);i+=1)		WAVE/D stim = $stringfromlist(i,stimFam)		respRef = stringfromlist(i,respFam)		if (attemptWaveReload)			da_fd_loadWaveFromWaveName(respRef)		endif		WAVE/D resp = $respRef		wn_autobridge_subtract(resp,stim,r_pipette_vals,baselineStartX,baselineEndX)//,addBackInstead)	endforendfunction analysis_bridge_calc(stimFam,respFam,bridgeStepChangeStartX,lastNegativeStep,zeroCurrentStep,outRef_all,outRef_bridge,attemptWaveReload)	String stimFam,respFam	Variable bridgeStepChangeStartX		//same start X as for analysis_cmd_stepChange..where to search for the step change that will be the basis for bridge balance	Variable lastNegativeStep,zeroCurrentStep		//position in stim family of last negative current step and step with no step change (if present.. pass +/-inf for no positive/negative steps, NaN for no zero current step	String outRef_all		//all stats in calculation .. kind of interesting to see spread of Rvals	String outRef_bridge	//just bridge values	Variable attemptWaveReload			Variable kill_outref_all = 0	if (strlen(outRef_all) < 1)		//no outref all provided		outRef_all = "analysis_outref_all_temp"		kill_outref_all = 1	endif		if (attemptWaveReload)		da_fd_loadWavesFromWaveName(respFam,0)	endif	Variable i,count=0, num = itemsinlist(stimFam); string stimRef, respRef, outRef_1d = "outRef_1d", outRef_1d_v2 = "analysis_bridge_v2_temp"	//latter only necessary because of dim label bug	Variable len_p = 5, t0_p	Make/O/D/N=(len_p) stim_vals, resp_vals, R_vals		//stim and response values at start of step and some number of points (==len_p) out, and there ratio (resistance)	dl_lblByIndAndWvName(stim_vals,0,"")				//labels dimensions as "stim_vals+num2str(p)	dl_lblByIndAndWvName(resp_vals,0,"")		dl_lblByIndAndWvName(R_vals,0,"")		for (i=0;i<num;i+=1)		if (i == zeroCurrentStep)			continue		//skip this iteration through loop		endif				stimRef = stringfromlist(i,stimFam)		WAVE stim = $stimRef		respRef = stringfromlist(i,respFam)		WAVE resp = $respRef		analysis_cmd_stepChange(stim,1,bridgeStepChangeStartX, i <= lastNegativeStep ,outRef_1d,"")				if (count==0)			WAVE out_1d = $outRef_1d		endif					t0_p = out_1d[%t0_start_P]		stim_vals = stim[t0_p + 1 + p] - stim[t0_p]		resp_vals = resp[t0_p + 1 + p] - resp[t0_p]		R_vals = resp_vals / stim_vals		//		print "t0_p",t0_p,"error",out_1d[%error],"stepThreshold",out_1d[%stepThreshold]				concatenate/NP=0/DL/O {$outRef_1d,stim_vals,resp_vals,R_vals}, $outRef_1d_v2/wave=out_1d_v2				//store results		if (i==0)			Duplicate/O $outRef_1d_v2,$outRef_all/wave=out			Redimension/N=(-1,count+1) out		else			Redimension/N=(-1,count+1) out			out[][count] = out_1d_v2[p]		endif				SetDimLabel 1,count,$respRef,out		count += 1			endfor		variable numRowsOut = dimsize(out,0)	variable numColsOut = dimsize(out,1)		Redimension/N=(-1,numColsOut + 1) out		//add a column to store average across all other columns	SetDimLabel 1,numColsOut,AVG,out	numColsOut += 1		Make/O/B/U/N=(numRowsOut,numColsOut) analysis_bridge_wstats_temp		for (i=0;i<numRowsOut;i+=1)		analysis_bridge_wstats_temp[][] = 1		analysis_bridge_wstats_temp[i][0,numColsOut-2] = 0		//only current row set to 1, all columns except last		ImageStats/R=analysis_bridge_wstats_temp/M=1 out		out[i][numColsOut-1] = V_avg	endfor		if (strlen(outRef_bridge) > 0)		analysis_bridge_rValsFromParams(out,outRef_bridge)	endif		killwaves/Z analysis_bridge_wstats_temp, t0_p,stim_vals,resp_vals,r_Vals, $outRef_1d//, $outRef_1d_v2		if (kill_outref_all)		killwaves/z $outRef_all	endif	end//end analysis_bridge()function analysis_bridge_rValsFromParams(paramsWv,outRef_rVals)	WAVE/D paramsWv; String outRef_rVals		Variable r_vals_start = FindDimLabel(paramsWv, 0, "R_vals0" )	Variable num_r_vals = dimsize(paramsWv,0) - r_vals_start	Make/O/D/N=(num_r_vals) $outRef_rVals/wave=out_bridge	dl_lblByInd("out_bridge",0,"R_vals",1)	out_bridge = paramsWv[r_vals_start + p]	endfunction analysis_bridge_applyToList(respFam,stimFam,bridgeValsRef,num_pipette_vals,bridgeType,baselineStartX,baselineEndX,attemptWaveReload,addBackInstead)		String respFam,stimFam		Variable bridgeType			//format of bridge reistance values: -1 for for no bridge balance, 0 for format generated by wn, 1 for VI format	String bridgeValsRef		//reference to bridge bals, "" ok for bridgeType == -1	Variable baselineStartX,baselineEndX	//baseline start x and baseline end x for bridge balance zero mean	Variable num_pipette_vals	//how many of the bridgeVals should be used (2 is standard)	Variable attemptWaveReload	Variable addBackInstead	//only for WN for now		if (bridgeType < 0)		return bridgeType	elseif (bridgeType == 1)		//vi type		analysis_bridge_apply($bridgeValsRef,num_pipette_vals,stimFam,respFam,baselineStartX,baselineEndX,attemptWaveReload)	elseif (bridgeType == 0)		//wn type		analysis_bridge_apply_wn($bridgeValsRef,num_pipette_vals,stimFam,respFam,baselineStartX,baselineEndX,attemptWaveReload,addBackInstead)	else		return -inf	endif	end//uses analysis_cmd_stepChange twice to find timing of start of a step and endfunction analysis_cmd_pulse(wv,isCC,searchStartX,isNegativeStep,outRef,preAppendLbl[storeAndOrForceMinStepSize])	WAVE wv	Variable isCC,searchStartX,isNegativeStep		//info on step. searchStartX should be some amount ahead of step	Double &storeAndOrForceMinStepSize	String outRef	String preAppendLbl		//lbl to append at start of outRef row dim labels. can be ""; "cmd" is suggested		String rise_temp =  "analysis_cmd_pulse_rise_temp", fall_temp =  "analysis_cmd_pulse_fall_temp"	String rise_lbl = preAppendLbl + "ri_"		//for rise	String fall_lbl = preAppendLbl + "fa_"		Double minStepSize = NaN	//allows minStepSize to be set by analysis_cmd_stepChange defaults (unless passed)		if (!ParamIsDefault(storeAndOrForceMinStepSize))		minStepSize = storeAndOrForceMinStepSize	endif	//	analysis_cmd_stepChange(wv,isCC,searchStartX,isNegativeStep,rise_temp,rise_lbl,storeAndOrForceMinStepSize=minStepSize)		WAVE/D rise = $rise_temp		variable numPntsBeforeSearchStart = 5		//want to make sure mean measurement happens after step change is complete		Variable step_searchStartX = rise[%$(rise_lbl+"t0_end_x")] + (numPntsBeforeSearchStart * dimdelta(wv,0)) + rise[%$(rise_lbl+"meanDurX")]		//baseline level determined by avg from (this position - meanDurX) to this value		analysis_cmd_stepChange(wv,isCC,step_searchStartX,!isNegativeStep,fall_temp,fall_lbl,storeAndOrForceMinStepSize=minStepSize)		concatenate/O/NP=0/DL/kill {rise,$fall_temp}, $outRefendfunction analysis_cmd_stepChange(wv,isCC,searchStartX,isNegativeStep,outRef,preAppendLbl[storeAndOrForceMinStepSize])	WAVE wv	Variable isCC,searchStartX,isNegativeStep	Double &storeAndOrForceMinStepSize	String outRef	String preAppendLbl		//lbl to append at start of outRef row dim labels. can be ""; "cmd" is suggested		Variable meanDurX = 0.004			//size of baseline and step measurements to avg .. keep relatively small to avoid edge effects, but setting larger might allow more accuracy if high noise in wave	Variable numSDsForMinStepSize = 6		//# sds away from baseline mean to set threshold at	Variable preCheckForStep = 1		variable edgeBaseAveraging = 1	variable edgePadding = 0.01	variable cmd_t0Threshold = .04	//see edgestats for more details		Double baselineMean = mean(wv,searchStartX-meanDurX,searchStartX)	Double baselineSD = sqrt(variance(wv,searchStartX-meanDurX,searchStartX))	Double minStepSize = baselineSD * numSDsForMinStepSize	//	Double minStepLevel = isCC ? .05*10^-12 : 0.0003		//in A or V	//handle parameterized version	if (!ParamIsDefault(storeAndOrForceMinStepSize))		if (numtype(storeAndOrForceMinStepSize))			//non-real input, set to used (default) step size			storeAndOrForceMinStepSize = minStepSize		else				//real input, use this for the step size			minStepSize = storeAndOrForceMinStepSize		endif	endif		Double stepThreshold = baselineMean + minStepSize * (isNegativeStep ? -1 : 1)		//initial (simple) check that step might actually exist	Variable error = 0	if (preCheckForStep)		if (isNegativeStep)			if (wavemin(wv) > stepThreshold)		//is largest change from baseline LESS negative than (negative-going) threshold?				error = 1			endif		else			if (wavemax(wv) < stepThreshold)		//converse for a positive going threshold				error = 1			endif		endif	endif			Double stepStart, stepEnd,stepMean,t0_start_P,t0_mid_P,t0_end_P,t0_start_X,t0_mid_X,t0_end_X,deltaMean	if (!error)		Make/O/N=2/D levels		FindLevels/Q/D=levels/R=(searchStartX,) wv, stepThreshold				if (V_flag == 2)			error = 2		else					stepStart = levels[0]			stepEnd = dimsize(levels,0) > 1 ? levels[1]	: NaN							//find step start at set threshold, track baseline and step values as well			EdgeStats/P/Q/A=(edgeBaseAveraging)/F=(cmd_t0Threshold)/R=(stepStart-edgePadding, stepStart + edgePadding) wv			t0_start_P = V_EdgeLoc1			t0_mid_P = V_EdgeLoc2			t0_end_P = V_EdgeLoc3			t0_start_X=pnt2x(wv,t0_start_P)			t0_mid_X=pnt2x(wv,t0_mid_P)			t0_end_X=pnt2x(wv,t0_end_P)			stepMean = mean(wv,t0_end_X,t0_end_X+meanDurX)				deltaMean = stepMean - baselineMean	 		 				 endif		 	endif			Variable numParams = 26	Make/O/D/N=(numParams) $outRef/wave=out	variable r=-1	r+=1;dl_assignAndLbl(out, r, isCC,preAppendLbl+ "isCC")	r+=1;dl_assignAndLbl(out, r, searchStartX,preAppendLbl+ "searchStartX")	r+=1;dl_assignAndLbl(out, r, ParamIsDefault(storeAndOrForceMinStepSize) ? NaN : storeAndOrForceMinStepSize,preAppendLbl+ "storeAndOrForceMinStepSize")	r+=1;dl_assignAndLbl(out, r, meanDurX,preAppendLbl+ "meanDurX")	r+=1;dl_assignAndLbl(out, r, numSDsForMinStepSize,preAppendLbl+ "numSDsForMinStepSize")	r+=1;dl_assignAndLbl(out, r, preCheckForStep,preAppendLbl+ "preCheckForStep")	r+=1;dl_assignAndLbl(out, r, edgeBaseAveraging,preAppendLbl+ "edgeBaseAveraging")	r+=1;dl_assignAndLbl(out, r, edgePadding,preAppendLbl+ "edgePadding")	r+=1;dl_assignAndLbl(out, r, baselineMean,preAppendLbl+ "baselineMean")	r+=1;dl_assignAndLbl(out, r, baselineSD,preAppendLbl+ "baselineSD")	r+=1;dl_assignAndLbl(out, r, minStepSize,preAppendLbl+ "minStepSize")	r+=1;dl_assignAndLbl(out, r, cmd_t0Threshold,preAppendLbl+ "cmd_t0Threshold")	r+=1;dl_assignAndLbl(out, r, stepStart,preAppendLbl+ "stepStart")	r+=1;dl_assignAndLbl(out, r, stepEnd,preAppendLbl+ "stepEnd")	r+=1;dl_assignAndLbl(out, r, t0_start_P,preAppendLbl+ "t0_start_P")	r+=1;dl_assignAndLbl(out, r, t0_mid_P,preAppendLbl+ "t0_mid_P")	r+=1;dl_assignAndLbl(out, r, t0_end_P,preAppendLbl+ "t0_end_P")	r+=1;dl_assignAndLbl(out, r, t0_start_X,preAppendLbl+ "t0_start_X")	r+=1;dl_assignAndLbl(out, r, t0_mid_X,preAppendLbl+ "t0_mid_X")	r+=1;dl_assignAndLbl(out, r, t0_end_X,preAppendLbl+ "t0_end_X")	r+=1;dl_assignAndLbl(out, r, V_EdgeLvl0,preAppendLbl+ "V_EdgeLvl0")	r+=1;dl_assignAndLbl(out, r, V_EdgeLvl4,preAppendLbl+ "V_EdgeLvl4")	r+=1;dl_assignAndLbl(out, r, stepMean,preAppendLbl+ "stepMean")	r+=1;dl_assignAndLbl(out, r, deltaMean,preAppendLbl+ "deltaMean")	r+=1;dl_assignAndLbl(out, r, stepThreshold,preAppendLbl+ "stepThreshold")	r+=1;dl_assignAndLbl(out, r, error,preAppendLbl+ "error")	//	if (stringmatch(nameofwave(wv),"G16091905_0006_1_AD1") && isNegativeStep)//		PRInt "--CMD INFO--"//		print/d "minStepSize",minStepSize,"baselineMean",baselineMean,"stepStart",stepStart,"stepEnd",stepend,"t0_start_P",t0_start_P//		Print/d "stepMean",stepMean,"deltaMean",deltaMean//		print "--CMD INFO END--"//	endifend//analysis_cmd()function absDist(coordsRef)	String coordsRef		Duplicate/O $coordsRef, coordsTempA		Make/O/N=(1,3) deltaCoords 	//will store change from point to point for each dimension (x,y,z)		Variable i,j, absDist = 0	for (i=1; i<DimSize(coordsTempA,0);i+=1)		deltaCoords = coordsTempA[i][q][r] - coordsTempA[i-1][q][r]		//calculate delta for x, y, z dimensions		absDist += sqrt((deltaCoords[0][0]^2) + (deltaCoords[0][1]^2) + (deltaCoords[0][2]^2))	endfor		Print "absDist",absDist	Note $coordsRef, "ABS DIST:" + num2str(absDist) + ";"	return absDistendfunction rescaleCoords(coordsRef)		//assumes that coords is some # rows * 3 cols. col 0 =x, 1=y,2=z									//converts to x and y to microns based on scale factor set below									//stores original pixel values in additional appended cols, one for each original col	String coordsRef		Variable xScaleFactor = 100/1050		//microns per pixel for 60X2X	Variable yScaleFactor = xScaleFactor	Variable zScaleFactor = 1/1			//micron spacing between slices (microns per slice) for z axis		Duplicate/O $coordsRef, coordsTemp	Redimension/N=(DimSize(coordsTemp,0),DimSize(coordsTemp,1) * 2) coordsTemp		coordsTemp[][(DimSize(coordsTemp,1)/2),DimSize(coordsTemp,1)-1] = coordsTemp[p][q-3]	coordsTemp[][0] *= xScaleFactor 		//pixels * microns/pixel = microns	coordsTemp[][1] *= yScaleFactor 			coordsTemp[][2] *= zScaleFactor	Note coordsTemp, "SCALE FACTOR (x,y,z):" + num2str(xScaleFactor) + ","  + num2str(yScaleFactor) + "," + num2str(zScaleFactor) + ";"endfunction saveCoords(coordsRef, cellName, albumName)	String coordsRef	String cellName	String albumName		String coordsAppendString = "_Coords"		//check file save path and move on, first declaring the global string that stores the save path, only if this path has been set using fio_setDataSavePath()	if (fio_checkGlobalFilePath())			//check path returns non-zero if there are any problems with symbolic path		Print "aborted in analysis_SSVI because file save path not set! Use fio_setDataSavePath()"		return 0	endif	SVAR/Z dataSavePathName				//this should be a global string with the name of the path that is set by fio_setDataSavePath()				Duplicate/O $coordsRef, $(cellName + coordsAppendString)		Note $(cellName + coordsAppendString), "CELL NAME:" + cellName + ";ALBUM NAME:" + albumName + ";"	SAVE/C/O/P=$dataSavePathName $(cellName + coordsAppendString)endfunction newCoords()	Make/O/N=(1,3) coordsTemp	Edit/K=1 coordsTemp	Print "Coords Name = coordsTemp"endfunction addWN(injectionSite, somaFirst, summaryRef, dist)	String summaryRef; Variable dist, injectionSite, somaFirst		String waves = TraceNameList("",";",1)		Variable somaPos, pedPos, stimPos		String injectionSiteIndicator		if (injectionSite == 0)		//injection at soma		injectionSiteIndicator = "S"		if (somaFirst == 1)			somaPos = 0; pedPos = 2; stimPos = 1		else			somaPos = 2; pedPos = 0; stimPos = 3		endif	else					//injection at ped		injectionSiteIndicator = "P"		if (somaFirst == 1)			somaPos = 0; pedPos = 2; stimPos = 3;		else			somaPos = 2; pedPos = 0; stimPos = 1;		endif	endif		if (WaveExists($summaryRef))		Duplicate/O/T $summaryRef, summaryTemp		Redimension/N=(DimSize(summaryTemp,0)+1, DimSize(summaryTemp,1)) summaryTemp	else				Make/O/T/N=(1,7) summaryTemp		Duplicate/O/T summaryTemp, $summaryRef		Edit/K=1 $summaryRef	endif		Variable currRow = DimSize(summaryTemp,0)-1	summaryTemp[currRow][0] = StringFromList(stimPos, waves)	summaryTemp[currRow][1] = StringFromList(somaPos, waves)	summaryTemp[currRow][2] = StringFromList(pedPos, waves)	summaryTemp[currRow][3] = num2str(dist)	summaryTemp[currRow][4] = StringFromList(stimPos, waves)[0,8]	summaryTemp[currRow][5] = StringFromList(stimPos, waves)[10,13]	summaryTemp[currRow][6] = injectionSiteIndicator		Duplicate/O/T summaryTemp, $summaryRef	end//File (abf) indexing function. //Makes or adds to a text wave//one row per file, 0th column is file name//1st column is full path as originally loaded//2nd column is CURRENT path up to folder containing folder that has the file <--means that only this has to be updated if using same organization on another hard drive//3rd column is folder containing the file (should remain constant)//4th column  is extension//should reconstruct CURRENT complete path, which is all that is needed to load by col 2 + col 3 + col 0 + "." + col 4//translation: (path to parent folder) +  (path to file folder) + ":" + (file name) + "." +file extension   (colon needed before file name but not before path to subfolder because of how built in functions are workingfunction fd_abfIndexer(indexedPathsRef)	String indexedPathsRef		Variable numColsForIndex = 5	Variable fileNameCol = 0, loadPathCol = 1, currParentPathCol = 2, currSubFolderCol = 3, currExtensionCol = 4		String pathSepStr = ":"		//Igor default	    	Variable refNum								    	String outputPaths //variable to store a carriage-return delimited list of the paths of the files selected    	String fileFilters = "ABF Files (*.abf):.abf;"			//when called by the Open function, this string determines what types of file formats will show    	fileFilters += "All Files:.*;"						        	Open/D/R/MULT=1/F=fileFilters refNum			//creates dialogue box for user to select files. Does not open files    	outputPaths = S_fileName    	    	Variable numSelFiles = ItemsInList(outputPaths,"\r")    	    	Print "Paths = " + outputPaths        	Variable firstNewRow   	if (strlen(outputPaths) == 0)						//aborts if 0 files selected (e.g. user hits cancel in dialogue)        	Print "Cancelled load, no files selected"		return 0   	endif   	if (WaveExists($indexedPathsRef))   		Duplicate/O/T $indexedPathsRef, indexedPathsTemp   		firstNewRow = DimSize(indexedPathsTemp,0)   		Redimension/N=(DimSize(indexedPathsTemp,0)+numSelFiles, DimSize(indexedPathsTemp,1)) indexedPathsTemp		//add rows for new file paths   	else   		Make/O/T/N=(numSelFiles,numColsForIndex) indexedPathsTemp   		firstNewRow = 0   	endif   	String currentPath   	Variable i, currentRow   	for (i=0;i<numSelFiles;i+=1)   		currentPath = StringFromList(i, outputPaths,"\r")   		currentRow = firstNewRow + i   		indexedPathsTemp[currentRow,1][fileNameCol] = ParseFilePath(3,currentPath,pathSepStr,0,0)		//grabs file name without extension   		indexedPathsTemp[currentRow,1][loadPathCol] = currentPath		//1st column is ORIGINAL full path   		indexedPathsTemp[currentRow,1][currParentPathCol] = ParseFilePath(1,currentPath,":",1,1)		//2nd col grabs up to parent folder   		indexedPathsTemp[currentRow,1][currSubFolderCol] = ParseFilePath(0,currentPath,":",1,1)		//3rd col grabs only file folder (in which file is directly stored) (no extension or period)   		indexedPathsTemp[currentRow,1][currExtensionCol] = ParseFilePath(4,currentPath,pathSepStr,0,0)			//grabs extension NO PERIOD    	endfor    	    	Duplicate/O/T indexedPathsTemp, $indexedPathsRef    	KillWaves/Z indexedPathsTempendfunction/S recreatePathInIndex(fileRow, indexedPathsRef)	Variable fileRow; String indexedPathsRef		Duplicate/O/T $indexedPathsRef, indexedPathsTemp		//must match fd_abfIndexer function	Variable fileNameCol = 0, loadPathCol = 1, currParentPathCol = 2, currSubFolderCol = 3, currExtensionCol = 4	String recreatedPath = indexedPathsTemp[fileRow][currParentPathCol] + indexedPathsTemp[fileRow][currSubFolderCol] + ":" + indexedPathsTemp[fileRow][fileNameCol] + "." + indexedPathsTemp[fileRow][currExtensionCol]	KillWaves/Z indexedPathsTemp		return recreatedPathendfunction sort2DWaveByCol(sortColNum, ref)	Variable sortColNum; String ref		Duplicate/O/T $ref, waveToSortTemp		Variable numRows  = DimSize(waveToSortTemp,0)	Variable numCols = DimSize(waveToSortTemp,1)		Duplicate/T/O/R=[][sortColNum] waveToSortTemp, sortKey		Variable i	for (i=0; i< numCols;i+=1)		Duplicate/T/O/R=[][i] waveToSortTemp, temp		//excise current column and store in temp		Sort sortKey, temp							//sorts indexes based on values in sortKey, rearranges temp by those index swaps				waveToSortTemp[][i] = temp[p]	 //row through each row of column i in wave to sort temp, get index of each row, and store the cell at that index in that index of the array to sort		//cant figure out why this is giving an error out of range for temp, but seems to be working	endfor		Duplicate/O waveToSortTemp, $ref	KillWaves/Z temp, waveToSortTempendfunction getFileSubset(fileSelListRef, fileDirectoryRef, outputSubsetRef)	String fileSelListRef, fileDirectoryRef, outputSubsetRef		Variable assumeStandardFileFormat = 1		//e.g. G15041100_0000, file names are 14 chars e.g. [0,13]		Variable fileNameCol = 0		//must match other functions!		Duplicate/O/T $fileSelListRef, fileSelListTemp	Duplicate/O/T $fileDirectoryRef, fileDirectoryTemp	String listToSearch = ""		//make a string list from file names column in fileDirectoryTemp so we can use igor seach function (probably inefficient)	Variable i	for (i=0;i<DimSize(fileDirectoryTemp,0);i+=1)		listToSearch += fileDirectoryTemp[i][fileNameCol] + ";"		endfor		Variable currSelIndex	String currFileName	Variable filesFound = 0	for (i=0;i<DimSize(fileSelListTemp,0);i+=1)		currFileName = fileSelListTemp[i]		if (assumeStandardFileFormat)			currFileName = currFileName[0,13]		endif		currSelIndex = WhichListItem(currFileName, listToSearch, ";")		if (currSelIndex < 0)			Print "Could not find: " + currFileName + " in file directory"		else			if (filesFound == 0)				Make/O/T/N=(1, DimSize(fileDirectoryTemp,1)) outputSubsetTemp			else				Redimension/N=(DimSize(outputSubsetTemp,0)+1, -1) outputSubsetTemp			endif			filesFound +=1			outputSubsetTemp[DimSize(outputSubsetTemp,0)-1][] = fileDirectoryTemp[currSelIndex][q]	//transfer whole row over to output subset temp row		endif	endfor		Duplicate/O outputSubsetTemp, $outputSubsetRef		KillWaves/Z fileSelListTemp, fileDirectoryTempendfunction removeCharsFromTWave(textWaveRef, numChars)	String textWaveRef; Variable numChars		Duplicate/O/T $textWaveRef, textWaveTemp		Variable i; String currStr	for (i=0; i<DimSize(textWaveTemp,0);i+=1)		currStr = textWaveTemp[i]		textWaveTemp[i] = currStr[0,strlen(currStr)-numChars-1]	endfor		Duplicate/O textWaveTemp, $textWaveRef	Killwaves/Z textWaveTempendfunction/S getWaveRowColAsStringList(waveRef,dimNum,dimIndex,sepStr)	String waveRef, sepStr	Variable dimNum	//0= row, 1 = col. Higher not supported	Variable dimIndex		//if 0 = rows, then this is picking the dimIndex-th Row 		if (strlen(sepStr) < 1)		sepStr=";"	endif		Variable i	if (dimNum == 0)		Duplicate/T/O/R=[dimIndex][0,DimSize($waveRef,1)-1]/free $waveRef, toListTemp		MatrixTranspose toListTemp 	else		Duplicate/T/O/R=[0,DimSize($waveRef,0)-1][dimIndex]/free $waveRef, toListTemp	endif		String outputList = ""	for (i=0;i<DimSize(toListTemp,0);i+=1)		outputList += toListTemp[i] + sepStr	endfor		return outputListend//Modified from Igor Exchange andyfaff	December 8, 2010 - 17:12 (modified to allow any sep str)Function/t text_removeStringListDuplicates(listStr, sepStr[dupListSaveStr,returnDupsInstead])	String listStr, sepStr	String dupListSaveStr	//optionally pass to get a list of duplicates	Variable returnDupsInstead		if (!strlen(sepStr))		sepStr = ";"	endif 	String retStr = "",dupList = ""	variable ii	for(ii = 0 ; ii < itemsinlist(listStr, sepStr) ; ii+=1)		if(whichlistitem(stringfromlist(ii , listStr, sepStr), retStr, sepStr) == -1)			retStr = addlistitem(stringfromlist(ii, listStr , sepStr), retStr, sepStr, inf)		else			dupList = addlistitem(stringfromlist(ii, listStr , sepStr), dupList, sepStr, inf)		endif			endfor			if (!ParamIsDefault(dupListSaveStr) && strlen(dupListSaveStr))		String/G $dupListSaveStr		SVAR out_dupList = $dupListSaveStr		out_dupList=dupList	endif		if (!PAramISDefault(returnDupsInstead) && returnDupsInstead)		return dupList	endif		return retStrEnd//From user "Igor" on Igor Exchange. Posted Oct. 29, 2010//for estimating actual size of  wave based on number of samples. size ~= sizeOfType() * numSamplesFunction sizeOfType(inType)		//returns size in bytes per sample. 	Variable inType 	Variable size=1	if(inType & 0x01)		size*=2	endif 	if(inType & 0x02)		size*=4	elseif(inType & 0x04)		size*=8	elseif(inType & 0x10)		size*=2	elseif(inType & 0x20)		size*=4	elseif(inType==0)		size=nan	endif	return sizeEndfunction setStepTiming()	WAVE brkInStepTiming	NVAR numOfPrimaryFile	NVAR firstStepStartX, firstStepEndX, secondStepStartX,secondStepEndX		brkInStepTiming[numOfPrimaryFile][0] = firstStepStartX	brkInStepTiming[numOfPrimaryFile][1] = firstStepEndX	brkInStepTiming[numOfPrimaryFile][2] = secondStepStartX	brkInStepTiming[numOfPrimaryFile][3] = secondStepEndXendfunction getStepTiming()	WAVE brkInStepTiming	NVAR numOfPrimaryFile	NVAR firstStepStartX, firstStepEndX, secondStepStartX,secondStepEndX	firstStepStartX= brkInStepTiming[numOfPrimaryFile][0]	firstStepEndX= brkInStepTiming[numOfPrimaryFile][1]	secondStepStartX = brkInStepTiming[numOfPrimaryFile][2]	secondStepEndX = brkInStepTiming[numOfPrimaryFile][3]endfunction recreateBrkIn(fileStartString)	String filestartString		//i.e. "G15091701*"		Variable stepStartBuffer = 0.0005		//in sec	Variable stepWinSize = 0.007			//in sec		String sealCurrents, wcCurrents, wcSubbedCurrents, wcMonoFits, wcDblFits, wcDblFits_C1, wcDblFits_C2	//	sealCurrents = waveList(fileStartString + "*CPSa",";","")	wcCurrents = waveList(fileStartString + "*CPBa",";","")	wcSubbedCurrents = waveList(fileStartString + "*CPSu",";","")	wcMonoFits = waveList(fileStartString + "*CPFi",";","")	wcDblFits = waveList(fileStartString + "*CPFdl",";","")	wcDblFits_C1 = waveList(fileStartString + "*CPFc1",";","")	wcDblFits_C2 = waveList(fileStartString + "*CPFc2",";","")	//	String sealCurrentRef = StringFromList(0,sealCurrents)	String wcCurrentRef = StringFromList(0,wcCurrents)	String wcSubbedCurrentRef = StringFromList(0,wcSubbedCurrents)	String wcMonoFitRef = StringFromList(0,wcMonoFits)	String wcDblFitRef = StringFromList(0,wcDblFits)	String wcDblFit_C1Ref = StringFromList(0,wcDblFits_C1)	String wcDblFit_C2Ref = StringFromList(0,wcDblFits_C2)		Display/K=1 $wcCurrentRef/TN=wcCurrent, $wcSubbedCurrentRef/TN=wcSubbedCurrent, $wcMonoFitRef/TN=monoFit, $wcDblFitRef/TN=dblFit, $wcDblFit_C1Ref/TN=dblFit_C1, $wcDblFit_C2Ref/TN=dblFit_C2		Variable fitStart = DimOffset($wcMonoFitRef, 0)	Variable fitEnd = fitStart + DimSize($wcMonoFitRef,0)*DimDelta($wcMonoFitRef,0)		SetAxis bottom, fitStart - stepStartBuffer,  fitStart - stepStartBuffer + stepWinSize	SetAxis/A=2 left		ModifyGraph rgb(wcSubbedCurrent)=(0,0,0),lstyle(monoFit)=7;DelayUpdate	ModifyGraph rgb(monoFit)=(0,15872,65280),lstyle(dblFit)=7,rgb(dblFit)=(65280,0,0);DelayUpdate	ModifyGraph lstyle(dblFit_C1)=1,lstyle(dblFit_C2)=1	ModifyGraph lstyle(wcCurrent)=1,rgb(wcCurrent)=(0,65280,33024)	ModifyGraph lsize(monoFit)=1.5,lsize(dblFit)=1.5endfunction displayVI(num, newGraph)	Variable num, newGraph		WAVE/T displayCellVISweeps_Ped, displayCellVISweeps_Soma	if (newGraph)		Display/K=1 	endif	String currSomaList = displayCellVISweeps_Soma[num]	String currPedList = displayCellVISweeps_Ped[num]	Variable i	for (i=0;i<ItemsInList(currSomaList);i+=1)		AppendtoGraph/C=(0,0,0) $StringFromList(i, currSomaList)		AppendToGraph $StringFromList(i, currPedList)		endforendfunction displayAvgVI_M()	Killwindowsbyname("*pulse*")		Variable i	WAVE/T displayCells	displayAvgVI(0,1,1)	for (i=1;i<DimSize(displayCells,0);i+=1)		displayAvgVI(i,0,1)		endforendfunction displayAvgVI(num,newGraph, subBaseline)	Variable num, newGraph, subBaseline		Variable winBuffer = 0.025		Variable absYAxEnd = 0	Variable absYAxStart = -0.01		Variable diffYAxEnd = .001	Variable diffYAxStart = -.001		Variable firstBaseWinStart = .15	Variable firstBaseWinEnd = .2413	Variable secondBaseWinStart = 0.80644	Variable secondBaseWinEnd = 0.84196		Variable firstPulseStart = 0.24376	Variable secondPulseStart = 0.84376	Variable pulseDur = 0.3	Variable ssWinSize = pulseDur/3//	if (num == 0)//		pulsedur = 0.2	//because of weird noise in average//		ssWinSize = pulseDur/5//	endif	Variable spaceTilSSWin = pulseDur - ssWinSize		String fromSomaGraphN = "FromSomaAvg"	String fromPedGraphN = "FromPedAvg"	WAVE/T displayCellVISweeps_Soma_AVG, displayCellVISweeps_Ped_AVG, displayCellVI_AvgDiff	WAVE somaSecond, stats		Variable fromSomaWinStart, fromPedWinStart, fromPedBaseStart, fromPedBaseEnd, fromSomaBaseStart, fromSomaBaseEnd	if (somaSecond[num])		//then second pulse is from soma, first from ped		fromSomaWinStart = secondPulseStart		fromPedWinStart = firstPulseStart						fromPedBaseStart = firstBaseWinStart		fromPedBaseEnd = firstBaseWinEnd		fromSomaBaseStart = secondBaseWinStart		fromSomaBaseEnd = secondBaseWinEnd	else		fromSomaWinStart = firstPulseStart		fromPedWinStart = secondPulseStart							fromPedBaseStart = secondBaseWinStart		fromPedBaseEnd = secondBaseWinEnd		fromSomaBaseStart = firstBaseWinStart		fromSomaBaseEnd = firstBaseWinEnd	endif				if (num == 0)		Cursor/W=Graph0 A, $"G15091701_0005_5_AD0", fromSomaBaseStart		Cursor/W=Graph0 B, $"G15091701_0005_5_AD0", fromSomaBaseEnd		Cursor/W=Graph0 C, $"G15091701_0005_5_AD0", fromPedBaseStart		Cursor/W=Graph0 D, $"G15091701_0005_5_AD0", fromPedBaseEnd		Cursor/W=Graph0 E,   $"G15091701_0005_5_AD0", fromSomaWinStart		Cursor/W=Graph0 F, $"G15091701_0005_5_AD0", fromPedWinStart	endif	if (newGraph)		Display/K=1/N=somaPulses		Display/K=1/N=pedPulses		Display/K=1/N=somaPulseDiffs	endif		String somaRef = displayCellVISweeps_Soma_AVG[num]	String pedRef = displayCellVISweeps_Ped_AVG[num]	String diffRef = displayCellVI_AvgDiff[num]	//means before step	Variable somaFromSomaBaseline = mean($somaRef, fromSomaBaseStart, fromSomaBaseEnd)	Variable pedFromSomaBaseline = mean($pedRef,  fromSomaBaseStart, fromSomaBaseEnd)	Variable somaFromPedBaseline = mean($somaRef, fromPedBaseStart, fromSomaBaseEnd)	Variable pedFromPedBaseline = mean($pedRef,  fromPedBaseStart, fromSomaBaseEnd)			AppendToGraph/C=(0,0,0)/W=somaPulses $somaRef	AppendToGraph/W=somaPulses $pedRef		AppendToGraph/C=(0,0,0)/W=pedPulses $somaRef	AppendToGraph/W=pedPulses $pedRef		AppendToGraph/C=(0,0,0)/W=somaPulseDiffs $diffRef/TN=fromSomaDiff	AppendToGraph/W=somaPulseDiffs $diffRef/TN=fromPedDiff		Setaxis/W=somaPulses bottom, -winBuffer, pulseDur + winBuffer	SetAxis/W=pedPulses bottom, -winBuffer, pulseDur	+ winBuffer		Setaxis/W=somaPulses left, absYAxStart, absYAxEnd	SetAxis/W=pedPulses left, absYAxStart, absYAxEnd		SetAxis/W=somaPulseDiffs bottom, -winBuffer, pulseDur + winBuffer	SetAxis/W=somaPulseDiffs left, diffYAxStart, diffYAxEnd			if (!subBaseline)	 	somaFromSomaBaseline = 0	 	pedFromSomaBaseline = 0	 	somaFromPedBaseline = 0		pedFromPedBaseline =0	endif		ModifyGraph/W=somaPulses offset($somaRef) = {-fromSomaWinStart, -somaFromSomaBaseline}	ModifyGraph/W=somaPulses offset($pedRef) = {-fromSomaWinStart, -pedFromSomaBaseline}	ModifyGraph/W=pedPulses offset($somaRef) = {-fromPedWinStart, -somaFromPedBaseline}	ModifyGraph/W=pedPulses offset($pedRef) = {-fromPedWinStart, -pedFromPedBaseline}		ModifyGraph/W=somaPulseDiffs offset(fromSomaDiff) = {-fromSomaWinStart,0}	ModifyGraph/W=somaPulseDiffs offset(fromPedDiff) = {-fromPedWinStart,0}		//means during step	Variable somaFromSomaStepMean = mean($somaRef, fromSomaWinStart + spaceTilSSWin, fromSomaWinStart + pulseDur)	Variable pedFromSomaStepMean = mean($pedRef, fromSomaWinStart + spaceTilSSWin, fromSomaWinStart + pulseDur)	Variable somaFromPedStepMean = mean($somaRef, fromPedWinStart + spaceTilSSWin, fromPedWinStart + pulseDur)	Variable pedFromPedStepMean = mean($pedRef, fromPedWinStart + spaceTilSSWin, fromPedWinStart + pulseDur)	//deltas during step	Variable somaFromSomaDelta  = somaFromSomaStepMean - somaFromSomaBaseline		Variable pedFromSomaDelta = pedFromSomaStepMean - pedFromSomaBaseline		Variable somaFromPedDelta = somaFromPedStepMean - somaFromPedBaseline	Variable pedFromPedDelta = pedFromPedStepMean - pedFromPedBaseline	//far site / near site ratio	Variable ratioFromSoma = pedFromSomaDelta / somaFromSomaDelta	Variable ratioFromPed = somaFromPedDelta / pedFromPedDelta		stats[num][0] = somaFromSomaBaseline	stats[num][1] = pedFromSomaBaseline	stats[num][2] = somaFromPedBaseline	stats[num][3] = pedFromPedBaseline		stats[num][4] = somaFromSomaStepMean	stats[num][5] = pedFromSomaStepMean	stats[num][6] = somaFromPedStepMean	stats[num][7] = pedFromPedStepMean	stats[num][8] = somaFromSomaDelta	stats[num][9] = pedFromSomaDelta	stats[num][10] = somaFromPedDelta	stats[num][11] = pedFromPedDelta	stats[num][12] = ratioFromSoma	stats[num][13] = ratioFromPed	WAVE testCurrents		//has test pulse sizes, **** in pA ****	stats[num][14] = ratioFromPed/ratioFromSoma	stats[num][15] = somaFromSomaDelta/(testCurrents[num]*10^-12)	stats[num][16] = pedFromPedDelta/(testCurrents[num]*10^-12)		endfunction/s fd_getChanNameList(fileNum, loadedChansOnly)	Variable fileNum, loadedChansOnly		Variable numChans = fd_getChanNFromFileInfoWave(fileNum)		string out = ""	variable i		for (i=0;i<numChans;i+=1)		if (loadedChansOnly)			if (fd_isChanSelected(fileNum, i))				out += fd_getChanStrFromFileInfoWave(fileNum, i, 1)		+ ";"			endif		else			out += fd_getChanStrFromFileInfoWave(fileNum, i, 1)	+ ";"		endif	endfor		return outend//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////ITEM HANDLING////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ///////////////////// GB functions for general handling of items, e.g. kill all windows, kill all variables, kill by name, etc./////////////////////Igor Binary Wave Loader. Prompts user to select one or more Igor binary files. Loads each one by namefunction/S WL()    Variable refNum    String outputPaths								//variable to store a carriage-return delimited list of the paths of the files selected    String fileFilters = "Ifor Binary (*.ibw):.ibw;"			//when called by the Open function, this string determines what types of file formats will show    fileFilters += "All Files:.*;"						        Open/D/R/MULT=1/F=fileFilters refNum			//creates dialogue box for user to select files. Does not open files    outputPaths = S_fileName       if (strlen(outputPaths) == 0)						//aborts if 0 files selected (e.g. user hits cancel in dialogue)        	Print "Cancelled load, no files selected"        	return ""   	endif   	  	Variable numFilesSelected = ItemsInList(outputPaths, "\r") 	Variable i; String filePathStr       for(i=0; i<numFilesSelected; i+=1)		//iterates through outputPaths list           	filePathStr = StringFromList(i, outputPaths, "\r")          	//NewPath pathTemp, filePathStr          	//Loads ibw waves with their saved name          	LoadWave/W/A/H filePathStr			///W/A uses file name. /H copies the file to this experiment rather than maintaining a reference to where the file was saved          	        //  	Printf "%d: %s\r", i, filePathStr      endfor                 return outputpaths	end//General panel helper functions. Usually a subroutine called by a panel-specific functionfunction adjustLenForFFT(waveRef)	String waveRef		Duplicate/O $waveRef, waveForFFTLenAdj	Variable len = numpnts(waveForFFTLenAdj)	if (mod(len,2) != 0)		DeletePoints len-1, 1, waveForFFTLenAdj		Duplicate/O waveForFFTLenAdj, $waveRef	endif	KillWaves/Z waveForFFTLenAdj	endendfunction updateSelListByNums(selListVarName, selListByNumsVarName)    String selListVarName, selListByNumsVarName        WAVE selListTemp = $selListVarName    Variable numSelections =  sum(selListTemp)    Make/O/N=(numSelections) $selListByNumsVarName/wave=selListByNumsTemp    Variable i,j=0    for (i=0;j<numSelections; i+=1)        if (selListTemp[i] !=0)            selListByNumsTemp[j] = i            j+=1        endif    endforend//takes in wave references to a selection list  (assumes 0s and 1s) and selection list by numbers//and selects an inclusive subset based on present selectionsfunction selectInclusiveSubsetG(selListVarName, selListByNumsVarName)		String selListVarName, selListByNumsVarName			WAVE selListTemp = $selListVarName	WAVE selListByNumsTemp = $selListByNumsVarName		if (sum(selListTemp) == 0)		//nothing is selected, so abort)		Print "Make one (or better yet, multiple) selection(s) to select a subset"		return 0	endif		Variable firstSelection = selListByNumsTemp[0]	Variable lastSelection = selListByNumsTemp[numpnts(selListByNumsTemp)-1]		selListTemp = 0	selListTemp[firstSelection,lastSelection] = 1		updateSelListByNums(selListVarName, selListByNumsVarName)								//passes the wave reference to this wave into a function that updates the selection list for any list box and copies it into the passed wave refend//GENERAL FUNCTIONS. Usually for use outside of a panelfunction reverseWave(waveRef)	String waveRef	Duplicate/O $waveRef, tempWaveForRev, originalWaveForRevTemp	tempWaveForRev = originalWaveForRevTemp[numpnts(tempWaveForRev)-1-p]	Duplicate/O tempWaveForRev, $waveRef	KillWaves/Z tempWaveForRev, originalWaveForRevTempendfunction killAll(includeWindows)	Variable includeWindows		if (includeWindows)		killWindowsByName("*")	endif		KillWaves/A	KillVariables/A	KillStrings/Aendfunction killGraphsAndTables()	String temp,cmd	for(;(strlen(WinName(0,1)) > 0);)		sprintf cmd, "KillWindow %s", WinName(0,1)		Execute cmd	endfor	for(;(strlen(WinName(0,2)) > 0);)		sprintf cmd, "KillWindow %s", WinName(0,2)		Execute cmd	endforendfunction killWavesByName(matchStrOrListOf, [reportFailure, out_killedOrNeverExistedList,userPromptedWindowKilling])	String matchStrOrListOf; Variable reportFailure	String &out_killedOrNeverExistedList	//pass to get list of waves that were in list and no longer exist after attempted kill	Variable userPromptedWindowKilling		//optionally pass for user prompted killing of windows that contain a wave and thus stop its killing		Variable listOnlySuccessfullyKilledWvs = 0		//1 to list just those waves that had existed and were killed, 0 to list all waves that were in list and are no longer present		//deal with potential input of wave list	Variable i; String killList=""	for (i=0;i<ItemsInList(matchStrOrListOf);i+=1)		//works fine if input is single matchStr too		killList += WaveList(StringFromList(i,matchStrOrListOf),";","")	endfor		String currRef; variable count = 0, waveExisted, waveExistsAfterKill	String killedOrNeverExistedList = "", successList = "", failList = ""	for (i=0;i<ItemsInList(killList);i+=1)		currRef = StringFromList(i,killList)		waveExisted = WaveExists($currRef)		KillWaves/Z $currRef; count += 1		waveExistsAfterKill = WaveExists($currRef)				if (waveExistsAfterKill)			if (!ParamIsDefault(userPromptedWindowKilling) && userPromptedWindowKilling)				disp_killWinsWithWave(currRef,1,1)				doupdate				waveExistsAfterKill = WaveExists($currRef)				if (waveExistsAfterKill)					failList += currRef + ";"				else					killedOrNeverExistedList += currRef + ";"					if (waveExisted)						successList += currRef + ";"					endif				endif			else				failList += currRef + ";"			endif		else			killedOrNeverExistedList += currRef + ";"			if (waveExisted)				successList += currRef + ";"			endif		endif				if (!ParamIsDefault(reportFailure))			if (waveExistsAfterKill)				Print "In killWavesByName(matchStr), failed to kill wave = " + currRef			endif		endif	endfor		if (!paramIsDefault(out_killedOrNeverExistedList))		out_killedOrNeverExistedList = killedOrNeverExistedList	endif		return itemsInList(killedOrNeverExistedLisT)endfunction killWavesInListGeneral(waveListRef, killOriginalList)	String waveListRef; Variable killOriginalList		Duplicate/O/T $waveListRef, listOfWavesToKillTemp	Variable i    	for (i=0; i< numpnts(listOfWavesToKillTemp);i+=1)    		KillWaves/Z $listOfWavesToKillTemp[i]    	endfor    		if (killOriginalList)		KillWaves/Z $waveListRef	endif	KillWaves/Z listOfWavesToKillTempendfunction killWavesInStrList(listStr, [listDelimiterStr, reportFailures])	String listStr, listDelimiterStr		//latter optional	Variable reportFailures		String usedDelimiterStr	if (ParamIsDefault(listDelimiterStr))		usedDelimiterStr = ";"	else		usedDelimiterStr = listDelimiterStr	endif		Variable i,failures=0	String ref	for (i=0;i<ItemsInList(listStr);i+=1)		ref=StringFromList(i, listStr, usedDelimiterStr)		KillWaves/Z $ref		if (WaveExists($ref))			if (!ParamIsDefault(reportFailures))				Print "in killWavesInStrList(listStr..), failed to kill wave = " + ref			endif			failures+=1		elseif (!ParamIsDefault(reportFailures) && (reportFailures == 2)	)		//report successes			Print "killWavesInStrList(listStr..) killed " + ref		endif	endfor		return failuresend//RESAMPLING FUNCTIONS//downsamples graphed traces to an average, expects sampling ratefunction downSampleTracesOnGraphByAvg(matchStr, newSampling, useSampleDur, useTNs)	String matchStr; variable newSampling, useSampleDur, useTNs		graph_getWaveList("",matchStr, "listOfGraphedWaves", useTNs)	WAVE/T listOfGraphedWaves		Variable i	for (i=0;i<DimSize(listOfGraphedWaves,0);i+=1)		downSampleByAvg(listOfGraphedWaves[i][0], newSampling, useSampleDur)	endfor	KillWaves/Z listOfGraphedWavesendfunction downSampleByAvg(waveRef, newSampling, useSampleDur)	String waveRef; Variable newSampling, useSampleDur		Duplicate/O $waveRef, waveToDownSample, newWave		if (useSampleDur)				//then input was time/sample not sample/time, need to invert		newSampling = 1/newSampling	endif		Variable oldRate = 1/DimDelta(waveToDownSample,0)	Resample/Rate=(newSampling) newWave		//I don't know how this resampling works, but I just want it to give me back the wave with the right units, notes, LENGTH, etc. but different sampling	Variable numOldSamplesPerNewSample = oldRate/newSampling				//gives # old samples per 1 new sample. (e.g. old is 10 Hz and new is 1 Hz, every 1s the old has 10 samples and the new has 1)	Variable deltaXPerNewSample  = numOldSamplesPerNewSample * 1/oldRate		//now have old samples / new sample * sec / old sample -- > gives sec per new sample		newWave = mean(waveToDownSample,x,x+deltaXPerNewSample) //now take the average value from the start time of each sample over the duration of that sample			Duplicate/O newWave, $waveRef	KillWaves/Z newWave, waveToDownSampleend//downsample a 2D wave (matched length x and y data). At present this is quite clunky//does not overwrite but generates an output version of yRef with new sampling rate//not sure if this has any utility outside of looking at how two variables covary on average//numXBins sets how many bins will be usedfunction downsampleYX(yRef, xRef, numXBins, outRef, putOnTopGraph)	String yRef, xRef, outRef; Variable numXBins, putOnTopGraph		Duplicate/O $yRef, yWave2D, yOutTemp	Duplicate/O $xRef, xWave2D, xOutTemp	yOutTemp = 0	xOutTemp = 0		//sort x wave in ascending order so that we can then quickly go through and bin similar points together.	sort xWave2D, xWave2D, yWave2D		//using xWave2D as key but also sorting yWave rearranged yWave positions in the array as positions are rearranged for xWave during the sort		Variable xMinVal = xWave2D[0]	Variable xRange = xWave2D[numpnts(xWave2D)-1] - xWave2D[0]	Variable rangePerBin = xRange/numXBins		Make/O/D/N=(numXBins,2) binValues			//2 columns, 0 = x vals, 1 = y vals	Make/O/N=(numXBins,2) binLocs				//2 columns 0 = bin start, 1 = binEnd	Variable i, currXVal, currYVal, currBinXAvg, currBinYAvg	Variable currBinNum = 0, currNextBinThresh = xMinVal + rangePerBin, currBinLen = 0	Variable rows=dimsize(xwave2d,0)	binLocs[0][0] = 0	for (i=0;i<rows;i+=1)				if ((xWave2D[i] >= currNextBinThresh) || (i == rows - 1))		//	Print "Last Bin = " + num2str(currBinNum) + ". BinThresh(real,norm) = " + num2str(currNextBinThresh) + "," + num2str((currNextBinThresh-xMinVal)/xRange)				//store old values			binValues[currBinNum][0] = currBinXAvg / currBinLen			binValues[currBinNum][1] = currBinYAvg / currBinLen			binLocs[currBinNum][1] = i - 1				//clear values for last bin			currBinXAvg = 0			currBinYAvg = 0			currBinLen = 0				//iterate as needed			currBinNum +=1			currNextBinThresh += rangePerBin				//store start of bin			if (currBinNum < rows)				binLocs[currBinNum][0] = i			endif		endif		currBinXAvg += xWave2D[i]		currBinYAvg += yWave2D[i]		currBinLen += 1	endfor	Duplicate/O binValues, $outRef	setdimlabel 1,0,x,$outRef	setdimlabel 1,1,y,$outRef	KillWaves/Z xOutTemp, yOutTemp //,xWave2D, yWave2D		if (putOnTopGraph)		String traceName = outRef + "_binned"		AppendToGraph $outRef[][1]/TN=$traceName vs $outRef[][0]		ModifyGraph mode($traceName)=3,marker($traceName)=19,mrkThick($traceName)=2;DelayUpdate		ModifyGraph rgb($traceName)=(0,0,0)	endifend//in progress: downsamples so that each bin contains an equal number of all the pointsfunction downsampleYXFromRange_equalPs(yWv, xWv, startX, endX, numXBins, outRef, putOnTopGraph, binByYNotX)	WAVE yWv, xWv; String outRef; Variable numXBins, putOnTopGraph, startX, endX	Variable binByYNotX		//pass 0 to bin by x vals, y to bin by y vals		Duplicate/O/R=(startX, endX)/free yWv, yWave2D	Duplicate/O/R=(startX, endX)/free xWv, xWave2D		if (binByYNotX)		//sort y wave in ascending order so that we can then easily go through and bin similar points together.		sort yWave2D, yWave2D, xWave2D		//using yWave2D as key but also sorting xWave rearranged xWave positions in the array as positions are rearranged for yWave during the sort	else		//sort x wave in ascending order so that we can then easily go through and bin similar points together.		sort xWave2D, xWave2D, yWave2D		//using xWave2D as key but also sorting yWave rearranged yWave positions in the array as positions are rearranged for xWave during the sort		endif		Variable pnts = DimSize(xWave2D,0)		variable pntsPerBin = pnts/numXBins		Make/O/D/N=(numXBins,9) $outRef/wave=binValues			//2 columns, 0 = x vals, 1 = y vals, 2 = reserved for linear fit values	setdimlabel 1,0,xVals,binValues	setdimlabel 1,1,yVals,binValues	setdimlabel 1,2,linearFityVals,binValues	setdimlabel 1,3,xVariance,binValues	setdimlabel 1,4,yVariance,binValues	setdimlabel 1,5,xSD,binValues	setdimlabel 1,6,ySD,binValues	setdimlabel 1,7,xSEM,binValues	setdimlabel 1,8,ySEM,binValues		binValues[][0] = mean(xWave2D, pnt2x(xWave2D,pntsPerBin*p) , pnt2x(xWave2D,(pntsPerBin-1)*(p+1)) )	//binValues[][1] = mean(yWave2D, pnt2x(yWave2D,pntsPerBin*p) , pnt2x(yWave2D,(pntsPerBin-1)*(p+1)) )	binValues[][1] = mean(yWave2D, pnt2x(xWave2D,pntsPerBin*p) , pnt2x(xWave2D,(pntsPerBin-1)*(p+1)) )		//changed on 171024 comports with Kim and Rieke protocol		//consider adding variance, sd, sem	binValues[][3] = variance(xWave2D, pnt2x(xWave2D,pntsPerBin*p) , pnt2x(xWave2D,(pntsPerBin-1)*(p+1)) )	//x val variance	binValues[][4] = variance(yWave2D, pnt2x(xWave2D,pntsPerBin*p) , pnt2x(xWave2D,(pntsPerBin-1)*(p+1)) )	//y val variance		//variance is already sample-corrected (divided by N-1 not N) so need only take sqrt to get sd	binValues[][5] = sqrt(binValues[p][3])	binValues[][6] = sqrt(binValues[p][4])		//standard error of the mean sem	binValues[][7] = binValues[p][5] / sqrt(pntsPerBin)	binValues[][8] = binValues[p][6] / sqrt(pntsPerBin)			if (putOnTopGraph)		String traceName = outRef + "_binned"		AppendToGraph $outRef[][1]/TN=$traceName vs $outRef[][0]		ModifyGraph mode($traceName)=3,marker($traceName)=19,mrkThick($traceName)=2;DelayUpdate		ModifyGraph rgb($traceName)=(0,0,0)	endifend //downsampleYXFromRange_equalPs	Duplicate/O/R=(startX, endX)/free yWv, yWave2D	Duplicate/O/R=(startX, endX)/free xWv, xWave2D		if (binByYNotX)		//sort y wave in ascending order so that we can then easily go through and bin similar points together.		sort yWave2D, yWave2D, xWave2D		//using yWave2D as key but also sorting xWave rearranged xWave positions in the array as positions are rearranged for yWave during the sort	else		//sort x wave in ascending order so that we can then easily go through and bin similar points together.		sort xWave2D, xWave2D, yWave2D		//using xWave2D as key but also sorting yWave rearranged yWave positions in the array as positions are rearranged for xWave during the sort		endif		Variable pnts = DimSize(xWave2D,0)		variable pntsPerBin = pnts/numXBins		Make/O/D/N=(numXBins,9) $outRef/wave=binValues			//2 columns, 0 = x vals, 1 = y vals, 2 = reserved for linear fit values	setdimlabel 1,0,xVals,binValues	setdimlabel 1,1,yVals,binValues	setdimlabel 1,2,linearFityVals,binValues	setdimlabel 1,3,xVariance,binValues	setdimlabel 1,4,yVariance,binValues	setdimlabel 1,5,xSD,binValues	setdimlabel 1,6,ySD,binValues	setdimlabel 1,7,xSEM,binValues	setdimlabel 1,8,ySEM,binValues		binValues[][0] = mean(xWave2D, pnt2x(xWave2D,pntsPerBin*p) , pnt2x(xWave2D,(pntsPerBin-1)*(p+1)) )	binValues[][1] = mean(yWave2D, pnt2x(xWave2D,pntsPerBin*p) , pnt2x(xWave2D,(pntsPerBin-1)*(p+1)) )		//changed on 171024 comports with Kim and Rieke protocol		//consider adding variance, sd, sem	binValues[][3] = variance(xWave2D, pnt2x(xWave2D,pntsPerBin*p) , pnt2x(xWave2D,(pntsPerBin-1)*(p+1)) )	//x val variance	binValues[][4] = variance(yWave2D, pnt2x(xWave2D,pntsPerBin*p) , pnt2x(xWave2D,(pntsPerBin-1)*(p+1)) )	//y val variance		//variance is already sample-corrected (divided by N-1 not N) so need only take sqrt to get sd	binValues[][5] = sqrt(binValues[p][3])	binValues[][6] = sqrt(binValues[p][4])		//standard error of the mean sem	binValues[][7] = binValues[p][5] / sqrt(pntsPerBin)	binValues[][8] = binValues[p][6] / sqrt(pntsPerBin)//downsamples so that each bin subtends an equal portion of the overall rangefunction/s downsampleYXFromRange(yRef,xRef,numXBins,outRef,putOnTopGraph,[forceXMin,forceXMax,yColxColList,startP,endP,vertAxN])	String yRef, xRef, outRef; Variable numXBins, putOnTopGraph,forceXMin,forceXMax	String yColxColList		//use just yRef but grab two different columns	Variable startP,endP	//specify range of yRef and xRef to use (optional)	String vertAxN		//for putOnTopGraph==1 force an axis name other than left		if (strlen(outref)< 1)		outRef = yref+"_bin"	endif	Variable usedStartP = (!ParamIsDefault(startP) && !numtype(startP))? startP : 0	Variable usedEndP = (!ParamIsDefault(endP) && !numtype(endP))? endP : dimsize($yRef,0)		if (!ParamIsDefault(yColxColList) && itemsinlist(yColxColList))		Variable yCol=str2num(stringfromlist(0,yColxcollist))				Variable xCol=str2num(stringfromlist(1,yColxcollist))		Duplicate/O/R=(usedStartP, usedEndP)[yCol] $yRef, yWv		Duplicate/O/R=(usedStartP, usedEndP)[xCol] $yRef, xWv		else		Duplicate/O/R=(usedStartP, usedEndP) $yRef, yWv		Duplicate/O/R=(usedStartP, usedEndP) $xRef, xWv		endif		Variable xMinVal = xWv[0]	Variable xMax=(!ParamIsDefault(forceXMax)&&!numtype(forceXmax))? forceXMax :wavemax(xWv)	Variable xMin=(!ParamIsDefault(forceXMin)&&!numtype(forceXMin))? forceXMin :wavemin(xWv)	Variable xRange = xMax - xMin	Variable rangePerBin = xRange/numXBins	Variable maxNumPnts=dimsize(xWv,0)	//	Make/O/D/N=(numXBins,5) $outref/wave=out		//0 will hold mean of y in range, 1 will hold mean of y, 2 holds sum of y, 3 holds sum of x, 4 holds count in each bin//	setscale/p x,xMin,rangePerBin,waveunits(xWv,0),out//	setdimlabel 1,0,yMean,out//	setdimlabel 1,1,xMean,out//	setdimlabel 1,2,ySum,out//	setdimlabel 1,3,ySum,out//	setdimlabel 1,4,binCount,out//	out=0	Make/O/D/N=(maxNumPnts,numxbins) ytemp,xtemp		//each bin is a column and rows contain diferent values that fit into that bin	make/o/n=(numXBins) binCounts	setscale/p y,xMin,rangePerBin,waveunits(xWv,0),ytemp,xtemp	ytemp=nan;xtemp=nan		//any unused cell will be nan and thus ignored by wavestats	binCounts=0		Variable i,bin,currBinCount,rows=dimsize(xWv,0); double xval,yval	for (i=0;i<rows;i+=1)		yval = yWv[i]		xval = xWv[i]		if (numtype(xval) || numtype(yval))		//ignore nans infs			continue		endif		bin = ScaleToIndex(xtemp, xval, 1 )		if (bin==numXBins)		//probably equal to or above xMax, so truncate to last bin			bin=numxbins-1		elseif (bin<0)			//probably below xMin, so put in 0th bin			bin=0		endif		currBinCount=binCounts[bin]		ytemp[currBinCount][bin]=yval		xtemp[currBinCount][bin]=xval		binCounts[bin]+=1	endfor			wavestats/pcst/q ytemp	WAVE M_WaveStats	duplicate/o/free M_WaveStats,yStatsTemp	wavestats/pcst/q xtemp	matrixtranspose yStatsTemp		//put bins into rows, stats into columns	matrixtranspose M_WaveStats		//same for x data	concatenate/dl/np=2/o {yStatsTemp,M_WaveStats},$outref/wave=out		//y data is first layer, x data is second layer	setscale/p x,xMin,rangePerBin,waveunits(xWv,0),out	//might transfer in wavestats and concatenate but not sure	setdimlabel 2,0,yData,out	setdimlabel 2,1,xData,out		Variable cols=dimsize(out,1)	redimension/n=(-1,cols+2,-1) out	setdimlabel 1,cols,avgMinusSEM,out	setdimlabel 1,cols+1,avgPlusSEM,out	out[][%avgMinusSEM][] = out[p][%avg][r] - out[p][%sem][r] 	out[][%avgPlusSEM][] = out[p][%avg][r] + out[p][%sem][r] 		if (putOnTopGraph)		String axN = selectstring(ParamIsDefault(vertAxN) || (strlen(vertAxN)<1),vertAxN,"left")				String mainTN=outRef+"_avg_bins"		String errorTN=outRef+"_avg_bins_plusSem"		AppendToGraph/l=$axN out[][%avg][0]/tn=$mainTN	//this is a bit muddled but works, dont feel like sorint out overwritten commands atm		ModifyGraph mode($mainTN)=5,tomode($mainTN)=1		appendtograph/l=$axN out[][%avgPlusSEM][0]/tn=$errorTN		ModifyGraph mode($errorTN)=5,toMode=0		ModifyGraph hbFill($mainTN)=3,useBarStrokeRGB($mainTN)=1,barStrokeRGB($mainTN)=(43690,43690,43690)		ModifyGraph mode($errorTN)=6		ModifyGraph rgb($mainTN)=(43690,43690,43690),mode($errorTN)=5,hbFill($errorTN)=4,rgb($errorTN)=(2,39321,1,32768)		ModifyGraph useBarStrokeRGB($errorTN)=1,barStrokeRGB($errorTN)=(0,0,0,0)		ModifyGraph rgb($mainTN)=(0,0,0)	endif		return outrefend//returns person R correlation by formula Covariance(x,y) / stdev(x) * stdev(y). Order of x,y doesn't matterfunction getPearsonR(yWv, xWv)	WAVE/D yWv, xWv		Variable xMean = mean(xWv)	Variable yMean = mean(yWv) 		Variable i, currNumer1, currNumer2	Variable runningNumer = 0, runningXDenom = 0, runningYDenom = 0	for (i=0; i<numpnts(xWv); i+=1)		currNumer1 = (xWv[i] - xMean)		currNumer2 = (yWv[i] - yMean)		runningNumer += currNumer1 * currNumer2			//calculating the covariance as we go through the wave		runningXDenom += currNumer1^2					//calculating x and y variance as well		runningYDenom += currNumer2^2	endfor	return runningNumer/(sqrt(runningXDenom) * sqrt(runningYDenom))		//final formula is Covariance(x,y) / stdev(x) * stdev(y)end		function getPearsonRFromRange(yRef, xRef, startX, endX)	String yRef, xRef	Variable startX, endX		Duplicate/O $xRef, xWaveRCorr	Duplicate/O $yRef, yWaveRCorr		Variable xMean = mean(xWaveRCorr, startX, endX)	Variable yMean = mean(yWaveRCorr, startX, endX) 		Variable i, currNumer1, currNumer2	Variable runningNumer = 0, runningXDenom = 0, runningYDenom = 0	for (i=x2pnt(xWaveRCorr, startX); i<x2pnt(xWaveRCorr, endX); i+=1)		currNumer1 = (xWaveRCorr[i] - xMean)		currNumer2 = (yWaveRCorr[i] - yMean)		runningNumer += currNumer1 * currNumer2			//calculating the covariance as we go through the wave		runningXDenom += currNumer1^2					//calculating x and y variance as well		runningYDenom += currNumer2^2	endfor	KillWaves/Z xWaveRCorr, yWaveRCorr	return runningNumer/(sqrt(runningXDenom) * sqrt(runningYDenom))		//final formula is Covariance(x,y) / stdev(x) * stdev(y)end	function/S analysis_FIRFilter(refsList, outputAppendStr, endOfBand_hz, startOfRejection_hz, numCoefs)	String refsList, outputAppendStr	//results are saved as each ref + appendStr	Double endOfBand_hz, startOfRejection_hz //see filterFIR and analysis -> filter tab for details. inputs may have different sample rates	Variable numCoefs	//lengh of filter in terms of coefficients, limit ~32000		Variable i	String currRef, currOut, outList  = ""	Double currSamplingFreq_hz, currEndOfBand, currStartOfRejection	Make/O/D/N=0 coefsTemp		for (i=0;i<ItemsInList(refsList);i+=1)		currRef = stringfromlist(i, refsList)		currOut = currRef + outputAppendStr; outList += currOut + ";"		Duplicate/O $currRef, $currOut		currSamplingFreq_hz = 1/DimDelta($currRef,0)		currEndOfBand = endOfBand_hz / currSamplingFreq_hz		currStartOfRejection = startOfRejection_hz / currSamplingFreq_hz		FilterFIR/DIM=0/LO={currEndOfBand,currStartOfRejection,numCoefs}/COEF coefsTemp, $currOut	endfor		killwaves/Z coefsTemp		return outListendfunction addCycles()	WAVE/T fileDirectory	Variable i	for (i=55;i<80;i+=3)		fileDirectory[i+0][7]="3"		fileDirectory[i+0][8]=".5"			fileDirectory[i+0][9]="2.5"			fileDirectory[i+1][7]="3"		fileDirectory[i+1][8]="1"			fileDirectory[i+1][9]="5"		fileDirectory[i+2][7]="3"		fileDirectory[i+2][8]="10"			fileDirectory[i+2][9]="5"			endforendfunction loadOD3()	WAVE/T fileDirectory		Variable i, count = 0;	Variable responseChanNum, responseFilteredChanNum, stimChanNum	String responseWaves, responseFilteredWaves, stimWaves	String currRespAvgRef, currRespFilteredAvgRef, currStimAvgRef	for (i=47;i<DimSize(fileDirectory,0);i+=1)		if (stringmatch(fileDirectory[i][8],"3") && stringmatch(fileDirectory[i][9],"1") && stringmatch(fileDirectory[i][10],"5"))			//fd_loadFile(i)			responseChanNum = fd_getChanNumForDigIn(i, 3)			responseFilteredChanNum = fd_getChanNumForDigIn(i, 4)			stimChanNum = fd_getChanNumForDigIn(i, 6)						currRespAvgRef = "ERG_Avg_R_" + num2str(i)			currRespFilteredAvgRef = "ERG_Avg_RF_" + num2str(i)			currStimAvgRef = "ERG_Avg_S_" + num2str(i)						fd_loadFileChannelToAvg(i, responseChanNum, currRespAvgRef)			fd_loadFileChannelToAvg(i, responseFilteredChanNum, currRespFilteredAvgRef)			fd_loadFileChannelToAvg(i, stimChanNum, currStimAvgRef)						//fd_loadFile(i)						Print "num2str(i)...", num2str(i) + ":" + currRespAvgRef + " " + currRespFilteredAvgRef + " " + currStimAvgRef			count +=1		endif	endfor	Print countend//function works with time strings output by Bruxton ABF g//Assumes strings are of the form "[month]/[day]/[year] [hour]:[minute]:[second] [AM/PM]"//This is the output from the Bruxton ABF handling macro ABFFilefunc_getTimefunction text_parseTimeStr(timeStr, outRef ,[useAMPM, returnThisParameter])	String timeStr; String outRef; Variable useAMPM, returnThisParameter			Variable month, day, year, hour, minute, second, isPM; String analyzedTimeStr		Variable relativeSweepTime	Variable hasRelativeSweepTime = stringmatch(timeStr, "*;*")		//one can pass timeStr in this format [timeStr];[relativeSweepTimeInSecs];, then the latter is saved for use in analysis of relative timing	if (hasRelativeSweepTime)		analyzedTimeStr = stringFromList(0, timeStr)		relativeSweepTime = str2num(stringfromList(1,timeStr))	else		analyzedTimeStr = timeStr		relativeSweepTime = 0	endif 		Variable isInUseAMPM =  (!ParamIsDefault(useAMPM) && useAMPM != 0)	//	Print ParamIsDefault(useAMPM), useAMPM, isInUseAMPM			analyzedTimeStr = ReplaceString(" ", analyzedTimeStr, "/")	sscanf analyzedTimeStr, "%d/%d/%d/%d:%d:%d", month, day, year, hour,minute, second			isPM = stringmatch(analyzedTimeStr, "*PM*")	//	Print "isPM",isPm	//	Print "timeStr",timeStr//	Print "month",month, "day",day, "year",year, "hour",hour,"minute",minute,"second", second,"isPM",isPM,"isInUseAMPM",isInUseAMPM		if (isInUseAMPM)		//all good, keep in am pm format	else		//if pm, add 12 hours		if (isPM && hour < 12)		//handle 1:00 pm to 11:59 pm			hour += 12		elseif (!isPM && hour == 12)		//12 am becomes 0			hour = 0		endif		endif	//	Print outRef, "isPM", isPm	Make/O/D/N=(10) outTemp	Variable r = -1	r+=1;dl_assignAndLbl(outTemp, r, year, "year")	r+=1;dl_assignAndLbl(outTemp, r, month, "month")	r+=1;dl_assignAndLbl(outTemp, r, day, "day")	r+=1;dl_assignAndLbl(outTemp, r, hour, "hour")	r+=1;dl_assignAndLbl(outTemp, r, minute, "minute")	r+=1;dl_assignAndLbl(outTemp, r, second, "second")	r+=1;dl_assignAndLbl(outTemp, r, isInUseAMPM ? isPM : NaN, "isPM")	r+=1;dl_assignAndLbl(outTemp, r, isInUseAMPM, "isInUseAMPM")	r+=1;dl_assignAndLbl(outTemp, r, relativeSweepTime, "relativeSweepTime")	r+=1;dl_assignAndLbl(outTemp, r, hasRelativeSweepTime, "hasRelativeSweepTime")			if (strlen(outRef) != 0)		Duplicate/O outTemp, $outRef	endif		Variable out = NaN	if (ParamIsDefault(returnThisParameter) && (returnThisParameter < DimSize(outTemp,0)))		out =  outTemp[returnThisParameter]	endif		KillWaves/Z outTemp		return outendfunction/S text_toggleTimeWaveAMPM(useAMPM, timeWaveRef)	Variable useAMPM; String timeWaveRef		WAVE/D timeWave = $timeWaveRef		Variable isAMPMFormat = timeWave[%isInUseAMPM]		if ( (isAMPMFormat && useAMPM) || (!isAMPMFormat && !useAMPM) )		return timeWaveRef		//do nothing if nothing needs to be done!	endif		Variable isPM		if (useAMPM)		//have to convert from 24 to AMPM		isPM = timeWave[%hour] > 12				if (isPM)			timeWave[%hour] -= 12			timeWave[%isPM] = 1		else			timeWave[%isPM] = 0		endif			timeWave[%isInUseAMPM] = 1	else					//have to convert from AMPM to 24		isPM = timeWave[%isPM]		if (isPM)			if (timeWave[%hour] < 12)		//1:00 pm to 11:59 pm				timeWave[%hour] += 12			endif		endif		timeWave[%isPM] = NaN		timeWave[%isInUseAMPM] = 0	endif			return timeWaveRef	end//5 for secs, 4 for mins, 3 for hours, 2 for days, 1 for months, 0 for yearsfunction text_getWaveTimeDifference(waveRef1, waveRef2, outUnit)	String waveRef1, waveRef2; Variable outUnit	String timeStr1 = fd_note_getWaveTimeStr(waveRef1,1)	String timeStr2 = fd_note_getWaveTimeStr(waveRef2,1)	//	Print "timeStr1",timeStr1,"timeStr2",timeStr2		return text_getTimeStrDifference(timeStr1, timeStr2, outUnit)endfunction text_getTimeSinceTimeStr(timeStr, waveRef, outUnit [lastSweepTimingFromAvg])	String waveRef, timeStr; Variable outUnit	Variable  lastSweepTimingFromAvg			//pass to specify that waveRef is going to be an average name and so use "AVG_LAST_SWEEP_TIME" keyword value			String cmpTimeStr	if (ParamIsDefault(lastSweepTimingFromAvg))		cmpTimeStr = fd_note_getWaveTimeStr(waveRef,1)	else		cmpTimeStr = fd_note_getWaveTimeStr(waveRef,1,lastSweepTimingFromAvg=1)	endif			return text_getTimeStrDifference(timeStr, cmpTimeStr, outUnit)endfunction text_fd_getRelTimeSinceFile(waveRef, fNum, outUnit, [ lastSweepTimingFromAvg])	String waveRef; Variable fNum, outUnit	Variable  lastSweepTimingFromAvg			//pass to specify that waveRef is going to be an average name and so use "AVG_LAST_SWEEP_TIME" keyword value		if (!strlen(waveRef) || !WaveExists($waveRef))		return NaN	endif		String fName = text_getInfoFromWaveName_S(waveRef, 0)//	String fileForEndTime = text_getInfoFromWaveName_S(waveRef, 1)	String fileForStartTime = num2str(fNum)	fileForStartTime = text_getPaddedString(4-strlen(fileForStartTime),4,fileForStartTime,"0")		Variable fd_fNumForStartTime = fd_getFIndexInFileInfoWave(fName+"_"+fileForStartTime)//	Variable fd_fNumForEndTime = fd_getFIndexInFileInfoWave(fName+"_"+fileForEndTime)		String startTimeStr = fd_getRecStartTFromFileInfoWave(fd_fNumForStartTime) + ";0;"	//deafults to start time of file. could add a sweepNum parameter and then instead of zero use sweepNum * sweepLen//	String endTimeStr = fd_getRecStartTFromFileInfoWave(fd_fNumForEndTime)	//	Print "fName",fName,"fileForEndTime",fileForEndTime,"fileForStartTime",fileForStartTime,"fd_fNumForStartTime",fd_fNumForStartTime,"fd_fNumForEndTime",fd_fNumForEndTime		if (ParamIsDefault(lastSweepTimingFromAvg))		return text_getTimeSinceTimeStr(startTimeStr, waveRef , outUnit)	else		return text_getTimeSinceTimeStr(startTimeStr, waveRef , outUnit, lastSweepTimingFromAvg=1)	endif	//	fd_getFIndexInFileInfoWave(fNameOrOtherStr)end//function works with time strings output by Bruxton ABF macro//Assumes strings are of the form "[month]/[day]/[year] [hour]:[minute]:[second] [AM/PM]"//This is the output from the Bruxton ABF handling macro ABFFilefunc_getTimefunction text_getTimeStrDifference(timeStr1, timeStr2, outUnit)	String timeStr1, timeStr2; Variable outUnit		text_parseTimeStr(timeStr1, "timeArrayRef1")	text_parseTimeStr(timeStr2, "timeArrayRef2")		Variable out = text_getTimeArrayDifference("timeArrayRef1", "timeArrayRef2", outUnit)	//	KillWaves/Z $"timeArrayRef1", $"timeArrayRef2"		return outend//timeArray1 and timeArray2 should be waves with 6 points, year;month;day;hour;minute;seconds. outUnit is 0-5 in order corresponding to the rows in timeConversions//text_parseTimeStr() generates waves of this formatfunction text_getTimeArrayDifference(timeArray1, timeArray2, outUnit)	String timeArray1, timeArray2; Variable outUnit 				Make/O/N=6 timeConversions 	  //for conversion to number of seconds	timeConversions[0] = 3.154e+7 //seconds per year (NOT used in calculation -- Igor date2secs algorithm instead. IS used in conversion from an accurate value for seconds back to the unit of interest, outUnit)	timeConversions[1] = 2.628e+6 //secons per month, on average (NOT used in calculation -- Igor date2secs algorithm instead. IS used in conversion from an accurate value for seconds back to the unit of interest, outUnit)	timeConversions[2] = 86400	 //seconds per day (NOT used in calculation -- Igor date2secs algorithm instead. IS used in conversion from an accurate value for seconds back to the unit of interest, outUnit)	timeConversions[3] = 3600		 //seconds per hour	timeConversions[4] = 60 		//seconds per minute	timeConversions[5] = 1		 //seconds per second		Duplicate/O $timeArray1, startTemp	Duplicate/O $timeArray2, endTemp		//relies on Igor's function to determine the amount of time passed between dates in seconds; this calculation is complicated by the Julian calendar.	Variable startDate_secs = date2secs(startTemp[0], startTemp[1], startTemp[2])	Variable endDate_secs = date2secs(endTemp[0], endTemp[1], endTemp[2])	Variable elapsedDays_inSecs = endDate_secs - startDate_secs		//check if format has AM/PM row; if necessary convert to non-AMPM format of time wave	text_toggleTimeWaveAMPM(0, "startTemp")	text_toggleTimeWaveAMPM(0, "endTemp")		//Now uses seconds per hour and seconds per minute, from the timeConversions wave to determine whether additional time should be added or subtracted for where each time was in each day.		//convert hour, min, (and seconds) to seconds	startTemp[3,5] *= timeConversions[p]	endTemp[3,5] *= timeConversions[p]		//sum to calculate number of seconds since start of each day	Variable timeSinceStartDayStart_secs = sum(startTemp, 3, 5)		//sum the number of seconds contributed by hours, mins, and seconds	Variable timeSinceEndDayStart_secs = sum(endTemp, 3, 5)	Variable timeDiffSinceDayStart_secs = timeSinceEndDayStart_secs - timeSinceStartDayStart_secs		//find difference between them		if (startTemp[%hasRelativeSweepTime])		timeDiffSinceDayStart_secs -= startTemp[%relativeSweepTime]		//subtract any additional time offset due to the actual start of the 1st sweep relative to its file creation time	endif	if (endTemp[%hasRelativeSweepTime])		timeDiffSinceDayStart_secs += endTemp[%relativeSweepTime]		//add any additional time offset due to the actual start of the 2nd sweep relative toits  file creation time	endif				//sum time elapsed in days with time elapsed in the difference between the time within each day		Variable totalElapsedTime_inSecs = elapsedDays_inSecs + timeDiffSinceDayStart_secs			//convert back to requested out unit	Variable out = totalElapsedTime_inSecs / timeConversions[outUnit]		KillWaves/Z startTemp, endTemp, timeConversions		return outendfunction erg_load()	WAVE/T fileDirectory		Variable i	for (i=0;i<DimSize(fileDirectory,0);i+=1)		if (stringmatch(fileDirectory[i][7],"3") && stringmatch(fileDirectory[i][8],"1") && stringmatch(fileDirectory[i][9],"3"))			fd_toggleFileLoad(i)		endif	endforendfunction erg_displayA(switchTime_sec)	Variable switchTime_sec		Variable t0 = ticks		//stores start time		SVAR list		Variable numTests = ItemsInList(list)	Variable numParams = 5	Make/O/N=(numTests, numParams) ergTestParams		Display/N=OLWin/K=1		Variable i,count	Variable currPulseStartTime, currBaselineMean	Variable prePulseWinSizeForAvg = .25		// in sec	String currRef, currCmdRef	for (i=0;i<numTests;i+=1)		currRef = StringFromList(i,	list)			currCmdRef = replacestring("RF", currRef, "S",1,1)		AppendToGraph/W=$S_name $currRef		//S_name stores actual name of window 			//find time of light pulse		Wavestats/Q $currCmdRef		currPulseStartTime = V_maxLoc				//store min peak val, max peak val (relative to average before step), min time, max time, min = A wave, max = B wave, very roughly		currBaselineMean = mean($currRef, currPulseStartTime - prePulseWinSizeForAvg, currPulseStartTime)				Wavestats/Q $currRef		ergTestParams[i][1] = V_minloc - currPulseStartTime		//time to min		ergTestParams[i][2] = V_min -  currBaselineMean		//baseline sub'd size of min		ergTestParams[i][3] = V_maxloc - currPulseStartTime		//time to max		ergTestParams[i][4] = V_max - currBaselineMean		//baseline sub'd size of max	endfor			Display/N=dispWin/K=1			//fancy moving display	String lastText = ""	Make/O/U/N=6 recT		for (i=0;i<numTests;i+=1)		if (switchTime_sec > 0)			do 				//do nothing			while (  ( (ticks - t0) / 60)  < (1 + 1*i))		 //while time in seconds is less than 1		endif				if (i < 1)		//remove last			text_parseTimeStr( fd_note_getWaveTimeStr(StringFromList(i, list),0), "recT")			Duplicate/O recT, recStartArray		else			RemoveFromGraph/W=$S_name $StringFromList(i-1,	list)				TextBox/N=displayBox/K		//kills last text box		endif		AppendToGraph/W=$S_name $StringFromList(i,	list)		//S_name stores actual name of window 		text_parseTimeStr( fd_note_getWaveTimeStr(StringFromList(i, list),0), "recT")		//lastText = StringFromList(i, list) + " H: " + num2stR(recT[3] - recStartArray[3]) + " S: " + num2str(recT[4] - recStartArray[4]) + "M : " + num2str(recT[5] - recStartArray[5]) // StringFromList(i, list) + "D: " + num2str(recT[2]) + " M: " + num2stR(recT[3]) + " S: " + num2str(recT[4]) + "M : " + num2str(recT[5])		lastText = StringFromList(i, list) + " " + num2str(text_getTimeArrayDifference("recStartArray", "recT", 2))		Textbox/W=$S_name /X=5/Y=70/N=displayBox lastText		SetAxis left -0.00017956543,-0.00011682129		doupdate				//fill in timing in params wave		ergTestParams[i][0] = text_getTimeArrayDifference("recStartArray", "recT", 2)	endfor			KillWaves/Z recT, recStartArrayendfunction func_getTime()	return ticksendfunction func_pause(pauseTime)	Variable pauseTime		Variable ticksPerSec = 60		Variable t0 = ticks	do			//nothing,ish!	while (((ticks-t0)/ticksPerSec) < pauseTime)end//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////ANALYSIS FUNCTIONS////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// /////////////////////////////GB functions for analyzing waves. These are generally task-specific functions, e.g. analyze selected current-response sweeps //Generally integrated with Proc_AnalysisPanel. Does not include action controls, but actioncontrol functions from analysis panel//call some of these functionsfunction displayPairwiseComparison(realRespRef, predictionRef, pairwiseBinsSaveRef, analysisStartX, analysisEndX, [baselineSubReal, baselineSubPred])	String realRespRef, predictionRef, pairwiseBinsSaveRef	Variable baselineSubReal, baselineSubPred	Variable analysisStartX, analysisEndX	KillWindowsByName(realRespRef + "WNC_P*")	Display/K=1/N=$(realRespRef + "WNC_P")	String pairwiseOverlayWN = S_Name				Variable predStartP = x2pnt($predictionRef, analysisStartX); Variable predEndP = x2pnt($predictionRef, analysisEndX)	Variable realStartP = x2pnt($predictionRef, analysisStartX); Variable realEndP = x2pnt($predictionRef, analysisEndX)		AppendToGraph/W=$pairwiseOverlayWN/C=(0,0,0)  $realRespRef[realStartP, realEndP]/TN=realVsPred_all vs $predictionRef[predStartP, predEndP]	AppendToGraph/W=$pairwiseOverlayWN $pairwiseBinsSaveRef[][1]/TN=$(realRespRef + "bins") vs $pairwiseBinsSaveRef[][0] 	AppendToGraph/W=$pairwiseOverlayWN $pairwiseBinsSaveRef[][2]/TN=$(realRespRef + "binsFit") vs $pairwiseBinsSaveRef[][0] 	ModifyGraph height=72*4, width=72*4,mode=2; doupdate	disp_matchAxisScaling_1win("*",winN=pairwiseOverlayWN)	Label bottom, "Predicted (\\U)"	Label left, "Real (\\U)"endfunction/S displayOverlaidPrediction(realRespRef, stimRef, predictionRef, baselineSub, [baseSubRegStartX, baseSubRegEndX])	String realRespRef, stimRef, predictionRef; Variable baselineSUb, baseSubRegStartX, baseSubRegEndX		KillWindowsByName(realRespRef + "WNC_O*")	Display/K=1/N=$(realRespRef + "WNC_O")	String winN = S_Name				//find window for prediction 	Variable startX = DimOffset($predictionRef, 0)	Variable endX = startX + ( ( DimSize($predictionRef, 0) - 1 ) * DimDelta($predictionRef,0) )	Variable startP_pred = x2pnt($predictionRef, startX), endP_pred = x2pnt($predictionRef, endX),  startP_real = x2pnt($realRespRef, startX), endP_real = x2pnt($realRespRef, endX), startP_stim=x2pnt($stimRef, startX), endP_stim=x2pnt($stimRef, endX)		AppendtoGraph/W=$winN/C=(0,0,0) $realRespRef[startP_real, endP_real]	AppendToGraph/W=$winN/C=(0,12800,52224) $predictionRef[startP_pred, endP_pred]	AppendToGraph/W=$winN/L=Lstim/C=(34816, 34816, 34816) $stimRef[startP_stim, endP_stim]	ModifyGraph axisEnab(left) = {0.3,1}, axisEnab(Lstim) = {0,.3}		if (baselineSub)		Variable usedBaselineMeanRegStartX = ParamIsDefault(baseSubRegStartX) ? startX : baseSubRegStartX, usedBaselineMeanRegEndX = ParamIsDefault(baseSubRegEndX) ? endX : baseSubRegEndX			Variable yOffsetReal = -mean($realRespRef, usedBaselineMeanRegStartX, usedBaselineMeanRegEndX)		Variable yOffsetPred = -mean($predictionRef, usedBaselineMeanRegStartX, usedBaselineMeanRegEndX)		ModifyGraph offset($realRespRef) = {0, yOffSetReal}, offset($predictionRef)={0, yOffsetPred}		endif		return winNendfunction wn_add(row, stimFromHS2, clear, use)	Variable row, clear, use		//use is for deciding whether to consider in main analysis, 1 for trustworthy, 0 for probably not	Variable stimFromHS2		//0 for left stim, 1 for right		WAVE/T wnSummary, hsList	Duplicate/O wnSummary, wnSummary_bu		wnSummary[row][25] = num2str(row)		Variable somaHS1 = stringmatch(wnSummary[row][1], "S")	Variable isSomaStim		if (somaHS1 && (stimFromHS2 == 0) )		isSomaStim = 1	elseif (!somaHS1 && (stimFromHS2 == 1) )		isSomaStim = 1	else		isSomaStim = 0	endif		if (clear)		wnSummary[row][26 + !isSomaStim] = num2str(use) + ";"	else		wnSummary[row][26 + !isSomaStim] += num2str(use) + ";"	endif		String respStr_S, respStr_P, stimStr_S, stimStr_P, respRefSoma, respRefPed, stimRefSoma, stimRefPed	if (somaHS1)		respStr_S = "*AD0"		stimStr_S = "*AD1"		respStr_P = "*AD2"		stimStr_P = "*AD3"	else		respStr_S = "*AD2"		stimStr_S = "*AD3"		respStr_P = "*AD0"		stimStr_P = "*AD1"		endif				if (isSomaStim)			respRefSoma = StringFromList(0, graph_getWaveList("", respStr_S, "", 0))		respRefPed = StringFromList(0, graph_getWaveList("", respStr_P, "", 0))		stimRefSoma = StringFromList(0, graph_getWaveList("", stimStr_S, "", 0))		if (clear)			wnSummary[row][2] = ""			wnSummary[row][3] = ""			wnSummary[row][4] = ""				endif		wnSummary[row][2] += stimRefSoma + ";"		wnSummary[row][3] += respRefSoma + ";"		wnSummary[row][4] += respRefPed + ";"	else		respRefSoma = StringFromList(0, graph_getWaveList("", respStr_S, "", 0))		respRefPed = StringFromList(0, graph_getWaveList("", respStr_P, "", 0))		stimRefPed = StringFromList(0, graph_getWaveList("", stimStr_P, "", 0))		if (clear)			wnSummary[row][5] = ""			wnSummary[row][6] = ""			wnSummary[row][7] = ""				endif		wnSummary[row][5] += stimRefPed + ";"		wnSummary[row][6] += respRefPed + ";"		wnSummary[row][7] += respRefSoma + ";"	endif			wn_updateResultsCols(row)endfunction wn_updateResultsCols(row)	Variable row		//NOTE: col 25 now reserved for hsList row		WAVE/T wnSummary	Variable numOutputsPerSite = 8				//wnFS is white noise from soma. wnSFS is white noise summary from soma	wnSummary[row][9] = appendToListItems("wnSRfS", wnSummary[row][2],"")		//soma from soma refs to waves generated	wnSummary[row][10] = appendToListItems("wnPRfS", wnSummary[row][2],"")		//ped from soma refs to waves generated	wnSummary[row][11] = appendToListItems("wnSPfS", wnSummary[row][2],"")		//soma from soma PARAMS	wnSummary[row][12] = appendToListItems("wnPPfS", wnSummary[row][2],"")		//ped from soma PARAMS	wnSummary[row][13] = appendToListItems("wnDPfS", wnSummary[row][2],"")		//from soma DIFF PARAMS	wnSummary[row][14] = appendToListItems("wnDFPfS", wnSummary[row][2],"")		//from soma FOLD DIFF PARAMS	wnSummary[row][15] = appendToListItems("wnDRfS", wnSummary[row][2],"")		//from soma DIFF REFS	wnSummary[row][16] = appendToListItems("wnDFRfS", wnSummary[row][2],"")		//from soma DIFF FOLD DIFF REFS		wnSummary[row][9 + numOutputsPerSite] = appendToListItems("wnSRfP", wnSummary[row][2],"")		//soma from ped refs to waves generated	wnSummary[row][10 + numOutputsPerSite] = appendToListItems("wnPRfP", wnSummary[row][2],"")		//ped from ped refs to waves generated	wnSummary[row][11 + numOutputsPerSite] = appendToListItems("wnSPfP", wnSummary[row][2],"")		//soma from ped PARAMS	wnSummary[row][12 + numOutputsPerSite] = appendToListItems("wnPPfP", wnSummary[row][2],"")		//ped from ped PARAMS	wnSummary[row][13 + numOutputsPerSite] = appendToListItems("wnDPfP", wnSummary[row][2],"")		//from ped DIFF PARAMS	wnSummary[row][14 + numOutputsPerSite] = appendToListItems("wnDFPfP", wnSummary[row][2],"")		//from ped FOLD DIFF PARAMS	wnSummary[row][15 + numOutputsPerSite] = appendToListItems("wnDRfP", wnSummary[row][2],"")		//from ped DIFF REFS	wnSummary[row][16 + numOutputsPerSite] = appendToListItems("wnDFRfP", wnSummary[row][2],"")		//from ped DIFF FOLD DIFF REFSendfunction reopenRefs(refsListRefOrStr, pathStr, loadExisting, [sepStr])	String refsListRefOrStr, pathStr	Variable loadExisting			//0 to abort load of waves that exist, 1 to load regardless	String sepStr				//optional pass delimiter / sep string used in refsList (only employeed by function if string list used), if not passed, semi colon is used as default		Print"refsListRefOrStr", refsListRefOrStr		if (ParamIsDefault(sepStr))		sepStr = ";"	endif		String extensionStr = ".ibw"	Variable isStrList = 0	if (stringmatch(refsListRefOrStr, "*" + sepStr + "*"))		isStrList = 1	endif		if (!isStrList)		WAVE/T refsListWave = $refsListRefOrStr	endif		Variable numRefs = isStrList ? ItemsInList(refsListRefOrStr, sepStr) : DimSize($refsListRefOrStr, 0)	Variable i, attemptCount=0, failCount=0; String currRef		Print "in reopenRefs, numRefs = " + num2str(numRefs)		for (i=0;i< numRefs;i+=1)		if (isStrList)			currRef = StringFromList(i, refsListRefOrStr, sepStr)		else			currRef = refsListWave[i]		endif		if (!loadExisting && !WaveExists($currRef)) 			//if loadExisting is 0, then only load if the wave does not exist			LoadWave/Q/W/O/P=$pathStr/h ( currRef + extensionStr )			attemptCount +=1			if (!WaveExists($currRef))				Print "in wn_reopenRefs, failed to reload " + currRef				failCount +=1			endif		endif	endfor		Print "reopenRefs() loads attempted = " + num2str(attemptCount) + ". Loads failed = " + num2str(failCount)endfunction wn_myCorr3(stimRef,respRef,outRefsListRef,paramsSaveRef,filterLenX,binSpacingX,winStartX,winSizeX,compRegStartX,compRegLenX,numNonlinearityBins,windowFuncStr)	String stimRef, respRef	String outRefsListRef, paramsSaveRef		Variable filterLenX, binSpacingX, winStartX, winSizeX	//standard values: 1, 0.5 (50% overlap of bins), 10, 35	Variable compRegStartX,compRegLenX		//region to compare stimulus and resp (usually outside of the region for building model. Until 180430 it was not, instead it did on entire region that was used to build	Variable numNonlinearityBins						//number of bins for analysis/display of non-linearity	String windowFuncStr			//see FFT function for details of options, pass "" empty str for no windowing (Default). NOT YET FULLY SUPPORTED		Print  "----STARTING wn_myCorr3 on " + stimRef + ", " + respRef		//outputs	//noDC data  (original data is already "saved" as original ref, should be used from this	String stimFromWinNDCSN = respRef + "wnSNCD";//stimR No Dc	String respRealNDCSN = respRef + "wnRNDC";	//wnR No DC	//convolution data 	String filter_TDSN = respRef + "wnF";	//filter for convolution	String respConvSN = respRef + "wnP" ; 	//wn Prediction	String filterScaled_TD = respRef + "wnFSC"	//filter scaled for parseval's..scaling is inverse dim delta (i.e., multiply by sample rate)	//frequency domain filters	String filter_FDSN = respRef + "wnFF" ; 	//wn Filter FD	String filterMag_FDSN = respRef + "wnFFNM";//wn Filter FD Normalized Mag	String filterPower_FDSN = respRef + "wnFP"; //wn Filter Power	String respPhase_FDSN = respRef + "wnFPh"; 	//wn Filter Phase 		String respBinnedConvSN = respRef + "wnBin" 		//save names for fit to TD linear filter //these last two created by wn_computePairedCorrParams	String filterFit_TDSN = respRef + "wnAP"				//wn Analysis Params	Variable windowingUsed	if (strlen(windowFuncStr) > 0)		windowingUsed = 1	else		windowingUsed = 0	endif		Variable winEndX = winStartX + winSizeX		//Using Duplicate_FD in case originals aren't loaded	//first want to know the mean of the traces and subtract that out, as this stuff doesn't vary in time and so won't tell us about time-dependent correlations	WAVE/D stimWave = $stimRef	Duplicate/O/D stimWave, $stimFromWinNDCSN/wave=stimWaveNoDC	Variable stimMean = mean(stimWave,winStartX, winEndX)	stimWaveNoDC -= stimMean	WAVE/D respWave = $respRef	Duplicate/O/D respWave, $respRealNDCSN/wave=respWaveNoDC	Variable respMean = mean(respWave,winStartX, winEndX)	respWaveNoDC -= respMean	SetScale/P x, 0,DimDelta(stimWave,0), stimWaveNoDC, respWave, respWaveNoDc		//make waves begin at zero even after duplicating from a subrange	//avgFilterAndConvolve(stimWaveRef, respWaveRef, outFilterTDRef, outFilterFDRef, outPredictionRef, useWindowing, startX, binSizeX, binStartSpacingX, [subOrNormEachRep])	//first generate the linear filters of the waves. Cross-correlation is performed in the time domain, and the result is normalized to the (average) power spectra of the stimulus for the same time bins	filterLenX = avgFilterAndConvolve(stimFromWinNDCSN, respRealNDCSN,filter_TDSN, filter_FDSN, respConvSN, windowingUsed, 0, filterLenX, binSpacingX, subEachRep = 1, baseSubOutput =1)		//added subOrNormEachRep=0 5/4/16	//filterLenX might be changed by one point to force an even number of points for FFT	WAVE filter_TD=$filter_TDSN, filter_FD=$filter_FDSN, respPredicted	=$respConvSN	//created by avgFilterAndConvolve																					//OLDre-calculate filter with normalization such that variance of response is scaled to variance of stimulus (Baccus and Meister 2002)	//calculate amount to scale filters by//	Variable stimAUCSq = area(stimWaveNoDC)^2//	Variable respAUCSq = area(respPredicted)^2//	Variable pedAUCSq = area(pedPredicted)^2	//	Variable respMultiplier = sqrt(stimAUCSq/respAUCSq)		//one form of normalization (not presently used here)//	Variable pedMultiplier = sqrt(stimAUCSq/pedAUCSq)//	Print "AUCSq stim = " + num2str(stimAUCSq) + ". resp = " + num2str(area(predictedEVresp)^2) + ". Ped = " + num2str(area(predictedEVPed)^2)																				//OLD: Duplicate/O binnedNonLinearityresp, $respBinnedConvSN		//wn Binned was "wnB" + "So"	Variable adjustedcompRegStartX=compRegStartX-winstartX		//that region is chopped off so shift by amount	Variable pearsonR = analyzeNL(respRealNDCSN, respConvSN, respBinnedConvSN,numNonlinearityBins,0,startX=compRegStartX,endX=(compRegStartX+compRegLenX))		//calculate frequency domain characteristics -- scaling handled by Igor 		FFT/out=5/dest=$respPhase_FDSN filter_TD	FFT/out=6/dest=$filterMag_FDSN filter_TD	FFT/out=7/dest=$filterPower_FDSN filter_TD	duplicate/o filter_TD, $filterScaled_TD/wave=filterScaled	variable dimdel=dimdelta(filter_TD,0)	filterScaled *=1/dimdel			//getNormalizedFFTMag("filter_FD", "filterMag_FD")	//WAVE filterMag_FD	//Frequency domain magnitude of filter (not power spectrum)//	Duplicate/O filterMag_FD, filterPhase_FD;		//calculate filterPhase (as a real wave) -- this is equivalent to fft/out=5 which gives phase	//Duplicate/O filter_FD, filterPhase_FD;	//Redimension/R filterPhase_FD			//filterPhase_FD = imag(r2polar(filter_FD))	//filterPhase_FD[0] = filterPhase_FD[1]; Unwrap 2*pi, filterPhase_FD			//calculate power spectrum. No need to time average as this is already a time averaged FFT. The power spectrum is the magsqr of the FFT divided by the number of points in the time domain, unless a window function is used	//Variable numpointsTD = DimSize(filter_TD,0)	//FFT/OUT=7/DEST=filterPower_FD filter_TD	//filterPower_FD /= numpointsTD	//store all in listRef if passed	Variable numOutRefs = 16	Make/O/T/N=(numOutRefs)  $outRefsListRef/wave=outRefsTemp; Variable count = 0	dl_assignAndLbl_T(outRefsTemp, count, stimRef, "stimRef"); count += 1	dl_assignAndLbl_T(outRefsTemp, count, respRef, "respRef"); count += 1	dl_assignAndLbl_T(outRefsTemp, count, stimFromWinNDCSN, "stimFromWinNDCSN"); count += 1	dl_assignAndLbl_T(outRefsTemp, count, respRealNDCSN, "respRealNDCSN"); count += 1	dl_assignAndLbl_T(outRefsTemp, count, filter_TDSN, "filter_TDSN"); count += 1		dl_assignAndLbl_T(outRefsTemp, count, respConvSN, "respConvSN"); count += 1	dl_assignAndLbl_T(outRefsTemp, count, respBinnedConvSN, "respBinnedConvSN"); count += 1	dl_assignAndLbl_T(outRefsTemp, count, filter_FDSN, "filter_FDSN"); count += 1	dl_assignAndLbl_T(outRefsTemp, count, filterMag_FDSN, "filterMag_FDSN"); count += 1	dl_assignAndLbl_T(outRefsTemp, count, filterPower_FDSN, "filterPower_FDSN"); count += 1		dl_assignAndLbl_T(outRefsTemp, count, respPhase_FDSN, "respPhase_FDSN"); count += 1	dl_assignAndLbl_T(outRefsTemp, count, filterFit_TDSN, "filterFit_TDSN"); count += 1	dl_assignAndLbl_T(outRefsTemp, count, windowFuncStr, "windowFuncStr"); count += 1	dl_assignAndLbl_T(outRefsTemp, count, paramsSaveRef, "paramsSaveRef"); count += 1	dl_assignAndLbl_T(outRefsTemp, count, filterScaled_TD, "filterScaled_TD"); count += 1		Variable numPassedParams = 11	Make/O/D/N=(numPassedParams) $paramsSaveRef		//fill for resp first	WAVE/D passedParamsTemp = $paramsSaveRef	Note passedParamsTemp, "WINDOWF:" + windowFuncStr + ";"; variable ii=0	passedParamsTemp[ii] = stimMean; SetDimLabel 0,ii,stimMean,passedParamsTemp	ii+=1;passedParamsTemp[ii] = respMean; SetDimLabel 0,ii,respMean,passedParamsTemp	ii+=1;passedParamsTemp[ii] = pearsonR; SetDimLabel 0,ii,pearsonR,passedParamsTemp	ii+=1;passedParamsTemp[ii] = filterLenX; SetDimLabel 0,ii,filterLenX,passedParamsTemp	ii+=1;passedParamsTemp[ii] = binSpacingX; SetDimLabel 0,ii,binSpacingX,passedParamsTemp	ii+=1;passedParamsTemp[ii] = windowingUsed; SetDimLabel 0,ii,windowingUsed,passedParamsTemp	ii+=1;passedParamsTemp[ii] = winStartX; SetDimLabel 0,ii,winStartX,passedParamsTemp	ii+=1;passedParamsTemp[ii] = winSizeX; SetDimLabel 0,ii,winSizeX,passedParamsTemp	ii+=1;passedParamsTemp[ii] = numNonLinearityBins; SetDimLabel 0,ii,numNonLinearityBins,passedParamsTemp	ii+=1;passedParamsTemp[ii] = compRegStartX; SetDimLabel 0,ii,compRegStartX,passedParamsTemp	ii+=1;passedParamsTemp[ii] = compRegLenX; SetDimLabel 0,ii,compRegLenX,passedParamsTemp end		//wn_myCorr3()function/S wn_genAndTestPredictions(filter_tdRef,stimFamily,respFamily,refsBaseName,outRef,analysisStartX,analysisEndX,dcRegStartX,dcRegEndX,doDisplay)	String filter_tdRef, stimFamily, respFamily			//one filter, matched (paired) list of stimulus and responses	Variable analysisStartX, analysisEndX, dcRegStartX, dcRegEndX, doDisplay			//see wn_genAndTestPrediction for details	String refsBaseName	//pass "" to have auto generated	String outRef		//place to store result refs, autogenerated based on baseName if "" is passed		if (strlen(refsBaseName) < 1)		refsBaseName = replacestring("wnF",filter_tdRef,"")	endif		//all names will use respFamily name as base, so that if there's soma and terminal the convolution result won't be given the same name	String refsList_suffix = "gtpr"		//gen and test predictions refs	String stimNoDcOutRef_suffix = "sND"	String respNoDcOutRef_suffix = "rND"	String predictionOutRef_suffix = "PX"	String pairwiseCompOutRef_suffix = "PW"		//for pair-wise comparison	String paramsWvRef_suffix = "gtpp"	//gen and test predictions params .. only used if outRef passed as ""		String paramsWvRef = refsBaseName + paramsWvRef_suffix	String refsListWvRef	if (strlen(outRef) > 0)		refsListWvRef = outRef	else		refsListWvRef = refsBaseName + refsList_suffix	endif		Print "wn_genAndTestPredictions(): refsListWvRef",refsListWvRef,"paramsWvRef",paramsWvRef		String stimNoDC_outList = "", respNoDc_outList = "", pred_outList = "", pairwiseComp_outList = ""	String subListDelim = ","	String listDelim = ";"		Variable numTraces = ItemsInList(stimFamily)	Variable numParams = 5, r = -1		Make/O/d/N=(numParams,numTraces)  $paramsWvRef/wave=paramsWv	r+=1;paramsWv[r][] = analysisStartX; SetDimLabel 0,r,analysisStartX,paramsWv	r+=1;paramsWv[r][] = analysisEndX; SetDimLabel 0,r,analysisEndX,paramsWv	r+=1;paramsWv[r][] = dcRegStartX; SetDimLabel 0,r,dcRegStartX,paramsWv	r+=1;paramsWv[r][] = dcRegEndX; SetDimLabel 0,r,dcRegEndX,paramsWv	r+=1; SetDimLabel 0,r,peasonR,paramsWv		Variable i; String stimRef, respRef;	String noDCStimOutRef, noDCRespOutRef, predictionOutRef, pairwiseCompOutRef	for (i=0; i<numTraces;i+=1)		stimRef = StringFromList(i, stimFamily)		respRef = StringFromList(i, respFamily)		noDCStimOutRef = refsBaseName + stimNoDcOutRef_suffix + num2str(i); stimNoDC_outList += noDCStimOutRef + listDelim		noDCRespOutRef = refsBaseName + respNoDcOutRef_suffix + num2str(i); respNoDc_outList += noDCRespOutRef + listDelim		predictionOutRef = refsBaseName + predictionOutRef_suffix + num2str(i); pred_outList += predictionOutRef + listDelim		pairwiseCompOutRef = refsBaseName + pairwiseCompOutRef_suffix + num2str(i); pairwiseComp_outList +=  pairwiseCompOutRef + listDelim			//gen and test prediction, store pearson R		paramsWv[r][i] = wn_genAndTestPrediction(filter_tdRef, stimRef, respRef, analysisStartX, analysisEndX, dcRegStartX, dcRegEndX, noDCStimOutRef, noDCRespOutRef, predictionOutRef, pairwiseCompOutRef, 0)	endfor		Make/O/T/N=(7) $refsListWvRef/wave=refsListWv; r = -1	r+=1;dl_assignAndLbl_T(refsListWv, r, stimFamily, "stimFamily")	r+=1;dl_assignAndLbl_T(refsListWv, r, respFamily, "respFamily")	r+=1;dl_assignAndLbl_T(refsListWv, r, stimNoDC_outList, "stimNoDCFamily")	r+=1;dl_assignAndLbl_T(refsListWv, r, respNoDc_outList, "respNoDcFamily")	r+=1;dl_assignAndLbl_T(refsListWv, r, pred_outList, "predFamily")	r+=1;dl_assignAndLbl_T(refsListWv, r, pairwiseComp_outList, "pairCompFamily")	r+=1;dl_assignAndLbl_T(refsListWv, r, paramsWvRef, "paramsWvRef")			String outList_v1=replacestring(listDelim,stimNoDC_outList,subListDelim)+listDelim+replacestring(listDelim,respNoDc_outList,subListDelim)+listDelim+replacestring(listDelim,pred_outList,subListDelim)+listDelim+replacestring(listDelim,pairwiseComp_outList,subListDelim)+listDelim	//	if (doDisplay)//		String dispList = stimNoDC_outList + ";" + respNoDc_outList + ";" + pred_outList + ";"//		String axesList = "L_0;L_1;L_1;"//		String axisPairs = "0,0.1;0.12,1;"//		disp_overlays("", 0, dispList,axesList, "g;b;B;",axisPairs=axisPairs)//, [axisPairs, traceNamesList, normalizationGroupsList, x1, x2])//	endif		return refsListWvRefend		//wn_genAndTestPredictionsfunction wn_genAndTesPredictions_disp(refsWv)	WAVE/T refsWv		//as generated by wn_genAndTestPredictions()		String stimFamily = refsWv[%stimFamily]	WAVE paramsWv = $refsWv[%paramsWvRef]	Variable numTraces = itemsinlist(stimFamily)	Variable i, analysisStartX,analysisEndX	for (i=0;i<numTraces;i+=1)		analysisStartX = paramsWv[%analysisStartX][i]		analysisEndX = paramsWv[%analysisEndX][i]		displayPairwiseComparison(sfl(i,refsWv[%respNoDcFamily]), sfl(i,refsWv[%predFamily]), sfl(i,refsWv[%pairCompFamily]), analysisStartX, analysisEndX)				displayOverlaidPrediction(sfl(i,refsWv[%respNoDcFamily]), sfl(i,refsWv[%stimNoDCFamily]), sfl(i,refsWv[%predFamily]), 0)	endfor	endfunction/S sfl(num,list)	Variable num; string list		return stringfromlist(num,list)	end//same functions used by white noisefunction wn_genAndTestPrediction(filter_tdRef, stimRef, respRef, analysisStartX, analysisEndX, dcRegStartX, dcRegEndX, noDCStimOutRef, noDCRespOutRef, predictionOutRef, pairwiseCompOutRef, doDisplay, [numNonlinearityBins])	String filter_tdRef, stimRef, respRef	Variable analysisStartX, analysisEndX 	//convolution takes place over entirety of stimulus, but edge effects can be avoided by restricting analysis to a region beyond the envelope of the filter	Variable numNonlinearityBins	Variable doDisplay					//pass to plot results	Variable dcRegStartX, dcRegEndX	//these set where baseline subtraction is performed	String noDCStimOutRef, noDCRespOutRef, predictionOutRef, pairwiseCompOutRef		if (ParamIsDefault(numNonlinearityBins))		numNonlinearityBins = 30			//default matches that used by wn_myCorr3	endif	//dc sub	Duplicate/O $stimRef, $noDCStimOutRef/WAVE=stim_noDC	Variable stimMean = wave_subMean(stim_noDC, dcRegStartX, dcRegEndX)	Duplicate/O $respRef, $noDCRespOutRef/WAVE=resp_noDc	Variable respMean = wave_subMean(resp_noDc, dcRegStartX, dcRegEndX)	note/nocr resp_noDC, "resp_baseSub_VAL:" + num2str(respMean) + ";stim_baseSub_VAL:" + num2str(stimMean) + ";"	note/nocr stim_noDC, "resp_baseSub_VAL:" + num2str(respMean) + ";stim_baseSub_VAL:" + num2str(stimMean) + ";"		Print "stimRef",stimRef,"respRef",respRef	Print "filter_tdRef", filter_tdRef, "noDCStimOutRef", noDCStimOutRef, "predictionOutRef",predictionOutRef	convolution(filter_tdRef, noDCStimOutRef, predictionOutRef,"V");		Variable pearsonR = analyzeNL(noDCRespOutRef, predictionOutRef, pairwiseCompOutRef,numNonlinearityBins,0, startX=analysisStartX, endX=analysisEndX);				if (doDisplay)		displayPairwiseComparison(noDCRespOutRef, predictionOutRef, pairwiseCompOutRef, analysisStartX, analysisEndX);		displayOverlaidPrediction(noDCRespOutRef, noDCStimOutRef, predictionOutRef,0);	endif		return pearsonRend//convenient because adds value and window to wave notefunction wave_subMean(inWv, startX, endX)	WAVE inWv; Variable startX, endX		Variable wmean = mean(inWv, startX, endX)	inWv -= wmean; note/NOCR inWv, "BASESUB_VAL:"+num2str(wmean) +";BASESUB_STARTX:"+num2str(startX)+";BASESUB_ENDX:"+num2str(endX)+";"	return wmeanend		//god sizes for fitting all this on one page (three rows, 8.5 x 11):	//width 4 and height 2 for overlay, width and height 2 for pairwise   use disp_matchAxisScaling("L_1;L_0;", 2) for soma and terminal	//height 1.75 for all others	//width 3 for filters	//width 2.5 for power and phase (have right and left axis labels)function wn_disp_pair_g(fromPed, refsListWvRef_s, refsListWvRef_p, diffRefsListWvRef, fDiffRefsListWvRef)	Variable fromPed	String refsListWvRef_s, refsListWvRef_p, diffRefsListWvRef, fDiffRefsListWvRef		Variable refsAt_S = strlen(refsListWvRef_s) > 0, refsAt_P = strlen(refsListWvRef_p) > 0, dualsite = refsAt_S && refsAt_P	Variable diffRefs = strlen(diffRefsListWvRef) > 0, fDiffRefs = strlen(fDiffRefsListWvRef) > 0 		String winN_base,paramsSaveRef_S,paramsSaveRef_P	Variable overlayStart_S,overlayEnd_S,overlayStart_P,overlayEnd_P,usedOverlayStart,usedOverlayEnd	if (refsAt_S)		WAVE/T refsListWv_s=$refsListWvRef_s		winN_base = text_getInfoFromWaveName_S(refsListWv_s[0], 0) + "_" + text_getInfoFromWaveName_S(refsListWv_s[0], 1) //added [0] to refsListWv_s to avoid igor 7 error, not sure if this affects function				paramsSaveRef_S=refsListWv_S[%paramsSaveRef]		WAVE params_S=$paramsSaveRef_S		overlayStart_S=params_S[%compRegStartX]		overlayEnd_S=overlayStart_S+params_S[%compRegLenX]		usedOverlayStart=overlayStart_S		usedOverlayEnd=overlayEnd_S	endif	if (refsAt_P)		WAVE/T refsListWv_p=$refsListWvRef_p		if (!refsAt_S)			winN_base = text_getInfoFromWaveName_S(refsListWv_p[0], 0) + "_" + text_getInfoFromWaveName_S(refsListWv_p[0], 1) //added [0] to refsListWv_s to avoid igor 7 error, not sure if this affects function		endif				paramsSaveRef_P=refsListWv_P[%paramsSaveRef]		WAVE params_P=$paramsSaveRef_P		overlayStart_P=params_P[%compRegStartX]		overlayEnd_P=overlayStart_P+params_P[%compRegLenX]		if (!refsAt_S)			usedOverlayStart=overlayStart_P			usedOverlayEnd=overlayEnd_P			endif	endif	if (diffRefs)		WAVE/T diffRefsList=$diffRefsListWvRef	endif	if (fDiffRefs)		WAVE/T fDiffRefsList=$fDiffRefsListWvRef	endif 	String stimRef	if (fromPed)		stimRef = refsListWv_p[2]	else		stimRef = refsListWv_s[2]	endif		String respRef_s,filter_TDSN_s,respConvSN_s,respBinnedConvSN_s,respPowerRef_s,respPhaseRef_s	if (refsAt_S)		respRef_s = refsListWv_s[3]; wave_check(respRef_s)		filter_TDSN_s = refsListWv_s[4]; wave_check(filter_TDSN_s)		respConvSN_s = refsListWv_s[5]; wave_check(respConvSN_s)		respBinnedConvSN_s = refsListWv_s[6]; wave_check(respBinnedConvSN_s)		//created by downSampleYX, 2 column wave; rows are bins, col 0 = xVal, col 1 = yVal		respPowerRef_s = refsListWv_s[9]; wave_check(respPowerRef_s)		respPhaseRef_s =  refsListWv_s[10]; wave_check(respPhaseRef_s)	endif		String respRef_p,filter_TDSN_p,respConvSN_p,respBinnedConvSN_p,respPowerRef_p,respPhaseRef_p	if (refsAt_p)		respRef_p = refsListWv_p[3]; wave_check(respRef_p)		filter_TDSN_p = refsListWv_p[4]; wave_check(filter_TDSN_p)		respConvSN_p = refsListWv_p[5]; wave_check(respConvSN_p)		respBinnedConvSN_p = refsListWv_p[6]; wave_check(respBinnedConvSN_p)		//created by downSampleYX, 2 column wave; rows are bins, col 0 = xVal, col 1 = yVal		respPowerRef_p = refsListWv_p[9]; wave_check(respPowerRef_p)		respPhaseRef_p =  refsListWv_p[10]; wave_check(respPhaseRef_p)	endif		String filter_TDSN_diff,powerRef_fDiff,phaseRef_fDiff	if (diffRefs) 		filter_TDSN_diff = diffRefsList[4]; wave_check(filter_TDSN_diff) 	endif 	if (fDiffRefs)	 	powerRef_fDiff = fDiffRefsList[9]; wave_check(powerRef_fDiff)		phaseRef_fDiff = fDiffRefsList[10]; wave_check(phaseRef_fDiff)	endif			Variable overlayWinStartX = 10, overlayWinEndX = 10.3	Variable td_startX = 0, td_endX = 0.2		Variable pWiseStartX = usedOverlayStart, pWiseEndX = usedOverlayEnd	Variable pWiseStartP = x2pnt($stimRef, pWiseStartX), pWiseEndP = x2pnt($stimRef, pWiseEndX)	Variable fd_startX = 1, fd_endX = 100	String td_predictedOverlay_w = winN_base + "wnO"; killwindowsbyname(td_predictedOverlay_w+"*")	String td_pointWiseOverlay_w = winN_base + "wnPO"; killwindowsbyname(td_pointWiseOverlay_w+"*")			String td_filter_w = winN_base + "wnF"; killwindowsbyname(td_filter_w+"*")	String fd_power_w = winN_base + "wnFP"; killwindowsbyname(fd_power_w+"*")	String fd_phase_w = winN_base + "wnFPh"; killwindowsbyname(fd_power_w+"*")		Variable r_s = 0, g_s = 0, b_s = 0	Variable r_p = 65280, g_p = 0, b_p = 0	Variable r_st = 30000, g_st = 30000, b_st = 30000		//stimulus = grey	Variable r_d = 0, g_d = 0, b_d = 52224			//difference color = blue		//overlay	String vScaleBarAxis	Display/K=1/N=$td_predictedOverlay_w 		//stim / all	AppendtoGraph/W=$td_predictedOverlay_w/C=(r_st,g_st,b_st)/L=L_2 $stimRef/TN=stim	Modifygraph/W=$td_predictedOverlay_w axisEnab(L_2) = {0,0.18}	Setaxis/W=$td_predictedOverlay_w bottom, overlayWinStartX, overlayWinEndX	SetAxis/W=$td_predictedOverlay_w/A=2 L_2	Label L_2 "\\U"; 			//soma	if (refsAt_S)		AppendToGraph/W=$td_predictedOverlay_w/C=(r_s,g_s,b_s)/L=L_0 $respRef_s/TN=resp_s		AppendToGraph/W=$td_predictedOverlay_w/C=(r_s,g_s,b_s)/L=L_1 $respConvSN_s/TN=pred_s		Modifygraph/W=$td_predictedOverlay_w axisEnab(L_0) = {.45,1},tick(L_0)=3,noLabel(L_0)=1,axRGB(L_0)=(65535,65535,65535)		Setaxis/W=$td_predictedOverlay_w/A=2 L_0		Label L_0 "        Predicted (\\U)";		vScaleBarAxis = "L_0"	endif			//ped	if (refsAt_P)		AppendToGraph/W=$td_predictedOverlay_w/C=(r_p,g_p,b_p)/L=L_0 $respRef_p/TN=resp_p		AppendToGraph/W=$td_predictedOverlay_w/C=(r_p,g_p,b_p)/L=L_1 $respConvSN_p/TN=pred_p		Modifygraph/W=$td_predictedOverlay_w axisEnab(L_1)={.15,.7},tick(L_1)=3,noLabel(L_1)=1,axRGB(L_1)=(65535,65535,65535)		SetAxis/W=$td_predictedOverlay_w/A=2 L_1		Label L_1 "Measured\\u#2      "		vScaleBarAxis = "L_1"	endif			//dual		if (dualSite)		disp_matchAxisScaling_1win("L_0;L_1",winN=td_predictedOverlay_w)	//give same axes to real and predicted		vScaleBarAxis = "L_0"		//prefers somatic L_0 axis in dual site	endif			//y scale bar for voltage	SetDrawEnv ycoord= $vScaleBarAxis,linethick= 3.00;DelayUpdate	DrawLine 0.119791666666667,0.015,0.119791666666667,0.005	SetDrawEnv ycoord= $vScaleBarAxis;DelayUpdate	DrawText 0.135416666666667,0.01,"10 mV"	Modifygraph lblpos =40, freepos = 0, fsize=10; doupdate		//point-wise	Display/K=1/N=$td_pointWiseOverlay_w 			//soma	if (refsAt_S)			AppendToGraph/W=$td_pointWiseOverlay_w/C=(r_s,g_s,b_s)/L=L_0 $respRef_s[pWiseStartP, pWiseEndP]/TN=rawResult_s vs  $respConvSN_s[pWiseStartP, pWiseEndP]		AppendToGraph/W=$td_pointWiseOverlay_w/C=(r_s,g_s,b_s)/L=L_0 $respBinnedConvSN_s[][1]/TN=binnedResults_s vs $respBinnedConvSN_s[][0]		AppendToGraph/W=$td_pointWiseOverlay_w/C=(r_s,g_s,b_s)/L=L_0 $respBinnedConvSN_s[][2]/TN=binnedResFit_s vs $respBinnedConvSN_s[][0]		ModifyGraph/W=$td_pointWiseOverlay_w mode(rawResult_s)=2,mode(binnedResults_s)=4,marker(binnedResults_s)=19,useMrkStrokeRGB(binnedResults_s)=1,mrkStrokeRGB(binnedResults_s)=(43520,43520,43520)		ModifyGraph/W=$td_pointWiseOverlay_w lstyle(binnedResFit_s)=3,lsize(binnedResFit_s)=2.5,rgb(binnedResFit_s)=(26112,26112,26112)		ErrorBars/W=$td_pointWiseOverlay_w binnedResults_s Y,wave=($respBinnedConvSN_s[*][%ySEM],$respBinnedConvSN_s[*][%ySEM])	endif		//ped	if (refsAT_P)		AppendToGraph/W=$td_pointWiseOverlay_w/C=(r_p,g_p,b_p)/L=L_0  $respRef_p[pWiseStartP, pWiseEndP]/TN=rawResult_p vs $respConvSN_p[pWiseStartP, pWiseEndP]		AppendToGraph/W=$td_pointWiseOverlay_w/C=(r_p,g_p,b_p)/L=L_0 $respBinnedConvSN_p[][1]/TN=binnedResults_p vs $respBinnedConvSN_p[][0]		AppendToGraph/W=$td_pointWiseOverlay_w/C=(r_p,g_p,b_p)/L=L_0 $respBinnedConvSN_p[][2]/TN=binnedResFit_p vs $respBinnedConvSN_p[][0]		ModifyGraph/W=$td_pointWiseOverlay_w mode(rawResult_p)=2,mode(binnedResults_p)=4,marker(binnedResults_p)=19,useMrkStrokeRGB(binnedResults_p)=1,mrkStrokeRGB(binnedResults_p)=(43520,43520,43520)		ModifyGraph/W=$td_pointWiseOverlay_w lstyle(binnedResFit_p)=3,lsize(binnedResFit_p)=2.5,rgb(binnedResFit_p)=(26112,26112,26112)		ErrorBars/W=$td_pointWiseOverlay_w binnedResults_P Y,wave=($respBinnedConvSN_P[*][%ySEM],$respBinnedConvSN_P[*][%ySEM])	endif		//all	Modifygraph/W=$td_pointWiseOverlay_w lblpos = 52, freepos = 0	Variable winSizeX_in = 4, winSizeY_in = 4	ModifyGraph/W=$td_pointWiseOverlay_w height=72*winSizeX_in, width=72*winSizeY_in	Label/W=$td_pointWiseOverlay_w bottom "Predicted (\\U)";DelayUpdate	Label/W=$td_pointWiseOverlay_w L_0 "Measured (\\U)"	SetAxis/A=2 L_0; SetAxis/A=2 bottom;	doUpdate	disp_matchAxisScaling_1win("bottom;L_0",winN=td_pointWiseOverlay_w)//, winN=td_pointWiseOverlay_w)			//make left and bottom have same range, choosing the larger range of the two		//dual	if (dualSite)		ReorderTraces/W=$td_pointWiseOverlay_w binnedResults_s,{rawResult_p};DelayUpdate		ReorderTraces/W=$td_pointWiseOverlay_w binnedResFit_s,{binnedResults_p}	endif	//td_filter	Display/K=1/N=$td_filter_w 	if (refsAt_S)		AppendToGraph/C=(r_s,g_s,b_s)/L=L_0 $filter_TDSN_s/TN=filterTD_s	endif	if (refsAt_P)		AppendToGraph/C=(r_p,g_p,b_p)/L=L_0 $filter_TDSN_p/TN=filterTD_p		endif	if (dualSite)		AppendToGraph/C=(r_d,g_d,b_d)/R=R_0 $filter_TDSN_diff/TN=filter_TDSN_diff	//skip first point for difference since difference at zero is very close to dividing by zero		SetAxis/A=2 R_0	endif	Setaxis bottom, td_startX, td_endX; SetAxis/A=2 L_0	Modifygraph lblpos = 52, freepos = 0	ModifyGraph highTrip(L_0)=1e+11,lowTrip(L_0)=1e-11,prescaleExp(L_0)=-9; Label L_0 "Filter (mV/pA)\\u#2"		//fd_power	Display/K=1/N=$fd_power_w	if (refsAt_S)		AppendToGraph/C=(r_s,g_s,b_s)/L=L_0 $respPowerRef_s/TN=filterPower_s	endif	if (refsAt_P)		AppendToGraph/C=(r_p,g_p,b_p)/L=L_0 $respPowerRef_p/TN=filterPower_p	endif	if (dualSite)		AppendToGraph/C=(r_d,g_d,b_d)/R=R_0 $powerRef_fDiff/TN=powerRef_fDiff		SetAxis/A=2 R_0		Label R_0 "\\K(0,0,52224)---\\K(0,0,0)  Fold \\u#2\\F'Wingdings 3'r\\F'Arial' Rel. Soma\\K(0,0,52224)  ---\\K(0,0,0)\\u#2"	endif	Modifygraph lblpos = 52, freepos = 0	Setaxis bottom, fd_startX, fd_endX; setAxis/A=2 L_0	ModifyGraph log(L_0)=1	modifygraph prescaleExp(L_0) = -12	ModifyGraph logHTrip(L_0)=1e+38,logLTrip(L_0)=1e-38	Label L_0 "Power (mV/nA)\\S2\\M/Hz"		//fd_phase	Display/K=1/N=$fd_phase_w	if (refsAt_S)		AppendToGraph/C=(r_s,g_s,b_s)/L=L_0 $respPhaseRef_s/TN=filterPhase_s	endif	if (refsAt_P)		AppendToGraph/C=(r_p,g_p,b_p)/L=L_0 $respPhaseRef_p/TN=filterPhase_p	endif	if (dualSite)		AppendToGraph/C=(r_d,g_d,b_d)/R=R_0 $phaseRef_fDiff/TN=phaseRef_fDiff		SetAxis/A=2 R_0		Label R_0 "\\K(0,0,52224)---\\K(0,0,0)  Fold \\u#2\\F'Wingdings 3'r\\F'Arial' Rel. Soma\\K(0,0,52224)  ---\\K(0,0,0)\\u#2"		endif	Modifygraph lblpos = 52, freepos = 0		Setaxis bottom, fd_startX, fd_endX; setAxis/A=2 L_0	Label L_0 "Phase (rad.)\\u#2";DelayUpdate	Label bottom "Frequency (\\U)";DelayUpdate	end	//wn_disp_pair_g()//checks a list of waves and returns true if all exist, zero if one or more do not exist (uses wave_check() on each ref)function wave_checkList(refsList)	String refsList		Variable i; String failList = "", ref	for (i=0;i<ItemsInList(refsList);i+=1)		ref = StringFromList(i, refsList)		if (!wave_check(ref))			failList += ref		endif	endfor		if (ItemsInList(failList))		Print "Waves not found in list. Missing waves:",failList,"Call stack:" ,GetRTStackInfo(3)		return 0	endif		return 1end	function wave_check(ref)	String ref		Variable wExists = WaveExists($ref)	Variable wHasPoints = numpnts($ref) > 1		if (!wExists)		Print "wave_check on " + ref + ". Wave does not exist. CallStack: " + GetRTStackInfo(3)		return 0	endif		if (!wHasPoints)		Print "wave_check on " + ref + ". Wave has only one point. CallStack: " + GetRTStackInfo(3)		return 0	endif		return 1	endfunction wn_disp_g(refsListWv, winN_base)	WAVE/T refsListWv; String winN_base		//save noDC data  (original data is already "saved" as original ref, should be used from this//	String stimFromWinNDCSN = respRef + "wnSNCD"; Duplicate/O stimWaveNoDC, $stimFromWinNDCSN	//stimR No Dc//	String respRealNDCSN = respRef + "wnRNDC"; Duplicate/O respWaveNoDC, $respRealNDCSN	//wnR No DC//	//save convolution data //	String filter_TDSN = respRef + "wnF"; Duplicate/O filter_TD, $filter_TDSN		//wn Filter//	String respConvSN = respRef + "wnP" ; Duplicate/O respPredicted, $respConvSN		//wn Prediction//	String respBinnedConvSN = respRef + "wnB" + "So"; Duplicate/O binnedNonLinearityresp, $respBinnedConvSN		//wn Binned//	//save names for frequency domain filters//	String filter_FDSN = respRef + "wnFF" ; Duplicate/O filter_FD, $filter_FDSN		//wn Filter FD//	String filterMag_FDSN = respRef + "wnFFNM"; Duplicate/O filterMag_FD, $filterMag_FDSN	//wn Filter FD Normalized Mag//	String filterPower_FDSN = respRef + "wnFP"; Duplicate/O filterPower_FD, $filterPower_FDSN		//wn Filter Power//	String respPhase_FDSN = respRef + "wnFPh"; 	Duplicate/O filterPhase_FD, $respPhase_FDSN; 	//wn Filter Phase//	//	//save names for fit to TD linear filter //these last two created by wn_computePairedCorrParams//	String filterFit_TDSN = respRef + "wnAP"				//wn Analysis Params'//	outRefsTemp[0] = stimRef//	outRefsTemp[1] = respRef//	outRefsTemp[2] = stimFromWinNDCSN//	outRefsTemp[3] = respRealNDCSN//	outRefsTemp[4] = filter_TDSN//	outRefsTemp[5] = respConvSN//	outRefsTemp[6] = respBinnedConvSN //	outRefsTemp[7] = filter_FDSN//	outRefsTemp[8] = filterMag_FDSN//	outRefsTemp[9] = filterPower_FDSN//	outRefsTemp[10] = respPhase_FDSN//	outRefsTemp[11] = filterFit_TDSN//	outRefsTemp[12] = windowFuncStr//	outRefsTemp[13] = paramsSaveRef	String stimRef = refsListWv[2]		String respRef = refsListWv[3] 	String filter_TDSN = refsListWv[4]	String respConvSN = refsListWv[5]	String respBinnedConvSN = refsListWv[6]		//created by downSampleYX, 2 column wave; rows are bins, col 0 = xVal, col 1 = yVal	String respPowerRef = refsListWv[9]	String respPhaseRef =  refsListWv[10]	Variable overlayWinStartX = 10, overlayWinEndX = 10.3	Variable pWiseStartX = 10, pWiseEndX = 35	Variable pWiseStartP = x2pnt($respRef, pWiseStartX), pWiseEndP = x2pnt($respRef, pWiseEndX)	Variable fd_startX = 1, fd_endX = 100	String td_predictedOverlay_w = winN_base + "wnR"; killwindowsbyname(td_predictedOverlay_w+"*")		String td_filter_w = winN_base + "wnF"; killwindowsbyname(td_filter_w+"*")	String fd_power_w = winN_base + "wnFP"; killwindowsbyname(fd_power_w+"*")	String fd_phase_w = winN_base + "wnFPh"; killwindowsbyname(fd_power_w+"*")		//overlay	Display/K=1/N=$td_predictedOverlay_w 	AppendToGraph/C=(0,0,0)/L=L_0 $respRef/TN=resp	AppendToGraph/C=(0,50000,0)/L=L_0 $respConvSN/TN=pred	AppendtoGraph/C=(30000,30000,30000)/L=L_1 $stimRef/TN=stim	Modifygraph lblpos =52, freepos = 0, axisEnab(L_0) = {.35,1}, axisEnab(L_1)={0,.35}	Setaxis bottom, overlayWinStartX, overlayWinEndX; Setaxis/A=2 L_0; SetAxis/A=2 L_1	//point-wise	Display/K=1/N=$td_predictedOverlay_w 	AppendToGraph/C=(0,0,0)/L=L_0 $respConvSN[pWiseStartP, pWiseEndP]/TN=rawResult vs  $respRef[pWiseStartP, pWiseEndP]	AppendToGraph/C=(0,0,0)/L=L_0 $respBinnedConvSN[][1]/TN=binnedResults vs $respBinnedConvSN[][0]	AppendToGraph/C=(0,0,0)/L=L_0 $respBinnedConvSN[][2]/TN=binnedResFit vs $respBinnedConvSN[][0]	Modifygraph lblpos = 52, freepos = 0	//td_filter	Display/K=1/N=$td_filter_w 	AppendToGraph/C=(0,0,0)/L=L_0 $filter_TDSN/TN=filterTD	Modifygraph lblpos = 52, freepos = 0	//fd_power	Display/K=1/N=$fd_power_w	AppendToGraph/C=(0,0,0)/L=L_0 $respPowerRef/TN=filterPower	Modifygraph lblpos = 52, freepos = 0	Setaxis bottom, fd_startX, fd_endX; setAxis/A=2 L_0	//fd_phase	Display/K=1/N=$fd_phase_w	AppendToGraph/C=(0,0,0)/L=L_0 $respPhaseRef/TN=filterPhase	Modifygraph lblpos = 52, freepos = 0		Setaxis bottom, fd_startX, fd_endX; setAxis/A=2 L_0		end//wn_disp_gfunction wn_getSelectedRep(row,isPed)	Variable row, isPed		WAVE/T wnSummary	return WhichListItem("2", wnSummary[row][25+isPed])endfunction wn_saveRefs(refList, pathStr, saveList)	String refList, pathStr	String &saveList		//help avoid attempts at duplicate saving, which seems to cause a serious error and stop further saves 		WAVE/T listWave = $refList	NVAR dupsCount			Variable i; String currRef	for (i=0;i<DimSize(listWave,0);i+=1)		currRef = listWave[i]		if (WaveExists($currRef) && WhichListItem(currRef, saveList) < 0)			SAVE/C/O/P=$pathStr $currRef			saveList += currRef + ";"		elseif (WaveExists($currRef) && WhichListItem(currRef, saveList) >= 0)			dupsCount +=1		endif	endfor	Print "dupscount = " +num2str(dupscount)endfunction wn_dispOverlay(row, fromPed, repNum)	Variable row, fromPed, repNum		WAVE/T wnSummary		String currStim = StringFromList(repNum, wnSummary[row][2 + (3*fromPed)])	String currSoma = StringFromList(repNum, wnSummary[row][3  + (3*fromPed)])	String currPed = StringFromList(repNum, wnSummary[row][4 + (3*fromPed)])		String winN = disp_overlays(currStim, 0, currSoma + "," + currPed +",;" +currStim +";","L_0;L_1", "b,R;g;", axisPairs=".2,1;0,.18")	SetAxis/W=$winN bottom, 10, 10.2; disp_setAxisToA2("L*", winN=winN)end//parameterized wn cross correlation at one site. Stores results in filterParamsSN from myCorr3//	wn_computePairedCorrParams(outRefsListRef, 0, "respWNParamsTemp", passedParams = passedParamsTemp)function wn_myCorr3Params_v2(refsListRef,[keyedRefList,skipFilter,skipPhase,powerSmoothParam])	String refsListRef		//output of myCorr3	String keyedRefList	//force references by keys instead of presumed sin	Variable skipFilter,skipPhase	Variable powerSmoothParam		//pass an odd number to use in power spectrum smoothing (helps for peak finding)		Variable doExpFit = 0	Variable doFilter=ParamIsDefault(skipFilter) || !skipFilter	VAriable doPhase=ParamIsDefault(skipPhase) || !skipPhase			Variable areaMeasureCutOffFreq = 250		String paramsOutRef,filterFit_FDSN	if ( ParamIsDefault(keyedRefList) || (strlen(keyedRefList) < 1) )		WAVE/T listTemp = $refsListRef		paramsOutRef = listTemp[%paramsSaveRef]		Print "starting wn_myCorr3Params(), refsListRef = " + refsListRef + ". paramsOutRef = " + paramsOutRef				//STARTING CALCULATING FILTER INFO ON SCALED VERSION 180509 filter_TDSN became filterScaled_TD (local wave is still filter_TD!!!)		Variable headerLookupFailure, failCount = 0		WAVE stimWaveNoDC = $listTemp[%stimFromWinNDCSN]		WAVE respWaveNoDC = $listTemp[%respRealNDCSN]		WAVE filter_TD = $listTemp[%filterScaled_TD]		WAVE respPower_FD = $listTemp[%filterPower_FDSN]		WAVE filterPhase_FD = $listTemp[%respPhase_FDSN]		WAVE respMag_FD = $listTemp[%filterMag_FDSN]		filterFit_FDSN =listTemp[%filterFit_TDSN]	else		paramsOutRef = stringbykey("paramsOutRef",keyedRefList)		Print "starting wn_myCorr3Params() with keyedRefList input. paramsOutRef = " + paramsOutRef				WAVE/Z stimWaveNoDC = $stringbykey("stimFromWinNDCSN",keyedRefList)		WAVE respWaveNoDC = $stringbykey("respWaveNoDC",keyedRefList)		WAVE/Z filter_TD = $stringbykey("filterScaled_TD",keyedRefList)		//meaningless ish for chirp		WAVE respPower_FD = $stringbykey("respPower_FD",keyedRefList)		//planning to pass impedence / amplitude FFT diffs for chirp		WAVE/Z respMag_FD = $stringbykey("filterMag_FDSN",keyedRefList)			WAVE/Z filterPhase_FD = $stringbykey("filterPhase_FD",keyedRefList)		filterFit_FDSN = stringbykey("filterFit_TDSN",keyedRefList)		endif	Variable filterLenX = nan	if (doFilter)		filterLenX = DimSize(filter_TD,0) * DimDelta(filter_TD,0)	endif		variable hasStim=WaveExists(stimWaveNoDC)		//Variance	Variable stimDCVariance = hasStim ? variance(stimWaveNoDC) : 0	Variable respDCVariance = variance(respWaveNoDC)	Print  "stimDCVariance = " + num2str(stimDCVariance), "respDCVariance = " + num2str(respDCVariance)	Variable resp_ssRes, resp_x0		//fitExpsAndPlot will store ssRes in these variables	Variable storeExpParams=0	if (doFilter && doExpFit)		//fit to sum of 4 exponentials (mostly to smooth--at first had hoped to get a nice time constant for each event but doesnt really seem to reflect just one event		Make/O/D coefWave =  {-1436.26,-1.00066e+06,0.0613322,2.57536e+06,0.0281398,-1.74838e+06,0.000167522,-3994.3,0.0692655}		//some initial conditions that were found previously and work well enough		String respExpFit = fitExpsAndPlot(coefWave, filterFit_FDSN, 1, 3, toFitRef = NameOfWave(filter_TD), plotWinName = NameOfWave(filter_TD) + "_F", ssResVar = resp_ssRes, x0Var = resp_x0)		WAVE filter_TD_fit = $filterFit_FDSN		//latter created by fitExpsAndPlot			storeExpParams = 1	endif	//max and min and 50% computed on original (had thought of using fit because sometimes there are fluctuations in the negative region, especially prominenet in some foveal filters, but these are still minor. Should check each to see if needed		Variable filterMaxLoc=nan,filterMaxVal=nan,filterMinLoc=nan,filterMinVal=nan,respFirstHalfMaxLoc=nan,respSecondHalfMaxLoc=nan,filterWidthAtHalfMAx=nan	Variable respNegRegionFound=nan,respZeroCrossing=nan,respFirstHalfMinLoc=nan,respSecondHalfMinLoc=nan	Variable respTotalFilterArea=nan,respPositiveFilterArea=nan,respNegativeFilterArea	=nan		if (doFilter)		WaveStats /Q/Z filter_TD		filterMaxLoc = V_maxLoc		filterMaxVal = V_max		filterMinLoc = V_minLoc		filterMinVal = V_min				FindLevel/EDGE=1/Q/R=(0,V_maxLoc) filter_TD, V_max/2		respFirstHalfMaxLoc = V_flag ? 0 : V_levelX		//if level not found (V_flag = 1), assumes it is because filter is already > 50% max at start of wave, so set start time to 0		FindLevel/EDGE=2/Q/R=(V_maxLoc, filterLenX) filter_TD, V_max/2		respSecondHalfMaxLoc = V_flag ? NaN : V_levelX		//if level not found (V_flag = 1), assumes it is because filter NEVER returns to < 50% peak. Warns user because this is unexpected		if (V_flag)			Print "Warning in myCorr2(). While computing respFallingHalfMaxLoc, falling phase not found"		endif		filterWidthAtHalfMAx=respSecondHalfMaxLoc - respFirstHalfMaxLoc				//SMOOTHING PERFORMED FOR MIN AS SOME FOVEAL FILTERS HAVE SOME FLUCTUATIONS HERE		respNegRegionFound = 0		if (V_min < 0)		//then filter has a negative-going region, compute stats for minimum peak			respNegRegionFound = 1			FindLevel/EDGE=2/Q/R=(V_maxLoc, V_minLoc) filter_TD, 0			//find zeroCrossing			respZeroCrossing = V_flag ? NaN : V_levelX				FindLevel/EDGE=2/Q/R=(V_maxLoc, V_minLoc) filter_TD, V_min / 2			respFirstHalfMinLoc = V_flag ? NaN : V_levelX				FindLevel/EDGE=1/Q/R=(V_minLoc, filterLenX) filter_TD, V_min / 2			respSecondHalfMinLoc = V_flag ? NaN : V_levelX			endif		//areas computed on real waves		getAreas(filter_TD, respTotalFilterArea, respPositiveFilterArea, respNegativeFilterArea, x1=0, x2=filterLenX)	endif		//peak info for impedance magnitude	Variable respMag_FD_max=nan, respMag_FD_maxLoc=nan, respMag_FD_FirstHalfMaxLoc=nan, respMag_FD_secondHalfMaxLoc=nan	Variable respMag_FD_FWHM=nan,respMag_FD_FWHM_Mid=nan	if (WaveExists(respMag_FD))		getPeakInfo(respMag_FD, 1, 0.5, respMag_FD_max, respMag_FD_maxLoc, respMag_FD_FirstHalfMaxLoc, respMag_FD_secondHalfMaxLoc)		respMag_FD_FWHM = respMag_FD_secondHalfMaxLoc - respMag_FD_FirstHalfMaxLoc		respMag_FD_FWHM_Mid = respMag_FD_FirstHalfMaxLoc + (respMag_FD_FWHM / 2)	endif			Duplicate/O/free respPower_FD, respPower_FD_smooth	Variable defaultPowerSmoothParam=5	Variable powerSmooth=(ParamIsDefault(powerSmoothParam)||numtype(powerSmoothParam)) ? defaultPowerSmoothParam : powerSmoothParam	if (powerSmooth != 0)		//if zero is passed, skip (e.g., in case the calling function already performed smoothing or none is needed)		Smooth/S=2 powerSmooth, respPower_FD_smooth		//least smoothing polynomial smoothing available with this algorithm. compared with binomial and boxcar and this seemed a little better (captured initial rise and peak better, only by eye though)	endif	Variable respPower_FD_max, respPower_FD_maxLoc, respPower_FD_FirstHalfMaxLoc, respPower_FD_secondHalfMaxLoc	getPeakInfo(respPower_FD_smooth, 1, 0.5, respPower_FD_max, respPower_FD_maxLoc, respPower_FD_FirstHalfMaxLoc, respPower_FD_secondHalfMaxLoc)	Variable respPower_FD_FWHM = respPower_FD_secondHalfMaxLoc - respPower_FD_FirstHalfMaxLoc	Variable respPower_FD_FWHM_Mid = respPower_FD_FirstHalfMaxLoc + (respPower_FD_FWHM / 2)	Variable respPower_totalArea = area(respPower_FD,pnt2x(respPower_FD,1),areaMeasureCutOffFreq)		//does not include DC	Variable respPower_DC = respPower_FD[0]	Variable respPower_Below20HzArea = area(respPower_FD , pnt2x(respPower_FD,1), 20)	Variable respPower_20to40HzArea = area(respPower_FD, 20,40)	Variable respPower_40to60HzArea = area(respPower_FD, 40,60)	Variable respPower_60to250HzArea = area(respPower_FD, 60, areaMeasureCutOffFreq)	//phase spectrum summary	Double respPhase_totArea=nan, respPhase_posArea=nan, respPhase_negArea=nan	Double respPhase_Below20Hz_totArea=nan, respPhase_Below20Hz_negArea=nan, respPhase_Below20Hz_posArea=nan	Double respPhase_20to40Hz_totArea=nan, respPhase_20to40Hz_negArea=nan, respPhase_20to40Hz_posArea=nan	Double respPhase_40to60Hz_totArea=nan, respPhase_40to60Hz_negArea=nan, respPhase_40to60Hz_posArea=nan	Double respPhase_60to250Hz_totArea=nan, respPhase_60to250Hz_negArea=nan, respPhase_60to250Hz_posArea=nan	Double respPhase_zeroCrossing=nan, respPhase_negPeak=nan, respPhase_negPeakLoc=nan,  respPhase_negPeak_firstHalfLoc=nan, respPhase_secondHalfLoc=nan	Double respPhase_negFWHM=nan,respPhase_negFWHMMid=nan	if (doPhase)		getAreas(filterPhase_FD, respPhase_totArea, respPhase_posArea, respPhase_negArea, x1=pnt2x(filterPhase_FD,1),x2=areaMeasureCutOffFreq); 	//start from point 1 to ignore DC		getAreas(filterPhase_FD, respPhase_Below20Hz_totArea, respPhase_Below20Hz_posArea, respPhase_Below20Hz_negArea, x1=pnt2x(filterPhase_FD,1),x2=20); 		getAreas(filterPhase_FD, respPhase_20to40Hz_totArea, respPhase_20to40Hz_posArea, respPhase_20to40Hz_negArea, x1=20,x2=40); 		getAreas(filterPhase_FD, respPhase_40to60Hz_totArea, respPhase_40to60Hz_posArea, respPhase_40to60Hz_negArea, x1=40,x2=60); 		getAreas(filterPhase_FD, respPhase_60to250Hz_totArea, respPhase_60to250Hz_posArea, respPhase_60to250Hz_negArea, x1=60,x2=areaMeasureCutOffFreq); 		getPeakInfo(filterPhase_FD, -1, 0.5, respPhase_negPeak, respPhase_negPeakLoc, respPhase_negPeak_firstHalfLoc, respPhase_secondHalfLoc, x2=20)		FindLevel /EDGE=1/Q/R=(respPhase_negPeakLoc,1000) filterPhase_FD, 0		respPhase_zeroCrossing = V_LevelX		respPhase_negFWHM = respPhase_secondHalfLoc - respPhase_negPeak_firstHalfLoc		respPhase_negFWHMMid = respPhase_negPeak_firstHalfLoc + ( respPhase_negFWHM / 2 )	endif			//save general parameters of this analysis//	Variable numParams = 9+26+35	WAVE/D wn_paramsTemp = $paramsOutRef		//numpnts 9 wave with initial params	Variable origNumParams = dimsize(wn_paramsTemp,0)	Variable newNumParams0=68		//update when adding params iterated by ii below	Redimension/N=(origNumParams+newNumParams0) wn_paramsTemp		//now has enough room for rest of wave	Variable ii=origNumParams;wn_paramsTemp[ii] = stimDCVariance;setdimlabel 0,ii,stimDCVariance,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respDCVariance;setdimlabel 0,ii,respDCVariance,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = filterMaxLoc;setdimlabel 0,ii,filterMaxLoc,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = filterMaxVal;setdimlabel 0,ii,filterMaxVal,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = filterMinLoc;setdimlabel 0,ii,filterMinLoc,wn_paramsTemp		ii+=1;wn_paramsTemp[ii] = filterMinVal;setdimlabel 0,ii,filterMinVal,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respFirstHalfMaxLoc;setdimlabel 0,ii,respFirstHalfMaxLoc,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respSecondHalfMaxLoc;setdimlabel 0,ii,respSecondHalfMaxLoc,wn_paramsTemp 	ii+=1;wn_paramsTemp[ii] = filterWidthAtHalfMAx;setdimlabel 0,ii,filterWidthAtHalfMAx,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respNegRegionFound;setdimlabel 0,ii,respNegRegionFound,wn_paramsTemp		ii+=1;wn_paramsTemp[ii] = respZeroCrossing;setdimlabel 0,ii,respZeroCrossing,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respFirstHalfMinLoc;setdimlabel 0,ii,respFirstHalfMinLoc,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respSecondHalfMinLoc;setdimlabel 0,ii,respSecondHalfMinLoc,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respTotalFilterArea;setdimlabel 0,ii,respTotalFilterArea,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respPositiveFilterArea;setdimlabel 0,ii,respPositiveFilterArea,wn_paramsTemp		ii+=1;wn_paramsTemp[ii] = respNegativeFilterArea;setdimlabel 0,ii,respNegativeFilterArea,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = resp_ssRes;setdimlabel 0,ii,resp_ssRes,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = resp_x0;setdimlabel 0,ii,resp_x0,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = !storeExpParams ? NaN : coefWave[0];setdimlabel 0,ii,coefWave0,wn_paramsTemp			//resp y0	ii+=1;wn_paramsTemp[ii] = !storeExpParams ? NaN : coefWave[1];setdimlabel 0,ii,coefWave1,wn_paramsTemp			//c1 a1		ii+=1;wn_paramsTemp[ii] = !storeExpParams ? NaN : coefWave[2];setdimlabel 0,ii,coefWave2,wn_paramsTemp			//c1 tau1	ii+=1;wn_paramsTemp[ii] = !storeExpParams ? NaN : coefWave[3];setdimlabel 0,ii,coefWave3,wn_paramsTemp			//c2 a1 ....	ii+=1;wn_paramsTemp[ii] = !storeExpParams ? NaN : coefWave[4];setdimlabel 0,ii,coefWave4,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = !storeExpParams ? NaN : coefWave[5];setdimlabel 0,ii,coefWave5,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = !storeExpParams ? NaN : coefWave[6];setdimlabel 0,ii,coefWave6,wn_paramsTemp		ii+=1;wn_paramsTemp[ii] = !storeExpParams ? NaN : coefWave[7];setdimlabel 0,ii,coefWave7,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = !storeExpParams ? NaN : coefWave[8];setdimlabel 0,ii,coefWave8,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respPower_FD_max;setdimlabel 0,ii,respPower_FD_max,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respPower_FD_maxLoc;setdimlabel 0,ii,respPower_FD_maxLoc,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respPower_FD_FirstHalfMaxLoc;setdimlabel 0,ii,respPower_FD_FirstHalfMaxLoc,wn_paramsTemp		ii+=1;wn_paramsTemp[ii] = respPower_FD_secondHalfMaxLoc;setdimlabel 0,ii,respPower_FD_secondHalfMaxLoc,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respPower_FD_FWHM;setdimlabel 0,ii,respPower_FD_FWHM,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respPower_FD_FWHM_Mid;setdimlabel 0,ii,respPower_FD_FWHM_Mid,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respPower_totalArea;setdimlabel 0,ii,respPower_totalArea,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respPower_DC;setdimlabel 0,ii,respPower_DC,wn_paramsTemp		ii+=1;wn_paramsTemp[ii] = respPower_Below20HzArea;setdimlabel 0,ii,respPower_Below20HzArea,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respPower_20to40HzArea;setdimlabel 0,ii,respPower_20to40HzArea,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respPower_40to60HzArea;setdimlabel 0,ii,respPower_40to60HzArea,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respPower_60to250HzArea;setdimlabel 0,ii,respPower_60to250HzArea,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respPhase_totArea;setdimlabel 0,ii,respPhase_totArea,wn_paramsTemp //phase area		ii+=1;wn_paramsTemp[ii] = respPhase_posArea;setdimlabel 0,ii,respPhase_posArea,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respPhase_negArea;setdimlabel 0,ii,respPhase_negArea,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respPhase_Below20Hz_totArea;setdimlabel 0,ii,respPhase_Below20Hz_totArea,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respPhase_Below20Hz_posArea;setdimlabel 0,ii,respPhase_Below20Hz_posArea,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respPhase_Below20Hz_negArea;setdimlabel 0,ii,respPhase_Below20Hz_negArea,wn_paramsTemp		ii+=1;wn_paramsTemp[ii] = respPhase_20to40Hz_totArea;setdimlabel 0,ii,respPhase_20to40Hz_totArea,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respPhase_20to40Hz_posArea;setdimlabel 0,ii,respPhase_20to40Hz_posArea,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respPhase_20to40Hz_negArea;setdimlabel 0,ii,respPhase_20to40Hz_negArea,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respPhase_40to60Hz_totArea;setdimlabel 0,ii,respPhase_40to60Hz_totArea,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respPhase_40to60Hz_posArea;setdimlabel 0,ii,respPhase_40to60Hz_posArea,wn_paramsTemp		ii+=1;wn_paramsTemp[ii] = respPhase_40to60Hz_negArea;setdimlabel 0,ii,respPhase_40to60Hz_negArea,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respPhase_60to250Hz_totArea;setdimlabel 0,ii,respPhase_60to250Hz_totArea,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respPhase_60to250Hz_posArea;setdimlabel 0,ii,respPhase_60to250Hz_posArea,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respPhase_60to250Hz_negArea;setdimlabel 0,ii,respPhase_60to250Hz_negArea,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respPhase_negPeak;setdimlabel 0,ii,respPhase_negPeak,wn_paramsTemp		ii+=1;wn_paramsTemp[ii] = respPhase_negPeakLoc;setdimlabel 0,ii,respPhase_negPeakLoc,wn_paramsTemp //phase negative peak	ii+=1;wn_paramsTemp[ii] = respPhase_negPeak_firstHalfLoc;setdimlabel 0,ii,respPhase_negPeak_firstHalfLoc,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respPhase_secondHalfLoc;setdimlabel 0,ii,respPhase_secondHalfLoc,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respPhase_zeroCrossing;setdimlabel 0,ii,respPhase_zeroCrossing,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respPhase_negFWHM;setdimlabel 0,ii,respPhase_negFWHM,wn_paramsTemp		ii+=1;wn_paramsTemp[ii] = areaMeasureCutOffFreq;setdimlabel 0,ii,areaMeasureCutOffFreq,wn_paramsTemp //cut off frequency for measurement	ii+=1;wn_paramsTemp[ii] = powerSmooth;setdimlabel 0,ii,powerSmooth,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respMag_FD_max;setdimlabel 0,ii,respMag_FD_max,wn_paramsTemp 	//impedance / magnitude related	ii+=1;wn_paramsTemp[ii] = respMag_FD_maxLoc;setdimlabel 0,ii,respMag_FD_maxLoc,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respMag_FD_FirstHalfMaxLoc;setdimlabel 0,ii,respMag_FD_FirstHalfMaxLoc,wn_paramsTemp		ii+=1;wn_paramsTemp[ii] = respMag_FD_secondHalfMaxLoc;setdimlabel 0,ii,respMag_FD_secondHalfMaxLoc,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respMag_FD_FWHM;setdimlabel 0,ii,respMag_FD_FWHM,wn_paramsTemp	ii+=1;wn_paramsTemp[ii] = respMag_FD_FWHM_Mid;setdimlabel 0,ii,respMag_FD_FWHM_Mid,wn_paramsTemp		//ADDITIONAL ANALYSIS 	String frequencyWindows="0,0;0.5,0.5;1,1;2,2;2.5,2.5;5,5;10,10;15,15;30,30;40,40;50,50;60,60;75,75;90,90;"		//point frequencies	make/free/o freqs = {1,2.5,5,15,30,60,90}	VAriable i,num=dimsize(freqs,0),prop,start,finish,wavelen,freq	prop=0.1	for (i=0;i<num;i+=1)		freq=freqs[i]		wavelen = freq*prop*0.5	//half of the proportion of the wavelegnth in either dir gives the full proportion		start = freq-wavelen		finish = freq+wavelen		frequencyWindows+=num2str(Start) + "," + num2str(finish) + ";"	endfor	prop = 0.25	for (i=0;i<num;i+=1)		freq=freqs[i]		wavelen = freq*prop*0.5	//half of the proportion of the wavelegnth in either dir gives the full proportion		start = freq-wavelen		finish = freq+wavelen		frequencyWindows+=num2str(Start) + "," + num2str(finish) + ";"	endfor	prop = 0.5	for (i=0;i<num;i+=1)		freq=freqs[i]		wavelen = freq*prop*0.5	//half of the proportion of the wavelegnth in either dir gives the full proportion		start = freq-wavelen		finish = freq+wavelen		frequencyWindows+=num2str(Start) + "," + num2str(finish) + ";"	endfor	frequencyWindows+="0.1,0.5;0.25,0.75;1.5,3.5;4,6;9,11;14,16;29,31;59,61;74,76;89,91;"			//~2hz bin frequencies	frequencyWindows+="0,5;1,6;2.5,7.5;5,10;7.5,12.5;10,15;12.5,17.5;15,20;20,25;25,30;27.5,32.5;30,35;35,40;40,45;45,50;50,55;57.5,62.5;55,60;60,65;65,70;70,75;75,80;80,85;85,90;87.5,92.5;90,95;95,100;"		//5 hz frequency bins	frequencyWindows+="0,10;5,15;10,20;15,25;20,30;25,35;30,40;35,45;40,50;45,55;50,60;55,65;60,70;65,75;70,80;75,85;80,90;85,95;90,100;,95,105;100,110;"		//10 hz frequency bins	frequencyWindows+="0,20;20,40;40,60;60,80;60,250;"			//classic windows (as less automated above)		Variable numFreqBins = itemsinlist(frequencyWindows)	Variable paramsPerWin=12	Variable numNewParams=paramsPerWin*numFreqBins	redimension/n=(origNumParams+newNumParams0+numNewParams) wn_paramsTemp	variable startrow	String startStr,finishStr,str	Double pAr,phArea,phPosArea,phNegArea,mAr,mAvg	Double pAvg,phAvg,phPosAvg,phNegAvg	for (i=0;i<numFreqBins;i+=1)		pAR=nan;pAvg=nan;phArea=nan;phPosArea=nan;phNegArea=nan;phAvg=nan;phPosAvg=nan;phNegAvg=nan;		mAr=nan;mAvg=nan;			str=stringfromlist(i,frequencyWindows)		startStr = stringfromlist(0,str,",")		start=str2num(startStr)		finishStr = stringfromlist(1,str,",")		finish=str2num(finishStr)				pAR=area(respPower_FD,start,finish)		pAvg=mean(respPower_FD,start,finish)		mAR=area(respMag_FD,start,finish)		mAvg=mean(respMag_FD,start,finish)						if (doPhase)			getAreas(filterPhase_FD, phArea, phPosArea, phNegArea, x1=start,x2=finish); 			getMeans(filterPhase_FD, phAvg, phPosAvg, phNegAvg, x1=start,x2=finish); 		endif				startStr = replacestring(".",startStr,"p")		finishStr= replacestring(".",finishStr,"p")		startrow=(origNumParams+newNumParams0)+i*paramsPerWin		dl_assignAndLbl(wn_paramsTemp,startrow,start,"BI_"+startStr+"_"+finishStr+"_stHz")		dl_assignAndLbl(wn_paramsTemp,startrow+1,finish,"BI_"+startStr+"_"+finishStr+"_finHz")		dl_assignAndLbl(wn_paramsTemp,startrow+2,pAr,"BI_"+startStr+"_"+finishStr+"_pAr")		dl_assignAndLbl(wn_paramsTemp,startrow+3,phArea,"BI_"+startStr+"_"+finishStr+"_phAr")		dl_assignAndLbl(wn_paramsTemp,startrow+4,phPosArea,"BI_"+startStr+"_"+finishStr+"_phPAr")				dl_assignAndLbl(wn_paramsTemp,startrow+5,phNegArea,"BI_"+startStr+"_"+finishStr+"_phNAr")		dl_assignAndLbl(wn_paramsTemp,startrow+6,pAvg,"BI_"+startStr+"_"+finishStr+"_pAvg")		dl_assignAndLbl(wn_paramsTemp,startrow+7,phAvg,"BI_"+startStr+"_"+finishStr+"_phAvg")		dl_assignAndLbl(wn_paramsTemp,startrow+8,phPosAvg,"BI_"+startStr+"_"+finishStr+"_phPAvg")		dl_assignAndLbl(wn_paramsTemp,startrow+9,phNegAvg,"BI_"+startStr+"_"+finishStr+"_phNAvg")				dl_assignAndLbl(wn_paramsTemp,startrow+10,mAR,"BI_"+startStr+"_"+finishStr+"_mAR")		dl_assignAndLbl(wn_paramsTemp,startrow+11,mAvg,"BI_"+startStr+"_"+finishStr+"_mAvg")	endfor	return newNumParams0+numNewParamsend		//wn_myCorr3Params_v2()function fio_disp_paramVsExcelParam(paramsSaveRef,paramRefList,paramRefLabel,cellNameList,excelParamStr)	String paramsSaveRef	String paramRefList,cellNameList		//ordered list of paramRefs and cellNameRefs	String paramRefLabel		//name of paramRefLabel. pass headerName;paramRefLabel to use header	String excelParamStr		//name of excel param to plot against, e.g. "ax_len" "rec_site_len" "total_len"		Variable hasParamHeader = stringmatch(paramRefLabel,"*;*"), param_row	String headerRef,paramLabel	if (hasParamHeader)		headerRef = stringfromlist(0,paramRefLabel)		paramLabel = stringfromlist(1,paramRefLabel)		param_row = findInHeader(paramLabel, headerRef)	else		paramLabel = paramRefLabel	endif		WAVE/T excel_info		Variable excel_col = FindDimLabel(excel_info, 1, excelParamStr)		if (excel_col < 0)		Print "fio_disp_paramVsExcelParam(): could not find excelParamStr",excelParamStr,"in excel_info wave"		return 0	endif		if (param_row < 0)		Print "fio_disp_paramVsExcelParam(): could not find paramRefLabel",paramRefLabel,"in headerRef",headerRef		return 0	endif		Variable numParams = itemsinlist(paramRefList)	Make/O/D/N=(numParams,2) $paramsSaveRef/wave=out	SetDimLabel 1,0,$excelParamStr,out	SetDimLabel 1,1,$paramLabel,out		Variable i,excel_row; string paramRef,cellName,cellNameForSearch	for (i=0;i<numParams;i+=1)		paramRef = stringfromlist(i,paramRefList)		WAVE/D paramWv = $paramRef		cellName = stringfromlist(i,cellnameList)		Setdimlabel 0,i,$cellname,out				cellNameForSearch = Replacestring("G",cellname,"") 		cellNameForSearch = cellNameForSearch[0,7]		//0 to 7 is name portion without G		excel_row = FindDimLabel(excel_info,0, cellNameForSearch )		//excel labels don't have G prefix but I might sometimes use it		if (excel_row < 0)			out[i][1] = inf			Print "fio_disp_paramVsExcelParam(): i",i,"could not find cellName",cellNameForSearch,"in excel_info wave",nameofwave(excel_info)					else			out[i][0] = str2num(excel_info[excel_row][excel_col])		endif				if (!hasParamHeader)			param_row = FindDimlabel(paramWv,0,paramLabel)		endif				if (param_row < 0)			out[i][1] = -inf			Print "fio_disp_paramVsExcelParam(): could not find paramLabel",paramRefLabel,"in paramRef",paramRef		else			out[i][1] = paramWv[param_row]		endif	endforend//USUALLY REVERSE SOMA AND TERMINAL FOR STIMULUS AT TERMINAL, so the comparison is always change at distal sitefunction/S wn_myCorr3CalcDiffs(fromPed, outRefs_S, outRefs_P, [diffsParamRef, fDiffsParamRef, diffsRefList, fDiffsRefList])	Variable fromPed; String outRefs_S, outRefs_P	String &diffsParamRef, &fDiffsParamRef, &diffsRefList, &fDiffsRefList		//pass to have output names stored in these strings																								//any value passed in is overwritten by default naming scheme																																										//default naming scheme + determination of output reference names	String baseName 	if (!fromPed)			baseName = text_getInfoFromWaveName_S(outRefs_S, 0) + "_" + text_getInfoFromWaveName_S(outRefs_S, 1)	else		baseName = text_getInfoFromWaveName_S(outRefs_P, 0) + "_" + text_getInfoFromWaveName_S(outRefs_P, 1)	endif	diffsParamRef = baseName + "_diffs_P"	fdiffsParamRef = baseName + "_fdiffs_P"	diffsRefList = baseName + "_diffs_R"	fdiffsRefList = baseName + "_fdiffs_R"		String outRefsList = diffsParamRef + ";" + fdiffsParamRef + ";" + diffsRefList + ";" + fdiffsRefList + ";"		if (!fromPed)		wn_myCorr3_getSpectraDiffs(outRefs_S, outRefs_P, diffsRefList, fdiffsRefList)		wn_myCorr3_getParamDiffs(outRefs_S, outRefs_P, diffsParamRef, fdiffsParamRef)	//	wn_export($outRefs_S, $outRefs_P, $diffsRefList, $fdiffsRefList)			//now defunct, saving handled in wn_main	else		wn_myCorr3_getSpectraDiffs(outRefs_P, outRefs_S, diffsRefList, fdiffsRefList)		wn_myCorr3_getParamDiffs(outRefs_P, outRefs_S, diffsParamRef, fdiffsParamRef)	//	wn_export($outRefs_S, $outRefs_P, $diffsRefList, $fdiffsRefList)			//now defunct, saving handled in wn_main	endif		Print "diffsParamRef, fdiffsParamRef:", diffsParamRef, ",", fdiffsParamRef, "diffsRefList, fdiffsRefList:", diffsRefList,",",fdiffsRefList	Print "for wn_disp_pair_g:", outRefs_S, ",", outRefs_P, ",", diffsRefList,",",fdiffsRefList		return outRefsListend	//wn_myCorr3CalcDiffsfunction wn_export(outRefs_S, outRefs_P, diffRefs, fDiffRefs)	WAVE/T outRefs_S, outRefs_P, diffRefs, fDiffRefs		//list of waves references to spectra		String wnPath = "wn_pathStr"		PathInfo $wnPath	if (!V_flag)		Newpath/O $wnPath	endif		String summaryWvName = text_getInfoFromWaveName_S(outRefs_S[0], 0) + "_" + text_getInfoFromWaveName_S(outRefs_S[0], 1) + "_all"		//added [0] to outRefs_S for Igor 7 compatibility, not sure how this affects things		Concatenate/T/O/NP=1 {outRefs_S, outRefs_P, diffRefs, fDiffRefs}, $summaryWvName		//concatenates each wave into 4 columns		WAVE/T wn_export_temp = $summaryWvName				Variable i,j; string ref	for (i=0;i<dimsize(wn_export_temp,0);i+=1)		for (j=0;j<dimsize(wn_export_temp,1);j+=1)				ref = wn_export_temp[i][j]			if (strlen(ref) && WaveExists($ref))				SAVE/C/O/P=$wnPath $ref			else				Print "missing wave: " + ref			endif		endfor	endfor		SAVE/C/O/P=$wnPath $summaryWvName		Print "Exporting spectra. Summary wave saved as", summaryWvNameendfunction wn_import_summaries()	String outRef = "wn_all_refs"	String wnPath = wn_setPath()			String summaryFilesList = ListMatch(indexedfile($wnPath,-1,".ibw"), "*_all.ibw")	Variable newTotal = ItemsInList(summaryFilesList)		Variable origCount	if (!WaveExists($outRef))		Make/O/T/N=(newTotal) $outRef/WAVE=out		origCount = 0	else		WAVE/T out = $outRef		origCount = DimSize(out,0)		Duplicate/O out, wn_all_refs_BU		Redimension/N=(newTotal) out	endif			//add new waves or all waves if wn_all_refs does not exist, maintain order of any pre-existing waves	Variable i; String file, ref; Variable newCount = 0	for (i=0;i<newTotal;i+=1)		file = StringFromList(i,summaryFilesList)		loadwave/O/Q/P=$wnPath/h file		ref = StringFromList(0, S_waveNames)					if (findInHeader(ref, "wn_all_refs") < 0)			//name not catalogued, so add			out[origCount+newCount] = StringFromList(0, S_waveNames)		//store name of wave			newCount += 1		endif	endforendfunction/S wn_setPath()	String wnPath = "wn_pathStr"		PathInfo $wnPath	if (!V_flag)		Newpath/O $wnPath	endif		return wnPathend//response at soma and terminal function wn_summaries_overlay(spectraNum, colNum, fromSoma, graphN, newGraph, axisN, rightAxis)	Variable spectraNum, colNum,fromSoma; String graphN, axisN; Variable newGraph, rightAxis				//power	//wn_summaries_disp(9, 0,1, 1, "num9", 1,"L_0", 0, 0, "b");wn_summaries_disp(9, 0,2, 1, "num9", 0,"L_0", 0, 3, "b")	//wn_summaries_disp(9, 1,1, 1, "num9", 0,"L_0", 0, 0, "1");wn_summaries_disp(9, 1,2, 1, "num9", 0,"L_0", 0, 3, "1")	//ModifyGraph log=1; setaxis bottom, 1,100;  setaxis/A=2 L_0endfunction/S wn_summaries_disp(spectraNum, colNum,justFovealOrPeriph, justFromSomaOrPed, graphN, newGraph,axisN, rightAxis, lstyle, colorAbbreviation)	Variable spectraNum, colNum, newGraph, rightAxis	String axisN, graphN		//graphN = "" for top graph	Variable justFovealOrPeriph		//0 for both, 1 just fovea, 2 just periph	Variable justFromSomaOrPed		//0 for both, 1 just from soma, 2 just from ped	String colorAbbreviation		//see vis_getColorForGraph() for details	Variable lstyle				//line style			String wnPath = wn_setPath()		String wn_savedFiles = indexedfile($wnPath,-1,".ibw")	String wn_savedWaves = ReplaceString(".ibw",wn_savedFiles,"")		//remove file suffix		if (!strlen(graphN))		graphN = winname(0,1)	endif		if (newGraph || !wintype(graphN))		Display/K=1/N=$graphN		if (!stringmatch(S_name, graphN) )			Print "Failed to make graph named",graphN,". new graph created = ", S_name			graphN = S_name		endif	endif		WAVE/T wn_all_refs, wn_all_info		String failedWvs = ""	Variable i, fileIndex, found, isFoveal, isFromSoma; String ref	Variable r,g,b; vis_getColorForGraph(colorAbbreviation, r, g, b)	for (i=0;i<DimSize(wn_all_refs,0);i+=1)		WAVE/T refsList = $wn_all_refs[i]		ref = refsList[spectraNum][colNum]		isFoveal = Stringmatch(wn_all_info[i][0], "Fovea*")		isFromSoma = Stringmatch(wn_all_info[i][1], "*fS")	//	Print "isFoveal", isFoveal,"isFromSoma", isFromSoma		if (justFovealOrPeriph)		//only plot in some cases, if passed as zero, always plot regardless of isFoveal			if (isFoveal && (justFovealOrPeriph == 2))				//do not plot because it's foveal and just peripheral is requested				continue			elseif (!isFoveal && (justFovealOrPeriph == 1))				//do not plot because it's peripheral and just foveal is requested				continue			endif		endif		if (justFromSomaOrPed)		//only plot in some cases, if passed as zero, always plot regardless of isFoveal			if (isFromSoma && (justFromSomaOrPed == 2))				//do not plot because it's fromSoma and just from ped is requested				continue			elseif (!isFromSoma && (justFromSomaOrPed == 1))				//do not plot because it's from terminal and justFromSoma is requested				continue			endif		endif								if (!WaveExists($ref))			fileIndex = WhichListItem(ref, wn_savedWaves)			if (fileIndex < 0)				failedWvs += ref  + ";"				found = 0			else				loadwave/O/Q/P=$wnPath/h StringFromList(fileIndex,wn_savedFiles)				found = 1			endif		else			found = 1		endif				if (found)			if (rightAxis)				AppendToGraph/W=$graphN/R=$axisN/C=(r,g,b) $ref			else				AppendToGraph/W=$graphN/L=$axisN/C=(r,g,b) $ref			endif			ModifyGraph/W=$graphN lstyle($ref) = lstyle		endif	endfor		if (ItemsInList(failedWvs))		Print "Failed to find N=",ItemsInList(failedWvs),"list:", failedWvs	endif		Modifygraph/W=$graphN lblpos=0, freepos=52		return graphNendfunction wn_myCorr3_getParamDiffs(outRefs_S, outRefs_P, outDiffParamsRef, outFoldDiffParamsRef)	String outRefs_S, outRefs_P, outDiffParamsRef, outFoldDiffParamsRef		WAVE/T refsWv_S = $outRefs_S, refsWv_P = $outRefs_P		String paramsRef_S = refsWv_S[%paramsSaveRef]	String paramsRef_P = refsWv_P[%paramsSaveRef]			KillWaves/Z  $outDiffParamsRef, $outFoldDiffParamsRef	Duplicate/O $paramsRef_S, $outDiffParamsRef, $outFoldDiffParamsRef			WAVE/D outDiffParamsWave = $outDiffParamsRef	WAVE/D outFoldDiffParamsWave = $outFoldDiffParamsRef	WAVE/D paramsWave_S = $paramsRef_S	WAVE/D paramsWave_P = $paramsRef_P		outDiffParamsWave = paramsWave_P - paramsWave_S	outFoldDiffParamsWave = paramsWave_P / paramsWave_S	end //wn_myCorr3_getParamDiffsfunction/S disp_printwave(waveRef)	String waveRef		String out = "disp_printwave(): name of wave=" + waveRef + ". WaveExists=" + num2str(WaveExists($waveRef)) + ". Wavetype =" + num2str(wavetype($waveref))		return outendfunction wn_myCorr3_getSpectraDiffs(outRefs_S, outRefs_P, outDiffListRef, outFoldDiffListRef)		//computes subtraction and fold change waves for each wave in outRefs	String outRefs_S, outRefs_P, outDiffListRef, outFoldDiffListRef		Duplicate/O $outRefs_S, $outDiffListRef, $outFoldDiffListRef		//copy over the soma text wave to each diff wave	WAVE/T outDiffsListWave = $outDiffListRef, outFoldDiffsListWave = $outFoldDiffListRef		//instantiate those waves here	outDiffsListWave = ""; outFoldDiffsListWave = ""											//clear the new text waves	WAVE/T outRefsWave_S = $outRefs_S, outRefsWave_P = $outRefs_P						//instantiate the original text waves here		Variable i	String errMsg = ""	for (i=0;i<DimSize(outRefsWave_S,0); i+=1)		//give proper names to output at index		outDiffsListWave[i] = outRefsWave_S[i] + "_D"		outFoldDiffsListWave[i] = outRefsWave_S[i] + "_F"		//get current waves at each ref index		//check: both somatic and terminal data waves exist, and there type is non-text (wavetype(wave) == 0 for text)		if ( (WaveExists($outRefsWave_S[i]) > 0) && (WaveExists($outRefsWave_P[i]) > 0) && (wavetype($outRefsWave_S[i]) != 0) && (wavetype($outRefsWave_P[i]) != 0) )// && !EqualWaves($outRefsWave_S[i], $outRefsWave_P[i] , 1) )			if ( (wavetype($outRefsWave_S[i]) & 2^0) != 0)			//complex				Duplicate/O/C $outRefsWave_S[i], currWave_SC, currOutWave_diffC, currOutWave_foldDiffC				Duplicate/O/C $outRefsWave_P[i], currWave_PC						errMsg = num2str(i) + " outRefsWave_S " + outRefsWave_S[0] +" outRefsWave_P "+ outRefsWave_P[0]				//make wave (via duplicate) at proper index, use it to do calculation, then store it (via duplicate) at proper index				currOutWave_diffC = currWave_PC - currWave_SC			//do difference calc, use currOutWave as placeholder				Duplicate/O/C currOutWave_diffC, $outDiffsListWave[i]		//save result in proper ref				//do same for fold change				currOutWave_foldDiffC = currWave_PC / currWave_SC			//do difference calc				Duplicate/O/C currOutWave_foldDiffC, $outFoldDiffsListWave[i]	//save result in proper ref							else				//non complex				Duplicate/O $outRefsWave_S[i], currWave_S, currOutWave_diff, currOutWave_foldDiff				Duplicate/O $outRefsWave_P[i], currWave_P				//make wave (via duplicate) at proper index, use it to do calculation, then store it (via duplicate) at proper index				if (DimSize(currWave_P,0) != DimSize(currWave_S,0))					Print "in wn_myCorr3_getSpectraDiffs(): non-equal input waves on index = " + num2str(i)					currOutWave_diff = NaN; currOutWave_foldDiff = NaN				else					currOutWave_diff[] = currWave_P[p] - currWave_S[p]			//do difference calc, use currOutWave as placeholder					Duplicate/O currOutWave_diff, $outDiffsListWave[i]		//save result in proper ref					//do same for fold change					currOutWave_foldDiff = currWave_P / currWave_S			//do difference calc				endif				Duplicate/O currOutWave_foldDiff, $outFoldDiffsListWave[i]	//save result in proper ref			endif		endif	endfor		KillWaves/Z ccurrWave_SC, currOutWave_diffC, currOutWave_foldDiffC, currWave_PC	KillWaves/Z currWave_S, currOutWave_diff, currOutWave_foldDiff, currWave_P	Print "created ref lists: " + outDiffListRef + " and " + outFoldDiffListRefend //wn_myCorr3_getSpectraDiffs()//takes selected stimulus, resp1 and resp2 (Assumes C0 = stim, C1= soma, C2= ped)function myCorr2(stimRef, somaRef, pedRef, cellStr, fromSoma, distStr, [outRefsListRef, paramsSaveRef])	String stimRef, somaRef, pedRef	String cellStr, distStr	Variable fromSoma	String outRefsListRef		//optional variable, if passed, stores in this reference a text wave containing the names of waves where results were stored	String paramsSaveRef		//optional variable, if passed, parameters relevant to this analysis will be stored there		//filter calculation settings	Variable filterLenX = 1			//sets size of bins therefore also filter length (in current implementation)	Variable numNonlinearityBins = 30		//how finely to segment the non-linearity (pairwise plot of predicted and actual voltage response at soma and ped)	Variable useWindowing = 0			//determines whether to use spectral windowing in Fourier transforms to find filter. Currently uses Hanning window, which may not be optimal	Variable binStartSpacingX = 0.5		//sets spacing between START of bins averaged to calculate filter, so for 1s bins, 0.5s spaces means 50% overlap			Variable winStartX=10	Variable winSizeX=35 	Variable winEndX = winStartX + winSizeX		WAVE/T waveListListWave; WAVE waveListSelListByNums	//Using Duplicate_FD in case originals aren't loaded	//first want to know the mean of the traces and subtract that out, as this stuff doesn't vary in time and so won't tell us about time-dependent correlations//	Duplicate/O/R=(winStartX, winEndX) $stimRef, stimWave, stimWaveNoDC; debug_checkRTErrState()	Duplicate_FD(stimRef, dupSaveRefOrRefs ="stimWave", x1=winStartX,x2=winEndX); WAVE stimWave	Duplicate/O stimWave, stimWaveNoDC; debug_checkRTErrState()	Variable stimMean = mean(stimWave)	stimWaveNoDC -= stimMean//	Duplicate/O/R=(winStartX, winEndX) $somaRef, somaWave, somaWaveNoDC; debug_checkRTErrState()	Duplicate_FD(somaRef,dupSaveRefOrRefs = "somaWave", x1=winStartX,x2=winEndX); WAVE somaWave	Duplicate/O somaWave, somaWaveNoDC; debug_checkRTErrState()	Variable somaMean = mean(somaWave)	somaWaveNoDC -= somaMean//	Duplicate/O/R=(winStartX, winEndX) $pedRef, pedWave, pedWaveNoDC; debug_checkRTErrState()	Duplicate_FD(pedRef, dupSaveRefOrRefs ="pedWave", x1=winStartX,x2=winEndX); WAVE pedWave	Duplicate/O pedWave, pedWaveNoDC; debug_checkRTErrState()	Variable pedMean = mean(pedWave)	pedWaveNoDC -= pedMean	//shift all excised regions to start at 0 (sometimes can screw up convolution etc., though it might not matter due to latest changes)	SetScale/P x, 0,DimDelta(stimWave,0), stimWave, stimWaveNoDC, somaWave, somaWaveNoDC, pedWave, pedWaveNoDC			//first generate the linear filters of the waves. Cross-correlation is performed in the time domain, and the result is normalized to the (average) power spectra of the stimulus for the same time bins		//for somatic	avgFilterAndConvolve("stimWaveNoDC", "somaWaveNoDC", "somaFilter_TD", "somaFilter_FD", "somaPredicted", useWindowing, 0, filterLenX, binStartSpacingX)//	avgFilterAndConvolve("stimWaveNoDC", "somaWaveNoDC", "somaFilter_TD", "somaFilter_FD", "somaPredicted", useWindowing, 0, filterLenX, binStartSpacingX, normEachRep = 2)	WAVE somaFilter_TD, somaFilter_FD, somaPredicted		//created by avgFilterAndConvolve		//for terminal	avgFilterAndConvolve("stimWaveNoDC", "pedWaveNoDC", "pedFilter_TD", "pedFilter_FD", "pedPredicted", useWindowing, 0, filterLenX, binStartSpacingX)	//	avgFilterAndConvolve("stimWaveNoDC", "pedWaveNoDC", "pedFilter_TD", "pedFilter_FD", "pedPredicted", useWindowing, 0, filterLenX, binStartSpacingX, normEachRep = 2)	WAVE pedFilter_TD, pedFilter_FD, pedPredicted			//created by avgFilterAndConvolve		//re-calculate filter with normalization such that variance of response is scaled to variance of stimulus (Baccus and Meister 2002)	//calculate amount to scale filters by//	Variable stimAUCSq = area(stimWaveNoDC)^2//	Variable somaAUCSq = area(somaPredicted)^2//	Variable pedAUCSq = area(pedPredicted)^2	//	Variable somaMultiplier = sqrt(stimAUCSq/somaAUCSq)		//one form of normalization (not presently used here)//	Variable pedMultiplier = sqrt(stimAUCSq/pedAUCSq)//	Print "AUCSq stim = " + num2str(stimAUCSq) + ". Soma = " + num2str(area(predictedEVSoma)^2) + ". Ped = " + num2str(area(predictedEVPed)^2)			Variable pearsonRSoma = analyzeNL("somaWaveNoDC", "somaPredicted", "binnedNonLinearitySoma",numNonlinearityBins,0)	WAVE binnedNonLinearitySoma	Variable pearsonRPed = analyzeNL("pedWaveNoDC", "pedPredicted", "binnedNonLinearityPed",numNonlinearityBins,0)	WAVE binnedNonLinearityPed			//calculate % change from soma for magnitude and phase	getNormalizedFFTMag("somaFilter_FD", "somaFilterMag_FD"); WAVE somaFilterMag_FD	getNormalizedFFTMag("pedFilter_FD", "pedFilterMag_FD"); WAVE pedFilterMag_FD	Duplicate/O somaFilterMag_FD, somaFilterPhase_FD	Duplicate/O pedFilterMag_FD, pedFilterPhase_FD, phaseDiffPedSoma_FD, magDiffPedSoma_FD	somaFilterPhase_FD = imag(r2polar(somaFilter_FD))	somaFilterPhase_FD[0] = somaFilterPhase_FD[1]; Unwrap 2*pi, somaFilterPhase_FD	pedFilterPhase_FD = imag(r2polar(pedFilter_FD))	pedFilterPhase_FD[0] = pedFilterPhase_FD[1]; Unwrap 2*pi, pedFilterPhase_FD	magDiffPedSoma_FD = (pedFilterMag_FD - somaFilterMag_FD)/somaFilterMag_FD	phaseDiffPedSoma_FD = (pedFilterPhase_FD - somaFilterPhase_FD)/somaFilterPhase_FD		//calculate power spectrum. No need to time average as this is already a time averaged FFT. The power spectrum is the magsqr of the FFT divided by the number of points in the time domain, unless a window function is used	Variable numpointsTD = DimSize(somaFilter_TD,0)	FFT/OUT=7/DEST=somaPower_FD somaFilter_TD	somaPower_FD /= numpointsTD	FFT/OUT=7/DEST=pedPower_FD pedFilter_TD	pedPower_FD /= numpointsTD	Duplicate/O somaPower_FD, somaPedPowerDiff_FD	somaPedPowerDiff_FD = pedPower_FD / somaPower_FD				//save original data names	String stimFromWinSN = stimRef + "StR"	String somaRealSN = somaRef + "SoR"	String pedRealSN = pedRef + "PeR"	//save convolution data 	String somaFilter_TDSN = somaRef + "CoF" + "So"	String pedFilter_TDSN = pedRef + "CoF" + "Pe"	String somaConvSN = somaRef + "CoC" + "So"	String pedConvSN = pedRef + "CoC"  + "Pe"	String somaBinnedConvSN = somaRef + "CoB" + "So"	String pedBinnedConvSN = pedRef + "CoB" + "Pe"	//save for equal variance results	String somaEVFilterSN = somaRef + "CoF" + "SoV"	String pedEVFilterSN = pedRef + "CoF" + "PeV"	String somaEVConvSN = somaRef + "CoC" + "SoV"	String pedEVConvSN = pedRef + "CoC"  + "PeV"	String somaEVBinnedConvSN = somaRef + "CoB" + "SoV"	String pedEVBinnedConvSN = pedRef + "CoB" + "PeV"		//save names for frequency domain filters	String somaFilter_FDSN = somaRef + "CoF" +"SoF"	String pedFilter_FDSN = pedRef + "Cof"+"PeF"	String somaFilterMag_FDSN = somaRef + "CoF"+"SFM"	String pedFilterMag_FDSN = pedRef + "CoF" + "PFM"	String somaPower_FDSN = somaRef + "CoFSM2"	String pedPower_FDSN = pedRef + "CoFSM2"	String somaPhase_FDSN = somaRef + "CoFPhS"	Print "soma Phase name = " + somaPhase_FDSN	String pedPhase_FDSN = pedRef + "CoFPhP"	Print "ped phase name = " +pedPhase_FDSN	//save names for frequency domain differences	String filterMagDiff_FDSN = stimRef + "CoFSM"	String filterPhaseDiff_FDSN = stimRef + "CoFSP"	String filterPowerDiff_FDSN = stimRef + "CoFM2D"	//save names for fit to TD linear filter //these last two created by wn_computePairedCorrParams	String somaFilterFit_TDSN = somaRef + "CoFLFS"	String pedFilterFit_TDSN = pedRef + "CoFLFP"			//copy all into proper wave references and add notes as appropriate (e.g. try to save information from original wave and add notes about analyses performed)	Duplicate/O stimWaveNoDC, $stimFromWinSN	Note $stimFromWinSN, " (WN_RealStimulus) "	Duplicate/O SomaWaveNoDC, $somaRealSN	Note $somaRealSN, " (WN_RealSoma) "	Duplicate/O pedWaveNoDC, $pedRealSN	Note $pedRealSN, " (WN_RealPed) "		Duplicate/O somaFilter_TD, $somaFilter_TDSN	Note/K $somaFilter_TDSN, note($somaRef) + " (Soma_WNFilter) "	Duplicate/O pedFilter_TD, $pedFilter_TDSN	Note/K $pedFilter_TDSN, note($pedRef) + "(Ped_WNFilter)"	Duplicate/O somaPredicted, $somaConvSN	Note/K $somaConvSN, note($somaRef) + " (Soma_WNPredicted) "	Duplicate/O pedPredicted, $pedConvSN	Note/K $pedConvSN, note($pedRef) + "(Ped_WNPredicted)"	Duplicate/O binnedNonLinearitySoma, $somaBinnedConvSN	Note/K $somaBinnedConvSN, note($somaRef) + " (Soma_WNNonLinearityBinned) "	Duplicate/O binnedNonLinearityPed, $pedBinnedConvSN	Note/K $pedBinnedConvSN, note($pedRef) + "(Ped_WNNonLinearityBinned)"				//and for frequency domain filters	Duplicate/O somaFilter_FD, $somaFilter_FDSN	Note/K $somaFilter_FDSN, note($somaRef) + " (Soma_WNFilter_FD) "	Duplicate/O pedFilter_FD, $pedFilter_FDSN	Note/K $pedFilter_FDSN, note($pedRef) + " (Ped_WNFilter_FD) "	Duplicate/O somaPower_FD, $somaPower_FDSN		Note/K $somaPower_FDSN, note($somaRef) + " (Soma_WNPower_FD) "	Duplicate/O pedPower_FD, $pedPower_FDSN	Note/K $pedPower_FDSN, note($pedRef) + " (Ped_WNPower_FD) "		Duplicate/O somaFilterPhase_FD, $somaPhase_FDSN; Print "debug check at somaFilterPhase_FD save";  debug_checkRTErrState()	Note/K $somaPhase_FDSN, note($somaRef) + " (Soma_WNPhase_FD) "		Duplicate/O pedFilterPhase_FD, $pedPhase_FDSN; debug_checkRTErrState(); 	Note/K $pedPhase_FDSN, note($pedRef) + " (Ped_WNPhase_FD) "		Print "finished phase save debuf check"			//for frequency domain differences	Duplicate/O magDiffPedSoma_FD, $filterMagDiff_FDSN	Note/K $filterMagDiff_FDSN, note($stimRef) + " (Ped - Soma FFT mag)"	Duplicate/O phaseDiffPedSoma_FD, $filterPhaseDiff_FDSN	Note/K $filterPhaseDiff_FDSN, note($stimRef) + " (Ped - Soma FFT phase)"	Duplicate/O somaFilterMag_FD, $somaFilterMag_FDSN				Note/K $somaFilterMag_FDSN, note($somaRef) + " (Soma FFT mag)"		Duplicate/O pedFilterMag_FD, $pedFilterMag_FDSN	Note/K $pedFilterMag_FDSN, note($pedRef) + " (Ped FFT phase)"			Duplicate/O somaPedPowerDiff_FD, $filterPowerDiff_FDSN	Note/K $filterPowerDiff_FDSN, note($stimRef) + " (Ped - Soma FFT POWER)"					//store all in listRef if passed	if (!ParamIsDefault(outRefsListRef))		Variable numOutRefs = 22		Make/O/T/N=(numOutRefs) outRefsTemp		outRefsTemp[0] = stimFromWinSN		outRefsTemp[1] = somaRealSN		outRefsTemp[2] = pedRealSN		outRefsTemp[3] = somaFilter_TDSN		outRefsTemp[4] = pedFilter_TDSN		outRefsTemp[5] = somaConvSN		outRefsTemp[6] = pedConvSN		outRefsTemp[7] = somaBinnedConvSN		outRefsTemp[8] = pedBinnedConvSN		outRefsTemp[9] = somaFilter_FDSN		outRefsTemp[10] = pedFilter_FDSN		outRefsTemp[11] = somaFilterMag_FDSN		outRefsTemp[12] = pedFilterMag_FDSN		outRefsTemp[13] = somaPower_FDSN		outRefsTemp[14] = pedPower_FDSN		outRefsTemp[15] = somaPhase_FDSN		outRefsTemp[16] = pedPhase_FDSN 		outRefsTemp[17] = filterMagDiff_FDSN		outRefsTemp[18] = filterPhaseDiff_FDSN		outRefsTemp[19] = filterPowerDiff_FDSN		outRefsTemp[20] = somaFilterFit_TDSN		//last two created by wn_computePairedCorrParams		outRefsTemp[21] = pedFilterFit_TDSN					Duplicate/O outRefsTemp, $outRefsListRef	; debug_checkRTErrState()		KillWaves/Z outRefsTemp			Make/O/T/N=(numOutRefs) wn_refsHeader		wn_refsHeader[0] = "stimFromWinSN"		wn_refsHeader[1] = "somaRealSN"		wn_refsHeader[2] = "pedRealSN"		wn_refsHeader[3] = "somaFilter_TDSN"		wn_refsHeader[4] = "pedFilter_TDSN"		wn_refsHeader[5] = "somaConvSN"		wn_refsHeader[6] = "pedConvSN"		wn_refsHeader[7] = "somaBinnedConvSN"		wn_refsHeader[8] = "pedBinnedConvSN"		wn_refsHeader[9] = "somaFilter_FDSN"		wn_refsHeader[10] = "pedFilter_FDSN"		wn_refsHeader[11] = "somaFilterMag_FDSN"		wn_refsHeader[12] = "pedFilterMag_FDSN"		wn_refsHeader[13] = "somaPower_FDSN"		wn_refsHeader[14] = "pedPower_FDSN"		wn_refsHeader[15] = "somaPhase_FDSN"		wn_refsHeader[16] = "pedPhase_FDSN" 		wn_refsHeader[17] = "filterMagDiff_FDSN"		wn_refsHeader[18] = "filterPhaseDiff_FDSN"		wn_refsHeader[19] = "filterPowerDiff_FDSN"			wn_refsHeader[20] = "somaFilterFit_TDSN"		wn_refsHeader[21] = "pedFilterFit_TDSN"		endif			if (!ParamIsDefault(paramsSaveRef))		Variable numPassedParams = 15		Make/O/D/N=(numPassedParams) passedParamsTemp		//fill for soma first		passedParamsTemp[0] = stimMean		passedParamsTemp[1] = somaMean		passedParamsTemp[2] = pearsonRsoma		passedParamsTemp[3] = filterLenX		passedParamsTemp[4] = binStartSpacingX		passedParamsTemp[5] = useWindowing		passedParamsTemp[6] = winStartX		passedParamsTemp[7] = winSizeX		passedParamsTemp[8] = numNonLinearityBins		wn_computePairedCorrParams(outRefsListRef, 0, "somaWNParamsTemp", passedParams = passedParamsTemp)		passedParamsTemp[0] = stimMean			//change soma-specific ones to ped-specific		passedParamsTemp[1] = pedMean		passedParamsTemp[2] = pearsonRped		wn_computePairedCorrParams(outRefsListRef, 1, "pedWNParamsTemp", passedParams = passedParamsTemp)		KillWaves passedParamsTemp		WAVE somaWNParamsTemp, pedWNParamsTemp		Duplicate/O pedWNParamsTemp, wnParamsTemp_Diff; debug_checkRTErrState()		wnParamsTemp_Diff -=somaWNParamsTemp		Concatenate/O/NP/D "somaWNParamsTemp;pedWNParamsTemp;wnParamsTemp_Diff;", $paramsSaveRef	endif			//save all to file//	Save/C/O/P=$dataSavePathName $stimFromWinSN, $somaFilter_TDSN, $pedFilter_TDSN, $somaConvSN, $pedConvSN, $somaBinnedConvSN, $pedBinnedConvSN		//non-EV//	Save/C/O/P=$dataSavePathName $somaEVFilterSN, $pedEVFilterSN, 	$somaEVConvSN,$pedEVConvSN, $somaEVBinnedConvSN,$pedEVBinnedConvSN			//EV//	Save/C/O/P=$dataSavePathName $somaFilter_FDSN, $pedFilter_FDSN, $filterMagDiff_FDSN, $filterPhaseDiff_FDSN 		//Kill unneeded stuff	KillWaves/Z somaFilter_TD, pedFilter_TD,binnedNonLinearitySoma, binnedNonLinearityPed		//Display results. First get rid of any old windows by the same names (need * at end because Igor likes to append numbers to window names) (this is total overkill, and could be problematic if you want to run this function with different parameters and get results for both in one instance of igor	KillWindowsByName(stimRef + "*Cor*")	KillWindowsByName(somaRef + "*Cor*")	KillWindowsByName(pedRef + "*Cor*")	KillWindowsByName(stimRef + "*CoC*")	KillWindowsByName(somaRef + "*CoC*")	KillWindowsByName(pedRef + "*CoC*")	KillWindowsByName(stimRef + "*CoF*")	KillWindowsByName(somaRef + "*CoF*")	KillWindowsByName(pedRef + "*CoF*")		KillWindowsByName(stimRef + "*CoM2*")				//names for display windows (need to display predicted and actual overlays and pairwise comparisons)	String filterWinName = stimRef + "CoF"	String predictedRespOverlayWN = stimRef + "CoCO"	String pairwiseOverlayWN = stimRef + "CoCP"		String frequencyDomain_MagnitudePlot = stimRef + "CoCM"	String frequencyDomain_PhasePlot = stimRef + "CoCR"	String frequencyDomain_PowerPlot = stimRef + "CoM2"		String idString = cellStr + "_" + distStr + "_S=" + num2str(fromSoma)	//Display convolution results		//linear filters	Display/K=1/N=$filterWinName $pedFilter_TDSN	AppendToGraph/C=(0,0,0) $somaFilter_TDSN	ModifyGraph lstyle($somaFilter_TDSN) = 0, lstyle($pedFilter_TDSN) = 0		//copying	AppendToGraph/B=Bin $pedFilter_TDSN/TN=pedRealIn	AppendToGraph/C=(0,0,0)/B=Bin $somaFilter_TDSN/TN=somaRealIn	Label left "Filter, Soma or \\K(65280,0,0)Terminal\\u#2\\K(0,0,0)\r(mV / nA or M\\F'Symbol'"; delayupdate	Label bottom "Delay (\\U)"	Label Bin "\\u#2"	 + idString	SetAxis Bin 0,0.01	Modifygraph freepos = 0, lblpos=52	ModifyGraph lblLatPos(bottom)=85,lowTrip(Bin)=0.005,notation(Bin)=1;DelayUpdate	ModifyGraph axisEnab(bottom)={0,0.6},axisEnab(Bin)={0.7,1}				//display predicted responses overlaid with originals	Display/K=1/N=$predictedRespOverlayWN	predictedRespOverlayWN = S_Name	AppendToGraph/L=Lped/C=(0,0,0) $pedRealSN		//real = black	AppendToGraph/L=Lsoma/C=(0,0,0) $somaRealSN	//real = black	AppendToGraph/C=(0,12800,52224)/L=Lped $pedConvSN	//regular prediction = blue	AppendToGraph/C=(0,12800,52224)/L=Lsoma $somaConvSN //regular prediction = blue	ModifyGraph lblpos = 52, freepos = 0, axisEnab(Lsoma) = {0,.48},  axisEnab(Lped) = {.52,1}//, axisEnab(RsomaEV) = {0,.48},axisEnab(RpedEV) = {0.52,1}	setaxis bottom, winStartX, winStartX + 0.5	Label Lped "\\K(65280,0,0)Terminal (\\U)";DelayUpdate	Label bottom "Time (\\U)" + idString;DelayUpdate	Label Lsoma "Soma(\\U)";DelayUpdate	ModifyGraph lblPos(Lped)=90,lblLatPos(Lped)=50,lblLatPos(Lsoma)=-40;DelayUpdate//	Label Lped "Voltage (mV) Real \\K(0,0,52224)Predicted\\u#2\r";DelayUpdate	Label Lsoma "\\JLSoma\\u#2      Terminal";DelayUpdate	Modifygraph height=72*1.5, width=72*4	SetAxis/A=2 Lsoma; SetAxis/A=2 Lped			//display pairwise overlay	Display/K=1/N=$pairwiseOverlayWN	pairwiseOverlayWN = S_Name	AppendToGraph/W=$pairwiseOverlayWN/C=(0,0,0) $somaRealSN/TN=soma vs $somaConvSN	AppendToGraph/W=$pairwiseOverlayWN $pedRealSN/TN=ped vs $pedConvSN	AppendToGraph/W=$pairwiseOverlayWN $somaBinnedConvSN[][1]/TN=somaBinned vs $somaBinnedConvSN[][0] 	AppendToGraph/W=$pairwiseOverlayWN $somaBinnedConvSN[][2]/TN=somaFit vs $somaBinnedConvSN[][0] 	AppendToGraph/W=$pairwiseOverlayWN $pedBinnedConvSN[][1]/TN=pedBinned vs $pedBinnedConvSN[][0] 	AppendToGraph/W=$pairwiseOverlayWN $pedBinnedConvSN[][2]/TN=pedFit vs $pedBinnedConvSN[][0] 		//make fits circles with outer grey and inner black (soma) or red (ped)			ModifyGraph mode(soma)=2, mode(ped)=2	ModifyGraph mode(somaBinned)=3,marker(somaBinned)=19, mrkThick(somaBinned)=2,rgb(somaBinned)=(0,0,0), mrkStrokeRGB(somaBinned)=(34816,34816,34816), useMrkStrokeRGB(somaBinned)=1	ModifyGraph mode(pedBinned)=3,marker(pedBinned)=19, mrkThick(pedBinned)=2,rgb(pedBinned)=(65280,0,0), mrkStrokeRGB(pedBinned)=(34816,34816,34816), useMrkStrokeRGB(pedBinned)=1	ModifyGraph mode(somaFit)=0, lstyle(somaFit) = 1, lsize(somaFit)=5,rgb(somaFit)=(34816,34816,34816)	ModifyGraph mode(pedFit)=0, lstyle(pedFit) = 1, lsize(pedFit)=5,rgb(pedFit)=(34816,34816,34816)	ReorderTraces somaBinned,{somaFit,pedFit}	Label left "Measured \rSoma or \\K(65280,0,0)Terminal\\K(0,0,0) (\\U)"	Label bottom "Linear Prediction (\\U) " + idString	Modifygraph height=72*2, width=72*2			//display frequency domain stuff			//magnitude version, cmplxmode=3 if using complex wave, unnecessary if converted to real magnitude		Display/K=1/N=$frequencyDomain_MagnitudePlot $pedFilterMag_FDSN; 	AppendToGraph/C=(0,0,0) $somaFilterMag_FDSN	AppendToGraph/C=(0,12800,52224)/L=leftDiff $filterMagDiff_FDSN	Label bottom "Frequency (\\U)" + idString	ModifyGraph axisEnab(left) = {.32,1}, axisEnab(leftDiff)={0,.28}, lblpos = 52, freepos=0	setaxis bottom, 0 , 150	setaxis/A=2 left; setaxis/A=2 leftDiff 	Modifygraph height=3*72, width=3*72	ModifyGraph lblPos(left)=72,lblPos(leftDiff)=72,lblLatPos(left)=-10	ModifyGraph lowTrip(left)=1e-06,prescaleExp(left)=-6,notation(left)=1;DelayUpdate	Label left "Filter (Frequency Domain) \rSoma or \\K(65280,0,0)Terminal"	Label leftDiff "Fraction change\rfrom soma\\u#2"			//phase version, cmplxmode=4		Display/K=1/N=$frequencyDomain_PhasePlot $pedPhase_FDSN; 	AppendToGraph/C=(0,0,0) $somaPhase_FDSN//	ModifyGraph cmplxmode=4			//only needed if putting up complex form instead of just phase magnitude	AppendToGraph/C=(0,12800,52224)/L=leftDiff $filterPhaseDiff_FDSN	Label bottom "Frequency (\\U)" + idString	Label leftDiff "Difference (rad.)";DelayUpdate	ModifyGraph axisEnab(left) = {.32,1}, axisEnab(leftDiff)={0,.28}, freepos=0	setaxis bottom, 0 , 150	ModifyGraph lblLatPos(left)=15;DelayUpdate	Label left "Phase Lag, Soma or \\K(65280,0,0)Terminal\\u#2\\K(0,0,0) (rad.)"	setaxis/A=2 left; setaxis/A=2 leftDiff	Modifygraph height=3*72, width=3*72	ModifyGraph lblPos(left)=75,lblPos(leftDiff)=75,lblLatPos(left)=-15;DelayUpdate	Label left "Phase Lag Soma\ror \\K(65280,0,0)Terminal\\u#2\\K(0,0,0) (rad.)";DelayUpdate	Label leftDiff "Fractional change\rfrom soma\\u#2"		Print "Soma filter = " + somaFilter_TDSN	Print "Ped filter = " + pedFilter_TDSN		//power version	Display/K=1/N=$frequencyDomain_PowerPlot	AppendtoGraph $pedPower_FDSN	AppendToGraph/C=(0,0,0) $somaPower_FDSN	AppendToGraph/C=(0,12800,52224)/L=Ldiff $filterPowerDiff_FDSN	Modifygraph axisEnab(left)={.32,1}, axisEnab(Ldiff) = {0,.28}, freepos = 0, lblpos = 52, highTrip(left)=1e+38,lowTrip(left)=1e-38,prescaleExp(left)=-12	Label left "Power Spectrum\rSoma or \\K(65280,0,0)Terminal\\u#2\\K(0,0,0) (mV\\S2\\M / nA\\S2\\M\\u#2)"; Label Ldiff "Fractional change\rfrom soma\\u#2"; Label bottom "Frequency (\\U)" + idString	SetAxis bottom, 0, 150	SetAxis/A=2 left; SetAxis/A=2 Ldiff	Modifygraph height=3*72, width=3*72end		//myCorr2//From acLight on igor exchange node 1562, June 17, 2010 (mentioned something like this being avaible in Igor 7.0...//Allows one to hit F12 and select a line to go to//from before igor 7//Menu "Procedure"//	"Kill window.../F11",/Q,test(winname(0,1))//endFunction GoToProcedureLine([lineNum])	Variable lineNum 	// Get the name of the top procedure window.	String topProcWinName = WinName(0, 128) 	// If topProcWinName is a null string or empty	// string, don't do anything.	if (numtype(strlen(topProcWinName)) == 0 && strlen(topProcWinName) > 0)		// Prompt the user for the line number if it's		// not provided as the optional parameter.		if (ParamIsDefault(lineNum))			Prompt lineNum, "Line to go to:"			DoPrompt "Go to line...", lineNum			if (V_flag == 1)				// Don't do anything if cancel button was pressed.				return 0			endif		endif 		// Check that lineNum is an actual number and is positive.		if (numtype(lineNum) == 0 && lineNum > 0)			DisplayProcedure/W=$(topProcWinName)/L=(lineNum)		endif	endifEnd		//might not compile because of replacement of respFilter with filterfunction/S wn_computePairedCorrParams(corrRefsList, doPed, saveRef, [passedParams])	String corrRefsList,saveRef; Variable doPed	WAVE passedParams		//optional, skip if not computing correlation anew		Variable areaMeasureCutOffFreq = 250		String startString	if (doPed)		startString = "ped"	else		startString = "soma"	endif		WAVE/T corrRefs = $corrRefsList	Print "heretestA. corrRefsList = " + corrRefsList	String stimWaveNoDCRef = getParamFromHeader_1D_T("stimFromWinSN", "wn_refsHeader", corrRefsList)	PRint "stimwave no dc = " + stimWaveNoDCRef//	Print num2str(waveexists($stimWaveNoDCRef))	WAVE stimWaveNoDC = $stimWaveNoDCRef	String respWaveNoDCRef = getParamFromHeader_1D_T(startString + "RealSN", "wn_refsHeader", corrRefsList)	Print "respWave no dc = " + respWaveNoDCRef//	Print num2str(waveexists($respWaveNoDCRef))	WAVE respWaveNoDC = $respWaveNoDCRef		String filter_TDSN  = getParamFromHeader_1D_T(startString + "Filter_TDSN", "wn_refsHeader", corrRefsList)	Print "filter_TDSN = " + filter_TDSN	WAVE filter_TD = $filter_TDSN	String respPower_FDSN = getParamFromHeader_1D_T(startString + "Power_FDSN", "wn_refsHeader", corrRefsList)	Print "respPower_FDSN = " + respPower_FDSN//	Print num2str(waveexists($respPower_FDSN))	WAVE respPower_FD = $respPower_FDSN	String filterPhase_FDSN = getParamFromHeader_1D_T(startString + "Phase_FDSN", "wn_refsHeader", corrRefsList)	Print "filterPhase_FDSN = " + filterPhase_FDSN	WAVE filterPhase_FD = $filterPhase_FDSN	Print "num2str(waveexists(filterPhase_FD))",num2str(waveexists(filterPhase_FD))	String filterFit_FDSN = getParamFromHeader_1D_T(startString + "FilterFit_TDSN", "wn_refsHeader", corrRefsList)	Print "filterFit_FDSN = " +filterFit_FDSN	Variable filterLenX = DimSize(filter_TD,0) * DimDelta(filter_TD,0)		//fit to sum of 4 exponentials (mostly to smooth--at first had hoped to get a nice time constant for each event but doesnt really seem to reflect just one event	Make/O/D coefWave =  {-1436.26,-1.00066e+06,0.0613322,2.57536e+06,0.0281398,-1.74838e+06,0.000167522,-3994.3,0.0692655}		//some initial conditions that were found previously and work well enough	Variable stimDCVariance = variance(stimWaveNoDC)	Print "stimDCVariance = ",num2str(stimDCVariance)	Variable respDCVariance = variance(respWaveNoDC)	Print "respDCVariance = ",num2str(respDCVariance)	Variable resp_ssRes, resp_x0		//fitExpsAndPlot will store ssRes in these variables	String respExpFit = fitExpsAndPlot(coefWave, filterFit_FDSN, 1, 3, toFitRef = filter_TDSN, plotWinName = filter_TDSN + "_F", ssResVar = resp_ssRes, x0Var = resp_x0)	WAVE filter_TD_fit = $filterFit_FDSN		//latter created by fitExpsAndPlot		//max and min and 50% computed on original (had thought of using fit because sometimes there are fluctuations in the negative region, especially prominenet in some foveal filters, but these are still minor. Should check each to see if needed	WaveStats /Q/Z filter_TD	Variable filterMaxLoc = V_maxLoc	Variable filterMaxVal = V_max	Variable filterMinLoc = V_minLoc	Variable filterMinVal = V_min	FindLevel/EDGE=1/Q/R=(0,V_maxLoc) filter_TD, V_max/2	Variable respFirstHalfMaxLoc = V_flag ? 0 : V_levelX		//if level not found (V_flag = 1), assumes it is because filter is already > 50% max at start of wave, so set start time to 0	FindLevel/EDGE=2/Q/R=(V_maxLoc, filterLenX) filter_TD, V_max/2	Variable respSecondHalfMaxLoc = V_flag ? NaN : V_levelX		//if level not found (V_flag = 1), assumes it is because filter NEVER returns to < 50% peak. Warns user because this is unexpected	if (V_flag)		Print "Warning in myCorr2(). While computing respFallingHalfMaxLoc, falling phase not found"	endif	//SMOOTHING PERFORMED FOR MIN AS SOME FOVEAL FILTERS HAVE SOME FLUCTUATIONS HERE	Variable respNegRegionFound = 0	Variable respZeroCrossing = NaN, respFirstHalfMinLoc = NaN, respSecondHalfMinLoc = NaN	if (V_min < 0)		//then filter has a negative-going region, compute stats for minimum peak		respNegRegionFound = 1		FindLevel/EDGE=2/Q/R=(V_maxLoc, V_minLoc) filter_TD, 0			//find zeroCrossing		respZeroCrossing = V_flag ? NaN : V_levelX			FindLevel/EDGE=2/Q/R=(V_maxLoc, V_minLoc) filter_TD, V_min / 2		respFirstHalfMinLoc = V_flag ? NaN : V_levelX			FindLevel/EDGE=1/Q/R=(V_minLoc, filterLenX) filter_TD, V_min / 2		respSecondHalfMinLoc = V_flag ? NaN : V_levelX		endif	//areas computed on real waves	Variable respTotalFilterArea, respPositiveFilterArea, respNegativeFilterArea		//created by getAreas	getAreas(filter_TD, respTotalFilterArea, respPositiveFilterArea, respNegativeFilterArea, x1=0, x2=filterLenX)			Duplicate/O respPower_FD, respPower_FD_smooth; debug_checkRTErrState()	Smooth/S=2 5, respPower_FD_smooth		//least smoothing polynomial smoothing available with this algorithm. compared with binomial and boxcar and this seemed a little better (captured initial rise and peak better, only by eye though)	Variable respPower_FD_max, respPower_FD_maxLoc, respPower_FD_FirstHalfMaxLoc, respPower_FD_secondHalfMaxLoc		getPeakInfo(respPower_FD_smooth, 1, 0.5, respPower_FD_max, respPower_FD_maxLoc, respPower_FD_FirstHalfMaxLoc, respPower_FD_secondHalfMaxLoc)		Variable respPower_FD_FWHM = respPower_FD_secondHalfMaxLoc - respPower_FD_FirstHalfMaxLoc	Variable respPower_FD_FWHM_Mid = respPower_FD_FirstHalfMaxLoc + (respPower_FD_FWHM / 2)	Variable respPower_totalArea = area(respPower_FD,pnt2x(respPower_FD,1),areaMeasureCutOffFreq)		//does not include DC	Variable respPower_DC = respPower_FD[0]	Variable respPower_Below20HzArea = area(respPower_FD , pnt2x(respPower_FD,1), 20)	Variable respPower_20to40HzArea = area(respPower_FD, 20,40)	Variable respPower_40to60HzArea = area(respPower_FD, 40,60)	Variable respPower_60to250HzArea = area(respPower_FD, 60, areaMeasureCutOffFreq)	KillWaves/Z respPower_FD_smooth		//phase spectrum summary	Variable respPhase_totArea, respPhase_posArea, respPhase_negArea	getAreas(filterPhase_FD, respPhase_totArea, respPhase_posArea, respPhase_negArea, x1=pnt2x(filterPhase_FD,1),x2=areaMeasureCutOffFreq); 	//start from point 1 to ignore DC	Variable respPhase_Below20Hz_totArea, respPhase_Below20Hz_negArea, respPhase_Below20Hz_posArea	getAreas(filterPhase_FD, respPhase_Below20Hz_totArea, respPhase_Below20Hz_posArea, respPhase_Below20Hz_negArea, x1=pnt2x(filterPhase_FD,1),x2=20); 	Variable respPhase_20to40Hz_totArea, respPhase_20to40Hz_negArea, respPhase_20to40Hz_posArea	getAreas(filterPhase_FD, respPhase_20to40Hz_totArea, respPhase_20to40Hz_posArea, respPhase_20to40Hz_negArea, x1=20,x2=40); 	Variable respPhase_40to60Hz_totArea, respPhase_40to60Hz_negArea, respPhase_40to60Hz_posArea	getAreas(filterPhase_FD, respPhase_40to60Hz_totArea, respPhase_40to60Hz_posArea, respPhase_40to60Hz_negArea, x1=40,x2=60); 	Variable respPhase_60to250Hz_totArea, respPhase_60to250Hz_negArea, respPhase_60to250Hz_posArea	getAreas(filterPhase_FD, respPhase_60to250Hz_totArea, respPhase_60to250Hz_posArea, respPhase_60to250Hz_negArea, x1=60,x2=areaMeasureCutOffFreq); 			Variable respPhase_zeroCrossing, respPhase_negPeak, respPhase_negPeakLoc,  respPhase_negPeak_firstHalfLoc, respPhase_secondHalfLoc	getPeakInfo(filterPhase_FD, -1, 0.5, respPhase_negPeak, respPhase_negPeakLoc, respPhase_negPeak_firstHalfLoc, respPhase_secondHalfLoc, x2=20)	FindLevel /EDGE=1/Q/R=(respPhase_negPeakLoc,1000) filterPhase_FD, 0	respPhase_zeroCrossing = V_LevelX	Variable respPhase_negFWHM = respPhase_secondHalfLoc - respPhase_negPeak_firstHalfLoc	Variable respPhase_negFWHMMid = respPhase_negPeak_firstHalfLoc + ( respPhase_negFWHM / 2 )			//save general parameters of this analysis	Variable numParams = 35+35	Make/D/O/N=(numParams) wn_paramsTemp	if (!ParamIsDefault(passedParams))		wn_paramsTemp[0,8] = passedParams[p]		//transfer passed params	endif	wn_paramsTemp[9] = stimDCVariance	wn_paramsTemp[10] = respDCVariance	wn_paramsTemp[11] = filterMaxLoc	wn_paramsTemp[12] = filterMaxVal	wn_paramsTemp[13] = filterMinLoc	wn_paramsTemp[14] = filterMinVal	wn_paramsTemp[15] = respFirstHalfMaxLoc	wn_paramsTemp[16] = respSecondHalfMaxLoc	wn_paramsTemp[17] = respNegRegionFound	wn_paramsTemp[18] = respZeroCrossing	wn_paramsTemp[19] = respFirstHalfMinLoc	wn_paramsTemp[20] = respSecondHalfMinLoc	wn_paramsTemp[21] = respTotalFilterArea	wn_paramsTemp[22] = respPositiveFilterArea	wn_paramsTemp[23] = respNegativeFilterArea	wn_paramsTemp[24] = resp_ssRes	wn_paramsTemp[25] = resp_x0	wn_paramsTemp[26] = coefWave[0]			//resp y0	wn_paramsTemp[27] = coefWave[1]			//c1 a1	wn_paramsTemp[28] = coefWave[2]			//c1 tau1	wn_paramsTemp[29] = coefWave[3] 			//c2 a1 ....	wn_paramsTemp[30] = coefWave[4] 	wn_paramsTemp[31] = coefWave[5] 	wn_paramsTemp[32] = coefWave[6] 	wn_paramsTemp[33] = coefWave[7] 	wn_paramsTemp[34] = coefWave[8] 	Variable psParamsStart = 35		//power	wn_paramsTemp[psParamsStart+0] = respPower_FD_max	wn_paramsTemp[psParamsStart+1] = respPower_FD_maxLoc	wn_paramsTemp[psParamsStart+2] = respPower_FD_FirstHalfMaxLoc	wn_paramsTemp[psParamsStart+3] = respPower_FD_secondHalfMaxLoc	wn_paramsTemp[psParamsStart+4] = respPower_FD_FWHM	wn_paramsTemp[psParamsStart+5] = respPower_FD_FWHM_Mid	wn_paramsTemp[psParamsStart+6] = respPower_totalArea	wn_paramsTemp[psParamsStart+7] = respPower_DC	wn_paramsTemp[psParamsStart+8] = respPower_Below20HzArea	wn_paramsTemp[psParamsStart+9] = respPower_20to40HzArea	wn_paramsTemp[psParamsStart+10] = respPower_40to60HzArea	wn_paramsTemp[psParamsStart+11] = respPower_60to250HzArea		//phase area	wn_paramsTemp[psParamsStart+12] = respPhase_totArea	wn_paramsTemp[psParamsStart+13] = respPhase_posArea	wn_paramsTemp[psParamsStart+14] = respPhase_negArea	wn_paramsTemp[psParamsStart+15] = respPhase_Below20Hz_totArea	wn_paramsTemp[psParamsStart+16] = respPhase_Below20Hz_posArea	wn_paramsTemp[psParamsStart+17] = respPhase_Below20Hz_negArea	wn_paramsTemp[psParamsStart+18] = respPhase_20to40Hz_totArea	wn_paramsTemp[psParamsStart+19] = respPhase_20to40Hz_posArea	wn_paramsTemp[psParamsStart+20] = respPhase_20to40Hz_negArea	wn_paramsTemp[psParamsStart+21] = respPhase_40to60Hz_totArea	wn_paramsTemp[psParamsStart+22] = respPhase_40to60Hz_posArea	wn_paramsTemp[psParamsStart+23] = respPhase_40to60Hz_negArea	wn_paramsTemp[psParamsStart+24] = respPhase_60to250Hz_totArea	wn_paramsTemp[psParamsStart+25] = respPhase_60to250Hz_posArea	wn_paramsTemp[psParamsStart+26] = respPhase_60to250Hz_negArea		//phase negative peak	wn_paramsTemp[psParamsStart+27] = respPhase_negPeak	wn_paramsTemp[psParamsStart+28] = respPhase_negPeakLoc	wn_paramsTemp[psParamsStart+29] = respPhase_negPeak_firstHalfLoc	wn_paramsTemp[psParamsStart+30] = respPhase_secondHalfLoc	wn_paramsTemp[psParamsStart+31] = respPhase_zeroCrossing	wn_paramsTemp[psParamsStart+32] = respPhase_negFWHM	wn_paramsTemp[psParamsStart+33] = respPhase_negFWHMMid		//cut off frequency for measurement	wn_paramsTemp[psParamsStart+34] = areaMeasureCutOffFreq	Duplicate/O wn_paramsTemp, $saveRef; debug_checkRTErrState()	return saveRef	end		//wn_computePairedCorrParams()function/S wn_getPairedCorrParamsHeader()	Variable numParams = 35+35	Make/O/T/N=(numParams) wn_paramsHeader_S		wn_paramsHeader_S[0] = "stimMean"	wn_paramsHeader_S[1] = "respMean"	wn_paramsHeader_S[2] = "pearsonRresp"	wn_paramsHeader_S[3] = "filterLenX"	wn_paramsHeader_S[4] = "binStartSpacingX"	wn_paramsHeader_S[5] = "useWindowing"	wn_paramsHeader_S[6] = "winStartX"	wn_paramsHeader_S[7] = "winSizeX"	wn_paramsHeader_S[8] = "numNonLinearityBins"	wn_paramsHeader_S[9] = "stimDCVariance"	wn_paramsHeader_S[10] = "respDCVariance"	wn_paramsHeader_S[11] = "filterMaxLoc"	wn_paramsHeader_S[12] = "filterMaxVal"	wn_paramsHeader_S[13] = "filterMinLoc"	wn_paramsHeader_S[14] = "filterMinVal"	wn_paramsHeader_S[15] = "respFirstHalfMaxLoc"	wn_paramsHeader_S[16] = "respSecondHalfMaxLoc"	wn_paramsHeader_S[17] = "respNegRegionFound"	wn_paramsHeader_S[18] = "respZeroCrossing"	wn_paramsHeader_S[19] = "respFirstHalfMinLoc"	wn_paramsHeader_S[20] = "respSecondHalfMinLoc"	wn_paramsHeader_S[21] = "respTotalFilterArea"	wn_paramsHeader_S[22] = "respPositiveFilterArea"	wn_paramsHeader_S[23] = "respNegativeFilterArea"	wn_paramsHeader_S[24] = "resp_ssRes"	wn_paramsHeader_S[25] = "resp_x0"	wn_paramsHeader_S[26] = "coefWave[0]"			//resp y0	wn_paramsHeader_S[27] = "coefWave[1]"			//c1 a1	wn_paramsHeader_S[28] = "coefWave[2]"			//c1 tau1	wn_paramsHeader_S[29] = "coefWave[3]"			//c2 a1 ....	wn_paramsHeader_S[30] = "coefWave[4]" 	wn_paramsHeader_S[31] = "coefWave[5]"	wn_paramsHeader_S[32] = "coefWave[6]" 	wn_paramsHeader_S[33] = "coefWave[7]" 	wn_paramsHeader_S[34] = "coefWave[8]" 	Variable psParamsStart = 35		//power	wn_paramsHeader_S[psParamsStart+0] = "respPower_FD_max"	wn_paramsHeader_S[psParamsStart+1] = "respPower_FD_maxLoc"	wn_paramsHeader_S[psParamsStart+2] = "respPower_FD_FirstHalfMaxLoc"	wn_paramsHeader_S[psParamsStart+3] = "respPower_FD_secondHalfMaxLoc"	wn_paramsHeader_S[psParamsStart+4] = "respPower_FD_FWHM"	wn_paramsHeader_S[psParamsStart+5] = "respPower_FD_FWHM_Mid"	wn_paramsHeader_S[psParamsStart+6] = "respPower_totalArea"	wn_paramsHeader_S[psParamsStart+7] = "respPower_DC"	wn_paramsHeader_S[psParamsStart+8] = "respPower_Below20HzArea"	wn_paramsHeader_S[psParamsStart+9] = "respPower_20to40HzArea"	wn_paramsHeader_S[psParamsStart+10] = "respPower_40to60HzArea"	wn_paramsHeader_S[psParamsStart+11] = "respPower_60to250HzArea"		//phase area	wn_paramsHeader_S[psParamsStart+12] = "respPhase_totArea"	wn_paramsHeader_S[psParamsStart+13] = "respPhase_posArea"	wn_paramsHeader_S[psParamsStart+14] = "respPhase_negArea"	wn_paramsHeader_S[psParamsStart+15] = "respPhase_Below20Hz_totArea"	wn_paramsHeader_S[psParamsStart+16] = "respPhase_Below20Hz_posArea"	wn_paramsHeader_S[psParamsStart+17] = "respPhase_Below20Hz_negArea"	wn_paramsHeader_S[psParamsStart+18] = "respPhase_20to40Hz_totArea"	wn_paramsHeader_S[psParamsStart+19] = "respPhase_20to40Hz_posArea"	wn_paramsHeader_S[psParamsStart+20] = "respPhase_20to40Hz_negArea"	wn_paramsHeader_S[psParamsStart+21] = "respPhase_40to60Hz_totArea"	wn_paramsHeader_S[psParamsStart+22] = "respPhase_40to60Hz_posArea"	wn_paramsHeader_S[psParamsStart+23] = "respPhase_40to60Hz_negArea"	wn_paramsHeader_S[psParamsStart+24] = "respPhase_60to250Hz_totArea"	wn_paramsHeader_S[psParamsStart+25] = "respPhase_60to250Hz_posArea"	wn_paramsHeader_S[psParamsStart+26] = "respPhase_60to250Hz_negArea"		//phase negative peak	wn_paramsHeader_S[psParamsStart+27] = "respPhase_negPeak"	wn_paramsHeader_S[psParamsStart+28] = "respPhase_negPeakLoc"	wn_paramsHeader_S[psParamsStart+29] = "respPhase_negPeak_firstHalfLoc"	wn_paramsHeader_S[psParamsStart+30] = "respPhase_secondHalfLoc"	wn_paramsHeader_S[psParamsStart+31] = "respPhase_zeroCrossing"	wn_paramsHeader_S[psParamsStart+32] = "respPhase_negFWHM"	wn_paramsHeader_S[psParamsStart+33] = "respPhase_negFWHMMid"		//cut off frequency for measurement	wn_paramsHeader_S[psParamsStart+34] = "areaMeasureCutOffFreq"		Duplicate/O/T wn_paramsHeader_S, wn_paramsHeader_P, wn_paramsHeader_Diff	wn_paramsHeader_S += "_S"		//will demarcate somatic portion (1st third)	wn_paramsHeader_P += "_P"		//pedicle region (2nd third)	wn_paramsHeader_Diff += "_D"	//difference, last third	Concatenate /NP /O /T "wn_paramsHeader_S;wn_paramsHeader_P;wn_paramsHeader_diff;", wn_paramsHeader	KillWAves/Z wn_paramsHeader_S, wn_paramsHeader_P, wn_paramsHeader_Diff			return NameOfWave(wn_paramsHeader)end		// wn_getPairedCorrParamsHeader()//threshold and output levels are all relative to zero for moment!function 	getPeakInfo(waveWithPeak, negOrPos, riseFallThreshold, peakVal, peakLoc, firstThresholdLoc, secondThresholdLoc, [x1, x2])	WAVE waveWithPeak				//suggest smoothing etc. for precision	Variable negOrPos				// less than 0 for negative going peak, greater than zero for pos going	Variable riseFallThreshold			//e.g. 0.5 for 50% peak locs	Variable &peakVal, &peakLoc, &firstThresholdLoc, &secondThresholdLoc	Variable x1, x2	//optionally specify start and end of potential peak loc		Variable startX, endX		//actual window used in X vals	if (!PAramISDefault(x1))		startX = x1	else		startX = DimOffset(waveWithPeak,0)	endif	if (!ParamIsDefault(x2))		endX = x2	else		endX = DimOffset(waveWithPeak,0) + DimSize(waveWithPeak,0) * DimDelta(waveWithPeak,0)	endif			if (negOrPos < 0)		Duplicate/O/free waveWithPeak, waveWithPeakTemp		waveWithPeakTemp *= -1	else		WAVE waveWithPeakTemp=waveWithPeak	endif		Wavestats/Q/R=(startX, endX)/Z waveWithPeakTemp 	peakVal = V_max	peakLoc = V_maxLoc	Variable prePeakMin=wavemin(waveWithPeakTemp,startx,V_maxLoc)	Variable postPeakMin=wavemin(waveWithPeakTemp,V_maxLoc,endx)		FindLevel /EDGE=1/Q/R=(startX,peakLoc) waveWithPeakTemp, prePeakMin+((peakVal-prePeakMin) * riseFallThreshold)	firstThresholdLoc = V_LevelX	FindLevel /EDGE=2/Q/R=(peakLoc, endX) waveWithPeakTemp, postPeakMin+((peakVal-postPeakMin) * riseFallThreshold)	secondThresholdLoc = V_LevelX	endfunction getAreas(inWave, totalAreaVar, posAreaVar, negAreaVar, [nonZeroThreshold, x1, x2])	WAVE inWave	Variable &totalAreaVar, &posAreaVar, &negAreaVar	Variable nonZeroThreshold, x1, x2		//optional parameters. nonZeroThresh will give area below input level and above input level	Variable threshold, startX, endX	if (!ParamIsDefault(nonZeroThreshold))		threshold = nonZeroThreshold	else		threshold = 0	endif	if (!PAramISDefault(x1))		startX = x1	else		startX = DimOffset(inWave,0)		Print "startX = " + num2str(startX)	endif	if (!ParamIsDefault(x2))		endX = x2	else		endX = DimOffset(inWave,0) + DimSize(inWave,0) * DimDelta(inWave,0)		Print "endX = " + num2str(endX)	endif			totalAreaVar = area(inWave, startX, endX)	Duplicate/O inWave, inWave_posTemp	inWave_posTemp = inWave_posTemp[p] > 0 ? inWave_posTemp[p] : 0			//sets all negative values to zero	posAreaVar = area(inWave_posTemp, startX, endX); killwaves/Z inWave_posTemp		negAreaVar = posAreaVar - totalAreaVar					//I've checked and these are additive for threshold of zero, don't see why they shouldnt be for others as wellendfunction getMeans(inWave, totalMeanVar, posMeanVar, negMeanVar, [nonZeroThreshold, x1, x2])	WAVE inWave	Variable &totalMeanVar, &posMeanVar, &negMeanVar	Variable nonZeroThreshold, x1, x2		//optional parameters. nonZeroThresh will give Mean below input level and above input level	Variable threshold, startX, endX	if (!ParamIsDefault(nonZeroThreshold))		threshold = nonZeroThreshold	else		threshold = 0	endif	if (!PAramISDefault(x1))		startX = x1	else		startX = DimOffset(inWave,0)		Print "startX = " + num2str(startX)	endif	if (!ParamIsDefault(x2))		endX = x2	else		endX = DimOffset(inWave,0) + DimSize(inWave,0) * DimDelta(inWave,0)		Print "endX = " + num2str(endX)	endif			totalMeanVar = mean(inWave, startX, endX)	Duplicate/O inWave, inWave_posTemp	inWave_posTemp = inWave_posTemp[p] > 0 ? inWave_posTemp[p] : 0			//sets all negative values to zero	posMeanVar = mean(inWave_posTemp, startX, endX); killwaves/Z inWave_posTemp		negMeanVar = posMeanVar - totalMeanVar					//I've checked and these are additive for threshold of zero, don't see why they shouldnt be for others as wellend//takes selected stimulus, resp1 and resp2 (Assumes C0 = stim, C1= soma, C2= ped)function myCorr(normalizeToPeak, useAP)	Variable normalizeToPeak, useAP		Variable filterLenX = 0.5			//filter length in seconds. Should check that this is => cross-correlation result (e.g. that correlation ~ 0 at t=filterLenX)	Variable numNonlinearityBins = 30		//how finely to segment the non-linearity (pairwise plot of predicted and actual voltage response at soma and ped)		//check file save path and move on, first declaring the global string that stores the save path, only if this path has been set using fio_setDataSavePath()	if (fio_checkGlobalFilePath())			//check path returns non-zero if there are any problems with symbolic path		Print "Aborted in myCorr because file save path not set. Use fio_setDataSavePath()"		return 0	endif	SVAR/Z dataSavePathName				//this should be a global string with the name of the path that is set by fio_setDataSavePath()		WAVE/T waveListListWave; WAVE waveListSelListByNums		Variable selRow = waveListSelListByNums[0]		Variable winStartX=10	Variable winSizeX=35 	Variable winEndX		if (useAP)		String stimRef = waveListListWave[selRow][0]		String somaRef = waveListListWave[selRow][1]		String pedRef = waveListListWave[selRow][2]	else		stimRef ="stimF300Hz"		somaRef = "somaF300Hz"		pedRef = "pedF300Hz"	endif		winSizeX +=  DimDelta($stimRef,0)		//makes numpnts even for present window size and sampling rate of 35 sec and 20 kHz. Even # is needed for FFT etc.	winEndX = winStartX + winSizeX		//first want to know the mean of the traces and subtract that out, as this stuff doesn't vary in time and so won't tell us about time-dependent correlations	Duplicate/O $stimRef, stimWave, stimWaveNoDC	Variable stimMean = mean(stimWave)	stimWaveNoDC -= stimMean	Duplicate/O $somaRef, somaWave, somaWaveNoDC	Variable somaMean = mean(somaWave)	somaWaveNoDC -= somaMean	Duplicate/O $pedRef, pedWave, pedWaveNoDC	Variable pedMean = mean(pedWave)	pedWaveNoDC -= pedMean		//now make copies of waves for correlation (correaltion overwrites dest wave only, but just to be safe we'll make copies of everything)//	Duplicate/O/R=(winStartX, winEndX) stimWaveNoDC, stimWaveCopy, stimWaveCor, corrStimSoma, corrStimPed		//latter two are so named because they will be the destination wave for the correlation. They must originally be filled with the stimulus			//	Duplicate/O/R=(winStartX, winEndX) somaWaveNoDC, somaWaveCopy, somaWaveCor, corrSomaPed//	Duplicate/O/R=(winStartX, winEndX) pedWaveNoDC, pedWaveCor		Duplicate/O/R=(winStartX, winEndX) stimWaveNoDC, stimWaveCopy, stimWaveCor, corrStimSoma, corrStimPed	Duplicate/O/R=(winStartX, winEndX) somaWaveNoDC, somaWaveCopy, somaWaveCor, corrSomaPed, corrStimSoma	Duplicate/O/R=(winStartX, winEndX) pedWaveNoDC, corrStimPed, corrSomaPed		//if normalizing to peak, need to calculate some info about the source waves (cannot do this to the destination waves AFTER correlating as they change to the result)	if (normalizeToPeak)		WaveStats/Q stimWaveNoDC		Variable stimWaveRMS = V_rms		Variable stimWaveLen = numpnts(stimWave)				WaveStats/Q somaWaveNoDC		Variable somaWaveRMS = V_rms		Variable somaWaveLen = numpnts(somaWave)				WaveStats/Q pedWaveNoDC		Variable pedWaveRMS = V_rms		Variable pedWaveLen =  numpnts(pedWave)	endif	//Correlation: Correlate srcWave, outWave, area under curve for srcWave and outWave is computed, and summed as outWave is shifted in time//From the literature (e.g. SAKURANAGA and Yu-ICHIRO ANDO, 1985; Kim and Rieke, 2001), it appears that one should shift the stimulus relative to//the response for constructing a linear filter (first order weiner kernel). Correspondingly the stimulus is shifted relative to the filter to construct the linear response//	Correlate somaWaveCor, corrStimSoma		//this is //	Correlate pedWaveCor, corrStimPed//	Correlate pedWaveCor, corrSomaPed	//if cross-correlating src=stim and dest/Input = response (cmd = Correlate stim, response) , then Convolve src=filter(result of cross-corr) and dest/Input=stim (cmd = Convolve/A filter, stim)	Correlate stimWaveCor, corrStimSoma			Correlate stimWaveCor, corrStimPed	Correlate somaWaveCor, corrSomaPed		//if normalize to peak, now need to modify outputs with stored information about the inputs to correlation function (see Correlate function help notes)	//Do not use this for constructing LN models! More thought has to be put into how to scale the linear component 	if (normalizeToPeak)		corrStimSoma /= (stimWaveRMS * sqrt(stimWaveLen) * somaWaveRMS * sqrt(somaWaveLen))		corrStimPed /= (stimWaveRMS * sqrt(stimWaveLen) * pedWaveRMS * sqrt(pedWaveLen))		corrSomaPed /= (somaWaveRMS * sqrt(somaWaveLen) * pedWaveRMS * sqrt(pedWaveLen))	endif		//shift to peak at 0	Variable newZeroX = DimOffset(corrStimSoma,0) - winStartX		//winStartX is equivalent to time "zero" for the filter, so we want to shift the current starting point by an additional -winStartX seconds	Variable xscale = DimDelta(corrStimSoma, 0)	SetScale/P x, newZeroX, xscale, corrStimSoma; SetScale/P x, newZeroX, xscale, corrStimPed; SetScale/P x, newZeroX, xscale, corrSomaPed		Wavestats/Q corrStimSoma	Variable somaMaxLoc = V_maxloc	Wavestats/Q corrStimPed	Variable pedMaxLoc = V_maxloc	Variable stimPedSomaDifference = pedMaxLoc - somaMaxLoc	Wavestats/Q corrSomaPed	Variable somaPedMaxLoc = V_maxloc		String corrStimSomaSN = somaRef + "_CorC"	String corrStimPedSN = pedRef + "_CorC"	String corrSomaPedSN = pedRef +"_CorV"		Duplicate/O corrStimSoma, $corrStimSomaSN	Duplicate/O corrStimPed, $corrStimPedSN	Duplicate/O corrSomaPed, $corrSomaPedSN	Save/C/O/P=$dataSavePathName $corrStimSomaSN,$corrStimPedSN, $corrSomaPedSN		//calculate convolution of generated filter (result of cross-correlation) and stimulus, see how well this predicts response (e.g. LN model/first order Weiner Kernel)	Duplicate/O/R=(winStartX, winEndX) somaWaveNoDC, somaReal	Duplicate/O/R=(winStartX, winEndX) pedWaveNoDC, pedReal		//stimForConvSoma and stimForConvPed will be used by Convolve and then overwritten with the result of the convolution. Will do the same with EV (equal Variance) versions after normalizing the filters to give EV predictions	Duplicate/O/R=(winStartX,winEndX) stimWaveNoDc, stimReal, stimForConvSoma, stimForConvPed, stimForEVConvSoma, stimForEVConvPed		Duplicate/O/R=(0,filterLenX) corrStimSoma, somaFilter, somaEVFilter	Duplicate/O/R=(0,filterLenX) corrStimPed, pedFilter, pedEVFilter		//the filters are not really acausal except for a slight tail that starts before t=0, my guess is that this is due to blurring by sampling/filtering. 	//with useCausalFiltering = 1 we will set filter = 0 for t < 0, forcing the filter to be causal. The Convolution is slightly different for causal and acausal filters	//first set t=0 to point 0, which equivalently sets the filter = 0 for t < 0, making it causal	//earlier we already shifted the filter so that start time is properly at t=0, and this value is stored in newZeroX	//find point number of newZeroX and delete points before that, then adjust scaling so t=0 is at point 0//	Variable firstPoint = x2pnt(somaFilter, 0)//	Print firstPoint		//delete points preceding t = 0//	DeletePoints 0, firstPoint-1, somaFilter, pedFilter		//since t = 0 was not originally at p = 0, t=0 has shifted, and it now has to be set such that t=0 at p0//	SetScale/P x, 0, xscale, somaFilter; SetScale/P x, 0, xscale, pedFilter				//now we can cut down the filter to it's proper length//	DeletePoints x2pnt(somaFilter, filterLenX), numpnts(somaFilter), somaFilter, pedFilter		//using num points because we want to delete all points after filterLenX, and this makes sure we will (it's ok to run out of index)			//make copies for later scaling for equal variance//	Duplicate/O somaFilter, somaEVFilter//	Duplicate/O pedFilter, pedEVFilter			//now do linear convolution with destWave = stimulus wave (output is overwritten into here)	Convolve somaFilter, stimForConvSoma	Convolve pedFilter, stimForConvPed			//the result adds points (length = filter length) to the result of the convolution, so remove these appended points	Duplicate/O/R=(winStartX, winEndX) stimForConvSoma, predictedSoma		Duplicate/O/R=(winStartX, winEndX) stimForConvPed, predictedPed		//re-calculate filter with normalization such that variance of response is scaled to variance of stimulus (Baccus and Meister 2002)	// I think any value such that Variance(predictedsoma) = Variance(predictedped) would be fine for comparison	Variable stimAUCSq = area(stimReal)^2	Print "stimAUCSq = " + num2str(stimAUCSq)	Variable somaAUCSq = area(predictedSoma)^2	Print "somaAUCSq = " + num2str(somaAUCSq)	Variable pedAUCSq = area(predictedPed)^2		Print "pedAUCSq = " + num2str(pedAUCSq)	Variable somaMultiplier = sqrt(stimAUCSq/somaAUCSq)	Variable pedMultiplier = sqrt(stimAUCSq/pedAUCSq)		Print "Multiplier soma = " + num2str(somaMultiplier) + ". Multiplier ped = " + num2str(pedMultiplier)	somaEVFilter *= somaMultiplier	pedEVFilter *= pedMultiplier		//redo linear convolution with EV-scaled filters	Convolve somaEVFilter, stimForEVConvSoma	Convolve pedEVFilter, stimForEVConvPed		//remove appended points as before	Duplicate/O/R=(winStartX, winEndX) stimForEVConvSoma, predictedEVSoma		Duplicate/O/R=(winStartX, winEndX) stimForEVConvPed, predictedEVPed			//add back mean of real responses. SHOULD SPLIT AND PLOT BOTH//	somaReal += somaMean//	pedReal += pedMean		//analysis of LN models:			//see how well (linearly) correlated the predicted and actual response are	Variable pearsonRSoma = getPearsonR(somaReal,predictedSoma)	Print "R originalConv Soma = " + num2str(pearsonRSoma)	Variable pearsonREVSoma = getPearsonR(somaReal,predictedEVSoma)	Print "R EVConv Soma = " + num2str(pearsonREVSoma)	Variable pearsonRPed = getPearsonR(pedReal,predictedPed)	Print "R originalConv Ped = " + num2str(pearsonRPed)	Variable pearsonREVPed = getPearsonR(pedReal,predictedEVPed)	Print "R EVConv Ped = " + num2str(pearsonREVPed)			Print "AUCSq stim = " + num2str(stimAUCSq) + ". Soma = " + num2str(area(predictedEVSoma)^2) + ". Ped = " + num2str(area(predictedEVPed)^2)			//bin the pairwise comparisons between predicted and actual response for a more compact description (standard in the field), more amenable to curve fitting	downSampleYX("somaReal","predictedSoma", numNonlinearityBins, "binnedNonlinearitySoma",0)	downSampleYX("pedReal","predictedPed", numNonlinearityBins, "binnedNonlinearityPed",0)	WAVE binnedNonlinearitySoma, binnedNonlinearityPed		//created by downSampleYX, 2 column wave; rows are bins, col 0 = xVal, col 1 = yVal	Make/O/D/N=(numNonlinearityBins) somaBinnedXVals, somaBinnedYVals, pedBinnedXVals, pedBinnedYVals		//cannot use the 2D wave binnedNonlinearitySoma because in one of igors horrible faults it has difficulty dealing with fitting one column vs another	somaBinnedXVals = binnedNonlinearitySoma[p][0]; somaBinnedYVals = binnedNonlinearitySoma[p][1]	pedBinnedXVals = binnedNonlinearityPed[p][0]; pedBinnedYVals = binnedNonlinearityPed[p][1]		//repeat for EV	downSampleYX("somaReal","predictedEVSoma", numNonlinearityBins, "binnedNonlinearitySomaEV",0)	downSampleYX("pedReal","predictedEVPed", numNonlinearityBins, "binnedNonlinearityPedEV",0)		WAVE binnedNonlinearitySomaEV, binnedNonlinearityPedEV	Make/O/D/N=(numNonlinearityBins) somaEVBinnedXVals, somaEVBinnedYVals, pedEVBinnedXVals, pedEVBinnedYVals	somaEVBinnedXVals = binnedNonlinearitySomaEV[p][0]; somaEVBinnedYVals = binnedNonlinearitySomaEV[p][1]	pedEVBinnedXVals = binnedNonlinearityPedEV[p][0]; pedEVBinnedYVals = binnedNonlinearityPedEV[p][1]		Make/O/D/N=2 linearCoefsSoma, linearCoefsPed, linearCoefsSomaEV, linearCoefsPedEV		CurveFit/W=2/N=1/Q=1 line, kwCWave = linearCoefsSoma, somaBinnedYVals/X=somaBinnedXVals	CurveFit/W=2/N=1/Q=1 line, kwCWave = linearCoefsPed, pedBinnedYVals/X=pedBinnedXVals		CurveFit/W=2/N=1/Q=1 line, kwCWave = linearCoefsSomaEV, somaEVBinnedYVals/X=somaEVBinnedXVals	CurveFit/W=2/N=1/Q=1 line, kwCWave = linearCoefsPedEV, pedEVBinnedYVals/X=pedEVBinnedXVals					//store fit results with original bin information (as column 3). First for normal (non-EV)	Redimension/N=(DimSize(binnedNonlinearitySoma,0), 3) binnedNonlinearitySoma, binnedNonlinearityPed	binnedNonlinearitySoma[][2] = linearCoefsSoma[0] + linearCoefsSoma[1]*binnedNonlinearitySoma[p][0]		//just using linear fit to predict y from x	binnedNonlinearityPed[][2] = linearCoefsPed[0] + linearCoefsPed[1]*binnedNonlinearityPed[p][0]			//same thing for ped		//then for EV	Redimension/N=(DimSize(binnedNonlinearitySoma,0), 3) binnedNonlinearitySomaEV, binnedNonlinearityPedEV	binnedNonlinearitySomaEV[][2] = linearCoefsSomaEV[0] + linearCoefsSomaEV[1]*binnedNonlinearitySomaEV[p][0]		//just using linear fit to predict y from x	binnedNonlinearityPedEV[][2] = linearCoefsPedEV[0] + linearCoefsPedEV[1]*binnedNonlinearityPedEV[p][0]			//same thing for ped		//	KillWaves/Z somaBinnedYVals, somaBinnedXVals, pedBinnedYVals, pedBinnedXVals,somaEVBinnedYVals, somaEVBinnedXVals, pedEVBinnedYVals, pedEVBinnedXVals		//save convolution related data	String stimFromWinSN = stimRef + "StR"	String somaRealSN = somaRef + "SoR"	String pedRealSN = pedRef + "PeR"	String somaFilterSN = somaRef + "CoF" + "So"	String pedFilterSN = pedRef + "CoF" + "Pe"	String somaConvSN = somaRef + "CoC" + "So"	String pedConvSN = pedRef + "CoC"  + "Pe"	String somaBinnedConvSN = somaRef + "CoB" + "So"	String pedBinnedConvSN = pedRef + "CoB" + "Pe"	//save for equal variance results	String somaEVFilterSN = somaRef + "CoF" + "SoV"	String pedEVFilterSN = pedRef + "CoF" + "PeV"	String somaEVConvSN = somaRef + "CoC" + "SoV"	String pedEVConvSN = pedRef + "CoC"  + "PeV"	String somaEVBinnedConvSN = somaRef + "CoB" + "SoV"	String pedEVBinnedConvSN = pedRef + "CoB" + "PeV"					//copy all into proper wave references and add notes as appropriate (e.g. try to save information from original wave and add notes about analyses performed)	Duplicate/O stimReal, $stimFromWinSN	Note $stimFromWinSN, " (WN_RealStimulus) "	Duplicate/O somaReal, $somaRealSN	Note $somaRealSN, " (WN_RealSoma) "	Duplicate/O pedReal, $pedRealSN	Note $pedRealSN, " (WN_RealPed) "		Duplicate/O somaFilter, $somaFilterSN	Note/K $somaFilterSN, note($somaRef) + " (Soma_WNFilter) "	Duplicate/O pedFilter, $pedFilterSN	Note/K $pedFilterSN, note($pedRef) + "(Ped_WNFilter)"	Duplicate/O predictedSoma, $somaConvSN	Note/K $somaConvSN, note($somaRef) + " (Soma_WNPredicted) "	Duplicate/O predictedPed, $pedConvSN	Note/K $pedConvSN, note($pedRef) + "(Ped_WNPredicted)"	Duplicate/O binnedNonLinearitySoma, $somaBinnedConvSN	Note/K $somaBinnedConvSN, note($somaRef) + " (Soma_WNNonLinearityBinned) "	Duplicate/O binnedNonLinearityPed, $pedBinnedConvSN	Note/K $pedBinnedConvSN, note($pedRef) + "(Ped_WNNonLinearityBinned)"		//same for equal variance	Duplicate/O somaEVFilter, $somaEVFilterSN	Note/K $somaEVFilterSN, note($somaRef) + " (Soma_WNFilterEV) "	Duplicate/O pedEVFilter, $pedEVFilterSN	Note/K $pedEVFilterSN, note($pedRef) + "(Ped_WNFilterEV)"	Duplicate/O predictedEVSoma, $somaEVConvSN	Note/K $somaEVConvSN, note($somaRef) + " (Soma_WNPredictedEV) "	Duplicate/O predictedEVPed, $pedEVConvSN	Note/K $pedEVConvSN, note($pedRef) + "(Ped_WNPredictedEV)"	Duplicate/O binnedNonLinearitySomaEV, $somaEVBinnedConvSN	Note/K $somaEVBinnedConvSN, note($somaRef) + " (Soma_WNNonLinearityBinnedEV) "	Duplicate/O binnedNonLinearityPedEV, $pedEVBinnedConvSN	Note/K $pedEVBinnedConvSN, note($pedRef) + "(Ped_WNNonLinearityBinnedEV)"				//save all to file	Save/C/O/P=$dataSavePathName $stimFromWinSN, $somaFilterSN, $pedFilterSN, $somaConvSN, $pedConvSN, $somaBinnedConvSN, $pedBinnedConvSN		//non-EV	Save/C/O/P=$dataSavePathName $somaEVFilterSN, $pedEVFilterSN, 	$somaEVConvSN,$pedEVConvSN, $somaEVBinnedConvSN,$pedEVBinnedConvSN			//EV		//Kill unneeded stuff	KillWaves/Z somaFilter, pedFilter,binnedNonLinearitySoma, binnedNonLinearityPed		//names for display windows (need to display predicted and actual overlays and pairwise comparisons)	String predictedRespOverlayWN = stimRef + "CoCO"	String pairwiseOverlayWN = stimRef + "CoCP"			//and for equal variance	String predictedEVRespOverlayWN = stimRef + "CoCOV"	String pairwiseEVOverlayWN = stimRef + "CoCPV"			//Display results. First get rid of any old windows by the same names (need * at end because Igor likes to append numbers to window names) (this is total overkill, and could be problematic if you want to run this function with different parameters and get results for both in one instance of igor	KillWindowsByName(stimRef + "*Cor*")	KillWindowsByName(somaRef + "*Cor*")	KillWindowsByName(pedRef + "*Cor*")	KillWindowsByName(stimRef + "*CoC*")	KillWindowsByName(somaRef + "*CoC*")	KillWindowsByName(pedRef + "*CoC*")	KillWindowsByName(stimRef + "*CoF*")	KillWindowsByName(somaRef + "*CoF*")	KillWindowsByName(pedRef + "*CoF*")			//Display cross-correlation result	String corrSummaryN = stimRef + "_CorS"	String corrSummaryTableN = corrSummaryN + "T"	String corrSummaryGraphN = corrSummaryN + "G"		Display/K=1/N=$corrSummaryTableN $corrStimSomaSN, $corrStimPedSN	corrSummaryTableN = S_Name	//just in case Igor decides to append numbers	setaxis bottom, -0.01, filterLenX		//zooms into center of trace with an arbitrary padding into negative values and stops at t = filterLenX for positive values	ModifyGraph lstyle($corrStimSomaSN) = 0,  lstyle($corrStimPedSN) =0, rgb( $corrStimSomaSN) = (0,0,0)		//changes line style and makes somatic trace black (ped red)//	ModifyGraph lblPos(L1) = 51, freePos(L1) = 0		//Display convolution results		//overlay chopped out "causal" linear filters with originals	AppendToGraph/W=$corrSummaryTableN $somaFilterSN, $pedFilterSN	ModifyGraph lstyle($somaFilterSN) = 0, lstyle($pedFilterSN) = 0, rgb( $somaFilterSN) = (0,0,0), lsize($somaFilterSN) = 1.5,  lsize($pedFilterSN) = 1.5		//add in EV responses on a different axis (the EV ones should share the same axis though)	AppendToGraph/W=$corrSummaryTableN/L=L_EV $somaEVFilterSN, $pedEVFilterSN	ModifyGraph axisEnab(left) = {0,.6}, axisEnab(L_EV) = {0.64,1}, lblPos(L_EV)=51, freePos(L_EV) = 0	ModifyGraph lstyle($somaEVFilterSN) = 0, lstyle($pedEVFilterSN) = 0, rgb( $somaEVFilterSN) = (0,0,0), lsize($somaEVFilterSN) = 1.5,  lsize($pedEVFilterSN) = 1.5		//copying	ModifyGraph lblPos(left)=70,lblPos(L_EV)=70,lblLatPos(left)=20;DelayUpdate	Label left "\\U at Soma or \r\\K(65280,0,0)Terminal\\K(0,0,0)";DelayUpdate	Label bottom "Delay (\\U)";DelayUpdate	Label L_EV "\\U\r(Normalized)"					//display predicted responses overlaid with originals	Display/K=1/N=$predictedRespOverlayWN/L=Lped $pedRealSN	predictedRespOverlayWN = S_Name	AppendToGraph/W=$predictedRespOverlayWN/R=Rped $pedConvSN	AppendToGraph/W=$predictedRespOverlayWN/L=Lsoma $somaRealSN	AppendToGraph/W=$predictedRespOverlayWN/R=Rsoma/C=(0,0,0) $somaConvSN	ModifyGraph/W=$predictedRespOverlayWN rgb($pedRealSN) = (34816,34816,34816), rgb($somaRealSN) = (34816,34816,34816)								//set real responses as gray	ModifyGraph lblPos(Lsoma) = 51, freePos(Lsoma) = 0, lblPos(Lped) = 51, freePos(Lped) = 0, lblPos(Rped) = 51, freePos(Rped) = 0, lblPos(Rsoma) = 51, freePos(Rsoma) = 0	ModifyGraph axisEnab(Lsoma) = {0,.48}, axisEnab(Lped) = {0.52,1}, axisEnab(Rsoma) = {0,0.48}, axisEnab(Rped) = {0.52,1}	setaxis bottom, winStartX, winStartX + .5			//zoom in on some portion		//add EVs 	AppendToGraph/W=$predictedRespOverlayWN/R=RpedEV $pedEVConvSN	AppendToGraph/W=$predictedRespOverlayWN/R=RsomaEV $somaEVConvSN	ModifyGraph lblPos(RsomaEV) = 51, freePos(RsomaEV) = 0, lblPos(RpedEV) = 51, freePos(RpedEV) = 0, axisEnab(RsomaEV) = {0,0.48}, axisEnab(RpedEV) = {0.52,1}	ModifyGraph lstyle($somaEVConvSN) = 8, lstyle($pedEVConvSN) = 8, lsize($somaEVConvSN) = 1.5, lsize($pedEVConvSN) = 1.5, rgb($somaEVConvSN) = (0,0,0)		//copying	ModifyGraph lblPos(Lped)=51,lblPos(Lsoma)=51,lblPos(RpedEV)=100;DelayUpdate	ModifyGraph lblPos(RsomaEV)=100,lblLatPos(Rped)=50,lblLatPos(Lsoma)=15;DelayUpdate	ModifyGraph freePos(RpedEV)=100,freePos(RsomaEV)=100;DelayUpdate	Label Lped "\\K(65280,0,0)Terminal (\\U)";DelayUpdate	Label bottom "Time (\\U)";DelayUpdate	Label Rped "\\K(21760,21760,21760)Linear Prediction (\\E)  ";DelayUpdate	Label Lsoma "Soma(\\U)";DelayUpdate	Label Rsoma "\\u#2";DelayUpdate	Label RpedEV "\\u#2";DelayUpdate	Label RsomaEV "\\u#2"			//display overlay	Display/K=1/N=$pairwiseOverlayWN	pairwiseOverlayWN = S_Name	AppendToGraph/W=$pairwiseOverlayWN/C=(0,0,0) $somaRealSN/TN=soma vs $somaConvSN	AppendToGraph/W=$pairwiseOverlayWN $pedRealSN/TN=ped vs $pedConvSN	AppendToGraph/W=$pairwiseOverlayWN $somaBinnedConvSN[][1]/TN=somaBinned vs $somaBinnedConvSN[][0] 	AppendToGraph/W=$pairwiseOverlayWN $somaBinnedConvSN[][2]/TN=somaFit vs $somaBinnedConvSN[][0] 	AppendToGraph/W=$pairwiseOverlayWN $pedBinnedConvSN[][1]/TN=pedBinned vs $pedBinnedConvSN[][0] 	AppendToGraph/W=$pairwiseOverlayWN $pedBinnedConvSN[][2]/TN=pedFit vs $pedBinnedConvSN[][0] 		//make fits circles with outer grey and inner black (soma) or red (ped)	ModifyGraph mode(soma)=2, mode(ped)=2	ModifyGraph mode(somaFit)=3,marker(somaFit)=19, mrkThick(somaFit)=2,rgb(somaFit)=(0,0,0), mrkStrokeRGB(somaFit)=(34816,34816,34816), useMrkStrokeRGB(somaFit)=1	ModifyGraph mode(pedFit)=3,marker(pedFit)=19, mrkThick(pedFit)=2,rgb(pedFit)=(65280,0,0), mrkStrokeRGB(pedFit)=(34816,34816,34816), useMrkStrokeRGB(pedFit)=1	ModifyGraph mode(somaBinned)=0, lstyle(somaBinned) = 1, lsize(somaBinned)=5,rgb(somaBinned)=(34816,34816,34816)	ModifyGraph mode(pedBinned)=0, lstyle(pedBinned) = 1, lsize(pedBinned)=5,rgb(pedBinned)=(34816,34816,34816)	ReorderTraces somaBinned,{somaFit,pedFit}		//copying	Label left "\\Z14Measured \rSoma or \\K(65280,0,0)Terminal\\K(0,0,0) (\\U)"	Label bottom "\\Z14Linear Prediction (\\E)"			//display EV overlays	Display/K=1/N=$pairwiseEVOverlayWN	pairwiseEVOverlayWN = S_Name	AppendToGraph/W=$pairwiseEVOverlayWN/C=(0,0,0) $somaRealSN/TN=somaEV vs $somaEVConvSN	AppendToGraph/W=$pairwiseEVOverlayWN $pedRealSN/TN=pedEV vs $pedEVConvSN	AppendToGraph/W=$pairwiseEVOverlayWN $somaEVBinnedConvSN[][1]/TN=somaEVBinned vs $somaEVBinnedConvSN[][0] 	AppendToGraph/W=$pairwiseEVOverlayWN $somaEVBinnedConvSN[][2]/TN=somaEVFit vs $somaEVBinnedConvSN[][0] 	AppendToGraph/W=$pairwiseEVOverlayWN $pedEVBinnedConvSN[][1]/TN=pedEVBinned vs $pedEVBinnedConvSN[][0] 	AppendToGraph/W=$pairwiseEVOverlayWN $pedEVBinnedConvSN[][2]/TN=pedEVFit vs $pedEVBinnedConvSN[][0] 		//make fits circles with outer grey and inner black (soma) or red (ped)	ModifyGraph mode(somaEV)=2, mode(pedEV)=2	ModifyGraph mode(somaEVFit)=3,marker(somaEVFit)=19, mrkThick(somaEVFit)=2,rgb(somaEVFit)=(0,0,0), mrkStrokeRGB(somaEVFit)=(34816,34816,34816), useMrkStrokeRGB(somaEVFit)=1	ModifyGraph mode(pedEVFit)=3,marker(pedEVFit)=19, mrkThick(pedEVFit)=2,rgb(pedEVFit)=(65280,0,0), mrkStrokeRGB(pedEVFit)=(34816,34816,34816), useMrkStrokeRGB(pedEVFit)=1		ModifyGraph mode(somaEVBinned)=0, lstyle(somaEVBinned) = 1, lsize(somaEVBinned)=5,rgb(somaEVBinned)=(34816,34816,34816)	ModifyGraph mode(pedEVBinned)=0, lstyle(pedEVBinned) = 1, lsize(pedEVBinned)=5,rgb(pedEVBinned)=(34816,34816,34816)	ReorderTraces somaEVBinned,{somaEVFit,pedEVFit}			//copying	ModifyGraph fSize=14;DelayUpdate	Label left "\\Z14Measured \rSoma or \\K(65280,0,0)Terminal\\K(0,0,0) (\\U)"	Label bottom "\\Z14Normalized Linear Prediction (\\E)"	//frequency-space analysis	//first for magnitude FFT		//on raw data	Duplicate/O/R=(winStartX, winEndX) stimWaveNoDC, stimWaveNoDCForFFT	Duplicate/O/R=(winStartX, winEndX) somaWaveNoDC, somaWaveNoDCForFFT	Duplicate/O/R=(winStartX, winEndX) pedWaveNoDC,pedWaveNoDCForFFT		adjustLenForFFT("stimWaveNoDCForFFT")		//makes sure rows are even, removed one point if not	adjustLenForFFT("somaWaveNoDCForFFT")	adjustLenForFFT("pedWaveNoDCForFFT")	adjustLenForFFT(somaFilterSN)	adjustLenForFFT(pedFilterSN)	//	Hanning stimWaveNoDCForFFT, somaWaveNoDCForFFT, pedWaveNoDCForFFT	fft/Dest=stimFD stimWaveNoDCForFFT					//FD for frequency domain, TD for time domain 	fft/Dest=somaFD somaWaveNoDCForFFT	fft/Dest=pedFD pedWaveNoDCForFFT		//on linear filter (non-EV, for now just considering that for purpopses of the LN model)	fft/Dest=somaFilterFD $somaFilterSN	fft/Dest=pedFilterFD $pedFilterSN	fft/Dest=stimMagStarter/OUT=3 stimWaveNoDCForFFT			//not going to use this FFT, but this will give scaling matched to the complex waves produced above in a real wave	fft/Dest=respMagStarter/OUT=3 somaWaveNoDCForFFT		fft/Dest=filterMagStarter/OUT=3 $somaFilterSN			Variable numpntsStimTD = numpnts(stimWaveNoDCForFFT)	Variable numpntsSomaTD = numpnts(somaWaveNoDCForFFT)	Variable numpntsPedTD = numpnts(pedWaveNoDCForFFT)	Variable numpntsSomaFilterTD = numpnts($somaFilterSN)	Variable numpntsPedFilterTD = numpnts($pedFilterSN)		Duplicate/O stimMagStarter, stimMagFDNorm	Duplicate/O respMagStarter, somaMagFDNorm, pedMagFDNorm, somaImpFDNorm, pedImpFDNorm	Duplicate/O filterMagStarter, somaFilterMagFDNorm, pedFilterMagFDNorm		//get the magnitude from the FFT result and normalize amplitude as described in the Fourier Transform help section 	stimMagFDNorm = real(r2polar(stimFD[p]))/numpntsStimTD		//stimFD is a complex wave in rectangular coords, r2polar returns r (real part of point returned) and angle (imaginey part), then real returns the real component magnitude  	somaMagFDNorm = real(r2polar(somaFD[p]))/numpntsSomaTD	pedMagFDNorm = real(r2polar(pedFD[p]))/numpntsPedTD	somaFilterMagFDNorm = real(r2polar(somaFilterFD[p]))/numpntsSomaFilterTD	pedFilterMagFDNorm = real(r2polar(pedFilterFD[p]))/numpntsPedFilterTD	stimMagFDNorm[1,numpnts(stimMagFDNorm)-2] = 2*stimMagFDNorm[p]	//the real component of the FFT output is scaled by 2/N(real, time domain wave) for all points except first and last, which are 1/N	somaMagFDNorm[1,numpnts(somaMagFDNorm)-2] = 2*somaMagFDNorm[p]	pedMagFDNorm[1,numpnts(pedMagFDNorm)-2] = 2*pedMagFDNorm[p]	somaFilterMagFDNorm[1,numpnts(somaFilterMagFDNorm)-2] = 2*somaFilterMagFDNorm[p]	pedFilterMagFDNorm[1,numpnts(pedFilterMagFDNorm)-2] = 2*pedFilterMagFDNorm[p]		//calculate impedence from FD magnitudes of somatic voltage response and ped voltage response, each individually divded by the FD magnitude of the stimulus	somaImpFDNorm = somaMagFDNorm/stimMagFDNorm	pedImpFDNorm = pedMagFDNorm / stimMagFDNorm		//calculate interesting subtraction results	Duplicate/O pedMagFDNorm, pedSomaSubMagFDNorm		//will store result of FDM(ped) - FDM(soma)	pedSomaSubMagFDNorm -=  somaMagFDNorm	Duplicate/O pedImpFDNorm, pedSomaSubImpNorm			//will store result of FDI(ped) - FDI(soma)	pedSomaSubImpNorm -= somaImpFDNorm	Duplicate/O pedFilterMagFDNorm, pedSomaSubFilterMagFDNorm		//will store result of FilterFDM(ped) - FilterFDM(soma	pedSomaSubFilterMagFDNorm -= somaFilterMagFDNorm		//name save names	String fftSaveAppendString = "FD"; 	//all FD are getting FD, just FD = complex wave (FFT output), FFD = FFT output from a filter, anything with M after this is the normalized magnitude only, I after is Mag  resp/ mag stim 	String appendNote = "(WN, Window:(" + num2str(winStartX) + "," + num2str(winEndX) + "; FFT:"		//FFT:FD indicates complex wave (FFT output), FFT:M is magnitude, if F in front then FFD		//stimulus stuff	String stimFDSN = stimREF + fftSaveAppendString	Note/K stimFD, note($stimRef) + appendNote + "FD"	Duplicate/O stimFD, $stimFDSN	String stimMagFDSN =  stimREF + fftSaveAppendString + "M"	Note/K stimMagFDNorm, note($stimRef) + appendNote + "FDM"	Duplicate/O stimMagFDNorm, $stimMagFDSN		//raw soma stuff	String somaFDSN = somaRef + fftSaveAppendString	Note/K somaFD, note($somaRef) + appendNote + "FD"	Duplicate/O somaFD, $somaFDSN	String somaMagFDSN = somaRef + fftSaveAppendString + "M"	Note/K somaMagFDNorm, note($somaRef) + appendNote + "FDM"	Duplicate/O somaMagFDNorm, $somaMagFDSN	String somaImpFDSN = somaRef + fftSaveAppendString +"I"	Note/K somaImpFDNorm, note($somaRef) + appendNote + "FDI"	Duplicate/O somaImpFDNorm, $somaImpFDSN			//raw ped stuff	String pedFDSN = pedRef + fftSaveAppendString	Note/K pedFD, note($pedRef) + appendNote + "FD"	Duplicate/O pedFD, $pedFDSN	String pedMagFDSN = pedRef + fftSaveAppendString + "M"	Note/K pedMagFDNorm, note($pedRef) + appendNote + "FDM"	Duplicate/O pedMagFDNorm, $pedMagFDSN	String pedImpFDSN = pedRef + fftSaveAppendString +"I"	Note/K pedImpFDNorm, note($pedRef) + appendNote + "FDI"	Duplicate/O pedImpFDNorm, $pedImpFDSN			//filter soma stuff	String somaFilterFDSN = somaRef + "F" + fftSaveAppendString 	Note/K somaFilterFD, note($somaRef) + appendNote + "FFD"	Duplicate/O somaFilterFD, $somaFilterFDSN		String somaFilterMagFDSN = somaRef + "F" +  fftSaveAppendString + "M"	Note/K somaFilterMagFDNorm, note($somaRef) + appendNote + "FFDM"	Duplicate/O somaFilterMagFDNorm, $somaFilterMagFDSN				//filter ped stuff		String pedFilterFDSN = pedRef + "F" +  fftSaveAppendString	Note/K pedFilterFD, note($pedRef) + appendNote + "FFD"	Duplicate/O pedFilterFD, $pedFilterFDSN		String pedFilterMagFDSN = pedRef + "F" +  fftSaveAppendString + "M"	Note/K pedFilterMagFDNorm, note($pedRef) + appendNote + "FFDM"	Duplicate/O pedFilterMagFDNorm, $pedFilterMagFDSN		//subtraction stuff (pedSomaSubMagFDNorm, pedSomaSubImpNorm, pedSomaSubFilterMagFDNorm)	String pedSomaSubMagFDSN = stimRef + "FDMPS"	Note/K pedSomaSubMagFDNorm, note($stimRef) + appendNote + "FDMPS"	Duplicate/O pedSomaSubMagFDNorm, $pedSomaSubMagFDSN			String pedSomaSubImpNormSN = stimRef + "FDIPS"	Note/K pedSomaSubImpNorm, note($stimRef) + appendNote + "FDIPS"	Duplicate/O pedSomaSubImpNorm, $pedSomaSubImpNormSN			String pedSomaSubFilterMagFDNormSN = stimRef + "FFDMPS"	Note/K pedSomaSubFilterMagFDNorm, note($stimRef) + appendNote + "FFDMPS"	Duplicate/O pedSomaSubFilterMagFDNorm, $pedSomaSubFilterMagFDNormSN						//save all to file	Save/C/O/P=$dataSavePathName $stimFDSN, $stimMagFDSN, $somaMagFDSN, $somaImpFDSN,$pedFDSN,$pedMagFDSN, $pedImpFDSN,$somaFilterFDSN,$somaFilterMagFDSN,$pedFilterFDSN,$pedFilterMagFDSN		Save/C/O/P=$dataSavePathName $pedSomaSubMagFDSN, $pedSomaSubImpNormSN, $pedSomaSubFilterMagFDNormSN				//kill any old windows	KillWindowsByName(stimRef + "*" + fftSaveAppendString + "*")	KillWindowsByName(pedRef + "*" + fftSaveAppendString + "*")	KillWindowsByName(somaRef + "*" + fftSaveAppendString + "*")	//instantiate new windows	//graphs for magnitude	Display/K=1/N=$(stimRef+fftSaveAppendString + "M") 		//stimulus to right axis	String stimMagGN = S_Name//	AppendToGraph/R=Rstim $stimMagFDSN		//responses to same left axis	AppendToGraph/L=L_abs $somaMagFDSN, $pedMagFDSN	AppendToGraph/L=L_sub $pedSomaSubMagFDSN	ModifyGraph rgb($somaMagFDSN) = (0,0,0), rgb($pedSomaSubMagFDSN)=(0,35328,35328)		//soma black stim grey ped red (default) subtraction (drk blue/green)	ModifyGraph axisEnab(L_Sub) = {0,.48}, axisEnab(L_Abs) = {0.52,1}, freepos = 0, lblPos = 51	setaxis bottom, .25,200; setaxis/A=2 L_abs; setaxis/A=2 L_sub			//auto scale after setting bottom to 0 to 200 Hz		//copying 	ModifyGraph fSize=14,lblLatPos(L_sub)=10;DelayUpdate	Label L_abs "\\Z14 Voltage (\\U)";DelayUpdate	Label bottom "\\Z14 Frequency (\\U)";DelayUpdate	Label L_sub "\\Z14Difference (\\U)"		//graph for impedence	Display/K=1/N=$(stimRef + fftSaveAppendString + "I")	String impGN = S_Name	AppendToGraph/L=L_abs $somaImpFDSN, $pedImpFDSN	AppendtoGraph/L=L_sub $pedSomaSubImpNormSN	ModifyGraph rgb($somaImpFDSN) = (0,0,0), rgb($pedSomaSubImpNormSN)= (0,35328,35328)		//soma plot black subtraction (drk blue/green)	ModifyGraph axisEnab(L_Sub) = {0,.48}, axisEnab(L_Abs) = {0.52,1}, freepos = 0, lblPos = 51	setaxis bottom, .25,200; setaxis/A=2 L_abs; setaxis/A=2 L_sub		//auto scale after setting bottom to 0 to 200 Hz		//copying in from manual update	ModifyGraph fSize=14,lblPos(L_abs)=70,lblPos(L_sub)=70,lblLatPos(L_sub)=10;DelayUpdate	ModifyGraph prescaleExp(L_abs)=-6,prescaleExp(L_sub)=-6,notation(L_sub)=1;DelayUpdate	Label L_abs "\\Z14 Impedence\r(M"	Label bottom "\\Z14 Frequency (\\U)";DelayUpdate	Label L_sub "\\Z14 Difference\r(M"		//graphs for FD of cross-correlation (magnitude only)	Display/K=1/N=$(stimRef + "F"+ fftSaveAppendString +"M")	String filterMagGN = S_Name		AppendToGraph/L=L_abs $somaFilterMagFDSN, $pedFilterMagFDSN	AppendToGraph/L=L_sub $pedSomaSubFilterMagFDNormSN	ModifyGraph rgb($somaFilterMagFDSN) = (0,0,0)	, rgb($pedSomaSubFilterMagFDNormSN) = (0,35328,35328)		//soma plot black subtraction (drk blue/green)	ModifyGraph axisEnab(L_Sub) = {0,.48}, axisEnab(L_Abs) = {0.52,1}, freepos = 0, lblPos = 51	setaxis bottom, .25,200; setaxis/A=2 L_abs; setaxis/A=2 L_sub	//auto scale after setting bottom to 0 to 200 Hz		//copying	ModifyGraph fSize=14,lblPos(L_abs)=70,lblPos(L_sub)=64;DelayUpdate	Label L_abs "\\Z14 Nominal \rVoltage\\u#2";DelayUpdate	Label bottom "\\Z14 Frequency (\\U)";DelayUpdate	Label L_sub "\\Z14 Difference\\u#2"		//summary info			//table with summary data	String corrSummaryHeaderN = corrSummaryN + "H"		//corrSummaryHeader defined above	Edit/K=1/N=$corrSummaryTableN $corrSummaryHeaderN, $corrSummaryN		//overlay of filter (cross-correlation) for soma and ped. Keep in mind that these are before shifting to t=0 at p0		Variable numSummaryPnts = 5	Make/O/D/N=(numSummaryPnts) corrSummary	Make/O/T/N=(numSummaryPnts) corrSummaryHeader		corrSummaryHeader[0] = "stim - soma max loc"	corrSummary[0] = somaMaxLoc	corrSummaryHeader[1] = "stim - ped  max loc"	corrSummary[1] = pedMaxLoc	corrSummaryHeader[2] = "ped - soma vs stim max loc difference"	corrSummary[2] = stimPedSomaDifference	corrSummaryHeader[3] = "ped vs soma max loc"	corrSummary[3] = somaPedMaxLoc		corrSummaryHeader[4] = "File: " + StringFromList(0,getFileNameFromWaveName(stimRef,0))+"; T: " + fd_note_getWaveTimeStr(stimRef,1) 	corrSummary[4] = NaN		//keeps this line blank so that it can be copied from excel			Duplicate/O corrSummary, $corrSummaryN	Duplicate/O corrSummaryHeader, $corrSummaryHeaderN	endfunction reverseCorrelation(stimRef, respRef, winStartX, winEndX, outputRef)	String stimRef, respRef, outputRef; Variable winStartX, winEndX		Variable rcLengthX = 1			//in seconds	Duplicate/O $stimRef, rcStimTemp	Duplicate/O $respRef, rcRespTemp		Variable sRate = DimDelta(rcStimTemp,0)	Print "sRate",sRate		//subtract means from both		Variable meanStim = mean(rcStimTemp,winStartX, winEndX)//	rcStimTemp -= meanStim	Variable meanResp = mean(rcRespTemp, winStartX, winEndX)//	rcRespTemp -= meanResp		Duplicate/O/R=(0,rcLengthX) rcRespTemp, rcOutputTemp	rcOutputTemp = 0		Variable xIndex	for (xIndex=winStartX;xIndex<winEndX;xIndex+=sRate)		rcOutputTemp += rcStimTemp(x+xIndex-rcLengthX+1)*rcRespTemp(xIndex)		//p is iterator through rcOutputTemp, so first point is p=0 and last is p = rcLengthX-1, so last point will be i	endfor		Duplicate/O rcOutputTemp, $outputRef		KillWaves/Z rcStimTemp, rcRespTemp, rcOutputTempendfunction/S getSelWaveByNumsAsString(selWaveRef, delimiterString)	String selWaveRef, delimiterString		Duplicate/O $selWaveRef, selWaveTempForPrint	Variable i; String outputString = ""	for (i=0;i<numpnts(selWaveTempForPrint);i+=1)		if (i>0)			//appending beforehand avoids trailing delimiter and checking >0 avoids preceding delimiter			outputString += delimiterString		endif		outputString += num2str(selWaveTempForPrint[i])	endfor	KillWaves/Z selWaveTempForPrint	return outputStringendfunction/S getSelWaveForLBColAsString(selWaveRef, colNum, delimiterString)	String selWaveRef, delimiterString; Variable colNum		Duplicate/O $selWaveRef, selWaveTempForPrint	WAVE/T waveListListWave		Variable i, currentSelRow; String outputString = ""	for (i=0;i<numpnts(selWaveTempForPrint);i+=1)		currentSelRow = selWaveTempForPrint[i]		if (i>0)			//appending beforehand avoids trailing delimiter and checking >0 avoids preceding delimiter			outputString += delimiterString		endif		outputString += waveListListWave[currentSelRow][colNum]	endfor		KillWaves/Z selWaveTempForPrint	return outputStringendfunction redisplayCellParamsHeader()	if (fio_checkGlobalFilePath())			//check path returns non-zero if there are any problems with symbolic path		Print "Aborted at redisplayCellParamsHeader() because file save path not set! Use fio_setDataSavePath()"		return 0	endif	SVAR/Z dataSavePathName				//this should be a global string with the name of the path that is set by fio_setDataSavePath()	//display cell params calcs	String cellParamsDisplayWinName = "CPC_Table"	String cellParamsSummaryWinName = "CPC_Summary"	String cellPAramsHeaderStandAloneName = "CPC_FreeHeader"	if (WinType(cellParamsDisplayWinName) > 0)		KillWindow $cellParamsDisplayWinName	endif	if (WinType(cellPAramsHeaderStandAloneName) > 0)		KillWindow $cellPAramsHeaderStandAloneName	endif	if (WinType(cellParamsSummaryWinName) > 0)		KillWindow $cellParamsSummaryWinName	endif		//Summary of wcParamsWave: 0-6 seal params, 7-13 wcParams, 14 access res, 15 mem res, 16 Cm, 17 y0, 18 coef, 19 tau, 20 x0, 21 N (seal, WC), 22 calc wave #	//now adding: 23-55 as adjusted units. 56 blank.  57-79 as normalized to initial brk in readings															//	Make/O/T/N=66 cellParamsTableHeader		Make/O/T/N=24 cellParamsTableHeader			Edit/K=1/N=$cellParamsDisplayWinName 				//values for header table:	cellParamsTableHeader[0] = "Seal InputRes (Ohm)"	cellParamsTableHeader[1] = "Seal DeltaCurrent (A)"	cellParamsTableHeader[2] = "Seal DeltaVoltage (V)"	cellParamsTableHeader[3] = "Seal BaselineCurrent (A)"	cellParamsTableHeader[4] = "Seal BaselineVoltage (V)"	cellParamsTableHeader[5] = "Seal StepCurrent (A)"	cellParamsTableHeader[6] = "Seal StepVoltage (A)"	cellParamsTableHeader[7] = "WC InputRes (Ohm)"	cellParamsTableHeader[8] = "WC DeltaCurrent (A)"	cellParamsTableHeader[9] = "WC DeltaVoltage (V)"	cellParamsTableHeader[10] = "WC BaselineCurrent (A)"	cellParamsTableHeader[11] = "WC BaselineVoltage (V)"	cellParamsTableHeader[12] = "WC StepCurrent (A)"	cellParamsTableHeader[13] = "WC StepVoltage (A)"	cellParamsTableHeader[14] = "WC AccessRes (Ohm) "	cellParamsTableHeader[15] = "WC MembraneRes (Ohm)"	cellParamsTableHeader[16] = "WC MembraneCapacitance (F)"	cellParamsTableHeader[17] = "WC Fit_y0 (A)"	cellParamsTableHeader[18] = "WC Fit_coef (A)"	cellParamsTableHeader[19] = "WC Tau (S)"	cellParamsTableHeader[20] =  "WC Fit_x0 (S)"	cellParamsTableHeader[21] = "Voltage at I = 0 (V)"	cellParamsTableHeader[22] = "N [Seal, WC]"	cellParamsTableHeader[23] = "Calc wave # (seal, WC)"//	cellParamsTableHeader[23,43] = cellParamsTableHeader[p-23]//	cellParamsTableHeader[45,65] = "ADJ_" + cellParamsTableHeader[p-45]	AppendToTable/W=$cellParamsDisplayWinName cellParamsTableHeader	Edit/K=1/N=$cellPAramsHeaderStandAloneName cellParamsTableHeader		//	String brkThruNoteString = "BRKTHRU:" 	String cellParamsSummaryAppendString = "S"		Make/O/T/N=16 cellParamsSummaryHeader	cellParamsSummaryHeader[0] = "Seal File"	cellParamsSummaryHeader[1] = "WC File"	cellParamsSummaryHeader[2] = "Rec Time"	cellParamsSummaryHeader[3] = "Seal R (Ohm)"	cellParamsSummaryHeader[4] = "WC Input R (Ohm)"	cellParamsSummaryHeader[5] = "WC Access R (Ohm)"	cellParamsSummaryHeader[6] = "WC Vhold at I=0"	cellParamsSummaryHeader[7] = "Cm"	cellParamsSummaryHeader[8] = "Tau"	cellParamsSummaryHeader[9] = "V_hold"	cellParamsSummaryHeader[10] = "V_delta"	cellParamsSummaryHeader[11] = "I_sealLeak"	cellParamsSummaryHeader[12] = "I_hold"	cellParamsSummaryHeader[13] = "I_delta"	cellParamsSummaryHeader[14] = "Seal_TraceNum"	cellParamsSummaryHeader[15] = "WC_TraceNum"		Edit/K=1/N=$cellParamsSummaryWinName	AppendToTable/W=$cellParamsSummaryWinName cellParamsSummaryHeader		//new items to add to wave list: 15-30. Normal units versions. 31-45. Relative to first wave	String calcParamsWaveList = WaveList("*_CPC", ";", "TEXT:0")	Print "Created the following cell params calc waves: " + calcParamsWaveList	Variable i, brkThruRefStartIndex, brkThruRefEndIndex; String currentRef, currentBrkThruRef		//current brk thru ref is the ref listed in the note for each paramsWave, which is a reference to the first params wave (right after brk thru) for the cell	for (i=0;i<ItemsInList(calcParamsWaveList,";");i+=1)				currentRef = StringFromList(i, calcParamsWaveList,";")		Duplicate/O $currentRef, cellParamsDisplayTemp		AppendToTable/W=$cellParamsDisplayWinName $currentRef			//	Print note(cellParamsDisplayTemp)				//now handle display of summary graph: 		String summaryRefName = currentRef + cellParamsSummaryAppendString		Make/O/T/N=16 summaryTemp		Note summaryTemp, "SUMMARY OF==:" + note(cellParamsDisplayTemp)		summaryTemp[0] = StringFromList(2,note(cellParamsDisplayTemp),";")		summaryTemp[1] = currentRef		summaryTemp[2] = StringFromList(1,note(cellParamsDisplayTemp),";")		//currently the zeroth position in the note wave is the time created		summaryTemp[3] = num2str(cellParamsDisplayTemp[0][0])			//seal resistance		summaryTemp[4] = num2str(cellParamsDisplayTemp[7][0])			//whole cell input resistance		summaryTemp[5] = num2str(cellParamsDisplayTemp[14][0])			//whole cell access resistance		summaryTemp[6] = num2str(cellParamsDisplayTemp[21][0])			//WC Vhold at I=0		summaryTemp[7] = num2str(cellParamsDisplayTemp[16][0]) //"Cm"		summaryTemp[8] = num2str(cellParamsDisplayTemp[19][0])//"Tau"		summaryTemp[9] = num2str(cellParamsDisplayTemp[11][0])//"V_hold"		summaryTemp[10] =  num2str(cellParamsDisplayTemp[9][0])	//"V_delta"		summaryTemp[11] = num2str(cellParamsDisplayTemp[3][0])	 //"I_sealLeak"		summaryTemp[12] = num2str(cellParamsDisplayTemp[10][0])	 //"I_hold"		summaryTemp[13] = num2str(cellParamsDisplayTemp[8][0])	 //"I_delta"		summaryTemp[14] = num2str(cellParamsDisplayTemp[22][0])	//seal trace num		summaryTemp[15] = num2str(cellParamsDisplayTemp[22][1])	//WC trace num						//save summary wave and save to folder		Duplicate/O summaryTemp, $summaryRefName			Save/C/O/P=$dataSavePathName $summaryRefName					AppendToTable/W=$cellParamsSummaryWinName $summaryRefName			endfor end//calculates step parameters for one or more listed steps. Assumes cursor C is placed at the first point at which the "final" command value is reached on top graph//assumes that one VOLTAGE-CURRENT is listed with voltage signal in col 0 and current in col 1function analysis_cCStepParamsForSel(showRawData)	Variable showRawData	 	 Variable levelOneStartX = xcsr(C)	 Variable levelTwoStartX = xcsr(D)	 Variable fitEndX = xcsr(E)	 Variable levelTwoEndX = xcsr(F)		 	 WAVE waveListSelListByNums	 WAVE/T waveListListWave	 	 String ccParamsAvgSaveNameAppendString = "_CStepP"	 	 Make/O/D/N=11 ccParamsAvg = 0	 	 Variable i, currListRow, currCol	 String currVoltageRef, currCurrentRef, currParamsRef	 String firstVoltageRef, lastVoltageRef,  firstCurrentRef, lastCurrentRef	 for (i=0;i<numpnts(waveListSelListByNums);i+=1)	 	currListRow = waveListSelListByNums[i]	 	currVoltageRef = waveListListWave[i][0]	 	currCurrentRef = waveListListWave[i][1]	 	currParamsRef = analysis_cCStepParams(currVoltageRef, currCurrentRef, levelOneStartX, levelTwoStartX, fitEndX, levelTwoEndX)	 	Duplicate/O $currParamsRef, paramsWaveTemp	 	ccParamsAvg += paramsWaveTemp	 	Note ccParamsAvg, note(paramsWaveTemp)	 	KillWaves/Z $currParamsRef	 	if (i==0)	 		firstvoltageRef = currVoltageRef	 		firstCurrentRef = currCurrentRef	 	endif	 endfor	 lastVoltageRef = currVoltageRef	 lastCurrentRef = currCurrentRef	 ccParamsAvg/=numpnts(waveListSelListByNums)	 	 avgTracesSelCol(0, "ccStepParamsVoltageAvg")	 avgTracesSelCol(1,"ccStepParamsCurrentAvg")	// WAVE ccStepParamsVoltageAvg, ccStepParamsCurrentAvg	 String voltageSaveName = getWaveNameBySweeps(firstVoltageRef, lastVoltageRef)	 String currentSaveName = getWaveNameBySweeps(firstCurrentRef, lastVoltageRef)	 Duplicate/O $"ccStepParamsVoltageAvg", $voltageSaveName	 Duplicate/O $"ccStepParamsCurrentAvg", $currentSaveName	 	 String ccParamsAvgSaveName = voltageSaveName + ccParamsAvgSaveNameAppendString	 Duplicate/O ccParamsAvg, $ccParamsAvgSaveName	 	 String displayWinName = "TEST"	 if (WinType(displayWinName) > 0 )	 	KillWindow $displayWinName	 endif	 	 Display/K=1/N=$displayWinName/L=leftVoltage $voltageSaveName	 	// AppendToGraph/W=$displayWinName/L=leftVoltage $voltageSaveName	// AppendToGraph/W=$displayWinName/L=leftCurrent $currentSaveName	 	 //make fit	 Duplicate/O/R=(levelTwoStartX, fitEndX) $voltageSaveName, ccVoltageStepFitTemp	 ccVoltageStepFitTemp = ccParamsAvg[0+7] + ccParamsAvg[1+7]*exp(-(x-ccParamsAvg[3+7])/ccParamsAvg[2+7])	 String voltageFitSaveName = voltageSaveName + "_FIT"	 Duplicate/O ccVoltageStepFitTemp, $voltageFitSaveName	 	 AppendToGraph/W=$displayWinName/L=leftVoltage $voltageFitSaveName	 	 SetAxis/W=$displayWinName bottom levelOneStartX, levelTwoEndX	 	 KillWaves/Z ccVoltageStepFitTemp, ccParamsAvg,paramsWaveTemp, $"ccStepParamsVoltageAvg", $"ccStepParamsCurrentAvg"endfunction/S analysis_cCStepParams(voltageRef, currentRef, levelOneStartX, levelTwoStartX, fitEndX, levelTwoEndX)	String voltageRef, currentRef; Variable levelOneStartX, levelTwoStartX, fitEndX, levelTwoEndX		String stepParamsSaveNameAppendString = "_CStepP"	Variable ssWinProportion = 1/6 		//determines how large the "steady state" window will be relative to the input window size		Duplicate/O $voltageRef, voltageTemp	Duplicate/O $currentRef, currentTemp		Variable levelOneEndX = levelTwoStartX - DimDelta(voltageTemp,0)		//take just one step back to get level one end x		Variable levelOneSSRangeInX = (levelOneEndX - levelOneStartX)*ssWinProportion	Variable levelTwoSSRangeInX = (levelTwoEndX - levelTwoStartX)* ssWinProportion			Variable levelOneSSStartX = levelOneEndX - levelOneSSRangeInX	Variable levelTwoSSStartX = levelTwoEndX - levelTwoSSRangeInX		if (levelTwoSSStartX < fitEndX)		Print "Warning! Second level steady state window encroaches user input end of exponential decay"		Print "May need to adjust ssWinProportion in analysis_cCStepParams"	endif		Make/D/O/N=7 ccStepParamsTemp	analysis_calcInputRes(currentRef, voltageRef, levelOneSSStartX, levelOneEndX, levelTwoSSStartX, levelTwoEndX, "ccStepParamsTemp")	Redimension/N=11 ccStepParamsTemp	Make/O/D/N=3 coefwave		//will put in as parameter for curvefit so that fit coefs are stored here	Make/O/D/N=1 W_fitconstants	//named place where curvefit stores x0 constant	CurveFit/W=2/N=1/Q=1/NTHR=0 exp_XOffset, kwCWave=coefWave, voltageTemp(levelTwoStartX,fitEndX)  //add /D to save the fit wave, /N/Q avoids certain updates being printed	ccStepParamsTemp[7,9] = coefWave[p-7]	ccStepParamsTemp[10] = W_fitconstants[0]		String ccStepParamsSaveName = voltageRef[0,strlen(voltageRef)-4] + stepParamsSaveNameAppendString		//takes off AD part of file name and appends append string	Note ccStepParamsTemp, "VOLTAGEREF:" + voltageREF + "; CURRENTREF:" + currentRef	Duplicate/O ccStepParamsTemp, $ccStepParamsSaveName	KillWaves/Z W_fitconstants, coefWave, ccStepParamsTemp, voltageTemp, currentTemp		return ccStepParamsSaveNameend//for dim = 0 returns the average of the row with number dim position; for dim = 1 returns the average of the columns with number dim position//only supports rows and cols. Probably not hard to right a better and more general version. This plays it safe as far as the format of the wave by using duplicate, but that also seems to me to make it harder to write with generality to higher dimsfunction getDimSegmentStats(dim, dimPos, waveRef, varNameStr [, startP , endP ])				Variable dim, dimPos; String waveRef	String varNameStr			//pass name of variable returned by wavestats. The following are V_avg, V_sum, V_sdev, V_min, V_max etc. see wavestats for complete list	Variable startP, endP 			//first and last position of dimension 		if (ParamIsDefault(startP))		startP = -Inf	endif	if (ParamIsDefault(endP))		endP = Inf	endif				Variable/G statsOutputTemp	Variable statsOutTemp	if (dim == 0)		//average across a row		Duplicate/O/R=[dimPos][startP, endP] $waveRef, segmentTemp	//	Duplicate/O/R=[dimPos][] $waveRef, segmentTemp	elseif (dim == 1)		Duplicate/O/R=[startP, endP][dimPos] $waveRef, segmentTemp	//	Duplicate/O/R=[][dimPos] $waveRef, segmentTemp	else		Print "Error in getDimSegmentStats. input dimension = 0 or 1 expected"	endif		//assign global variable to variable of name varNameStr	Wavestats/Q segmentTemp	String cmd	sprintf cmd, "Wavestats/Q %s", "segmentTemp"	Execute/Q cmd	//executes wavestats globally so that the functions are available globally. A bit messy unfortunately bc variables created by wave stats remain after function ends	sprintf cmd, "%s = %s", "statsOutputTemp", varNameStr			//assigns variable with name varNameStr to stats output temp	Execute/Z/Q cmd		if (V_flag != 0)		//V_flag is updated by execute			Print "Error in getDimSegmentStats. Variable with name of varNameStr (input parameter) not found"	endif		statsOutTemp = statsOutputTemp		//save in temp variable so we can kill global one//	KillVariables statsOutputTemp		KillWaves/Z segmentTemp		return statsOutTempend//THIS FUNCTION IS SPECIFIC TO SUMMARY DATA GENERATED FOR CURRENT INJECTIONfunction getNonZeroSweepDimSegmentAvg(targetRowNum, currentInjRowNum,targetWaveRef,currentInjWaveRef)	Variable targetRowNum, currentInjRowNum; String targetWaveRef,currentInjWaveRef		Duplicate/O $targetWaveRef, targetWave	Duplicate/O $currentInjWaveRef, currentInjWave				Variable i, minInj, minInjCol; Variable output = 0	for (i=0;i<DimSize(currentInjWave,1);i+=1)		if (i==0)			minInj = abs(currentInjWave[currentInjRowNum][i])			minInjCol = i		else			if(abs(currentInjWave[currentInjRowNum][i]) < abs(minInj))				minInj = abs(currentInjWave[currentInjRowNum][i])				minInjCol = i			endif		endif	endfor	for (i=0;i<DimSize(targetWave,1);i+=1)		if (i != minInjCol)			output += targetWave[targetRowNum][i]		endif	endfor	output /= DimSize(targetWave,1)-1	KillWaves/Z targetWave, currentInjWave	return outputend//takes in a 2D array and a dimension, 0 for rows and 1 for columns, and a dimensionPos e.g. 3 for 3rd row, returns linear fit coeffiencts//plots data and fit and DOES NOT DELETE NEW WAVES if makePlot = 1//ignores NaN values if present in y wave (does not handle NaN values in X wave but easy to addfunction/S getLinearfFtToDimSegment(yDim,yDimPos,yWaveRef, xDim,xDimPos, xWaveRef, makePlot)	Variable yDim,yDimPos, xDim,xDimPos,makePlot; String yWaveRef, xWaveRef		String separatorString = ";"	String S_output	if (yDim == 0)		//average across a row		Duplicate/O/R=[yDimPos,yDimPos][] $yWaveRef, ySegmentTemp		Make/O/D/N=(DimSize(ySegmentTemp,1)) ySegmentFinalTemp		ySegmentFinalTemp = ySegmentTemp[0][p]		//need to put into rows from columns	elseif (yDim == 1)		Duplicate/O/R=[][yDimPos,yDimPos] $yWaveRef, ySegmentFinalTemp	else		return ""	endif		if (xDim == 0)		//average across a row		Duplicate/O/R=[xDimPos,xDimPos][] $xWaveRef, xSegmentTemp		Make/O/D/N=(DimSize(xSegmentTemp,1)) xSegmentFinalTemp		xSegmentFinalTemp = xSegmentTemp[0][p]		//need to put into rows from columns	elseif (xDim == 1)		Duplicate/O/R=[][xDimPos,xDimPos] $xWaveRef, xSegmentFinalTemp	else		return ""	endif		//check for NaN values in yWave and remove if present)	Variable currentIndex	if (numtype(sum(ySegmentFinalTemp)) != 0)		//one NaN value will make sum NaN, and numtype() will only return 0 for a real number (so infinite or NaN are actually removed)		for (currentIndex=0;currentIndex<numpnts(ySegmentFinalTemp);currentIndex+=1)			if (numtype(ySegmentfinalTemp[currentIndex]) != 0)				DeletePoints currentIndex, 1, ySegmentFinalTemp, xSegmentFinalTemp				currentIndex -=1		//must step back so that next round current index will be the same index as this round, as delete points has shifted the next point forward to the position of the deleted point			endif		endfor	endif		if (numpnts(ySegmentFinalTemp) != numpnts(xSegmentFinalTemp))		return ""	endif		Make/O/D/N=2 fitCoefWave	CurveFit/Q/N=1/NTHR=0 line, kwCWave=fitCoefWave, ySegmentFinalTemp/X=xSegmentFinalTemp		S_output = num2str(fitCoefWave[0]) + separatorString + num2str(fitCoefWave[1]) + separatorString			if (makePlot)		Print "got here"		Duplicate/O ySegmentFinalTemp, ySegmentFit		ySegmentFit = fitCoefWave[0] + fitCoefWave[1] * xSegmentFinalTemp[p]		Display/K=1/N=LinearFitDisplay		String plotName = S_name		AppendToGraph/W=$plotName/C=(0,0,0) ySegmentFinalTemp vs xSegmentFinalTemp		AppendToGraph/W=$plotName ySegmentFit vs xSegmentFinalTemp	endif		KillWaves/Z fitCoefWave, xSegmentTemp, xSegmentFinalTemp, ySegmentTemp, ySegmentFinalTemp, ySegmentFit, W_coef	return S_outputendfunction killWindowsByName(matchStr,[types,exceptionsList,lastLeft,lastTop,lastRight,lastBottom])	String matchStr	Variable types //optional number. 1 = graphs, 2 = tables, 4 = layouts, 16 = notesbooks, etc. or bitwise comparison	Variable &lastLeft, &lastTop, &lastRight, &lastBottom		//optionally store last window positions	String exceptionsList	//pass names that are to be spared -- can actually be a list of matchStrs		String optionsStr = ""	if (!ParamIsDefault(types))		optionsStr = "WIN:" + num2str(types)	endif		String matchingWindows = WinList(matchStr, ";",optionsStr)	Variable firstWinKilled = 0		Variable i; string winN	for (i=0; i <ItemsInList(matchingWindows,";");i+=1)		winN = StringFromList(i,matchingWindows,";")		if (i==0)			if (!ParamIsDefault(lastLeft) && !ParamIsDefault(lastTop) && !ParamIsDefault(lastRight) && !ParamIsDefault(lastBottom) )				getWindowPos(lastLeft, lastTop, lastRight, lastBottom, winN = winN)			endif		endif				//if exception list not passed or if window not on exception list, then attempt kill		if (ParamIsDefault(exceptionsList) || ( text_matchToListStrs(winN, exceptionsList) < 0) )					if (WinType(winN) > 0)				KillWindow $winN			endif			if (WinType(winN) > 0)				Print "Attempt to killwindow name = " + winN + " failed."				if (i==0)					firstWinKilled = 0				endif			else				if (i==0)					firstWinKilled = 1				endif						endif					endif				endfor		return firstWinKilledendfunction text_matchToListStrs(testStr, listOfMatchStrs)	String testStr		//string to test	String listOfMatchStrs	//list of one or more matchStrs to test against		variable i	for (i=0;i<ItemsInList(listOfMatchStrs);i+=1)		if (stringmatch(testSTr, STringFromList(i, listOfMatchStrs)))			return 1		endif			endfor		return 0endfunction getWindowPos(left, top, right, bottom, [winN])	Variable &left, &top, &right, &bottom; String winN		if (ParamIsDefault(winN))		winN = ""	endif		GetWindow $winN, wsize	left =V_left	right =V_right	top =V_top	bottom= V_bottomendfunction setWindowPos(left, top, right, bottom, [winN])	Variable left, top, right, bottom; String winN		if (ParamIsDefault(winN))		winN = ""	endif		MoveWindow/W=$winN left, top, right, bottomend//brings windows with name matching matchStr to top of user interfacefunction bringToTop(matchStrList,[appendbeforeMatchStrs,appendAfterMatchStrs,newPosStr])	String matchStrList	String appendbeforeMatchStrs,appendAfterMatchStrs //optionally pass things to append to all match strings; useful for lists that are somehow related to another name	String newPosStr		//needs to be new "left;top;right;bottom;" for MoveWindow command  .. coords set to be in inches!		Variable i,num	String matchStrListTemp=""	if ( !ParamIsDefault(appendbeforeMatchStrs) && (strlen(appendbeforeMatchStrs) > 0) )		num=itemsinlist(matchStrList)		for (i=0;i<num;i+=1)			matchStrListTemp += appendbeforeMatchStrs + stringfromlist(i,matchStrList) + ";"		endfor		matchStrList = matchStrListTemp; matchStrListTemp = ""	endif		if ( !ParamIsDefault(appendAfterMatchStrs) && (strlen(appendAfterMatchStrs) > 0) )		num=itemsinlist(matchStrList)		for (i=0;i<num;i+=1)			matchStrListTemp += stringfromlist(i,matchStrList) + appendAfterMatchStrs + ";"		endfor		matchStrList = matchStrListTemp;	endif			String allWins=winlist("*", ";","")	String matchingWins=text_ListMatchStrList(allWins,matchStrList)	num=ItemsInList(matchingWins,";")//	Print "num",num,"matchingWins",matchingWins		Variable moveWindows= !ParamIsDefault(newPosStr) && (itemsinlist(newPosStr) > 3)	if (moveWindows)		Variable left=str2num(stringfromlisT(0,newPosStr))		Variable top=str2num(stringfromlisT(1,newPosStr))		Variable right=str2num(stringfromlisT(2,newPosStr))		Variable bottom=str2num(stringfromlisT(3,newPosStr))	endif	String winN	for (i=0; i < num;i+=1)		winN=StringFromList(i,matchingWins)		if (WinType(winN) > 0)			DoWindow/F $winN			if (moveWindows)				movewindow/I/W=$winN left,top,right,bottom			endif		endif	endforendfunction analysis_SSVIOld()		//assumes wave list has 3 columns, Code0 = current injection site, Code1=secondary site, e.g. I=0 site, code2= current command	WAVE waveListSelListByNums	WAVE/T waveListListWave		if (Dimsize(waveListSelListByNums,0) < 1)		Print "Select waves for SSVI analysis"		return 0	endif		Variable useCsrs = 0			//intended for passing in as a parameter later		Variable stepStartX, stepEndX	if (!useCsrs)			//must check these for new protocols if not using csrs		stepStartX =  1.3438		//first point of step		stepEndX = 3.3438		//first point of back to baseline	else		stepStartX =  xcsr(C)		//first point of step		stepEndX = xcsr(D) 		//first point of back to baseline		endif			Variable SSMeasureWinSize = .5		//in seconds. Used for steady state average window	Variable peakSearchWinSize = 0.25		String SSVIAppendString = "_VSP"		//VSP for VI Steady State Parameters	String SSVISiteOneAppendString = "S1"		//S1 for site 1, this is the site where current injection is, final string is VIPS1	String SSVISiteTwoAppendString = "S2"		//S2 for site 2, this is the site where observing, final string is VIPS2	SSVISiteOneAppendString = SSVIAppendString + SSVISiteOneAppendString	SSVISiteTwoAppendString = SSVIAppendString + SSVISiteTwoAppendString		Variable firstIndex = waveListSelListByNums[0], lastIndex =  waveListSelListByNums[Dimsize(waveListSelListByNums,0) -1]	String tempName = getWaveNameBySweeps(waveListListwave[firstIndex], waveListListwave[lastIndex])	String SSVINameTemplate = StringFromList(0,getFileNameFromWaveName(tempName,0), ";")		//generates a file name that indicates date, file num, and sweep range	String s1FinalName = SSVINameTemplate + SSVISiteOneAppendString	String s2FinalName = SSVINameTemplate + SSVISiteTwoAppendString		Variable numCalcParams = 27	Make/D/O/N=(Dimsize(waveListSelListByNums,0),numCalcParams) SSVItempS1	Make/D/O/N=(Dimsize(waveListSelListByNums,0),numCalcParams) SSVItempS2	String rInSSVIOutputTempName = 	"rInSSVIOutputTemp"		//reference that will store the resultant waves from input res calc	Make/O/N=1 rInSSVIOutputTemp		//just have this so we don't have declare it in the loop		Variable V_max, V_min, V_maxloc, V_minloc	Make/O/D/N=3 coefwave		//will put in as parameter for curvefit so that fit coefs are stored here	Make/O/D/N=1 W_fitconstants	//named place where curvefit stores x0 constant		String S1NoteString = "S1 Response Waves Analyzed:"		//stores names of waves analyzed	String S2NoteString = "S1 Response Waves Analyzed:"	String commandNoteString = ". Command Waves Analyzed:"		//this will be stored after waves analyzed in each note		//first analyze baseline	Variable peakVal, peakLoc	Variable i, index; String commandRef, s1Ref, s2Ref	for (i=0;i<Dimsize(waveListSelListByNums,0);i+=1)		Print "--------------------------IN I = " + num2str(i) + "------------------------------"		index = waveListSelListByNums[i]			s1Ref = waveListListWave[index][0]		s2Ref = waveListListWave[index][1]		commandRef = waveListListWave[index][2]			S1NoteString += s1Ref + ";"		S2NoteString += s2Ref + ";"		commandNoteString += commandRef + ";"			//(currentWaveRef, voltageWaveRef, baselineStartX, baselineEndX, stepStartX, stepEndX, outputRef)		analysis_calcInputRes(commandRef, s1Ref, stepStartX-SSMeasureWinSize, stepStartX, stepEndX - SSMeasureWinSize, stepEndX, rInSSVIOutputTempName)		SSVITempS1[i][0,6] = rInSSVIOutputTemp[q]		analysis_calcInputRes(commandRef, s2Ref, stepStartX-SSMeasureWinSize, stepStartX, stepEndX - SSMeasureWinSize, stepEndX, rInSSVIOutputTempName)		SSVItempS2[i][0,6] = rInSSVIOutputTemp[q]		//find peak (S1 first)		Wavestats/Q/R=(stepStartX, stepStartX +  peakSearchWinSize) $s1Ref		if (SSVITempS1[i][1] < 0)		//DeltaCurrent < 0, so look for min			peakVal = V_min			peakLoc = V_minloc		elseif (SSVITempS1[i][1] > 0)			peakVal = V_max			peakLoc = V_maxloc		else			peakVal= NaN	//NaN will indicate peak not found. Not ideal			peakLoc = peakSearchWinSize 		endif		//fit curve from step start to peak		CurveFit/W=2/N=1/Q=1/NTHR=0 exp_XOffset, kwCWave=coefWave, $s1Ref(stepStartX,peakLoc)		Print "At (" +num2str(i) +") (S1) coefWave = "		Print "coefwave",coefwave		SSVITempS1[i][7,9] = coefWave[q-7]		SSVITempS1[i][10] = W_fitconstants[0]						//calculate additional parameters		(S1 first)		SSVITempS1[i][12] = peakVal -  SSVITempS1[i][4]		//peak - baseline		SSVITempS1[i][13] = peakVal -  SSVITempS1[i][6]		//peak - stepSS		SSVITempS1[i][14] = peakVal						//peak		SSVITempS1[i][11] = SSVITempS1[i][12] / SSVITempS1[i][1]	//deltaV (peak-baseline)/ deltaI (peak-baseline) --apparent resistance		SSVITempS1[i][15] = peakLoc - stepStartX			//time to peak				//additional info		SSVITempS1[i][25] = stepStartX		SSVITempS1[i][26] = peakLoc				//find peak (S2)		Wavestats/Q/R=(stepStartX, stepStartX +  peakSearchWinSize) $s2Ref		if (SSVITempS1[i][1] < 0)		//DeltaCurrent < 0, so look for min			peakVal = V_min			peakLoc = V_minloc		elseif (SSVITempS1[i][1] > 0)			peakVal = V_max			peakLoc = V_maxloc		else			peakVal= NaN	//NaN will indicate peak not found. Not ideal			peakLoc = peakSearchWinSize 		endif			//fit curve to peak		CurveFit/W=2/N=1/Q=1/NTHR=0 exp_XOffset, kwCWave=coefWave, $s2Ref(stepStartX,peakLoc)		Print "At (" +num2str(i) +") (S2) coefWave = "		Print "coefwave",coefwave		SSVITempS2[i][7,9] = coefWave[q-7]		SSVITempS2[i][10] = W_fitconstants[0]						//calc additional parameters (s2)		SSVITempS2[i][12] = peakVal -  SSVITempS2[i][4]		//peak - baseline		SSVITempS2[i][13] = peakVal -  SSVITempS2[i][6]		//peak - stepSS		SSVITempS2[i][14] = peakVal						//peak		SSVITempS2[i][11] = SSVITempS2[i][12] / SSVITempS2[i][1]	//deltaV (peak-baseline)/ deltaI (peak-baseline) --apparent resistance		SSVITempS2[i][15] = peakLoc - stepStartX			//time to peak				//calculate relative (S1 vs S2 and vis versa) parameters		SSVITempS1[i][16] = SSVITempS1[i][4] - SSVITempS2[i][4]		//baseline - baseline		SSVITempS1[i][17] = SSVITempS1[i][2] - SSVITempS2[i][2]		//delta (step-baseline) - delta (step - baseline)		SSVITempS1[i][18] = SSVITempS1[i][2] / SSVITempS2[i][2]		//delta (step-baseline) / delta (step - baseline)		SSVITempS1[i][19] = SSVITempS1[i][12] - SSVITempS2[i][12]		//delta (peak-baseline) - delta(peak - baseline)			SSVITempS1[i][20] = SSVITempS1[i][12] / SSVITempS2[i][12]		//delta (peak-baseline) / delta(peak - baseline)		SSVITempS1[i][21] = SSVITempS1[i][15] - SSVITempS2[i][15]		//time to peak - time to peak			SSVITempS1[i][22] = SSVITempS1[i][15] / SSVITempS2[i][15]		//time to peak / time to peak		SSVITempS1[i][23] = SSVITempS1[i][9] - SSVITempS2[i][9]		//tau - tau		SSVITempS1[i][24] = SSVITempS1[i][9] - SSVITempS2[i][9]		//tau - tau				SSVITempS2[i][16] = SSVITempS2[i][4] - SSVITempS1[i][4]		//baseline - baseline		SSVITempS2[i][17] = SSVITempS2[i][2] - SSVITempS1[i][2]		//delta (step-baseline) - delta (step - baseline)		SSVITempS2[i][18] = SSVITempS2[i][2] / SSVITempS1[i][2]		//delta (step-baseline) / delta (step - baseline)		SSVITempS2[i][19] = SSVITempS2[i][12] - SSVITempS1[i][12]		//delta (peak-baseline) - delta(peak - baseline)			SSVITempS2[i][20] = SSVITempS2[i][12] / SSVITempS1[i][12]		//delta (peak-baseline) / delta(peak - baseline)		SSVITempS2[i][21] = SSVITempS2[i][15] - SSVITempS1[i][15]		//time to peak - time to peak			SSVITempS2[i][22] = SSVITempS2[i][15] / SSVITempS1[i][15]		//time to peak / time to peak		SSVITempS2[i][23] = SSVITempS2[i][9] - SSVITempS1[i][9]		//tau - tau		SSVITempS2[i][24] = SSVITempS2[i][9] - SSVITempS1[i][9]		//tau - tau			//aditional info			SSVITempS2[i][25] = stepStartX		SSVITempS2[i][26] = peakLoc		//save both waves appropriately			endfor	//save waves	Duplicate/O SSVITempS1, $s1FinalName	Note $s1FinalName, S1NoteString + commandNoteString	Duplicate/O SSVITempS2, $s2FinalName	Note $s2FinalName, S2NoteString + commandNoteString	KillWaves/Z SSVITempS1, SSVITempS2, coefWave, W_fitconstants, rInSSVIOutputTemp	displayVISSParamsWaves(s1FinalName, s2FinalName)endfunction displayVISSParamsWaves(s1ParamsRef, s2ParamsRef)	String s1ParamsRef, s2ParamsRef		Duplicate/O $s1ParamsRef, s1ParamsDisplayTemp	Duplicate/O $s2ParamsRef, s2ParamsDisplayTemp		String s1fitAppendString = "_VS1F"	String s2fitAppendString = "_VS2F"		String s1TraceRecogString = "*" + StringFromList(0,getFileNameFromWaveName(s1ParamsRef,1),";") + "*AD2"	String s2TraceRecogString =  "*" + StringFromList(0,getFileNameFromWaveName(s2ParamsRef,1),";") +  "*AD0"	String stimTraceRecogString =  "*" + StringFromList(0,getFileNameFromWaveName(s2ParamsRef,1),";") +  "*AD3"	String s1TraceList = WaveList(s1TraceRecogString, ";", "TEXT:0")	String s2TraceList = WaveList(s2TraceRecogString, ";", "TEXT:0") 	String stimTraceList = WaveList(stimTraceRecogString, ";", "TEXT:0") 		String expFitWinName = s1ParamsRef + "_FIT"	String genOutDisplayWinName = s1ParamsRef + "_GDO"		//for general display zoom out	String genInDisplayWinName = s1ParamsRef + "_GDI"		//for general display zoom in		if (WinType(expFitWinName) > 0)		killWindow $expFitWinName	endif	if (WinType(genOutDisplayWinName) > 0)		killWindow $genOutDisplayWinName	endif	if (WinType(genInDisplayWinName) > 0)		killWindow $genInDisplayWinName	endif		Display/N=$expFitWinName	ModifyGraph expand=1.5	Display/N=$genOutDisplayWinName	ModifyGraph expand=1.5	Display/N=$genInDisplayWinName	ModifyGraph expand=1.5	Variable bottomOutStart = 0.6, bottomOutEnd = 4.5, bottonInStart = 1.3, bottomInEnd = 1.6, bottomOutScaleBarSize=.5, bottomInScaleBarSize=.05	Make/O/T/N=(ItemsInList(s1TraceList,";")) dataDisplayRowsListS1		Make/O/T/N=(ItemsInList(s1TraceList,";")) dataDisplayRowsListS2//	Make/O/T/N=(ItemsInList(s1TraceList,";")) dataDisplayRowsListStim			Variable i; String currS1Ref, currS2Ref, currStimRef, currS1SaveName, currS2SaveName//	for (i=0;i<ItemsInList(s1TraceList,";"); i+=1)	for (i=0;i<ItemsInList(s1TraceList,";"); i+=1)		currS1Ref = StringFromList(i, s1TraceList, ";")		currS2Ref = StringFromList(i, s2TraceList, ";")		currStimRef = StringFromList(i, stimTraceList, ";")		dataDisplayRowsListS1[i]  = currS1Ref		dataDisplayRowsListS2[i]  = currS2Ref	//	dataDisplayRowsListStim[i] =  currStimRef		Duplicate/O/R=(s1ParamsDisplayTemp[i][25], s1ParamsDisplayTemp[i][26]) $currS1Ref, currS1Fit		Duplicate/O/R=(s2ParamsDisplayTemp[i][25], s2ParamsDisplayTemp[i][26]) $currS2Ref, currS2Fit		//make and display curve fits		currS1Fit = 0		currS2Fit = 0		currS1Fit = s1ParamsDisplayTemp[i][7] + s1ParamsDisplayTemp[i][8]*exp(-(x-s1ParamsDisplayTemp[i][10])/s1ParamsDisplayTemp[i][9]) 		currS2Fit = s2ParamsDisplayTemp[i][7] + s2ParamsDisplayTemp[i][8]*exp(-(x-s2ParamsDisplayTemp[i][10])/s2ParamsDisplayTemp[i][9]) 		currS1SaveName = currS1Ref + s1fitAppendString		currS2SaveNAme = currS2Ref + s2fitAppendString		Duplicate/O currS1Fit, $currS1SaveName		Duplicate/O currS2Fit, $currS2SaveName		AppendToGraph/W=$expFitWinName/L=left0/C=(0,0,0) $currS1Ref  //black		AppendToGraph/W=$expFitWinName/L=left0/C=(65280,0,0) $currS1SaveName //red		ModifyGraph/W=$expFitWinName lsize($currS1SaveName) = 2, lstyle($currS1SaveName) =11		AppendToGraph/W=$expFitWinName/L=left0/C=(0,039168,0)   $currS2Ref		//green		AppendToGraph/W=$expFitWinName/L=left0/C= (0,0,52224)  $currS2SaveName //blue		ModifyGraph/W=$expFitWinName lsize($currS2SaveName) = 2, lstyle($currS2SaveName) = 11					//display traces at various windows		AppendToGraph/W=$genOutDisplayWinName/L=leftOut/B=BottOut/C=(0,0,0) $currS1Ref  //black		AppendToGraph/W=$genOutDisplayWinName/L=leftOut/B=BottOut/C=(0,039168,0)   $currS2Ref		//green		AppendToGraph/W=$genOutDisplayWinName/L=leftStim/B=BottOut/C=(0,0,0)    $currStimRef		//green						AppendToGraph/W=$genInDisplayWinName/L=leftIn/B=BottIn/C=(0,0,0) $currS1Ref  //black		AppendToGraph/W=$genInDisplayWinName/L=leftIn/B=BottIn/C=(0,039168,0)   $currS2Ref		//green		AppendToGraph/W=$genInDisplayWinName/L=leftStim/B=BottIn/C=(0,0,0)    $currStimRef		//green			endfor	ModifyGraph/W=$expFitWinName lblPos(left0)=51, freePos(left0)=0	ModifyGraph/W=$genOutDisplayWinName lblPos(leftOut)=51, freePos(leftOut)=0, lblPos(leftStim)=51, freePos(leftStim)=0, freePos(BottOut) = 20		//positive free pos puts outside window	ModifyGraph/W=$genInDisplayWinName lblPos(leftIn)=51, freePos(leftIn)=0, lblPos(leftStim)=51, freePos(leftStim)=0, freePos(BottIn) = 20	ModifyGraph/W=$genOutDisplayWinName axisEnab(leftStim)={0.,0.2}, axisEnab(leftOut)={0.22,1}		ModifyGraph/W=$genInDisplayWinName axisEnab(leftStim)={0.,0.2}, axisEnab(leftIn)={0.22,1}				setAxis/W=$genOutDisplayWinName BottOut, bottomOutStart, bottomOutEnd	setAxis/W=$genInDisplayWinName BottIn, bottonInStart, bottomInEnd	//	getAxis/W=$genOutDisplayWinName BottOut	ModifyGraph/W=$genOutDisplayWinName freePos(BottOut) = 20, tick(BottOut) = 3, noLabel(BottOut) = 2//	getAxis/W=$genOutDisplayWinName leftOut//	Print V_min	Variable scaleBarYPos = -0.07	setDrawEnv/W=$genOutDisplayWinName xcoord=BottOut, yCoord=leftOut, lineThick=2; DelayUpdate	DrawLine/W=$genOutDisplayWinName bottomOutEnd-(2*bottomOutScaleBarSize),scaleBarYPos,bottomOutEnd-(bottomOutScaleBarSize),scaleBarYPos; DelayUpdate//	DrawText/W=$genOutDisplayWinName bottomOutEnd-(2*bottomOutScaleBarSize), scaleBarYPos, num2str(bottomOutScaleBarSize) + " s"	ModifyGraph/W=$genInDisplayWinName freePos(BottIn) = 20, tick(BottIn) = 3, noLabel(BottIn) = 2	ModifyGraph/W=$genInDisplayWinName freePos(BottIn) = 20, tick(BottIn) = 3, noLabel(BottIn) = 2//	GetAxis/W=$genInDisplayWinName leftIn	 scaleBarYPos = -0.1	setDrawEnv/W=$genInDisplayWinName xcoord=BottIn, yCoord=leftIn, lineThick=2; DelayUpdate	DrawLine/W=$genInDisplayWinName bottomInEnd-(2*bottomInScaleBarSize),scaleBarYPos,bottomInEnd-(1*bottomInScaleBarSize),scaleBarYPos; DelayUpdate	//	DrawText/W=$genInDisplayWinName bottomOutEnd-(1.5*bottomInScaleBarSize), scaleBarYPos, num2str(bottomInScaleBarSize) + " s"			//amplitude	String ssAmpSSVIWinName = s1ParamsRef + "_SSA"	if (WinType(ssAmpSSVIWinName) > 0)		killWindow $ssAmpSSVIWinName	endif	Display/N=$ssAmpSSVIWinName 		ModifyGraph expand=1.5	AppendToGraph/W=$ssAmpSSVIWinName/L=absDeltaVss/C=(0,0,0) $s1ParamsRef[][2] vs $s1ParamsRef[][1]	AppendToGraph/W=$ssAmpSSVIWinName/L=absDeltaVss/C=(0,039168,0) $s2ParamsRef[][2] vs $s2ParamsRef[][1]		AppendToGraph/W=$ssAmpSSVIWinName/L=absDeltaVp/C=(0,0,0) $s1ParamsRef[][12] vs $s1ParamsRef[][1]	AppendToGraph/W=$ssAmpSSVIWinName/L=absDeltaVp/C=(0,039168,0) $s2ParamsRef[][12] vs $s2ParamsRef[][1]		AppendToGraph/W=$ssAmpSSVIWinName/L=DeltaDeltaV/C=(0,0,52224) $s2ParamsRef[][17] vs $s2ParamsRef[][1]	//in blue: ss amp - s amb	AppendToGraph/W=$ssAmpSSVIWinName/L=DeltaDeltaV/C=(65280,0,0) $s2ParamsRef[][19] vs $s2ParamsRef[][1]	//in red: peak amp - peak amp				ModifyGraph/W=$ssAmpSSVIWinName lblPos(absDeltaVss)=51, freePos(absDeltaVss)=0,  lblPos(absDeltaVp)=51, freePos(absDeltaVp)=0,  lblPos(DeltaDeltaV)=51, freePos(DeltaDeltaV)=0	ModifyGraph/W=$ssAmpSSVIWinName axisEnab(absDeltaVss)={0,0.38}, axisEnab(absDeltaVp)={.4,0.78} , axisEnab(DeltaDeltaV)={0.8,1}		//time to peak	String peakTimeSSVIWinName = s1ParamsRef + "_SPT"		//SS Peak time	if (WinType(peakTimeSSVIWinName) > 0)		killWindow $peakTimeSSVIWinName	endif	Display/N=$peakTimeSSVIWinName 		ModifyGraph expand=1.5	AppendToGraph/W=$peakTimeSSVIWinName/L=timeToPeakL/C=(0,0,0) $s1ParamsRef[][15] vs $s1ParamsRef[][1]	AppendToGraph/W=$peakTimeSSVIWinName/L=timeToPeakL/C=(0,039168,0) $s2ParamsRef[][15] vs $s2ParamsRef[][1]		AppendToGraph/W=$peakTimeSSVIWinName/L=DeltaTimeToPeakL/C=(0,039168,0) $s2ParamsRef[][21] vs $s2ParamsRef[][1]				ModifyGraph/W=$peakTimeSSVIWinName lblPos(timeToPeakL)=51, freePos(timeToPeakL)=0,  lblPos(DeltaTimeToPeakL)=51, freePos(DeltaTimeToPeakL)=0	ModifyGraph/W=$peakTimeSSVIWinName axisEnab(timeToPeakL)={0,0.6}, axisEnab(DeltaTimeToPeakL)={.62,1}			String paramsDisplayTableName = s1ParamsRef + "_T"	if (WinType(paramsDisplayTableName) > 0)		killWindow $paramsDisplayTableName	endif		String dataDisplayRowsListS1Name = s1ParamsRef + "_TR" //for table rows	String dataDisplayRowsListS2Name = s2ParamsRef + "_TR"	Duplicate/O dataDisplayRowsListS1, $dataDisplayRowsListS1Name	Duplicate/O dataDisplayRowsListS2, $dataDisplayRowsListS2Name			Edit/K=1/N=$paramsDisplayTableName $dataDisplayRowsListS1Name, $s1ParamsRef, $dataDisplayRowsListS2Name, $s2ParamsRef			KillWaves/Z s1ParamsDisplayTemp, s2ParamsDisplayTemp, currS1Fit, currS2Fitend//returns wave of 0=Resistance, 1=delta current 2 = delta voltage, 3 =baseline  current, 4 = baseline voltage, 5 = step current, 6 = step voltagefunction/S analysis_calcInputRes(currentWaveRef, voltageWaveRef, baselineStartX, baselineEndX, stepStartX, stepEndX, outputRef)	String currentWaveRef, voltageWaveRef, outputRef; Variable baselineStartX, baselineEndX, stepStartX, stepEndX		Make/O/D/N=7 inputResTempWave	inputResTempWave[3] = mean($currentWaveRef, baselineStartX, baselineEndX)			//baseline current  3	inputResTempWave[4] = mean($voltageWaveRef, baselineStartX, baselineEndX)			//baseline voltage  4	inputResTempWave[5] = mean($currentWaveRef, stepStartX, stepEndX)					//step current  5	inputResTempWave[6] = mean($voltageWaveRef, stepStartX, stepEndX)					//step voltage  6	inputResTempWave[1] = inputResTempWave[5]-inputResTempWave[3]					//delta current 1	inputResTempWave[2] = inputResTempWave[6]-inputResTempWave[4]					//delta voltage  2	inputResTempWave[0] = inputResTempWave[2]/inputResTempWave[1]					//input resistance  0		Duplicate/O inputResTempWave, $outputRef	KillWaves/Z inputResTempWave	return outputRefend//returns a string (list) with file name;waveType, semi-colon delimited, where file type is a single character 0 = native, 1= multisweep average, or 2= multifile averagefunction/S getFileNameFromWaveName(wName, prefixOnly)  	String wName; Variable prefixOnly	//for prefix only, instead of fileName, will return just G15112200 or equivalent, without file numbers		//types of file names: G15112200_0000_ (native) or S000111AD0 (multisweep average) or G15112200_000111_ (multi-file average). Same from this prefix: G151122_0000	Variable endNameIndex	Variable waveTypeNum	if (stringmatch(wName[2,strlen(wName)-7],"*S*"))		//search for an S in wName but ignore first two chars incase these are initials, also last 6 case funky endings (should be garaunteed at least 6 trailing characters)		waveTypeNum = 2	//multifile average with form S000111....		endNameIndex = strsearch(wName,"S",2) - 1 //find S index and then back up one for last char of file name		If(prefixOnly)			return wName[0,endNameIndex] + ";" + num2str(waveTypeNum)				endif		return wName[0,endNameIndex+7] + ";" + num2str(waveTypeNum)		//for whole file name, returns filePrefix+S+000111	endif	Variable firstDashIndex = strsearch(wName,"_",0)		//find first _ index	Variable secondDashIndex = strsearch(wName,"_",firstDashIndex+1)	//start from after first _ index and look for next dash	if (firstDashIndex + 5 == secondDashIndex)			//then form is _0000_ not  _000111_		waveTypeNum = 0		//native file name	else		waveTypeNum = 1		//multisweep average	endif	if (prefixOnly)		return wName[0,firstDashIndex-1] + ";" + num2str(waveTypeNum)	endif	return wName[0,secondDashIndex-1] + ";" + num2str(waveTypeNum)end//1 for fileNum, 2 for sweepNum, 3 for chStrfunction text_getInfoFromWaveName_V(inName,itemNum)	String inName; Variable itemNum		if (itemNum < 1)		return 0	endif		String outStr = text_getInfoFromWaveName_S(inName, itemNum)		Variable out		if (itemNum == 3)				//channel, remove AD		outStr = ReplaceString("AD",outStr,"")	endif		out = str2num(outStr)		if (itemNum == 2)		//sweepNum being returned, subtract 1 so that sweep numbers go from 0 to N -1 for N sweeps (naming by bruxton is unfortunately 1 to N)		out -=1	endif		return outend//0 for cellName 1 for fileNum, 2 for sweepNum, 3 for chStr//4 for "signature" (prefix letter(s)), 5-8 for year, month, day, cell #//9+ for longer portion from start of name: 9 = cellName_fileNum//10 = cellName_fileNum_sweepNum, 11 = cellName_fileNum_sweepNum_chanStrfunction/S text_getInfoFromWaveName_S(inName, itemNum_maxOf11, [saveRefForAllInfo])	String inName; Variable itemNum_maxOf11	String saveRefForAllInfo	//optionally pass to save all name components		String temp,cellName, fileNumAsStr, sweepNumAsStr, chStr	Make/O/T/N=(12) getInfoFromWaveName_S_temp		if (stringmatch(inName[1,inf],"*S*"))		//likely indicates average wave..result will be as if the first sweep in the average was passed			String sweepStartAndEndNumAsStr		temp = ReplaceString("S", inName, " ")		temp = ReplaceString("_", temp, " ")		temp = ReplaceString("AD", temp, " ")		sscanf temp, "%s %s %s %s", cellName, fileNumAsStr, sweepStartAndEndNumAsStr, chStr		sweepNumAsStr = sweepStartAndEndNumAsStr[0,2]		chStr = "AD" + chStr				else				temp = ReplaceString("_", inName, " ")	//replace "_" with " " which works with sscanf		sscanf temp, "%s %s %s %s", cellName, fileNumAsStr, sweepNumAsStr, chStr		endif		getInfoFromWaveName_S_temp[0] = cellName	getInfoFromWaveName_S_temp[1] = fileNumAsStr	getInfoFromWaveName_S_temp[2] = sweepNumAsStr	getInfoFromWaveName_S_temp[3] = chStr		//decompose cell name	//first find the start of the numeric portion of the cell name (to differentiate it from the 1 to 2 letter "signature" e.g. G15121402, we want to find the index of the leftmost 1	Variable i; String cellNameTemp = cellName; Variable currCharVal	for (i=0;i<strlen(cellNameTemp);i+=1)		sscanf cellNameTemp[i], "%c", currCharVal		if (text_asciiIsNumber(currCharVal))			break		//leaves the loop with i = index of first numeric value		endif	endfor			getInfoFromWaveName_S_temp[4] = cellName[0,i-1]		//"signature" portion, i is index of first numeric value. Usually cellName[0,0] which returns for example "G"	getInfoFromWaveName_S_temp[5] = cellName[i,i+1]		//yearStr	getInfoFromWaveName_S_temp[6] = cellName[i+2,i+3]		//monthStr	getInfoFromWaveName_S_temp[7] = cellName[i+4, i+5]		//dayStr	getInfoFromWaveName_S_temp[8] = cellName[i+6,i+7]		//cell # string		//elaborations	getInfoFromWaveName_S_temp[9] = getInfoFromWaveName_S_temp[0] + "_" + getInfoFromWaveName_S_temp[1]	getInfoFromWaveName_S_temp[10] = getInfoFromWaveName_S_temp[9] + "_" + getInfoFromWaveName_S_temp[2]	getInfoFromWaveName_S_temp[11] = getInfoFromWaveName_S_temp[10] + "_" + getInfoFromWaveName_S_temp[3]			if (!ParamIsDefault(saveRefForAllInfo) && (strlen(saveRefForAllInfo) != 0) )		Duplicate/O getInfoFromWaveName_S_temp, $saveRefForAllInfo	endif		String outStr = getInfoFromWaveName_S_temp[itemNum_maxOf11]			if (itemNum_maxOf11 < DimSize(getInfoFromWaveName_S_temp,0))		outStr = getInfoFromWaveName_S_temp[itemNum_maxOf11]		else		outStr = getInfoFromWaveName_S_temp[DimSize(getInfoFromWaveName_S_temp,0)-1]		//default to return full name (should be equal to inName)	endif	KillWaves/Z getInfoFromWaveName_S_temp	return outStrendfunction/S text_getCellNumFromWaveName(str)	String str		Variable firstScoreLoc=strsearch(str,"_",0)		return str[firstScoreLoc-2,firstScoreLoc-1]	endfunction text_asciiIsNumber(charVal)	Variable charVal		Variable asciiNumsStart = 48	//pos of first number in ascii table (0)	Variable asciiNumsEnd = 57	//pos of last number in acii table (9)		return ( (charVal >= asciiNumsStart) && (charVal <= asciiNumsEnd) ) endfunction text_asciiIsAlphabetical(charVal)	Variable charVal		Variable asciiFirstUpperCase = 65	//A	Variable asciiLasttUpperCase = 90	//Z	Variable asciiFirstLowerCase = 97	//a	Variable asciiLastLowerCase = 122//z		return ( (charVal >= asciiFirstUpperCase) && (charVal <= asciiLasttUpperCase) ) || ( (charVal >= asciiFirstLowerCase) && (charVal <= asciiLastLowerCase) ) end///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////TRACE AVERAGING//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////function avgSweepsByColRowSels()	WAVE waveListSelListByNums	WAVE/T waveListListWave		Variable fileNameEnd = 11//13			//numpnts in file name string up to the end of the file name index, e.g. G14102203_0000 = 13, G141022_0000 = 11	Variable sourceNameLength = 3	//numpnts for source name, e.g. AD3 = 3		Variable currentCol, tempRowIndex; String avgName, tempWaveRef	for (currentCol=0;currentCol<DimSize(waveListListWave,1);currentCol+=1)		avgName = "S"			//S will signify sweep averages		//get the sweep nums for the first and last sweeps in this column 		tempRowIndex = waveListSelListByNums[0]		tempWaveRef = waveListListWave[tempRowIndex][currentCol]		avgName += getSweepNumAsText(tempWaveRef)		tempRowIndex = waveListSelListByNums[DimSize(waveListSelListByNums,0)-1]		tempWaveRef = waveListListWave[tempRowIndex][currentCol]		//build the name of the avg wave for saving the average		avgName += getSweepNumAsText(tempWaveRef)		avgName = tempWaveRef[0,fileNameEnd] + avgName + tempWaveRef[strlen(tempWaveRef)-sourceNameLength, strlen(tempWaveRef)-1]		avgTracesSelCol(currentCol, avgName)	endforendfunction avgCol(colNum)	Variable colnum	WAVE waveListSelListByNums	WAVE/T waveListListWave		Variable fileNameEnd = 11//13			//numpnts in file name string up to the end of the file name index, e.g. G14102203_0000 = 13, G141022_0000 = 11	Variable sourceNameLength = 3	//numpnts for source name, e.g. AD3 = 3		Variable currentCol, tempRowIndex; String avgName, tempWaveRef	currentCol = colNum		avgName = "S"			//S will signify sweep averages	//get the sweep nums for the first and last sweeps in this column 	tempRowIndex = waveListSelListByNums[0]	tempWaveRef = waveListListWave[tempRowIndex][currentCol]	avgName += getSweepNumAsText(tempWaveRef)	tempRowIndex = waveListSelListByNums[DimSize(waveListSelListByNums,0)-1]	tempWaveRef = waveListListWave[tempRowIndex][currentCol]	//build the name of the avg wave for saving the average	avgName += getSweepNumAsText(tempWaveRef)	avgName = tempWaveRef[0,fileNameEnd] + avgName + tempWaveRef[strlen(tempWaveRef)-sourceNameLength, strlen(tempWaveRef)-1]	avgTracesSelCol(currentCol, avgName)endfunction appendToWaveNames(matchStr, appendStr)	String matchStr, appendStr		String listTemp = wavelist(matchStr, ";","")		String currName, newName; Variable i	for (i=0;i<ItemsInList(listTemp,";");i+=1)		currName = stringfromlist(i,listTemp,";")		newName = currName + appendStr		Duplicate/O $currName, $newName		KillWaves $currName	endforendfunction displayWithSepAxes(matchStr, gName)	String matchStr,gName		String listTemp = WaveList(matchStr, ";","TEXT:0")	String axisNTemp, axisPrefix = "L_"	Variable i; String currRef	Display/K=1/N=$gName	for (i=0;i<ItemsInList(listTemp,";");i+=1)		currRef = StringFromList(i,listTemp,";")		axisNTemp = axisPrefix + currRef		if (wavemax($currRef) < 1)		//tries to avoid the light stimuli			AppendToGraph/L=$axisNTemp $currRef		endif	endforendfunction displayNOL(matchStr, gName)	String matchStr,gName		Variable padProportion		String listTemp = WaveList(matchStr, ";","TEXT:0")	Variable i; 	String currRef	for (i=0;i<ItemsInList(listTemp,";");i+=1)		currRef = StringFromList(i,listTemp,";")		if (wavemax($currRef) > 1)		//tries to avoid the light stimuli			listTemp = RemoveListItem(i, listTemp,";")			i-=1		//step back once since what should be next is now in the current position		endif	endfor	Variable numPlots = ItemsInList(listTemp,";")	Variable axisSteps = 1/numPlots	Variable axisHeight = axisSteps - (axisSteps * padProportion)		String axisNTemp, axisPrefix = "L_"		Variable currHeightStart = 0	Killwindowsbyname(gName + "*")	Display/K=1/N=$gName	for (i=0;i<numPlots;i+=1)		currRef = StringFromList(i,listTemp,";")		axisNTemp = axisPrefix + currRef			AppendToGraph/L=$axisNTemp $currRef			ModifygRaph axisEnab($axisNTemp) = {currHeightStart, currHeightStart + axisHeight}			currHeightStart += axisSteps	endfor	ModifyGraph freepos=0, lblpos = 52endfunction/S getWaveNameBySweeps(firstSweepRef, lastSweepRef)		//uses the file number from the first wave name passed, not the second 	//assumes standard sweep names of form G14001122_0000_[sweepNum] or similar (all numbers can vary in length), works by finding dashes	String firstSweepRef, lastSweepRef	Variable sourceNameLength = 3	//numpnts for source name, e.g. AD3 = 3		Variable firstDashIndex = strsearch(firstSweepRef,"_",0)		//find first _ index	Variable secondDashIndex = strsearch(firstSweepRef,"_",firstDashIndex+1)	//start from after first _ index and look for next dash		String finalName = StringFromList(0,getFileNameFromWaveName(firstSweepRef, 0),";")			//returns just the portion up to the first dash	finalName+= 	"S" + getSweepNumAsText(firstSweepRef) + getSweepNumAsText(lastSweepRef) 	finalName += firstSweepRef[strlen(firstSweepRef)-sourceNameLength, strlen(firstSweepRef)-1]	return finalName	endfunction halfMaxWidth(summaryRef)	String summaryRef		Variable baseStartX = xcsr(C)	Variable baseEndX = xcsr(D)	Variable peakX = xcsr(E)		String ref =  csrwave(C)	Duplicate/O $ref, halfMaxTemp		Variable baseMean = mean(halfMaxTemp, baseStartX, baseEndX)		Variable peakVal = halfMaxTemp(peakX)	Variable amplitude = peakVal - baseMean	Variable halfVal = peakVal - (amplitude/2)	FindLevel/R=(peakX, baseEndX) halfMaxTemp, halfVal 	//searches backwards from peak to baseline end	Variable risingHalfMaxX = V_LevelX	FindLevel/R=(peakX) halfMaxTemp, halfVal 	//searches forward from peak to end of wave	Variable fallingHalfMaxX = V_LevelX	Variable width = fallingHalfMaxX - risingHalfMaxX 		Print "ref...",ref + "; " + num2str(risingHalfMaxX) + "; " + num2str(fallingHalfMaxX) +"; " + num2stR(width)	if (WaveExists($summaryRef))		Duplicate/O/T $summaryRef, summaryTemp		Redimension/N=(DimSize(summaryTemp,0)+1,DimSize(summaryTemp,1)) summaryTemp		//add a row	else		Make/O/T/N=(1,5) summaryTempTemp		Duplicate/O/T summaryTempTemp, summaryTemp	endif	summaryTemp[DimSize(summaryTemp,0)-1][0] = ref	summaryTemp[DimSize(summaryTemp,0)-1][1] = num2str(baseMean)	summaryTemp[DimSize(summaryTemp,0)-1][2] = num2str(peakVal)	summaryTemp[DimSize(summaryTemp,0)-1][3] = num2str(amplitude)	summaryTemp[DimSize(summaryTemp,0)-1][4] = num2str(width)	Duplicate/O summaryTemp, $summaryRef	KillWaves halfMaxTemp, summaryTemp, summaryTempTemp	return widthendfunction/S getSweepNumAsText(waveRef)		//returns last 3 digits of sweep num as text. Always makes three digits. E.g. sweep 8 returns 008	String waveRef		Variable firstDashIndex = strsearch(waveRef,"_",0)		//find first _ index	Variable secondDashIndex = strsearch(waveRef,"_",firstDashIndex+1)	//start from after first _ index and look for next dash	Variable thirdDashIndex = strsearch(waveRef,"_",secondDashIndex+1)	//same for third dash	Variable sweepNumTemp = str2num(waveRef[secondDashIndex+1,thirdDashIndex-1])			//this should get rid of any preceding 0s		String sweepStringTemp = num2str(sweepNumTemp)										//this turns the number, now with no preceding 0s, into a string again																						//if # had 4 digits, it should just save that way	for (;strlen(sweepStringTemp) < 3;)														//this appends preceding 0s until we are at length 3 e.g. 1 = 001		sweepStringTemp = "0" + sweepStringTemp			endfor		return sweepStringTempendfunction avgTraces(waveListForAveraging, avgWaveOutputName)				//takes in two wave refs, one to a list of one or more waves and one to an output wave and computes the average of the wave named in the text wave, storing it in the placeholder	String waveListForAveraging, avgWaveOutputName			Duplicate/O/T/R=[][0] $waveListForAveraging, avgTracesWaveListTemp	Duplicate/O $avgTracesWaveListTemp[0], finalAvgWaveTemp	finalAvgWaveTemp  = 0		String noteTemp = "AVERAGED WAVE (N=" + num2str(DimSize(avgTracesWaveListTemp,0)) + ". WAVE Names =\r"		Variable i	for (i=0; i<numpnts(avgTracesWaveListTemp);i+=1)		Duplicate/O $avgTracesWaveListTemp[i], avgTracesCurrentWaveTemp		finalAvgWaveTemp += avgTracesCurrentWaveTemp		noteTemp += avgTracesWaveListTemp[i] +";\r"//		Print "in avgTraces (3.5): iteration = " + num2str(i) + ". waveLength = " + num2str(numpnts(avgTracesCurrentWaveTemp))	endfor	finalAvgWaveTemp /= numpnts(avgTracesWaveListTemp)		Duplicate/O finalAvgWaveTemp, $avgWaveOutputName	Note/K $avgWaveOutputName, noteTemp	KillWaves/Z finalAvgWaveTemp, avgTracesCurrentWaveTemp, avgTracesWaveListTempendfunction avgTracesCol(dummydummy, columnNum, avgWaveOutputName)		//takes in a wavelist ref of one wavelist with one or more columns and stores the avg in avgWaveOutputName	String dummydummy, avgWaveOutputName; variable columnNum		Print "avgTraces col (a) = " + dummydummy	Print "avgTraces col (b) = " + avgWaveOutputName	Duplicate/O/T $dummydummy, dummydummy2	Make/O/T/N=(DimSize(dummydummy2,0)) dummydummy3	dummydummy3[] = dummydummy2[p][columnNum]	Print "in avgTracesCol (1): " + dummydummy	Print "a",num2str(DimSize($dummydummy,0))+ " HERE!"	Print "b",num2str(DimSize(dummydummy3,0)) + " HERE2"	Print "dummydummy3",dummydummy3	avgTraces("dummydummy3", avgWaveOutputName)		KillWaves/Z avgTracesColListTemp, dummydummy2, dummydummy3endfunction avgTracesSelCol(columnNum, avgWaveOutputName)		//takes in a column number and generates avg of selected waves in column number, selected in wave list box, saves in refernce passed on avgWaveSaveRef 	Variable columnNum; String avgWaveOutputName 	WAVE waveListSelListByNums	WAVE/T waveListListWave		Make/O/T/N=(DimSize(waveListSelListByNums,0)) avgTracesSelColListTemp	avgTracesSelColListTemp = waveListListWave[waveListSelListByNums[p]][columnNum]	avgTraces("avgTracesSelColListTemp", avgWaveOutputName)		KillWaves/Z avgTracesSelColListTempend//function baselineSubtract(matchString, makeNewWaves, offsetToCsrB) //must select baseline region with two cursors. Function will start with wave on cursor A and subtract baseline from all waves with name matching matchstrfunction baselineSubtract(matchString, offsetToCsrB, yReset, useTNs)	String matchString; Variable yReset, offsetToCsrB, useTNs			//if makeNewWaves = 1 will save copy of background subtracted wave		//REMOVE TO USE	//Print "use subtract baseline unless you want to alter the actual waves. If you want to use this function delete return 0 after this text"	//return 0		Variable baseStartX = xcsr(a)	Variable baseEndX =  xcsr(b)	Variable xOffsetX = 0	if (offsetToCsrB)		xOffsetX = -xcsr(b)	endif		String listOfWavesForBSName = "listOfWavesForBS"		graph_getWaveList("", matchString, listOfWavesForBSName,useTNs)		//sets listOfWavesForBS as a reference to a text wave with references to matching waves displayd on top graph		WAVE/T listOfWavesForBS		Variable i,  baselineYLevel	if (yReset)		for (i=0;i<DimSize(listOfWavesForBS,0);i+=1)				ModifyGraph offset($listOfWavesForBS[i][1]) = {xOffsetX,0}		endfor	else		for (i=0;i<DimSize(listOfWavesForBS,0);i+=1)			baselineYLevel = mean($listOfWavesForBS[i],baseStartX, baseEndX)			ModifyGraph offset($listOfWavesForBS[i][1]) = {xOffsetX,-baselineYLevel}		endfor	endif	//	if (makeNewWaves ==1)//		for (i=0;i<DimSize(listOfWavesForBS,0);i+=1)//			subtractBaseline(listOfWavesForBS[i], baseStartX, baseEndX)//		endfor//	endif	KillWaves/Z listOfWavesForBS, baselineSubFromGraphTempWaveendfunction baseSub_GenUse(matchStr, reset, offsetToCsrB, useTNs, [xStart, xEnd, xOffset, useMinOrMax, rideAlongByOrderMatchStr, rideAlongByNameSub, winN,col]) //must select baseline region with two cursors. Function will start with wave on cursor A and subtract baseline from all waves with name matching matchstr	String matchStr; Variable offsetToCsrB, useTNs			//if makeNewWaves = 1 will save copy of background subtracted wave	Variable reset			//if 1, will change so that no baseline subtraction is performed	Variable xStart, xEnd		//optional input instead of cursors	Variable xOffset			//optional x offset to along with y offset from baseline sub; overrides "reset"	Variable useMinOrMax	//if 0, uses cursor averages. if -1, uses minimum in window, if 1, uses maximum in window. STILL TO BE IMPLEMENTED	String winN				//optionally pass winN, top win used by default if not passed	String rideAlongByOrderMatchStr	//optionally pass to baseline subtract additional waves in a paired fashion: for each wave found that matches matchStr, waves in the same index of the list of waves generated that matches rideAlongByOrderMatchStr will also be offset similarly	Variable col		//optionally put in one column			String rideAlongByNameSub		if (ParamIsDefault(winN) || (strlen(winN) == 0) )		winN = winname(0,1)		//topmost GRAPH	endif		if (strlen(matchStr) == 0)		//input of no matchStr is made to recognize all		matchStr = "*"	endif		Variable numRideAlongsByOrder = !ParamIsDefault(rideAlongByOrderMatchStr) ? ItemsInList(rideAlongByOrderMatchStr) : 0		//	if (numRideAlongsByOrder > 0)//		Make/O/T/N=(numRideAlongsByOrder) bs_rideAlongsLists//		bs_rideAlongsLists = ""//		bs_rideAlongsLists[p] = StringFromList(1, disp_getMatchingWvsAndTNsList(winN, StringFromList(p, rideAlongByOrderMatchStr), useTNs) , ":")		//	endif		//mutually exclusive by ride along by order	Variable numRideAlongsByName =  !ParamIsDefault(rideAlongByNameSub) ? ItemsInList(rideAlongByNameSub) : 0	//	Print "numRideAlongsByName = " +num2str( numRideAlongsByName)			Variable csrErrorCleared = 0	Variable baseStartX, baseEndX 	if (ParamIsDefault(useMinOrMax) || useMinOrMAx == 0)		if (ParamIsDefault(xStart))			baseStartX = xcsr(a, winN)			csrErrorCleared = (GetRTError(1) || csrErrorCleared) ?  1 : 0 		else			baseStartX = xStart		endif		if (ParamIsDefault(xEnd))			baseEndX =  xcsr(b, winN)			csrErrorCleared = (GetRTError(1) || csrErrorCleared) ?  1 : 0 		else			baseEndX = xEnd		endif	else		GetAxis/Q/W=$winN bottom		Variable winStart = V_min		Variable winEnd = V_max	endif		Variable xOffsetX = 0	if (offsetToCsrB)		xOffsetX = -xcsr(b,winN)	//	csrErrorCleared = (GetRTError(1) || csrErrorCleared) ?  1 : 0 	endif		if (!ParamIsDefault(xOffset))		xOffsetX = xOffset	endif		String listOfTraces = TraceNameList(winN, ";", 1)	Variable i,j,k		String matchingListParent = disp_getMatchingWvsAndTNsList(winN, matchStr, useTNs)	String listOfMatchingWaves = StringFromList(0, matchingListParent,":")	String listOfMatchingTraces = StringFromList(1, matchingListParent,":")			if (numRideAlongsByName > 0)		Make/O/T/N=(numRideAlongsByName) rideAlongByNameMatchList		//rideAlongByNameSub = ReplaceString("*",rideAlongByNameSub,"")		//remove semicolons		//list all waves that are potential name matches		rideAlongByNameMatchList[] = StringFromList(0, disp_getMatchingWvsAndTNsList(winN, StringFromList(p, rideAlongByNameSub) , 0 ),":")	else		killwaves rideAlongByNameMatchList	endif//	//	Print "listOfMatchingWaves = " + listOfMatchingWaves//	Print "listOfMatchingTraces = " + listOfMatchingTraces			Variable numTracesToBS = ItemsInList(listOfMatchingTraces)	String potentialMatchList, currRideAlongMatchStr, currMainWvName_mod, currRideAlongWvName, currRideAlongWvName_mod	Variable oneCol=!ParamIsDefault(col) && (numtype(col)==0)	Variable baselineYLevel, intialXOffset, intialYOffset	Variable listColToUseForWaveName = 0	Variable listColToUseForTraceName = 1	String offsetStr, info, currTraceName	String currWvRef	String currRideAlongTN	Variable rideAlongMatchStrNum	for (i=0;i<numTracesToBS;i+=1)		currTraceName = StringFromList(i, listOfMatchingTraces)		currWvRef = StringFromList(i, listOfMatchingWaves)		if (reset)			baselineYLevel = 0		else			if (ParamIsDefault(useMinOrMax) || useMinOrMAx == 0)				if ((numtype(baseStartX) == 2) || (numtype(baseEndX) == 2))		//if cursors have no value use whole trace					if (oneCol)						duplicate/o/r=[][col]/free $currWvRef,meanTempWv;redimension/n=(-1) meanTempWv						baselineYLevel = mean(meanTempWv)					else						baselineYLevel = mean($currWvRef)					endif				else					if (oneCol)						duplicate/o/r=[][col]/free $currWvRef,meanTempWv;redimension/n=(-1) meanTempWv						baselineYLevel = mean(meanTempWv,baseStartX,baseEndX)					else						baselineYLevel = mean($currWvRef,baseStartX, baseEndX)					endif				endif			else				info = TraceInfo(winN,currTraceName, 0)				offsetStr = StringByKey("offset(x)", info, "=")	// e.g., "{10,20}"				if (strlen(offsetStr) > 0)					sscanf offsetStr, "{%g,%g}", intialXOffset, intialYOffset					xOffsetX = reset ? 0 : intialXOffset				else					intialXOffset = 0					intialYOffset = 0					if (offsetToCsrB)						xOffsetX = -xcsr(b,winN)						csrErrorCleared = (GetRTError(1) || csrErrorCleared) ?  1 : 0 					else						xOffsetX = 0					endif				endif				WaveStats /Q /R = (winStart-intialXOffset, winEnd - intialXOffset )/Z $currWvRef				if (useMinOrMax < 0)		//baseline subtract to most negative peak					baselineYLevel = V_min				else						//baseline subtract to most positive peak					baselineYLevel = V_max				endif			endif		endif				ModifyGraph/W=$winN offset($currTraceName) = {xOffsetX,-baselineYLevel}				for (j=0;j<numRideAlongsByName;j+=1)			potentialMatchList = rideAlongByNameMatchList[j]			currRideAlongMatchStr = ReplaceString("*",StringFromList(j, rideAlongByNameSub),"")						//remove asteriks from ride along matchstring			currMainWvName_mod = ReplaceString(ReplaceString("*",matchStr,""), currWvRef, "")			//remove matchStr from currWvName, ignoring any astericks			for (k=0;k<ItemsInList(potentialMatchList);k+=1)				currRideAlongWvName = StringFromList(k, potentialMatchList)				currRideAlongWvName_mod = ReplaceString(currRideAlongMatchStr, currRideAlongWvName, "")	//remove rideAlongMatchStr from potential wave name				if (stringmatch(currMainWvName_mod,  currRideAlongWvName_mod))	//if these are a match after removal, then treat the ride along in the same way as the main wave					ModifyGraph/W=$winN offset($currRideAlongWvName) = {xOffsetX,-baselineYLevel}				endif			endfor		endfor	//		for (rideAlongMatchStrNum=0;rideAlongMatchStrNum<numRideAlongsByOrder;rideAlongMatchStrNum+=1)		//no iterations for 0 ride alongs (default)//			currRideAlongTN = StringFromList(i, bs_rideAlongsLists[rideAlongMatchStrNum])//			Print "currRideAlongTN = " + currRideAlongTN + ". curr TN = " + currTraceName//			ModifyGraph/W=$winN offset($currRideAlongTN) = {xOffsetX,-baselineYLevel}//		endfor//		for (rideAlongMatchStrNum=0;rideAlongMatchStrNum<numRideAlongsByName;rideAlongMatchStrNum+=1)		//no iterations for 0 ride alongs (default)//			currRideAlongTN = StringFromList(i, bs_rideAlongsLists[rideAlongMatchStrNum])//			ModifyGraph/W=$winN offset($currRideAlongTN) = {xOffsetX,-baselineYLevel}//		endfor	endfor			if (csrErrorCleared)		Print "Cursor error cleared in baseSub_genUse(). Likely purposeful non-cursor user use, but printing in case of need to debug"	endif	KillWaves/Z listOfWavesForBS, baselineSubFromGraphTempWave,rideAlongByNameMatchList, bs_rideAlongsListsendfunction fullRange(traceMatchStr,startX,endX)	STring traceMatchStr; variable startX,endX		if (numtype(startX))		startX = 0	endif		if (numtype(endX))		endX = inf	endif		string winN=winname(0,1)	string list=listmatch(TraceNameList(winN, ";", 1),traceMatchStr)		Variable i,num=itemsinlist(list)	String trace,ref	double minval,maxval,range	for (i=0;i<num;i+=1)		trace=stringfromlist(i,list)		ref=nameofwave(TraceNameToWaveRef(winN,trace))		minVal=wavemin($ref,startX,endX)		maxVal=wavemax($ref,startX,endX)		range=maxVal-minVal		modifygraph/W=$winN muloffset($trace)={0,1/range},offset($trace)={0,-minVal/range}	endforend//kill any windows containing a wave, optionally checking with user before each windowkill call. //returns list of those waves that either could not be killed or were cancelled by user//if window containing wave still present after call to this function, then// strlen(disp_killWinsWithWave()) > 0 will be truefunction/S disp_killWinsWithWave(wvMatchStr,promptUserBeforeKill,killMatchingWvsAfter)	String wvMatchStr		//match string for waves to kill	Variable promptUserBeforeKill		//pass to bring each window to top then prompt to check with user if kill ok	Variable killMatchingWvsAfter		//attempts to kill matching waves after killing all windows	Variable userPromptDefault = 1		//1 for poised to kill window, 0 for not	String listOfWinsWithWv = disp_getWinListForWv(wvMatchStr)//	Print "listOfWinsWithWv",listOfWinsWithWv	String win, killFails="", killCancels="", killSuccesses=""	variable i	if (promptUserBeforeKill)		Variable reallyKillWindow		//variable to prompt		for (i=0;i<ItemsInList(listOfWinsWithWv);i+=1)			win = stringfromlist(i,listOfWinsWithWv)			setWindowPos_center(win, 1)				reallyKillWindow = userPromptDefault					prompt reallyKillWindow, "Really kill window="+win+ "? [1: yes. 0: no.]"			doprompt "disp_killWinsWithWave()", reallyKillWindow			if (reallyKillWindow)				killwindow/Z $win				if (Wintype(win))					killFails += win + ";"				else					killSuccesses += win + ";"				endif			else				killCancels += win + ";"			endif		endfor	else		for (i=0;i<ItemsInList(listOfWinsWithWv);i+=1)			win = stringfromlist(i,listOfWinsWithWv)			killwindow/Z $win			if (Wintype(win))				killFails += win + ";"			else				killSuccesses += win + ";"			endif		endfor	endif			if (killMatchingWvsAfter)		killWavesByName(wvMatchStr)	endif		return killFails + killCancelsend//center a window and optionally bring it to the topfunction setWindowPos_center(winN, bringToTop)	String winN	Variable bringToTop		if (!strlen(winN))		winN = winname(0,1)	endif		Variable left_center=250, top_center=200//where to set left and and top of window, size unchanged. 250,200 is good for my computer	Variable left_to_right, top_to_bottom		Variable left_original,top_original,right_original,bottom_original	//tracks original window pos		getWindowPos(left_original,top_original,right_original,bottom_original,winN=winN)		left_to_right = right_original - left_original	top_to_bottom = bottom_original-top_original	setWindowPos(left_center,top_center,left_center+left_to_right,top_center+top_to_bottom,winN=winN)		if (bringToTop)		dowindow/F $winN	endifendfunction/S disp_getWinListForWv(wvMatchStrOrList[forceWinTypes])		String wvMatchStrOrList	//match string for waves to list	Variable forceWinTypes		//optionally pass an input for winList wintypes, otherwise will list tables and graphs									//pass forceWinTypes=1 for graphs only forceWinTypes=2 for tables only, etc		Variable windowTypes = ParamIsDefault(forceWinTypes) ? 2^0 + 2^1 : forceWinTypes	//includes graphs, tables (I don't think any other can contain waves in a way that stops	//the wave from being killed, which is my main goal with this type of function	//skips layouts, notebooks, panels, procedures, etc.			String all_wins = winList("*",";","WIN:"+num2str(windowTypes))	Variable i,j; string matchStr, win, winWvList, out = ""		for (i=0;i<itemsinlist(wvMatchStrOrList);i+=1)		matchStr = stringfromlist(i,wvMatchStrOrList)				for (j=0;j<itemsinlist(all_wins);j+=1)						win = stringfromlist(j,all_wins)						winWvList = wavelist(matchStr,";","WIN:"+win)		//waves in curr window matching wvMatchStrOrList			if (ItemsInLisT(winWvList) > 0)				out += win + ";"			endif							endfor		endfor		return out	end//returns list of matching waves then matching traces, each list semicolon delimited, colon between the two lists. use StringFromList(0, listOut, ":") to get wave names, and StringFromList(1, listOut, ":") for trace namesfunction/S disp_getMatchingWvsAndTNsList(winN, matchStr, matchToTN_notToWvName)	String winN, matchStr	Variable matchToTN_notToWvName	//0 for matches to wave name regardless of each trace name, 1 for matches to each trace name regardless of wave name		if (strlen(matchStr) == 0)		matchStr = "*"	endif	String listOfTraces = TraceNameList(winN, ";", 1)	String listOfMatchingTraces="", listOfMatchingWaves=""		//list of traces and their associated wave (paired by order) 	Variable i	if (matchToTN_notToWvName)		listOfMatchingTraces = ListMatch(listOfTraces, matchStr)		listOfMatchingWaves =  text_getWvListFromTraceList(winN, listOfMatchingTraces)		//preserves order of trace list	else		//match to wave names not trace names		//check the name of the wave for each trace for a match. if a match, store the trace to be adjusted along with the wave for that trace. must include duplicates because each trace is unique, even if its underlying wave is not		String listOfWavesForAllTraces = text_getWvListFromTraceList(winN, listOfTraces), currWvRef		for (i=0;i<ItemsInList(listOfWavesForAllTraces);i+=1)			currWvRef = StringFromList(i,listOfWavesForAllTraces)			if (stringmatch(currWvRef, matchStr))				listOfMatchingWaves += currWvRef + ";"				listOfMatchingTraces += StringFromList(i, listOfTraces) + ";"			endif		endfor	endif		return listOfMatchingWaves + ":" + listOfMatchingTracesendfunction/S text_getWvListFromTraceList(winN, traceNames)	String winN, traceNames		String out = "", currTraceName	Variable i	for (i=0;i<ItemsInList(traceNames);i+=1)		currTraceName = StringFromList(i, traceNames)		out += NameOfWave(TraceNameToWaveRef(winN, currTraceName)) + ";"		endfor	return outend//usePeak: -1 for use negative going peak, 1 for using positive-going peak, 0 for not using peakfunction normAmp_byCsrMeans(matchString, offsetToCsrB, useTNs, baselineFromPeak, troughFromPeak) //must select baseline region with two cursors. Function will start with wave on cursor A and subtract baseline from all waves with name matching matchstr	String matchString; Variable offsetToCsrB, useTNs			//if makeNewWaves = 1 will save copy of background subtracted wave	Variable baselineFromPeak, troughFromPeak		Variable normalizedAmp = 1		//e.g. volt		if (strlen(matchString) == 0)		//input of no matchstring is made to recognize all		matchString = "*"	endif			if (troughFromPeak == 0)		Variable baseStartX = xcsr(a)		Variable baseEndX =  xcsr(b)	else		GetAxis/Q bottom		Variable startTroughFind = V_min		Variable endTroughFind = V_max	endif	if (baselineFromPeak == 0)		Variable stepStartX = xcsr(c)		Variable stepEndX = xcsr(d)	else		GetAxis/Q bottom		Variable startPeakFind = V_min		Variable endPeakFind = V_max	endif	Variable xOffsetX	if (offsetToCsrB)		xOffsetX = -xcsr(b)	endif			String listOfWaves = graph_getWaveList("", matchString, "",useTNs)		//sets listOfWavesForBS as a reference to a text wave with references to matching waves displayd on top graph		WAVE/T listOfWavesForBS	String currRef,  offsetStr, info	Variable i,  baselineYLevel, finalYLevel, amp, scaleFactor	Variable xOffsetFound, yOffsetFound, initialXOffsetX	for (i=0;i<ItemsInlist(listOfWaves);i+=1)		currRef = StringFromList(i, listOfWaves)			//	info = TraceInfo("", currRef, 0)	///	offsetStr = StringByKey("offset(x)", info, "=")	// e.g., "{10,20}"	//	if (strlen(offsetStr) > 0)	//		sscanf offsetStr, "{%g,%g}", xOffsetFound, yOffsetFound	//		xOffsetX = xOffsetFound	//		initialXOffsetX = xOffsetX	//	else			initialXOffsetX = 0			if (offsetToCsrB)				xOffsetX = -xcsr(b)			else				xOffsetX = 0			endif	//	endif						if (troughFromPeak == 0)			baselineYLevel = mean($currRef,baseStartX, baseEndX)		else			Wavestats/Q/R=(startTroughFind -initialXOffsetX, endTroughFind-initialXOffsetX) $currRef			if (troughFromPeak==-1)		//use negative-going peak				baselineYLevel = V_min			else				baselineYLevel = V_max			endif			endif						if (baselineFromPeak==0)			finalYLevel = mean($currRef,stepStartX, stepEndX)		else			Wavestats/Q/R=(startPeakFind-initialXOffsetX, endPeakFind-initialXOffsetX) $currRef			if (baselineFromPeak==-1)		//use negative-going peak				finalYLevel = V_min			else				finalYLevel = V_max			endif		endif//		Print "final Y level = " + num2str(finalYLevel) + " . baseline Y = " + num2str( baselineYLevel)		amp = finalYLevel  - baselineYLevel		scaleFactor = normalizedAmp/amp					ModifyGraph offset($currRef) = {xOffsetX,(-baselineYLevel)*scaleFactor}, muloffset($currRef) = {0, scaleFactor}	endfor	KillWaves/Z listOfWavesForBS, baselineSubFromGraphTempWave	SetAxis/A=2 leftendfunction resetOffsets(matchString) //must select baseline region with two cursors. Function will start with wave on cursor A and subtract baseline from all waves with name matching matchstr	String matchString				Variable reset			//if 1, will change so that no baseline subtraction is performed		Variable normalizedAmp = 1		//e.g. volt			if (strlen(matchString) == 0)		//input of no matchstring is made to recognize all		matchString = "*"	endif				String listOfWaves = graph_getWaveList("", matchString, "",0)		//sets listOfWavesForBS as a reference to a text wave with references to matching waves displayd on top graph		String currRef	Variable i,  baselineYLevel, finalYLevel, amp, scaleFactor	for (i=0;i<ItemsInlist(listOfWaves);i+=1)		currRef = StringFromList(i, listOfWaves)		ModifyGraph offset($currRef) = {0,0}, muloffset($currRef) = {0, 0}	endforendfunction zeroXAxisAtCursor(restore)	Variable restore 		Variable xOffsetX = -xcsr(A)	if (restore == 1)		xOffsetX = 0			//intended to allow one to put everything back to normal if a 1 is passed	endif	String listOfTracesToZeroName = "listOfTracesToZero"	graph_getWaveList("","*",listOfTracesToZeroName,1)	WAVE/T listOfTracesToZero		Variable i	for (i=0;i<DimSize(listOfTracesToZero,0);i+=1)		ModifyGraph offset($listOfTracesToZero[i][1]) = {xOffsetX,0}		//col 1 is trace ref rather than wave ref			endfor	KillWaves/Z listOfTracesToZeroendfunction/S graph_getWaveList(graphName, matchString, waveListRef, useTNs, [returnTNList])		//returns a reference to a text wave containing the names of waves who are displayed on the named graph (or "" for top graph) and also match matchString	String graphName, matchString, waveListRef								//returns string list, does not create wavelistRef if ref is "" (empty string)	Variable useTNs														//col 1 is wave name, col 2 is trace name	Variable returnTNList													//returns list of trace names instead of sweep names																			String traceList = TraceNameList(graphName, ";", 1)									Make/O/T/N=(1,2) matchingWavesOnGraph		String currentTraceString	String currentWaveName	String listout_wnames = "", listout_tnames = ""	Variable i, numMatchWavesFound = 0	for (i=0;i<ItemsInList(traceList,";");i+=1)		currentTraceString = StringFromList(i,traceList,";")		//currentTrace string may or may not be equal to wave name, TraceNameToWaveRef gives the actual wave name		Wave currentSubtractWave = TraceNameToWaveRef("", currentTraceString)		currentWaveName = NameOfWave(currentSubtractWave)		if ((stringmatch(currentWaveName,matchString) && (!useTNs)) || (stringmatch(currentTraceString,matchString) && useTNs))			numMatchWavesFound+=1			if (numMatchWavesFound>DimSize(matchingWavesOnGraph,0))				Redimension/N=(DimSize(matchingWavesOnGraph,0)+1,2) matchingWavesOnGraph		//redimension to add one row, keep column num the same			endif			matchingWavesOnGraph[DimSize(matchingWavesOnGraph,0)-1][0] = currentWaveName		//add wave name and trace name to last row			matchingWavesOnGraph[DimSize(matchingWavesOnGraph,0)-1][1] = currentTraceString			listout_wnames += currentWaveName + ";"			listout_tnames += currentTraceString + ";"		endif	endfor		if (strlen(waveListRef) > 0)		Duplicate/O matchingWavesOnGraph, $waveListRef	endif		KillWaves/Z matchingWavesOnGraph	//do not kill currentSubtractWave! This should only be a refence to a real data wave	if (ParamIsDefault(returnTNList))		return listout_wnames	endif	return listout_tnames	endfunction appendWaveListToGraph(graphName, waveListRef, vertAxisName, isLeft, bottomAxisName, TNPrefix, useWaveName)	String graphName, waveListRef, vertAxisName, bottomAxisName, TNPrefix; Variable isLeft, useWaveName	//will make TN = TNPrefix + waveName if useWaveName != 0		Duplicate/O/T/R=[][0] $waveListRef, waveListToPlotTemp		//copies just first column, so that if input is 2D (e.g. wave names first column trace names second), still works out ok	String TNTemp			if (strlen(bottomAxisName) < 1)		bottomAxisName = "bottom"	endif		Variable i		if (isLeft)		if (strlen(vertAxisName) < 1)			vertAxisName = "left"		endif		for (i=0;i<DimSize(waveListToPlotTemp,0);i+=1)			if (strlen(TNPrefix) > 0)				if (useWaveName)					TNTemp =TNPrefix + waveListToPlotTemp[i]				else					TNTemp = TNprefix + "_" + num2str(i)				endif			else				TNTemp = waveListToPlotTemp[i]			endif			AppendToGraph/W=$graphName/L=$vertAxisName/B=$bottomAxisName $waveListToPlotTemp[i]/TN=$TNTemp		endfor	else		if (strlen(vertAxisName) < 1)			vertAxisName = "right"		endif		for (i=0;i<DimSize(waveListToPlotTemp,0);i+=1)			if (strlen(TNPrefix) > 0)				TNTemp = TNPrefix + num2str(i)			else				TNTemp = waveListToPlotTemp[i]			endif			AppendToGraph/W=$graphName/L=$vertAxisName/B=$bottomAxisName $waveListToPlotTemp[i]		endfor		endifendfunction removeTracesFromGraph(graphName, matchStr)	String graphName, matchStr							//col 1 is wave name, col 2 is trace name																		//foot note why the hell am I using redimension instead of finding out the list length and making the output wave the proper length from the start?	String traceList = TraceNameList("", ";", 1)								//seriously I can't remember and there's probably no good reason		String currentTraceString	String matchingWaves = ";"	Variable i, numMatchWavesFound	for (i=0;i<ItemsInList(traceList,";");i+=1)		currentTraceString = StringFromList(i,traceList,";")		//currentTrace string may or may not be equal to wave name, TraceNameToWaveRef gives the actual wave name		if (stringmatch(currentTraceString,matchStr))			matchingWaves = AddListItem(matchingWaves, currentTraceString, ";")			numMatchWavesFound+=1			RemoveFromGraph/W=$graphName $currentTraceString		endif	endfor		Print "Removed: " + matchingWavesendfunction colorTraces_Multi(graphN, matchStr, startColor,opac)	String graphN, matchStr; Variable startColor	variable opac		if (strlen(graphN) < 1)		graphN = winname(0,1)	endif		if (strlen(matchStr) < 1)		matchStr = "*"	endif	String traceList = TraceNameList(graphN, ";", 1)										String currentTraceString	String matchingWaves = ";"	Variable i, numMatchWavesFound, currR, currG, currB,count=0	for (i=0;i<ItemsInList(traceList,";");i+=1)		currentTraceString = StringFromList(i,traceList,";")		//currentTrace string may or may not be equal to wave name, TraceNameToWaveRef gives the actual wave name		if (stringmatch(currentTraceString,matchStr))			vis_getColor(startColor+count, currR, currG, currB)			if (numtype(opac))				ModifyGraph/W=$graphN rgb($currentTraceString) = (currR, currG, currB)			else				ModifyGraph/W=$graphN rgb($currentTraceString) = (currR, currG, currB,opac)			endif			count+=1		endif	endforendfunction colorGraphTraces(graphName, matchStr, rVal, gVal, bVal, presetColor)	String graphName, matchStr; Variable rVal, gVal, bVal, presetColor		switch (presetColor)		case 0:			//standard red			rVal = 65280; gVal = 0; bVal = 0			break		case 1:			//black			rVal = 0; gVal = 0; bVal = 0; 			break		case 2: 			//grey			rVal = 21760; gVal = 21760; bVal = 21760			break		case 3:			//dark blue/green			rVal = 0; gVal = 35328; bVal = 35328			break		case 4:			//blue			rVal = 0; gVal = 12800; bVal = 52224			break		default:		//anything but these (e.g. -1) just keeps colors as input			break	endswitch																				String traceList = TraceNameList("", ";", 1)										String currentTraceString	String matchingWaves = ";"	Variable i, numMatchWavesFound	for (i=0;i<ItemsInList(traceList,";");i+=1)		currentTraceString = StringFromList(i,traceList,";")		//currentTrace string may or may not be equal to wave name, TraceNameToWaveRef gives the actual wave name		if (stringmatch(currentTraceString,matchStr))			ModifyGraph/W=$graphName rgb($currentTraceString) = (rVal, gVal, bVal)		endif	endforendfunction normalizeTraces(peakNotRange,[forceCol,axMatchStr])	Variable peakNotRange,forceCol		//forceCol to use, -1 for last col instead	String axMatchStr		graph_getWaveList("","*","listOfWavesInTrace",1)	WAVE/T listOfWavesInTrace		Variable i, minY, maxY, range,col	Make/O/D/N=(DimSize(listOfWavesInTrace,0)) mins,maxes		//D2 array, one row per wave, min = col 1, max = col 2	for (i=0;i<DimSize(listOfWavesInTrace,0);i+=1)		if (dimsize($listOfWavesInTrace[i][0],1) < 2)			mins[i] = wavemin($listOfWavesInTrace[i][0])			maxes[i]= wavemax($listOfWavesInTrace[i][0])		else			WAVE wv = $listOfWavesInTrace[i][0]			if (paramIsDefault(forceCol))				col =  finddimlabel(wv,1,"avg")				if (col < 0)					col = 0				endif			else				if (forceCol < 0)					col = dimsize(wv,1)-1				else					col = forceCol				endif			endif			wavestats/q/rmd=[][col] wv			mins[i] = V_min			maxes[i] = v_max		endif	endfor	minY = wavemin(mins)	maxY = wavemax(maxes)	range = maxY - minY		for (i=0;i<DimSize(listOfWavesInTrace,0);i+=1)		if (peakNotRange)			ModifyGraph  muloffset($listOfWavesInTrace[i][1])={0,1/(maxes[i])}		else			ModifyGraph  muloffset($listOfWavesInTrace[i][1])={0,1/(maxes[i]-mins[i])}//, offset($listOfWavesInTrace[i][1])={0,-mins[i]}		endif	endforend	function subtractBaseline(waveRef, baseStartX,baseEndX)	String waveRef; Variable baseStartX, baseEndX		String baselineSubtractAppendString = "_BS"		String finalName = waveRef + baselineSubtractAppendString		Duplicate/O $waveRef, subtractBaselineWaveTemp	Variable subtractedAmount = mean(subtractBaselineWaveTemp, baseStartX, baseEndX)	subtractBaselineWaveTemp -= subtractedAmount		Print "Baseline subtraction on "+ waveRef + ". Baseline determined in X range from: [ " + num2str(baseStartX)  + "," + num2str(baseEndX) +"]. Subtracted = " + num2str(subtractedAmount)		Duplicate/O subtractBaselineWaveTemp, $finalName	KillWaves/Z subtractBaselineWaveTempendfunction displayCellParamsCalcList()	if(WinType("cellParamsTable") != 0) 				KillWindow cellParamsTable	endif		WAVE/T cellParamsCalcList_ZZ, cellParamsCalcHeaderList_ZZ	Duplicate/O/T cellParamsCalcList_ZZ, cellParInNiceUnitsList_ZZ, cellParNiceUnitsUnitsList_ZZ	//new lists to hold waves for each cell params calc																//each of these lists holds a wave, header defines what parameters are stored in calcList wave																//calcList wave has actual cell params values, inNiceUnits has conversions performed below																//to units that we're used to for display, unitsList has the units corresponding with the converted values	Edit/K=1/N=cellParamsTable $cellParamsCalcHeaderList_ZZ[0]		//sets first column as variable names (will have to modify if ever there are cell params list with differeing headers in one experiment file	ModifyTable/W=cellParamsTable width(Point) = 0, width( $cellParamsCalcHeaderList_ZZ[0])=35		//width of point index (first) column, header (second) column	Variable i	for (i=0;i<numpnts(cellParamsCalcList_ZZ);i+=1)		AppendToTable/W=cellParamsTable $cellParamsCalcList_ZZ[i]		ModifyTable/W=cellParamsTable width($cellParamsCalcList_ZZ[i])=40		//width column 3				cellParInNiceUnitsList_ZZ[i] = "InNiceUnits" + cellParamsCalcList_ZZ[i]		Duplicate/O $cellParamsCalcList_ZZ[i], tempCalcInNiceUnits		tempCalcInNiceUnits[0] *= 10^-9			//Rseal, gigaohm		tempCalcInNiceUnits[1] *= 10^12			//sealLeak, pA		tempCalcInNiceUnits[2] *= 10^-6			//Rwc, Megaohm		tempCalcInNiceUnits[3] *= 10^12			//WCLeak, pA		tempCalcInNiceUnits[4] *= 10^-6			//Ra, Megaohm		tempCalcInNiceUnits[5] *= 10^-6			//Rm, Megaohm		tempCalcInNiceUnits[6] *= 10^12			//Cm, pF		tempCalcInNiceUnits[7] *= 10^3			//tau, ms		tempCalcInNiceUnits[8, numpnts(tempCalcInNiceUnits)] = NaN		//no need to convert the rest		Duplicate/O tempCalcInNiceUnits, $cellParInNiceUnitsList_ZZ[i]		AppendToTable/W=cellParamsTable $cellParInNiceUnitsList_ZZ[i]		ModifyTable/W=cellParamsTable width($cellParInNiceUnitsList_ZZ[i])=35	//width column 4 (nice units converted)		cellParNiceUnitsUnitsList_ZZ[i] = "UnitsStr" + cellParamsCalcList_ZZ[i]		Duplicate/O/T $cellParamsCalcHeaderList_ZZ[i], tempCalcUnits		//no real reason to use the header list, just assures correct units		tempCalcUnits[0] = "GigaOhms"		//Rseal, gigaohm		tempCalcUnits[1] = "pA" 	//sealLeak, pA		tempCalcUnits[2] = "MegaOhms"			//Rwc, Megaohm		tempCalcUnits[3] = "pA"		//WCLeak, pA		tempCalcUnits[4] = "MegaOhms"			//Ra, Megaohm		tempCalcUnits[5] = "MegaOhms"		//Rm, Megaohm		tempCalcUnits[6] = "pF"		//Cm, pF		tempCalcUnits[7] = "ms"			//tau, ms		tempCalcUnits[8, numpnts(tempCalcUnits)] = ""							Duplicate/O tempCalcUnits, $cellParNiceUnitsUnitsList_ZZ[i]		AppendToTable/W=cellParamsTable $cellParNiceUnitsUnitsList_ZZ[i]		ModifyTable/W=cellParamsTable alignment($cellParNiceUnitsUnitsList_ZZ[i])=0, width($cellParNiceUnitsUnitsList_ZZ[i])=40		//sets to left justify for column 5 and sets width column 5 (units str)		ModifyTable/W=cellParamsTable style=1 //puts in bold	endfor	ModifyTable/W=cellParamsTable size=4, showParts = (2^0+2^1+2^4+2^5+2^6)		//font size to 6		//show parts uses a bitwise parameter, those bits left out aren't shown 	KillWaves/Z tempCalcInNiceUnits, tempCalcUnitsendfunction appendToCellParamsCalcList(paramsWaveTemp, paramsHeaderWaveTemp)		//renames stores paramsWaveTemp and paramsHeaderWaveTemp in two wave lists	Wave paramsWaveTemp; Wave/T paramsHeaderWaveTemp		Print "paramsHeaderWaveTemp",paramsHeaderWaveTemp	String tempNameString ="TESTING" + "_ZZ", tempHeaderNameString = "TESTING" + "_HEADER_ZZ"		//appending _ZZ to things that must be saved	Variable numRows, currentRow		WAVE/T/Z cellParamsCalcList_ZZ, cellParamsCalcHeaderList_ZZ	if (WaveExists(cellParamsCalcList_ZZ) == 0)		//check whether a previous cellPArams has been appended		Make/O/T/N=1 cellParamsCalcList_ZZ, cellParamsCalcHeaderList_ZZ	else		numRows = numpnts(cellParamsCalcList_ZZ)		Redimension/N=(numRows + 1) cellParamsCalcList_ZZ, cellParamsCalcHeaderList_ZZ	endif		currentRow = numpnts(cellParamsCalcList_ZZ) - 1		//sets to new, open row		cellParamsCalcList_ZZ[currentRow] = tempNameString	cellParamsCalcHeaderList_ZZ[currentRow] = tempHeaderNameString	Duplicate/O paramsWaveTemp, $cellParamsCalcList_ZZ[currentRow] 	Duplicate/O paramsHeaderWaveTemp, $cellParamsCalcHeaderList_ZZ[currentRow] end /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////Noise analysis///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////function makeSTA(stimRef, signalRef)	String stimRef, signalRef		KillWaves/Z staStimTemp, staSignalTemp, currentStaTemp,  finalStaTemp		Duplicate/O $stimRef, staStimTemp	Duplicate/O $signalRef, staSignalTemp		Variable windowSize = 1		//in seconds, sets the length of the STA, just needs to be longer than the apparent integration tiime of the filter	Variable startTime = 20	Variable endTime = 48		Variable sampleRate = DimDelta(staSignalTemp, 0)	Variable windowSampleSize = windowSize / sampleRate	Variable startPoint = x2pnt(staSignalTemp, startTime)	Print "startPoint",startPoint	Variable endPoint = x2pnt(staSignalTemp,endTime)	Print "endPoint",endPoint	Print windowSampleSize,"windowSampleSize"		Duplicate/O/R=[0,windowSampleSize-1] staStimTemp, finalStaTemp, currentStaTemp	finalStaTemp = 0	currentStaTemp =0		Variable currentSampleNum, currentRespValue, i =0	for (currentSampleNum =startPoint ; currentSampleNum<endPoint; currentSampleNum+=5)		i+=1		Print "i",i//		currentStaTemp[0,] = staStimTemp[currentSampleNum-windowSampleSize +p]		Duplicate/O/R=[currentSampleNum-windowSampleSize, currentSampleNum] staStimTemp, currentStaTemp		currentRespValue = staSignalTemp[currentSampleNum]			currentStaTemp *= currentRespValue					//weights the current sta by the cells activity at the time immediately after		finalStaTemp[0,] = finalStaTemp[p] + currentStaTemp[p]										//adds the weighed sta to total 	endfor	finalStaTemp /= i															//makes finalStaTemp an average	KillWaves/Z staStimTemp, staSignalTemp, currentStaTempend/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////Chirp analysis/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////currently functioningfunction/S updatedChirpAnalysis(doOtherChirpAnalyses, chirpWinStartForFFT,chirpWinEndForFFT)		//order should be stimulus = col 1, soma = col 2, ped = col 3	Variable doOtherChirpAnalyses, chirpWinStartForFFT,chirpWinEndForFFT		WAVE waveListSelListByNums	WAVE/T waveListListWave		Variable numCycles =336		Variable saveExcisedAndFits = 0		if (DimSize(waveListListWave,1) != 3)		Print "Select a set or set(s) of 3 chirp waves: stimulus, site1 response, site2 response!"		return ""	endif		Variable numSelChirpSweeps = numpnts(waveListSelListByNums)	if (numSelChirpSweeps > 1)		Print "Just one chirp run for now please!"		return ""	endif		Variable selIndex = waveListSelListByNums[0]	String stimRef = waveListListWave[selIndex][0]	String somaRef = waveListListWave[selIndex][1]	String pedRef = waveListListWave[selIndex][2]		if(!doOtherChirpAnalyses)		return stimRef + ";" + somaRef + ";" + pedRef	endif 		analyzeChirpGeneral(waveListListWave[selIndex][0], numCycles,saveExcisedAndFits, "")	analyzeChirpGeneral(waveListListWave[selIndex][1], numCycles,saveExcisedAndFits, "")	analyzeChirpGeneral(waveListListWave[selIndex][2], numCycles,saveExcisedAndFits, "")		displayChirps(waveListListWave[selIndex][0], waveListListWave[selIndex][1],waveListListWave[selIndex][2],0,1)		//NOTE: smoothing e.g. smooth/B=5 3, fftMagWave can help these look better, not sure how legit it is to do though...	fftChirpAmplitudesNew(waveListListWave[selIndex][0],waveListListWave[selIndex][1],waveListListWave[selIndex][2], chirpWinStartForFFT, chirpWinEndForFFT)	return stimRef + ";" + somaRef + ";" + pedRefendfunction chF(somaFilterRef, pedFilterRef, doOtherChirpAnalyses)	String somaFilterRef, pedFilterRef	Variable doOtherChirpAnalyses		if (fio_checkGlobalFilePath())			//check path returns non-zero if there are any problems with symbolic path		Print "aborted in analysis_SSVI because file save path not set! Use fio_setDataSavePath()"		return 0	endif	SVAR/Z dataSavePathName				//this should be a global string with the name of the path that is set by fio_setDataSavePath()			Variable convolutionStartX = 0	Variable convolutionEndX = 9.7	Variable NLAnalysisStartX = 0.2	Variable numNonlinearityBins = 50		String refs = updatedChirpAnalysis(doOtherChirpAnalyses, NLAnalysisStartX, convolutionEndX)	String stimRef = stringFromList(0,refs,";")	String somaRef =  stringFromList(1,refs,";")	String pedRef =  stringFromList(2,refs,";")		//excise region and baseline subtract	Duplicate/O/R=(convolutionStartX,convolutionEndX) $stimRef, stimChirpPredTemp	Duplicate/O/R=(convolutionStartX,convolutionEndX) $somaRef, somaChirpPredTemp	Duplicate/O/R=(convolutionStartX,convolutionEndX) $pedRef, pedChirpPredTemp		Variable stimMean = mean(stimChirpPredTemp)	Variable somaMean = mean(somaChirpPredTemp)	Variable pedMean = mean(pedChirpPredTemp)		stimChirpPredTemp -= stimMean	somaChirpPredTemp -= somaMean		pedChirpPredTemp -= pedMean			//convolve to predict chirp based on filters	String somaChirpPredSN = stimRef + "CF1SP"		//chirp filter 1 soma predicted	String pedChirpPredSN = stimREf + "CF1PP"			//as above for ped	String somaChirpRealSN = stimRef + "CF1SR"		//chirp filter 1 soma real	String pedChirpRealSN = stimREf + "CF1PR"	String somaChirpBinnedSN = stimRef + "CF1SB"	//chirp filter 1 soma binned	String pedChirpBinnedSN = stimRef + "CF1PB"	//chirp filter 1 ped binned		convolution(somaFilterRef, "stimChirpPredTemp",somaChirpPredSN,"V")	convolution(pedFilterRef, "stimChirpPredTemp", pedChirpPredSN,"V")	Duplicate/O somaChirpPredTemp, $somaChirpRealSN	Note/K $somaChirpRealSN, note($somaRef) + " (Soma chirp Response Region excised for prediction by LN Model. Filter = " + somaFilterRef +". Vavg:" + num2str(somaMean) + ".);"	Duplicate/O pedChirpPredTemp, $pedChirpRealSN	Note/K $pedChirpRealSN, note($pedRef) + " (Ped chirp Response Region excised for prediction by LN Model. Filter = " + pedFilterRef +". Vavg:" + num2str(pedMean) + ".);"	//save results	Save/C/O/P=$dataSavePathName $somaChirpPredSN, $pedChirpPredSN , $somaChirpRealSN , $pedChirpRealSN , $somaChirpBinnedSN , $pedChirpBinnedSN		Note/K $somaChirpPredSN,  note($somaRef) + " (Soma chirp prediction by LN Model. Filter = " + somaFilterRef +". Vavg:" + num2str(somaMean) + ".);"	Note/K $pedChirpPredSN,  note($pedRef) + " (Ped chirp prediction by LN Model. Filter = " + pedFilterRef +". Vavg:" + num2str(pedMean) + ".);"				//test convolution results	Variable pearsonSoma = analyzeNLRange(somaChirpRealSN, somaChirpPredSN, somaChirpBinnedSN,NLAnalysisStartX, convolutionEndX, numNonlinearityBins,0)	Variable pearsonPed = analyzeNLRange(somaChirpRealSN, somaChirpPredSN, pedChirpBinnedSN,NLAnalysisStartX, convolutionEndX,numNonlinearityBins,0)	Note $somaChirpBinnedSN, "PEARSONR: " + num2str(pearsonSoma) + ";"	Note $pedChirpBinnedSN, "PEARSONR: " + num2str(pearsonPed) + ";"	//display results	KillWindowsByName("*" + stimRef + "CF1" + "*")		//overlay	Display/K=1/N=$somaChirpPredSN 	AppendToGraph/L=Lsoma/C=(0,0,0) $somaChirpRealSN, $somaChirpPredSN	ModifyGraph rgb($somaChirpPredSN) = (0,12800,52224)	AppendToGraph/L=Lped/C=(0,0,0) $pedchirpRealSN, $pedChirpPredSN	ModifyGraph rgb($pedChirpPredSN) = (0,12800,52224)		Make/O/D/N=5 dummyChirpPred	AppendToGraph/L=Ldummy dummyChirpPred	ModifyGraph axisEnab(Lsoma)={0,0.48},axisEnab(Lped)={0.52,1},freePos(Lsoma)=0;DelayUpdate	ModifyGraph freePos(Lped)=0	ModifyGraph fSize(Lsoma)=14,fSize(bottom)=14,fSize(Lped)=14,lblPos(Lsoma)=52;DelayUpdate	ModifyGraph lblPos(Lped)=52,lblPos(Ldummy)=50,lblLatPos(Ldummy)=20;DelayUpdate	ModifyGraph freePos(Ldummy)=300;DelayUpdate	Label Lsoma "\\Z14Soma\\u#2\r";DelayUpdate	Label bottom "Time (\\U)";DelayUpdate	Label Lped "\\Z14Terminal\\u#2\r";DelayUpdate	Label Ldummy "\\Z14 Voltage (mV) Real \\K(0,0,52224)Predicted"	ModifyGraph hideTrace(dummyChirpPred)=1			//pairwise		Variable startP = x2pnt($somaChirpPredSN, NLAnalysisStartX)		Variable endP = x2pnt($somaChirpPredSN, convolutionEndX)	Display/K=1/N=$somaChirpBinnedSN	AppendToGraph/C=(0,0,0) $somaChirpRealSN[startP,endP]/TN=soma vs $somaChirpPredSN[startP,endP]	AppendToGraph $pedChirpRealSN[startP,endP]/TN=ped vs $pedChirpPredSN[startP,endP]	AppendToGraph $somaChirpBinnedSN[][1]/TN=somaBinned vs $somaChirpBinnedSN[][0]	AppendToGraph $somaChirpBinnedSN[][2]/TN=somaFit vs $somaChirpBinnedSN[][0]		AppendToGraph $pedChirpBinnedSN[][1]/TN=pedBinned vs $pedChirpBinnedSN[][0] 	AppendToGraph $pedChirpBinnedSN[][2]/TN=pedFit vs $pedChirpBinnedSN[][0] 		//make fits circles with outer grey and inner black (soma) or red (ped)	ModifyGraph mode(soma)=2, mode(ped)=2		ModifyGraph mode(somaBinned)=3,marker(somaBinned)=19, mrkThick(somaBinned)=2,rgb(somaBinned)=(0,0,0), mrkStrokeRGB(somaBinned)=(34816,34816,34816), useMrkStrokeRGB(somaBinned)=1	ModifyGraph mode(pedBinned)=3,marker(pedBinned)=19, mrkThick(pedBinned)=2,rgb(pedBinned)=(65280,0,0), mrkStrokeRGB(pedBinned)=(34816,34816,34816), useMrkStrokeRGB(pedBinned)=1	ModifyGraph mode(somaFit)=0, lstyle(somaFit) = 1, lsize(somaFit)=5,rgb(somaFit)=(34816,34816,34816)	ModifyGraph mode(pedFit)=0, lstyle(pedFit) = 1, lsize(pedFit)=5,rgb(pedFit)=(34816,34816,34816)	ReorderTraces somaBinned,{somaFit,pedFit}	ModifyGraph fSize=14;DelayUpdate	Label left "\\Z14Measured \rSoma or \\K(65280,0,0)Terminal\\K(0,0,0) (\\U)"	Label bottom "\\Z14Linear Prediction (\\U)"endfunction fftChirpAmplitudesNew(stimRef, somaRef, pedRef, startWinX, endWinX)	String stimRef, somaRef,pedRef; Variable startWinX, endWinX		Variable removeDC = 1		//will subtract baseline average from time domain signals (major DC component of frequency domain)		if (fio_checkGlobalFilePath())			//check path returns non-zero if there are any problems with symbolic path		Print "aborted in analysis_SSVI because file save path not set! Use fio_setDataSavePath()"		return 0	endif	SVAR/Z dataSavePathName				//this should be a global string with the name of the path that is set by fio_setDataSavePath()		Variable pntLen = x2pnt($stimRef,endWinX) - x2pnt($stimRef,startWinX)	if (mod(pntLen,2) == 0)		//if pntLen is even, then duplicate will give an array of pntLen + 1, so need to reduce by 1		Print "got here"		endWinX -= DimDelta($stimRef,0)		//check if numpnts in wave windows will be even, if not, remove one point so it is even (FFT only works with even)	endif	//copy waves in	Duplicate/O/R=(startWinX, endWinX) $stimRef, stimChirpTD	Duplicate/O/R=(startWinX, endWinX) $somaRef, somaChirpTD	Duplicate/O/R=(startWinX, endWinX) $pedRef, pedChirpTD	//calculate mean for possible reference (most needed if DC)	Variable meanStim = mean(stimChirpTD); Variable meanSoma = mean(somaChirpTD); Variable meanPed = mean(pedChirpTD)	if (removeDC)		stimChirpTD -= meanStim		somaChirpTD -= meanSoma		pedChirpTD -= meanPed	endif	//calcualte cross-correlation between stim and soma and stim and ped (gives magnitude back in V per A, and phase difference	crossCorrelateRelPS("stimChirpTD", "somaChirpTD", "crossStimSoma_FD",startWinX, endWinX,1,0,0,0); WAVE crossStimSoma_FD	crossCorrelateRelPS("stimChirpTD", "pedChirpTD", "crossStimPed_FD",startWinX, endWinX,1,0,0,0); WAVE crossStimPed_FD	getNormalizedFFTMag("crossStimSoma_FD", "crossStimSomaMag_FD"); WAVE crossStimSomaMag_FD	getNormalizedFFTMag("crossStimPed_FD", "crossStimPedMag_FD"); WAVE crossStimPedMag_FD	Duplicate/O crossStimSoma_FD, crossStimSomaPhase_FD, crossStimPedPhase_FD	Redimension/R crossStimSomaPhase_FD,crossStimPedPhase_FD		//change to real so we can store just mag or just phase here		//magnitude and difference	Duplicate/O crossStimSomaMag_FD, crossSomaPedMagDiff_FD	crossSomaPedMagDiff_FD = (crossStimPedMag_FD - crossStimSomaMag_FD) / crossStimSomaMag_FD	crossStimSomaPhase_FD = imag(r2polar(crossStimSoma_FD))	crossStimSomaPhase_FD[0] = crossStimSomaPhase_FD[1]; Unwrap 2*pi, crossStimSomaPhase_FD	//doing this because first point has no phase info (DC)	crossStimPedPhase_FD = imag(r2polar(crossStimPed_FD))	crossStimPedPhase_FD[0] = crossStimPedPhase_FD[1]; Unwrap 2*pi, crossStimPedPhase_FD	//doing this because first point has no phase info (DC)	Duplicate/O crossStimPedPhase_FD, crossSomaPedPhaseDiff_FD	crossSomaPedPhaseDiff_FD = (crossStimPedPhase_FD - crossStimSomaPhase_FD) / crossStimSomaPhase_FD			//soma-related	String appendNote = "(Chirp response, Window:" + num2str(startWinX) + "," + num2str(endWinX) + ")FFT:"	String somaFDISN = somaRef + "cFDI"			//chirp frequency domain impedence	Note/K crossStimSomaMag_FD, note($somaRef) + appendNote + "cFDI"		Duplicate/O crossStimSomaMag_FD, $somaFDISN	String somaFDPSN = somaRef + "cFDP"		//chirp frequency domain phase	Note/K crossstimSomaPhase_FD, note($somaRef) + appendNote + "cFDP"		Duplicate/O crossstimSomaPhase_FD, $somaFDPSN			//ped-related	String pedFDISN = pedRef + "cFDI"	Note/K crossStimPedMag_FD, note($pedRef) + appendNote + "cFDI"		Duplicate/O crossStimPedMag_FD, $pedFDISN	String pedFDPSN = pedRef + "cFDP"	Note/K crossStimPedPhase_FD, note($pedRef) + appendNote + "cFDP"		Duplicate/O crossStimPedPhase_FD, $pedFDPSN		//subtration	String pedSomaSubFDISN = stimRef + "cFDIPS"				//PS for ped soma (subtraction)	Note/K crossSomaPedMagDiff_FD,  note($stimRef) + appendNote + "cFDIPS (Impedence diff as fraction of somatic)"	Duplicate/O crossSomaPedMagDiff_FD, $pedSomaSubFDISN	String pedSomaSubFDPSN = stimRef + "cFDPPS"	Note/K crossSomaPedPhaseDiff_FD,  note($stimRef) + appendNote + "cFDPPS (Phase diff as fraction of somatic)"	Duplicate/O crossSomaPedPhaseDiff_FD, $pedSomaSubFDPSN		Save/C/O/P=$dataSavePathName $somaFDISN , $somaFDPSN , $pedFDISN, $pedFDPSN , $pedSomaSubFDISN , $pedSomaSubFDPSN	//display results	String impGN = pedSomaSubFDISN	String phaseGN = pedSomaSubFDPSN	KillWindowsByName("*" + "cFD" + "*")	Variable minDisFreq = 0.25	Variable maxDispFreq = 150			//impedence		Display/K=1/N=$pedSomaSubFDISN 	AppendToGraph/L=L_abs $somaFDISN, $pedFDISN	AppendToGraph/L=L_sub $pedSomaSubFDISN		ModifyGraph rgb($somaFDISN) = (0,0,0), rgb($pedSomaSubFDISN) = (0,35328,35328)	ModifyGraph lblpos = 51, freepos = 0 	setaxis bottom minDisFreq,maxDispFreq; setaxis/A=2 L_abs; setaxis/A=2 L_sub	ModifyGraph fSize=14,axisEnab(L_abs)={0.33,1},axisEnab(L_sub)={0,0.29};DelayUpdateLabel L_abs "\\Z14Impedence (M\\"Label bottom "\\Z14 Frequency (\\U)";DelayUpdateLabel L_sub "\\Z14Difference  (M\\"modifygraph height=72*3.5, width=72*3setaxis bottom, 0.25, 150setaxis/A=2 L_abssetaxis/A=2 L_subModifyGraph lblPos(L_abs)=68,lblPos(L_sub)=72;DelayUpdateLabel L_sub "\\Z14Fractional change\rfrom soma\\u#2"Label L_abs "\\Z14Soma or \\K(65280,0,0)Terminal\\u#2\\K(0,0,0)\r(mV / nA)\\u#2"ModifyGraph lblPos(L_abs)=82,lblPos(L_sub)=82,prescaleExp(L_abs)=-6ModifyGraph lowTrip(L_abs)=1e-05	//phase	Display/K=1/N=$pedSomaSubFDPSN 	AppendToGraph/L=L_abs $somaFDPSN, $pedFDPSN	AppendToGraph/L=L_sub $pedSomaSubFDPSN		ModifyGraph rgb($somaFDPSN) = (0,0,0), rgb($pedSomaSubFDPSN) = (0,35328,35328)	ModifyGraph lblpos = 51, freepos = 0 	setaxis bottom minDisFreq,maxDispFreq; setaxis/A=2 L_abs; setaxis/A=2 L_sub		ModifyGraph fSize=14,axisEnab(L_abs)={0.33,1},axisEnab(L_sub)={0,0.29};DelayUpdate	Label L_abs "\\Z14Phrase lag (radian)\\u#2";DelayUpdate	Label bottom "\\Z14 Frequency (\\U)";DelayUpdate	Label L_sub "\\Z14Difference  (M\\"	modifygraph height=72*3.5, width=72*3	setaxis bottom, 0.25, 150	setaxis/A=2 L_abs	setaxis/A=2 L_sub	ModifyGraph lblPos(L_abs)=68,lblPos(L_sub)=72;DelayUpdateLabel L_abs "\\Z14Phase (rad.)\\u#2";DelayUpdateLabel L_sub "\\Z14Fractional change\rfrom soma\\u#2"ModifyGraph lowTrip(L_sub)=1e-07endfunction fftChirpAmplitudesOld(stimRef, somaRef, pedRef, startWinX, endWinX)	String stimRef, somaRef,pedRef; Variable startWinX, endWinX		Variable removeDC = 1		//will subtract baseline average from time domain signals (major DC component of frequency domain)		if (fio_checkGlobalFilePath())			//check path returns non-zero if there are any problems with symbolic path		Print "aborted in analysis_SSVI because file save path not set! Use fio_setDataSavePath()"		return 0	endif	SVAR/Z dataSavePathName				//this should be a global string with the name of the path that is set by fio_setDataSavePath()		Variable pntLen = x2pnt($stimRef,endWinX) - x2pnt($stimRef,startWinX)	if (mod(pntLen,2) == 0)		//if pntLen is even, then duplicate will give an array of pntLen + 1, so need to reduce by 1		Print "got here"		endWinX -= DimDelta($stimRef,0)		//check if numpnts in wave windows will be even, if not, remove one point so it is even (FFT only works with even)	endif	//copy waves in	Duplicate/O/R=(startWinX, endWinX) $stimRef, stimChirpTD	Duplicate/O/R=(startWinX, endWinX) $somaRef, somaChirpTD	Duplicate/O/R=(startWinX, endWinX) $pedRef, pedChirpTD	//calculate mean for possible reference (most needed if DC)	Variable meanStim = mean(stimChirpTD); Variable meanSoma = mean(somaChirpTD); Variable meanPed = mean(pedChirpTD)	if (removeDC)		stimChirpTD -= meanStim		somaChirpTD -= meanSoma		pedChirpTD -= meanPed	endif	//	crossCorrelateRelPS("stimChirpTD", "somaChirpTD", "cross_FD",startWinX, endWinX,1,0,1,1)	//calculate and store FD of chirp (complex wave)	fft/dest=stimChirpFD stimChirpTD	fft/dest=somaChirpFD somaChirpTD	fft/dest=pedChirpFD pedChirpTD	//make placeholders for properly scaled magnitude waves for chirp	fft/out=3/dest=stimChirpFDMagTemp stimChirpTD	fft/out=3/dest=somaChirpFDMagTemp somaChirpTD	fft/out=3/dest=pedChirpFDMagTemp pedChirpTD	Duplicate/O stimChirpFDMagTemp, stimChirpFDMag	Duplicate/O somaChirpFDMagTemp,somaChirpFDMag	Duplicate/O pedChirpFDMagTemp, pedChirpFDMag; KillWaves/Z stimChirpFDMagTemp, somaChirpFDMagTemp, pedChirpFDMagTemp	//calculate magnitude of chirp across frequency domain and store in magnitude waves. Scaling is as in Fourier Transform explanation by Igor	stimChirpFDMag = real(r2polar(stimChirpFD[p]))/numpnts(stimChirpTD)	somaChirpFDMag = real(r2polar(somaChirpFD[p]))/numpnts(somaChirpTD)	pedChirpFDMag = real(r2polar(pedChirpFD[p]))/numpnts(pedChirpTD)	stimChirpFDMag[1,numpnts(stimChirpFDMag)-2] =  2*stimChirpFDMag[p]	somaChirpFDMag[1,numpnts(somaChirpFDMag)-2] = 2*somaChirpFDMag[p]	pedChirpFDMag[1,numpnts(pedChirpFDMag)-2] =2*pedChirpFDMag[p]	//duplicate magnitude waves, calculate complex impedence (FD response amplitude / FD stimulus amplitude) 	Duplicate/O pedChirpFDMag, somaFDImp, pedFDImp	somaFDImp = somaChirpFDMag[p] / stimChirpFDMag[p]	pedFDImp = pedChirpFDMag[p] / stimChirpFDMag[p]	//subtract soma and pedicle 	Duplicate/O pedChirpFDMag, pedSomaSubFDMag, pedSomaSubFDImp	pedSomaSubFDMag -= somaChirpFDMag[p]	pedSomaSubFDImp = pedFDImp[p] - somaFDImp		//save results	String appendNote = "(Chirp response, Window:" + num2str(startWinX) + "," + num2str(endWinX) + ")FFT:"		//stim-related	String stimFDSN = stimRef + "cFD"	Note/K stimChirpFD, note($stimRef) + appendNote + "cFD"	Duplicate/O stimChirpFD, $stimFDSN	String stimFDMSN = stimRef + "cFDM"	Note/K stimChirpFDMag, note($stimRef) + appendNote + "cFDM"	Duplicate/O stimChirpFDMag, $stimFDMSN		//soma-related	String somaFDSN = somaRef + "cFD"	Note/K somaChirpFD, note($somaRef) + appendNote + "cFD"	Duplicate/O somaChirpFD, $somaFDSN	String somaFDMSN = somaRef + "cFDM"	Note/K somaChirpFDMag, note($somaRef) + appendNote + "cFDM"	Duplicate/O somaChirpFDMag,$somaFDMSN	String somaFDISN = somaRef + "cFDI"	Note/K somaFDImp, note($somaRef) + appendNote + "cFDI"		Duplicate/O somaFDImp, $somaFDISN		//ped-related	String pedFDSN = pedRef + "cFD"	Note/K pedChirpFD, note($pedRef) + appendNote + "cFD"	Duplicate/O pedChirpFD, $pedFDSN	String pedFDMSN = pedRef + "cFDM"	Note/K pedChirpFDMag, note($pedRef) + appendNote + "cFDM"	Duplicate/O pedChirpFDMag, $pedFDMSN	String pedFDISN = pedRef + "cFDI"	Note/K pedFDImp, note($pedRef) + appendNote + "cFDI"		Duplicate/O pedFDImp, $pedFDISN		//subtration	String pedSomaSubFDMSN = stimRef + "cFDMPS"	Note/K pedSomaSubFDMag, note($stimRef) + appendNote + "cFDMPS"	Duplicate/O pedSomaSubFDMag, $pedSomaSubFDMSN	String pedSomaSubFDISN = stimRef + "cFDIPS"	Note/K pedSomaSubFDImp,  note($stimRef) + appendNote + "cFDIPS"	Duplicate/O pedSomaSubFDImp, $pedSomaSubFDISN		Save/C/O/P=$dataSavePathName $stimFDSN , $stimFDMSN , $somaFDSN , $somaFDMSN , $somaFDISN , $pedFDSN , $pedFDMSN , $pedFDISN, $pedSomaSubFDMSN, $pedSomaSubFDISN				//display results	String stimMGN = stimFDMSN	String respMGN = pedSomaSubFDMSN	String impGN = pedSomaSubFDISN	KillWindowsByName("*" + "cFD" + "*")	Variable minDisFreq = 0.25	Variable maxDispFreq = 150		//stimulus 	Display/K=1/N=$stimMGN 	AppendToGraph/C=(21760,21760,21760) $stimFDMSN	setaxis bottom, minDisFreq, maxDispFreq; setaxis/A=2 left		//voltage response	Display/K=1/N=$pedSomaSubFDMSN 	AppendToGraph/L=L_abs $somaFDMSN, $pedFDMSN	AppendToGraph/L=L_sub $pedSomaSubFDMSN	ModifyGraph rgb($somaFDMSN) = (0,0,0), rgb($pedSomaSubFDMSN) = (0,35328,35328)	ModifyGraph axisEnab(L_sub) = {0,0.29}, axisEnab(L_abs) = {0.33,1}, lblpos = 51, freepos = 0 	setaxis bottom minDisFreq,maxDispFreq; setaxis/A=2 L_abs; setaxis/A=2 L_sub	ModifyGraph fSize=14	ModifyGraph lblLatPos(L_sub)=12;DelayUpdateLabel L_abs "\\Z14Voltage (\\U)";DelayUpdateLabel bottom "\\Z14Frequency (\\U)";DelayUpdateLabel L_sub "\\Z14Difference (\\U)"modifygraph height=72*3.5, width=72*3setaxis bottom, 0, 100			//impedence		Display/K=1/N=$pedSomaSubFDISN 	AppendToGraph/L=L_abs $somaFDISN, $pedFDISN	AppendToGraph/L=L_sub $pedSomaSubFDISN		ModifyGraph rgb($somaFDISN) = (0,0,0), rgb($pedSomaSubFDISN) = (0,35328,35328)	ModifyGraph lblpos = 51, freepos = 0 	setaxis bottom minDisFreq,maxDispFreq; setaxis/A=2 L_abs; setaxis/A=2 L_sub	ModifyGraph fSize=14,axisEnab(L_abs)={0.33,1},axisEnab(L_sub)={0,0.29};DelayUpdateLabel L_abs "\\Z14Impedence (M\\"Label bottom "\\Z14 Frequency (\\U)";DelayUpdateLabel L_sub "\\Z14Difference  (M\\"modifygraph height=72*3.5, width=72*3setaxis bottom, 0.25, 100setaxis/A=2 L_abssetaxis/A=2 L_subend//NOT CURRENTLY FUNCTIONINGfunction poolAnalyzeSelectChirps()	WAVE waveListSelListByNums	WAVE/T waveListListWave		Print "in pool analyze select chirps"		Variable standardNumCycles = 336				//336 for original waves			if (DimSize(waveListListWave,1) != 3)		Print "Select a set or set(s) of 3 chirp waves: stimulus, site1 response, site2 response!"		return 0	endif	Variable numSelChirpSweeps = numpnts(waveListSelListByNums)		Print numSelChirpSweeps	Make/O/T/N=(numSelChirpSweeps,3) listOfChirpsToAverage		String stimWaveRef, respARef, respBRef, stimNote = "", respANote = "", respBNote = ""	//will keep track of what waves got averaged	Variable i, currentWaveIndex		String tempString, nameString = "_"		for (i=0;i<numSelChirpSweeps;i+=1)		listOfChirpsToAverage[i][0] = waveListListWave[waveListSelListByNums[i]][0]		stimNote += listOfChirpsToAverage[i][0] + ";"		listOfChirpsToAverage[i][1] = waveListListWave[waveListSelListByNums[i]][1]		respANote += listOfChirpsToAverage[i][1] + ";"		listOfChirpsToAverage[i][2] = waveListListWave[waveListSelListByNums[i]][2]		respBNote += listOfChirpsToAverage[i][2] + ";"				if (i==0)			tempString = listOfChirpsToAverage[i][0]			nameString += tempString[11,13]		elseif (i == numSelChirpSweeps-1)			tempString = listOfChirpsToAverage[i][0]				//should save namestring in the form _000111_ where 000 is first sweep num, always 3 digits, and 111 last, also always 3			nameString += tempString[11,13]				endif	endfor	nameString += "_"	Print "in pool analyze, nameString = " + nameString	String stimAvgName = listOfChirpsToAverage[0][0]	stimAvgName[9,16] = nameString	Print "in poolrAnalyze a: " + stimAvgName	String respAAvgName = listOfChirpsToAverage[0][1]	respAAvgName[9,16] = nameString	Print "in poolrAnalyze b: " +respAAvgName	String respBAvgName = listOfChirpsToAverage[0][2]	respBAvgName[9,16] = nameString	Print "in poolrAnalyze c: " + respBAvgName	if (numSelChirpSweeps > 1)			//then we have more than one sweep selected, and we will assume they are replicates and average them, computing things for the average		avgTracesCol("listOfChirpsToAverage", 0, stimAvgName)		avgTracesCol("listOfChirpsToAverage", 1, respAAvgName)		avgTracesCol("listOfChirpsToAverage", 2, respBAvgName)	endif			analyzeChirpGeneral(stimAvgName, standardNumCycles,1, stimNote)	analyzeChirpGeneral(respAAvgName, standardNumCycles,1, respANote)	analyzeChirpGeneral(respBAvgName, standardNumCycles,1, respBNote)		displayChirps(stimAvgName, respAAvgName, respBAvgName, 0, numSelChirpSweeps)//	analyzeIndividualChirpReps("listOfChirpsToAverage", standardNumCycles,0, stimNote, respANote, respBNote)				KillWaves/Z listOfChirpsToAverage	KillStrings/Z S_nameendfunction analyzeIndividualChirpReps(listOfIndivChirpsRef, numCycles, useExistingParamsWaves, note1, note2, note3)		//takes a reference to a 1D or 2D list of chirp waves and generates summary parameters and statistics	String listOfIndivChirpsRef; Variable numCycles, useExistingParamsWaves	//if useExistingParamsWaves = 1 it will assume that the params waves have already been generated 	String note1,note2,note3	//notes for appending to each result	Print "In analyzeIndividualChirpReps (A)"		Duplicate/O/T $listOfIndivChirpsRef, listOfIndivChirps, listOfIndivParamsWaves	Variable numChirpSets = DimSize(listOfIndivChirps,0)		Print "(A cntd) numChirpSets = " + num2str(numChirpSets)		//compute parameters for each wave	String currentStimRef, currentRespARef, currentRespBRef, currentStimParamsRef, currentRespAParamsRef, currentRespBParamsRef	Variable i,j	for (i=0; i<numChirpSets;i+=1)		currentStimRef = listOfIndivChirps[i][0]		currentRespARef = listOfIndivChirps[i][1]		currentRespBRef = listOfIndivChirps[i][2]		currentStimParamsRef = currentStimRef + "_pa"		currentRespAParamsRef = currentRespARef + "_pa"		currentRespBParamsRef = currentRespBRef + "_pa"		if (!useExistingParamsWaves)			analyzeChirpGeneral(currentStimRef, numCycles, 0, note1)			//0 specifies not to save individual cycles or fits waves			analyzeChirpGeneral(currentRespARef, numCycles, 0, note2)			analyzeChirpGeneral(currentRespBRef, numCycles, 0, note3)			additionalChirpAnalysis(currentStimRef,currentRespARef,currentRespBRef)		endif	endfor	listOfIndivParamsWaves[][] = listOfIndivChirps[p][q] + "_pa"		//transfer chirp list to params list, appending _pa so that it now references the newly generated parameters waves		Duplicate/O $listOfIndivParamsWaves[0][0], stimAvgWave, stimSDWave	Duplicate/O $listOfIndivParamsWaves[0][1], respAAvgWave, respASDWave, respBAvgWave, respBSDWave	stimAvgWave = 0; stimSDWave = 0; respAAvgWave = 0; respASDWave = 0; respBAvgWave = 0; respBSDWave = 0		//make waves to store averages and stdevs of all paremeters stored in params waves. Start with averages:	String stimParamsAvgName = listOfIndivParamsWaves[0][0]	stimParamsAvgName[10,13] = "chAS"				//chAS differentates from chAv which marks the waves generated from the averaged chirp stim and responses	String respAParamsAvgName = listOfIndivParamsWaves[0][1]	respAParamsAvgName[10,13] = "chAS"	String respBParamsAvgName = listOfIndivParamsWaves[0][2]	respBParamsAvgName[10,13] = "chAS"		//then stdevs:	String stimParamsSDName = listOfIndivParamsWaves[0][0]	stimParamsSDName[10,13] = "chSD"	String respAParamsSDName = listOfIndivParamsWaves[0][1]	respAParamsSDName[10,13] = "chSD"	String respBParamsSDName = listOfIndivParamsWaves[0][2]	respBParamsSDName[10,13] = "chSD"		//calculate average by addition in place	for (i=0;i<numChirpSets;i+=1)		Duplicate/O $listOfIndivParamsWaves[i][0], currentWave		stimAvgWave[][] += currentWave[p][q]		Duplicate/O $listOfIndivParamsWaves[i][1], currentWave		respAAvgWave[][] += currentWave[p][q]		Duplicate/O $listOfIndivParamsWaves[i][2], currentWave		respBAvgWave[][] += currentWave[p][q]	endfor	stimAvgWave[][] = stimAvgWave[p][q]/numChirpSets	respAAvgWave[][] = respAAvgWave[p][q]/numChirpSets	respBAvgWave[][] = respBAvgWave[p][q]/numChirpSets		//compute standard deviation by first calculating the numerator for the variance in place	for (i=0; i<numChirpSets;i+=1)		Duplicate/O $listOfIndivParamsWaves[i][0], currentWave		stimSDWave[][] += (currentWave[p][q] - stimAvgWave[p][q])^2		Duplicate/O $listOfIndivParamsWaves[i][1], currentWave		respASDWave[][] += (currentWave[p][q] - respAAvgWave[p][q])^2				Duplicate/O $listOfIndivParamsWaves[i][2], currentWave		respBSDWave[][] += (currentWave[p][q] - respBAvgWave[p][q])^2		endfor		//calculate the final standard deviation by dividing this numerator by N-1 (gives variance), then taking the square root (gives SD)	stimSDWave[][] = stimSDWave[p][q]/(numChirpSets - 1)	stimSDWave[][] = sqrt(stimSDWave[p][q])	respASDWave[][] = respASDWave[p][q]/(numChirpSets - 1)	respASDWave[][] = sqrt(respASDWave[p][q])	respBSDWave[][] = respBSDWave[p][q]/(numChirpSets - 1)	respBSDWave[][] = sqrt(respBSDWave[p][q])		Duplicate/O stimAvgWave, $stimParamsAvgName; Duplicate/O stimSDWave, $stimParamsSDName	Duplicate/O respAAvgWave, $respAParamsAvgName; Duplicate/O respASDWave, $respAParamsSDName	Duplicate/O respBAvgWave, $respBParamsAvgName; Duplicate/O respBSDWave, $respBParamsSDName		displayChirps(stimParamsAvgName, respAParamsAvgName, respBParamsAvgName, 1, numChirpSets)			//1 for parameters only		KillWaves/Z stimAvgWave,stimSDWave,respAAvgWave, respASDWave, respBAvgWave, respBSDWave, paramsWaveTemp, listOfIndivParamsWaves, currentWaveendfunction analyzeChirpGeneral(chirpRef, numCycles, saveCyclesAndFits, noteString)		//numCycles = 335 works for the original chirp stimulus	String chirpRef, noteString; Variable numCycles, saveCyclesAndFits			//savesCyclesAndFits = 1, cycles will be excised for display and waves saved for each fit		Print "in analyzeChirpGeneral for wave = " + chirpRef		//check file save path and move on, first declaring the global string that stores the save path, only if this path has been set using fio_setDataSavePath()	if (fio_checkGlobalFilePath())			//check path returns non-zero if there are any problems with symbolic path		Print "aborted in analysis_SSVI because file save path not set! Use fio_setDataSavePath()"		return 0	endif	SVAR/Z dataSavePathName				//this should be a global string with the name of the path that is set by fio_setDataSavePath()		Duplicate/O $chirpRef, chirpWave		String cycleWaveAppendString = "_cy"			//_cycles wave is a 2D text wave with references to the excised cycle (col 1), falling phase fit (col 2) and rising fit (col 3)	String paramsWaveAppendString = "_pa"		//name to append to waves generated. _params is a 2D wave with parameters for each cycle (1 row per cycle)	//each individual wave generated and referenced by _cycles wave will have name [chirpRef]_  + cycles_ +  [riseFit/fallFit/data]_ + cycleNum			Variable extraCycleProportionLeft = 0.1	//sets what fraction preceding and proceding cycles should be excised with a cycle 0.1 = 10% of the cycle period on either side	Variable extraCycleProportionRight = 0.55	Variable fitWindowSize = 0.55		//sets what proportion of the cycle a fit will include (only approximated--by the size of the last cycle--as the cycle size is not known at the time of fit)	Variable initialStartT = 0.1563		//beginning of stimulus. Function will find first crest and start from there	Variable periodGuess = 16333			//estimate of period of first cycle in points	Variable initialFitPoint = x2pnt(chirpWave, initialStartT)		String cycleWaveString = chirpRef + cycleWaveAppendString	String paramsWaveString = chirpRef + paramsWaveAppendString	Make/D/O/N=(numCycles,19) fitParamsWaveTemp//N=17 {K0f,K1f,K2f,K3f, K0r,K1r,K2r,K3r, crest1P, troughP, crest2P, fallFitWindowEnd, risefitWindowEnd, Crest2P-Crest1P, period (s), equiv freq (s)}, where K0r, k0f is the 0th fit parameter for rise and fall respectively		if (saveCyclesAndFits == 1)		Make/O/T/N=(numCycles,3) cyclesWaveTemp	//this will keep references excised individual cycles from the original data, at end will copy this into ref from cycleWaveString, same thing for fitParamsWaveTemp and paramsWaveString	endif			Make/D/O/N=4 fitCoefs		//temporarily stores the fit parameters generated with each fit	Variable V_minloc, V_maxloc	//stores the min and max X values generatded by WaveStats()		//find initial crestP	Duplicate/O/R=[initialFitPoint, (initialFitPoint + periodGuess)] chirpWave, chirpExcisedPhase, chirpFit	CurveFit/W=2/N=1/Q=1/NTHR=0/B=(periodGuess) sin, kwCWave=fitCoefs, chirpExcisedPhase	chirpFit=0	chirpFit = fitCoefs[0]+fitCoefs[1]*sin(fitCoefs[2]*x+fitCoefs[3])	WaveStats/Q chirpFit	Variable fitWindowStart = x2pnt(chirpWave, V_maxloc)	//this should be the first crest of the first full cycle, assuming the start point is correct	Variable fitWindowEnd = x2pnt(chirpWave, V_minloc)		periodGuess = 2*(fitWindowEnd - fitWindowStart)		//updates expected period based on distance between crest and trough of first cycle	String cycleNameString	Variable i, dataWindowStart, dataWindowEnd, waveMidVal						//iterates through each cycle	for(i=0;i<numCycles;i+=1)			//will break loop by other methods		if (i>0)						//positions are updated before the for loop for the special case of the first iteration			fitWindowStart = fitParamsWaveTemp[i-1][10]	//fit window starts at the ending crest of the last wave			periodGuess = fitParamsWaveTemp[i-1][13]		//period guess is the last period		endif				//Fit the falling phase of the cycle		fitWindowEnd = fitWindowStart + (periodGuess*fitWindowSize)	//use a set proportion of the period as window size		fitParamsWaveTemp[i][8] = fitWindowStart			//stores crestP1					Duplicate/O/R=[fitWindowStart,fitWindowEnd] chirpWave, chirpExcisedPhase, chirpFit		CurveFit/W=2/N=1/Q=1/NTHR=0/B=(periodGuess) sin, kwCWave=fitCoefs, chirpExcisedPhase		chirpFit=0		chirpFit = fitCoefs[0]+fitCoefs[1]*sin(fitCoefs[2]*x+fitCoefs[3])				//store falling fit and parameters		fitParamsWaveTemp[i][11] = fitWindowEnd		//stores fit window ending of the falling phase fit		fitParamsWaveTemp[i][0,3] = fitCoefs[q]			//stores falling phase fit coefs				if (saveCyclesAndFits == 1)			cycleNameString = cycleWaveString + "_fa_" + num2str(i)		//saves copy of falling phase fit			cyclesWaveTemp[i][0] = cycleNameString			Duplicate/O chirpFit, $cyclesWaveTemp[i][0]			Note $cyclesWaveTemp[i][0], noteString		endif				WaveStats/Q chirpFit		fitParamsWaveTemp[i][9] = x2pnt(chirpWave, V_minloc)	//stores trough P				//find and store the falling phase middle location (let's call this the true start of this cycle and the true end of the last cycle		waveMidVal = wavemin(chirpFit) + ((wavemax(chirpFit) - wavemin(chirpFit))/2)		FindLevel/Q chirpFit, waveMidVal		//find half level		if (V_flag)			Print "FindLevel flag in" + chirpRef + ". Cycle = " + num2str(i)		endif		fitParamsWaveTemp[i][16] = V_levelX		if (i>0)			fitParamsWaveTemp[i-1][18] = V_levelX		endif						//Fit the rising phase of the cycle		fitWindowStart = fitParamsWaveTemp[i][9]			//use the trough as the starting point for the rising phase fit		fitWindowEnd = fitWindowStart + (periodGuess * fitWindowSize)		//use a set proportion of the period as window size again				Duplicate/O/R=[fitWindowStart,fitWindowEnd] chirpWave, chirpExcisedPhase, chirpFit		CurveFit/W=2/N=1/Q=1/NTHR=0/B=(periodGuess) sin, kwCWave=fitCoefs, chirpExcisedPhase		chirpFit=0		chirpFit = fitCoefs[0]+fitCoefs[1]*sin(fitCoefs[2]*x+fitCoefs[3])				//store rising fit and parameters		fitParamsWaveTemp[i][12] = fitWindowEnd		//stores fit window ending of the rising phase fit		fitParamsWaveTemp[i][4,7] = fitCoefs[q-4]			//stores rising phase fit coefs				if (saveCyclesAndFits == 1)			cycleNameString = cycleWaveString + "_ri_" + num2str(i)		//saves copy of rising phase fit			cyclesWaveTemp[i][1] = cycleNameString			Duplicate/O chirpFit, $cyclesWaveTemp[i][1]			Note $cyclesWaveTemp[i][1], noteString		endif				WaveStats/Q chirpFit		fitParamsWaveTemp[i][10] = x2pnt(chirpWave, V_maxloc)	//stores crest2P				//find and store the rising phase "true" middle of cycle 		FindLevel/Q chirpFit, waveMidVal		//find half level		if (V_flag)			Print "FindLevel flag in" + chirpRef + ". Cycle = " + num2str(i)		endif		fitParamsWaveTemp[i][17] = V_levelX				//store remaining cycle parameters		fitParamsWaveTemp[i][13] = fitParamsWaveTemp[i][10] - fitParamsWaveTemp[i][8] 			//stores effective period in points		fitParamsWaveTemp[i][14] = DimDelta(chirpWave,0)*fitParamsWaveTemp[i][13]					//stores effective period in sec		fitParamsWaveTemp[i][15] = 1/ fitParamsWaveTemp[i][14]											//stores effective frequency in Hz		if (saveCyclesAndFits == 1)			//store excised portion of cycle			cycleNameString = cycleWaveString  + "_da_" + num2str(i)			cyclesWaveTemp[i][2] = cycleNameString			dataWindowStart = fitParamsWaveTemp[i][8] - (extraCycleProportionLeft*fitParamsWaveTemp[i][13])			//data window start is crest1P - extracyclePortion*cyclePeriod			dataWindowEnd = fitParamsWaveTemp[i][9] + (extraCycleProportionRight*fitParamsWaveTemp[i][13])		//data window end is crest2P + extracyclePortion*cyclePeriod			Duplicate/O/R=[dataWindowStart,dataWindowEnd] chirpWave, $cyclesWaveTemp[i][2]			Note $cyclesWaveTemp[i][2], noteString		endif		endfor	//save cycleWave and paramsWave in appropriate wave references	Duplicate/O fitParamsWaveTemp, $paramsWaveString	Note $paramsWaveString, noteString	Save/C/O/P=$dataSavePathName $paramsWaveString		if (saveCyclesAndFits == 1)		Duplicate/O cyclesWaveTemp, $cycleWaveString		Note $cycleWaveString, noteString	endif		KillWaves/Z cyclesWaveTemp, fitParamsWaveTemp, chirpFit, chirpExcisedPhase, chirpWave, fitCoefs, W_sigmaendfunction displayChirps(stimChirpRef, responseARef, responseBRef, paramsOnly, numReps)			//paramsOnly = 1 directs that only summary plots with parameter waves are used, 	String stimChirpRef, responseARef, responseBRef; Variable paramsOnly, numReps		Print "in displayChirps for " + stimChirpRef + ";" + responseARef + ";" + responseBRef +" . Params only = " + num2str(paramsOnly)		Variable hasCyclesWaves = 1			//assumes that cycles waves (excised wave cycle, rising and falling fit waves, exist for all waves, but we will check that later)	//	if ((DimSize($responseARef,1) < 20) || (DimSize($responseBRef,1) < 20))	additionalChirpAnalysis(stimChirpRef, responseARef, responseBRef)//	endif		if (!paramsOnly)		Duplicate/O $stimChirpRef, stimWave		Duplicate/O $responseARef, responseAWave		Duplicate/O $responseBRef, responseBWave	endif		String cmd	String chirpsDisplayName = responseARef + "_ch"	String chirpsNoOverlayDisplayName = responseARef + "_chNOL"	String chirpsOverlayADisplayName = responseARef + "_chOLA"	String chirpsOverlayBDisplayName = responseARef + "_chOLB"	String chirpsOverlayCDisplayName = responseARef + "_chOLC"	String chirpsOverlayDDisplayName = responseARef + "_chOLD"	String chirpAmpPlotName = responseARef + "_chAmp"	String chirpLatPlotName = responseARef + "_chLat"	String tableName = responseARef + "Tab"		if (!paramsOnly)		if (WinType(chirpsDisplayName) > 0)			sprintf cmd, "KillWindow %s", chirpsDisplayName		//have to print because KillWindow only accepts the literal string variable, not the reference to the string			Execute cmd		endif		if(WinType(chirpsNoOverlayDisplayName) > 0)			sprintf cmd, "KillWindow %s", chirpsNoOverlayDisplayName			Execute cmd		endif		KillWindowsByName(responseARef + "_chO*")	endif		if(WinType(chirpAmpPlotName) > 0)		sprintf cmd, "KillWindow %s", chirpAmpPlotName		Execute cmd	endif	if(WinType(chirpLatPlotName) > 0)		sprintf cmd, "KillWindow %s", chirpLatPlotName		Execute cmd	endif	if (WinType(tableName) > 0)		sprintf cmd, "KillWindow %s", tableName		Execute cmd	endif		String cycleWaveAppendString = "_cy"			String paramsWaveAppendString = "_pa"		if (!paramsOnly)		String stimCyclesWaveName = stimChirpRef + cycleWaveAppendString		String responseACyclesWaveName = responseARef + cycleWaveAppendString		String responseBCyclesWaveName = responseBRef + cycleWaveAppendString			Print stimCyclesWaveName,"stimCyclesWaveName"		Print responseACyclesWaveName,"responseACyclesWaveName"		Print responseBCyclesWaveName,"responseBCyclesWaveName"				if (WaveExists($stimCyclesWaveName))			//check for cycles wave			Duplicate/O/T $stimCyclesWaveName, stimCyclesWave			Duplicate/O/T $responseACyclesWaveName, responseACyclesWave			Duplicate/O/T $responseBCyclesWaveName, responseBCyclesWave		else			hasCyclesWaves = 0		endif	endif		String stimParamsWaveName = stimChirpRef + paramsWaveAppendString	String responseAParamsWaveName = responseARef + paramsWaveAppendString	String responseBParamsWaveName = responseBRef + paramsWaveAppendString		Duplicate/O $stimParamsWaveName, stimParamsWave	Duplicate/O $responseAParamsWaveName, responseAParamsWave	Duplicate/O $responseBParamsWaveName, responseBParamsWave		if (!paramsOnly)		//generate chirp display		sprintf cmd, "Display/K=1/N=%s", chirpsDisplayName		Execute cmd		AppendToGraph/L=chirpL $stimChirpRef		AppendToGraph/L=respAL $responseARef		AppendToGraph/L=respBL $responseBRef			//add fit waves as overlays, if fit waves were saved		if (hasCyclesWaves == 1)			Variable i; String tempName			for (i=0;i<DimSize(stimCyclesWave,0);i+=1)				tempName = stimCyclesWave[i][0]			//displays the falling phase fit for the ith cycle				if (WaveExists($tempName))					AppendToGraph/L=chirpL $tempName					ModifyGraph lsize($tempName)=3,rgb($tempName)=(0,0,0)				endif				tempName = responseACyclesWave[i][0]				if (WaveExists($tempName))					AppendToGraph/L=respAL $tempName					ModifyGraph lsize($tempName)=3,rgb($tempName)=(0,0,0)				endif				tempName = responseBCyclesWave[i][0]				if(WaveExists($tempName))					AppendToGraph/L=respBL $tempName					ModifyGraph lsize($tempName)=3,rgb($tempName)=(0,0,0)				endif			endfor		endif			//adjust axes 		ModifyGraph axisEnab(chirpL)={0,.19}, axisEnab(respAL) = {.21,.59}, axisEnab(respBL) = {.61,1}		ModifyGraph lblPos(chirpL)=51, freePos(chirpL)=0, lblPos(respAL)=51, freePos(respAL)=0, lblPos(respBL)=51, freePos(respBL)=0	endif		//generate chirp overlay displays if excised cycle waves are available and paramsOnly is 0	if ((hasCyclesWaves == 1) && !paramsOnly)		//generate y-axis normalized plot		Display/K=1/N=$chirpsOverlayADisplayName		Display/K=1/N=$chirpsOverlayBDisplayName		Display/K=1/N=$chirpsOverlayCDisplayName		Display/K=1/N=$chirpsOverlayDDisplayName		Variable yOffsetVar = 0		for (i=0; i<DimSize(stimCyclesWave,0);i+=1)			//append stimulus			tempName = stimCyclesWave[i][2]			AppendToGraph/W=$chirpsOverlayADisplayName/R=chirpR/C=(21760,21760,21760) $tempName	//		AppendToGraph/W=$chirpsOverlayBDisplayName/R=chirpR/C=(21760,21760,21760) $tempName		//LEAVING B WITHOUT STIMULUS			AppendToGraph/W=$chirpsOverlayCDisplayName/R=chirpR/C=(21760,21760,21760) $tempName			AppendToGraph/W=$chirpsOverlayDDisplayName/R=chirpR/C=(21760,21760,21760) $tempName			//append response A			tempName = responseACyclesWave[i][2]			AppendToGraph/W=$chirpsOverlayADisplayName/L=respL $tempName			ModifyGraph/W=$chirpsOverlayADisplayName offset($tempName)={0,-responseAParamsWave[i][yOffsetVar]}, rgb($tempName)=(0,0,0) //CURRENTLY SET TO HAVE A = SOMA = BLACK			AppendToGraph/W=$chirpsOverlayBDisplayName/L=respL $tempName			ModifyGraph/W=$chirpsOverlayBDisplayName offset($tempName)={0,-responseAParamsWave[i][yOffsetVar]}, rgb($tempName)=(0,0,0) //CURRENTLY SET TO HAVE A = SOMA = BLACK				AppendToGraph/W=$chirpsOverlayCDisplayName/L=respL $tempName			ModifyGraph/W=$chirpsOverlayCDisplayName offset($tempName)={0,-responseAParamsWave[i][yOffsetVar]}, rgb($tempName)=(0,0,0) //CURRENTLY SET TO HAVE A = SOMA = BLACK				AppendToGraph/W=$chirpsOverlayDDisplayName/L=respL $tempName			ModifyGraph/W=$chirpsOverlayDDisplayName offset($tempName)={0,-responseAParamsWave[i][yOffsetVar]}, rgb($tempName)=(0,0,0) //CURRENTLY SET TO HAVE A = SOMA = BLACK							//append response B and adjust axes			tempName = responseBCyclesWave[i][2]			AppendToGraph/W=$chirpsOverlayADisplayName/L=respL $tempName				ModifyGraph/W=$chirpsOverlayADisplayName offset($tempName)={0,-responseBParamsWave[i][yOffsetVar]}//, rgb($tempName)=(0,0,0)			ModifyGraph/W=$chirpsOverlayADisplayName lblpos=51, freepos=0, width=72*8, height = 72*2			setaxis/W=$chirpsOverlayADisplayName bottom, 0.2,3.5			setaxis/W=$chirpsOverlayADisplayName/A=2 respL			AppendToGraph/W=$chirpsOverlayBDisplayName/L=respL $tempName				ModifyGraph/W=$chirpsOverlayBDisplayName offset($tempName)={0,-responseBParamsWave[i][yOffsetVar]}//, rgb($tempName)=(0,0,0)			ModifyGraph/W=$chirpsOverlayBDisplayName lblpos=51, freepos=0, width=72*8, height = 72*2		//	setaxis/W=$chirpsOverlayBDisplayName bottom, 2.5,3.5		//	setaxis/W=$chirpsOverlayBDisplayName/A=2 respL			AppendToGraph/W=$chirpsOverlayCDisplayName/L=respL $tempName				ModifyGraph/W=$chirpsOverlayCDisplayName offset($tempName)={0,-responseBParamsWave[i][yOffsetVar]}//, rgb($tempName)=(0,0,0)			ModifyGraph/W=$chirpsOverlayCDisplayName lblpos=51, freepos=0, height=72*2, width=72*3.5			setaxis/W=$chirpsOverlayCDisplayName bottom, 3.5,4.25			setaxis/W=$chirpsOverlayCDisplayName/A=2 respL			AppendToGraph/W=$chirpsOverlayDDisplayName/L=respL $tempName				ModifyGraph/W=$chirpsOverlayDDisplayName offset($tempName)={0,-responseBParamsWave[i][yOffsetVar]}//, rgb($tempName)=(0,0,0)			ModifyGraph/W=$chirpsOverlayDDisplayName lblpos=51, freepos=0, height=72*2, width=72*3.5				setaxis/W=$chirpsOverlayDDisplayName bottom, 6,6.25			setaxis/W=$chirpsOverlayDDisplayName/A=2 respL		endfor	endif		String responseAAbsAmpFitName = responseARef + "_AWA"	String responseBAbsAmpFitName = responseBRef + "_AWA"	String responseBSubAmpFitName = responseBRef + "_AWS"		String responseAAbsLatFitName = responseARef + "_LWA"	String responseBAbsLatFitName = responseBRef + "_LWA"			//Amplitude summary plot	sprintf cmd, "Display/K=1/N=%s", chirpAmpPlotName	Execute cmd	AppendToGraph/L=absAmpL/C=(0,0,0) $responseAParamsWaveName[1,DimSize(responseAParamsWave,0)-1][1] vs $stimParamsWaveName[1,DimSize(responseAParamsWave,0)-1][15]	AppendToGraph/L=absAmpL $responseBParamsWaveName[1,DimSize(responseBParamsWave,0)-1][1] vs $stimParamsWaveName[1,DimSize(responseBParamsWave,0)-1][15]		//% change latency at terminal	AppendToGraph/L=relAmpL $responseBParamsWaveName[1,DimSize(responseBParamsWave,0)-1][30] vs $stimParamsWaveName[1,DimSize(responseBParamsWave,0)-1][15]		//ABS Difference//	AppendToGraph/L=relAmpL $responseBParamsWaveName[1,DimSize(responseBParamsWave,0)-1][25]/$responseAParamsWaveName[1,DimSize(responseAParamsWave,0)-1][1]) vs $stimParamsWaveName[1,DimSize(responseBParamsWave,0)-1][15]		ModifyGraph lblPos(absAmpL)=55,lblPos(relAmpL)=55,prescaleExp(absAmpL)=3;DelayUpdateModifyGraph prescaleExp(relAmpL)=3,notation(relAmpL)=1,axisEnab(absAmpL)={0.33,1};DelayUpdateModifyGraph axisEnab(relAmpL)={0,0.29};DelayUpdateLabel absAmpL "\\Z14 Amplitude (mV)\\u#2";DelayUpdateLabel bottom "\\Z14Frequency (Hz)\\u#2";DelayUpdateLabel relAmpL "\\Z14 Difference (mV)\\u#2"ModifyGraph fsize=14ModifyGraph height=72*4, width=72*3modifygraph freepos=0,lblpos=52ModifyGraph lblPos(absAmpL)=70,lblPos(relAmpL)=80,lowTrip(relAmpL)=0.0001;DelayUpdateModifyGraph prescaleExp(relAmpL)=0;DelayUpdateLabel absAmpL "\\Z14Amplitude (mV)\\u#2";DelayUpdateLabel relAmpL "\\Z14Fractional change \rfrom soma\\u#2"		//Latency summary plot	sprintf cmd, "Display/K=1/N=%s", chirpLatPlotName	Execute cmd	AppendToGraph/L=absLatL/C=(0,0,0) $responseAParamsWaveName[1,DimSize(responseAParamsWave,0)-1][17] vs $stimParamsWaveName[1,DimSize(responseAParamsWave,0)-1][15]//	AppendToGraph/L=absLatL/C=(0,0,0) $responseAAbsLatFitName[0,187] //currently set to have SOMA = A = BLACK	AppendToGraph/L=absLatL $responseBParamsWaveName[1,DimSize(responseBParamsWave,0)-1][17] vs $stimParamsWaveName[1,DimSize(responseBParamsWave,0)-1][15]	AppendToGraph/L=relLatL $responseBParamsWaveName[1,DimSize(responseBParamsWave,0)-1][31] vs $stimParamsWaveName[1,DimSize(responseBParamsWave,0)-1][15]		//% change latency at terminal//	AppendToGraph/L=relLatL $responseBParamsWaveName[1,DimSize(responseBParamsWave,0)-1][20] vs $stimParamsWaveName[1,DimSize(responseBParamsWave,0)-1][15]		//abs relative latency old//	AppendToGraph/L=foldLatL $responseBParamsWaveName[1,DimSize(responseBParamsWave,0)-1][27] vs $stimParamsWaveName[1,DimSize(responseBParamsWave,0)-1][15]		//fold latency old	ModifyGraph lblpos=0, freepos=0modifygraph fsize=14ModifyGraph prescaleExp(absLatL)=3,prescaleExp(relLatL)=3;DelayUpdateModifyGraph axisEnab(absLatL)={0.33,1},axisEnab(relLatL)={0,0.29};DelayUpdateLabel absLatL "\\Z14 Latency (ms)\\u#2";DelayUpdateLabel bottom "\\Z14 Frequency (Hz)\\u#2";DelayUpdateLabel relLatL "\\Z14 Difference (ms)\\u#2"ModifyGraph height=72*4, width=72*3modifygraph freepos=0,lblpos=52ModifyGraph lowTrip(relLatL)=1e-05,prescaleExp(relLatL)=0,notation(relLatL)=1ModifyGraph lblPos(absLatL)=66,lblPos(relLatL)=72;DelayUpdateLabel relLatL "\\Z14Fractional change\rfrom soma\\u#2"		String responseAAdditionalParamsName = responseARef + "_AP"	String responseBAdditionalParamsName = responseBRef + "_AP"		//final summary table	String respSummaryRef = responseARef + "_RS"	String respSummaryHeaderRef = respSummaryRef + "H"	String respSummaryTableN = respSummaryHeaderRef	if (WinType(respSummaryTableN) > 0)		KillWindow $respSummaryTableN	endif	Edit/K=1/N=$respSummaryTableN $respSummaryHeaderRef, $respSummaryRef				Make/T/O/N=(numpnts($responseAAdditionalParamsName)) chirpTableFirstCol	chirpTableFirstCol[0,3] = {num2str(numReps), stimChirpRef, responseARef, responseBRef}	sprintf cmd, "Edit/N=%s %s, %s, %s", tableName, "chirpTableFirstCol", responseAAdditionalParamsName, responseBAdditionalParamsName	Execute cmd	KillWaves/Z stimWave, responseAWave, responseBWave, stimCyclesWave, responseACyclesWave, responseBCyclesWave, stimParamsWave, responseAParamsWave, responseBParamsWaveendfunction additionalChirpAnalysis(stimChirpRef, responseARef, responseBRef)		//takes in references to chirp and two responses, appends to associated response parameter waves additional calculations	String stimChirpRef, responseARef, responseBRef		Variable sampleRate = 20000			//in Hz MAY NEED TO CHANGE!		String paramsWaveAppendString = "_pa"			String stimParamsWaveName = stimChirpRef + paramsWaveAppendString	String responseAParamsWaveName = responseARef + paramsWaveAppendString	String responseBParamsWaveName = responseBRef + paramsWaveAppendString		Duplicate/O $stimParamsWaveName, stimParamsWave	Duplicate/O $responseAParamsWaveName, responseAParamsWave	Duplicate/O $responseBParamsWaveName, responseBParamsWave		Redimension/N=(DimSize(responseAParamsWave,0), 35) responseAParamsWave	Redimension/N=(DimSize(responseBParamsWave,0), 35) responseBParamsWave		responseAParamsWave[][32,34] = responseAParamsWave[p][q-16]			//want to take from cols 16,17,18 and put in 32,33,34 	responseBParamsWave[][32,34] = responseBParamsWave[p][q-16]		responseAParamsWave[][16] = responseAParamsWave[p][8]/sampleRate -  stimParamsWave[p][8]/sampleRate 		//responseCrestP1 - stimCrestP1	responseAParamsWave[][17] = responseAParamsWave[p][9]/sampleRate - stimParamsWave[p][9]/sampleRate 		//responseTrough- stimTrough	responseAParamsWave[][18] = responseAParamsWave[p][10]/sampleRate  - stimParamsWave[p][10]/sampleRate 		//responseCrestP2 - stimCrestP2		responseBParamsWave[][16] = responseBParamsWave[p][8] /sampleRate - stimParamsWave[p][8]/sampleRate 	//responseCrestP1 - stimCrestP1	responseBParamsWave[][17] = responseBParamsWave[p][9]/sampleRate  - stimParamsWave[p][9]/sampleRate 	//responseTrough- stimTrough	responseBParamsWave[][18] = responseBParamsWave[p][10] /sampleRate - stimParamsWave[p][10]/sampleRate		responseAParamsWave[][19] = responseAParamsWave[p][8]/sampleRate  - responseBParamsWave[p][8]/sampleRate 	//responseACrestP1 - responseBCrestP1	responseAParamsWave[][20] = responseAParamsWave[p][9]/sampleRate  - responseBParamsWave[p][9]/sampleRate 		//responseATrough- responseBTrough	responseAParamsWave[][21] = responseAParamsWave[p][10] /sampleRate - responseBParamsWave[p][10]/sampleRate 	//responseACrestP2 - responseBCrestP2		responseBParamsWave[][19] = responseBParamsWave[p][8]/sampleRate - responseAParamsWave[p][8]/sampleRate	//responseBCrestP1 - responseACrestP1	responseBParamsWave[][20] = responseBParamsWave[p][9]/sampleRate - responseAParamsWave[p][9]/sampleRate		//responseBTrough- responseATrough	responseBParamsWave[][21] = responseBParamsWave[p][10]/sampleRate - responseAParamsWave[p][10]	/sampleRate//responseBCrestP2 - responseACrestP2			//more amplitude and latency data		responseAParamsWave[][22] = responseAParamsWave[p][1]/responseBParamsWave[p][1]		//responseAfall Amplitude / responseB	responseAParamsWave[][23] = responseAParamsWave[p][5]/responseBParamsWave[p][5]		//responseArise Amp / response B		responseBParamsWave[][22] = responseBParamsWave[p][1]/responseAParamsWave[p][1]		//responseBfall Amplitude / responseA	responseBParamsWave[][23] = responseBParamsWave[p][5]/responseAParamsWave[p][5]		//responseBrise Amp / response A		responseAParamsWave[][24] = responseAParamsWave[p][13]/responseBParamsWave[p][13]		//responseAperiod/responseBperiod	responseBParamsWave[][24] = responseBParamsWave[p][13]/responseAParamsWave[p][13]		//responseBperiod/responseAperiod		responseBParamsWave[][25] = responseBParamsWave[p][1] - responseAParamsWave[p][1]		//responseAmpF - responseAmpF	responseBParamsWave[][26] = responseBParamsWave[p][4] - responseAParamsWave[p][4]		//responseAmpR - responseAmpR		responseAParamsWave[][25] = responseAParamsWave[p][1] - responseBParamsWave[p][1]		//responseAmpF - responseAmpF	responseAParamsWave[][26] = responseAParamsWave[p][5] - responseBParamsWave[p][5]		//responseAmpR - responseAmpR		responseAParamsWave[][27] = responseAParamsWave[p][17]/responseBParamsWave[p][17]		//response LatencyA/B	responseBParamsWave[][27] = responseBParamsWave[p][17]/responseAParamsWave[p][17]		//response LatencyB/A		responseAParamsWave[][28] = responseAParamsWave[p][2]/(2*Pi)				//responseFrequencyF in s	responseAParamsWave[][29] = responseAParamsWave[p][6]/(2*Pi)				//responseFrequencyR in s		responseBParamsWave[][28] = responseBParamsWave[p][2]/(2*Pi)				//responseFrequencyF in s	responseBParamsWave[][29] = responseBParamsWave[p][6]/(2*Pi)				//responseFrequencyR in s			responseAParamsWave[][30] = responseAParamsWave[p][25] / responseBParamsWave[p][1]			//responseAmpF (A) - responseAmF (B) / responseAmpFB	responseAParamsWave[][31] = responseAParamsWave[p][20] / responseBParamsWave[p][17]	//respA latency - respB latency / resp B latency		responseBParamsWave[][30] = responseBParamsWave[p][25] / responseAParamsWave[p][1]			//responseBeBmpF (A) - responseAmF (B) / responseAmpFB	responseBParamsWave[][31] = responseBParamsWave[p][20] / responseAParamsWave[p][17]	//respA latency - respB latency / resp B latency		Duplicate/O stimParamsWave,  $stimParamsWaveName	Duplicate/O responseAParamsWave, $responseAParamsWaveName	Duplicate/O responseBParamsWave, $responseBParamsWaveName		String respAAdditionalParamsName = responseARef + "_AP"	String respBAdditionalParamsName = responseBRef + "_AP"		Make/O/D/N=13 respAAdditionalParams	Make/O/D/N=13 respBAdditionalParams		//stores delta current injection	Duplicate/O/R=[][0] stimParamsWave, placeholderWave		//grabs the 1st column	respAAdditionalParams[0] = wavemax(placeholderWave) - wavemin(placeholderWave)		//takes delta current for current injection	respBAdditionalParams[0] = respAAdditionalParams[0]		//generate fits for amplitude plot	String coefAndConstWaveName = responseARef + "_AFA"			//for ampltiude fits - absolute	String expFitWaveName = responseARef+ "_AWA"					//for amplitude wave - absolute	Make/D/O/N=4 tempCoefsWave	Duplicate/O/R=[1,DimSize(responseAParamsWave,0)-1][1] responseAParamsWave, tempExpFitWave			//for absolute fit amplitude vs apparent freq (respA)	CurveFit/W=2/N=1/Q=1 exp_XOffset, responseAParamsWave[1,DimSize(responseAParamsWave,0)-1][1]/X=stimParamsWave[1, DimSize(responseAParamsWave,0)-1][15]			WAVE W_coef, W_fitConstants	//generated by curvefit	tempCoefsWave[0,2] = W_coef[p]	tempCoefsWave[3] = W_fitConstants[0]	tempExpFitWave =W_coef[0] + W_coef[1]*exp(-(x-W_fitConstants[0])/W_coef[2])	Duplicate/O tempCoefsWave, $coefAndConstWaveName	Duplicate/O tempExpFitWave, $expFitWaveName	respAAdditionalParams[1] = W_coef[0]	respAAdditionalParams[2] = W_coef[1]	respAAdditionalParams[3] = W_coef[2]	respAAdditionalParams[4] = W_fitConstants[0]		//for absolute fit amplitude vs apparent freq (respB)	coefAndConstWaveName = responseBRef + "_AFA"			//for ampltiude fits - absolute	expFitWaveName = responseBRef+ "_AWA"					//for amplitude wave - absolute		CurveFit/W=2/N=1/Q=1/NTHR=0 exp_XOffset, responseBParamsWave[1,DimSize(responseAParamsWave,0)-1][1]/X=stimParamsWave[1, DimSize(responseAParamsWave,0)-1][15]			tempCoefsWave[0,2] = W_coef[p]	tempCoefsWave[3] = W_fitConstants[0]		tempExpFitWave =W_coef[0] + W_coef[1]*exp(-(x-W_fitConstants[0])/W_coef[2])	Duplicate/O tempCoefsWave, $coefAndConstWaveName	Duplicate/O tempExpFitWave, $expFitWaveName	respBAdditionalParams[1] = W_coef[0]	respBAdditionalParams[2] = W_coef[1]	respBAdditionalParams[3] = W_coef[2]	respBAdditionalParams[4] = W_fitConstants[0]			//calculate the apparent resistance during chirp//	respAAdditionalParams[5] = respAAdditionalParams[3]/respAAdditionalParams[0]//	respBAdditionalParams[5] = respBAdditionalParams[3]/respBAdditionalParams[0]	//for relative fit amplitude (B - A) vs apparent freq:	coefAndConstWaveName = responseBRef + "_AFS"			//for ampltiude fits - subtraction	expFitWaveName = responseBRef+ "_AWS"					//for amplitude wave - subtraction		CurveFit/W=2/N=1/Q=1/NTHR=0 exp_XOffset, responseBParamsWave[1,DimSize(responseAParamsWave,0)-1][25]/X=stimParamsWave[1, DimSize(responseAParamsWave,0)-1][15]		tempCoefsWave[0,2] = W_coef[p]	tempCoefsWave[3] = W_fitConstants[0]			tempExpFitWave =W_coef[0] + W_coef[1]*exp(-(x-W_fitConstants[0])/W_coef[2])	Duplicate/O tempCoefsWave, $coefAndConstWaveName	Duplicate/O tempExpFitWave, $expFitWaveName		respAAdditionalParams[5] = -W_coef[0]	respAAdditionalParams[6] = -W_coef[1]	respAAdditionalParams[7] = W_coef[2]	respBAdditionalParams[5] = W_coef[0]	respBAdditionalParams[6] = W_coef[1]	respBAdditionalParams[7] = W_coef[2]		Variable latencyFitStartP = 30	//for absolute latency vs apparent freq (Resp A)	coefAndConstWaveName = responseARef + "_LFA"			//for ampltiude fits - subtraction	expFitWaveName = responseARef+ "_LWA"					//for amplitude wave - subtraction		CurveFit/W=2/N=1/Q=1/NTHR=0 exp_XOffset, responseAParamsWave[latencyFitStartP,DimSize(responseAParamsWave,0)-1][17]/X=stimParamsWave[latencyFitStartP, DimSize(responseAParamsWave,0)-1][15]		tempCoefsWave[0,2] = W_coef[p]	tempCoefsWave[3] = W_fitConstants[0]			tempExpFitWave =W_coef[0] + W_coef[1]*exp(-(x-W_fitConstants[0])/W_coef[2])	Duplicate/O tempCoefsWave, $coefAndConstWaveName	Duplicate/O tempExpFitWave, $expFitWaveName		respAAdditionalParams[8] = W_coef[0]	respAAdditionalParams[9] = W_coef[1]	respAAdditionalParams[10] = W_coef[2]	respAAdditionalParams[11] = W_fitConstants[0]		//for absolute latency vs apparent freq (Resp B)	coefAndConstWaveName = responseBRef + "_LFA"			//for ampltiude fits - subtraction	expFitWaveName = responseBRef+ "_LWA"					//for amplitude wave - subtraction		CurveFit/W=2/N=1/Q=1/NTHR=0 exp_XOffset, responseBParamsWave[latencyFitStartP,DimSize(responseAParamsWave,0)-1][17]/X=stimParamsWave[latencyFitStartP, DimSize(responseAParamsWave,0)-1][15]		tempCoefsWave[0,2] = W_coef[p]	tempCoefsWave[3] = W_fitConstants[0]			tempExpFitWave =W_coef[0] + W_coef[1]*exp(-(x-W_fitConstants[0])/W_coef[2])	Duplicate/O tempCoefsWave, $coefAndConstWaveName	Duplicate/O tempExpFitWave, $expFitWaveName	respBAdditionalParams[8] = W_coef[0]	respBAdditionalParams[9] = W_coef[1]	respBAdditionalParams[10] = W_coef[2]	respBAdditionalParams[11] = W_fitConstants[0]		Duplicate/O/R=[][20] responseAParamsWave, placeholderWave		//grabs the 1st column		respBAdditionalParams[12] = mean(placeholderWave)	respAAdditionalParams[12] = -respBAdditionalParams[5]		//make response summary data 	Variable numSummaryPnts = 25	Make/O/D/N=(numSummaryPnts) respSummary	Make/O/T/N=(numSummaryPnts) respSummaryHeader		respSummaryHeader[0] = "Stimulus c1 amp"	respSummary[0] = stimParamsWave[0][1]		//gets first parameter from 0th cycle,which is amplitude of the falling phase fit  	respSummaryHeader[1] = "Soma c1 amp"	respSummary[1] = responseAParamsWave[0][1]	respSummaryHeader[2] = "Peda c1 amp"	respSummary[2] = responseBParamsWave[0][1]	respSummaryHeader[3] = "Soma App Res c1"	respSummary[3] = respSummary[1] / respSummary[0]	respSummaryHeader[4] = "Ped App Res c1"	respSummary[4] = respSummary[2] / respSummary[0]	respSummaryHeader[5] = "c1 Res difference (ped - soma)"	respSummary[5] = respSummary[4] - respSummary[3]		respSummaryHeader[6] = "Soma f50 amp"	respSummary[6] = getSingleExpFitValue(50,respAAdditionalParams[1],respAAdditionalParams[2],respAAdditionalParams[3], respAAdditionalParams[4])	respSummaryHeader[7] = "Ped f50 amp"	respSummary[7] = getSingleExpFitValue(50,respBAdditionalParams[1],respBAdditionalParams[2],respBAdditionalParams[3], respBAdditionalParams[4])	respSummaryHeader[8] = "f50 amp difference (ped - soma)"	respSummary[8] = respSummary[7] - respSummary[6]	respSummaryHeader[9] = "Soma f100 amp"	respSummary[9] = getSingleExpFitValue(100,respAAdditionalParams[1],respAAdditionalParams[2],respAAdditionalParams[3], respAAdditionalParams[4])	respSummaryHeader[10] = "Ped f100 amp"	respSummary[10] = getSingleExpFitValue(100,respBAdditionalParams[1],respBAdditionalParams[2],respBAdditionalParams[3], respBAdditionalParams[4])	respSummaryHeader[11] = "f100 amp difference (ped - soma)"	respSummary[11] = respSummary[10] - respSummary[9]	respSummaryHeader[12] = "Soma f50 lat"	respSummary[12] = getSingleExpFitValue(50, respAAdditionalParams[8], respAAdditionalParams[9], respAAdditionalParams[10], respAAdditionalParams[11])	respSummaryHeader[13] = "Ped 50 lat"	respSummary[13] = getSingleExpFitValue(50, respBAdditionalParams[8], respBAdditionalParams[9], respBAdditionalParams[10], respBAdditionalParams[11])	respSummaryHeader[14] = "f50 lat difference (ped - soma)"	respSummary[14] = respSummary[13] - respSummary[12]	respSummaryHeader[15] = "Soma f100 lat"	respSummary[15] = getSingleExpFitValue(100, respAAdditionalParams[8], respAAdditionalParams[9], respAAdditionalParams[10], respAAdditionalParams[11])	respSummaryHeader[16] = "Ped 100 lat"	respSummary[16] = getSingleExpFitValue(100, respBAdditionalParams[8], respBAdditionalParams[9], respBAdditionalParams[10], respBAdditionalParams[11])	respSummaryHeader[17] = "f100 lat difference (ped - soma)"	respSummary[17] = respSummary[16] - respSummary[15]		respSummaryHeader[18] = "Soma amp Tau"	respSummary[18] = respAAdditionalParams[3]	respSummaryHeader[19] = "Ped amp Tau"	respSummary[19] = respBAdditionalParams[3]	respSummaryHeader[20] = "Amp tau difference (ped - soma)"	respSummary[20] = respSummary[19] - respSummary[18]	respSummaryHeader[21] = "Soma lat tau"	respSummary[21] = respAAdditionalParams[10]	respSummaryHeader[22] = "Ped lat tau"	respSummary[22] = respBAdditionalParams[10]	respSummaryHeader[23] = "Lat tau difference (ped - soma)"	respSummary[23] = respSummary[22] - respSummary[21]	respSummaryHeader[24] = "File: " + StringFromList(0,getFileNameFromWaveName(stimChirpRef,0))+"; T: " + fd_note_getWaveTimeStr(stimChirpRef,1) 	respSummary[24] = NaN		String respSummarySaveName = responseARef + "_RS"	String respSummaryHeaderSaveName = respSummarySaveName + "H"		Duplicate/O respSummary, $respSummarySaveName	Duplicate/O respSummaryHeader, $respSummaryHeaderSaveName		Duplicate/O respAAdditionalParams, $respAAdditionalParamsName	Duplicate/O respBadditionalParams, $respBAdditionalParamsName		KillWaves/Z stimParamsWave,responseAParamsWave,responseBParamsWave //tempCoefsWave, tempExpFitWaveendfunction plotChirpCycles(chirpParamsRef, isStimChirp)	String chirpParamsRef; Variable isStimChirp		Variable useSameVert = 1		String chirpRef = chirpParamsRef[0,strlen(chirpParamsRef)-4]			//removed presumed ending of "_pa"		Duplicate/O $chirpParamsRef, chirpParamsTemp		Variable cycleStartColNum, cycleEndColNum	if (isStimChirp)		cycleStartColNum = 16		cycleEndColNum = 18		else		cycleStartColNum = 32		cycleEndColNum = 34		endif		Display/K=1/N=$(chirpRef+"chPOL")		Variable i, cycleStartX, cycleEndX; String currTN, Vname = "Lc", Bname	for (i=0;i<DimSize(chirpParamsTemp,0);i+=1)		currTN = chirpRef + "c" + num2str(i)		if (!useSameVert)			VName = "Lc" + num2str(i)		endif		cycleStartX = chirpParamsTemp[i][cycleStartColNum]		cycleEndX = chirpParamsTemp[i][cycleEndColNum]				AppendtoGraph/L=$Vname/B=$("Bc" + num2str(i)) $chirpRef[x2pnt($chirpRef,cycleStartX), x2pnt($chirpRef,cycleEndX)]/TN=currTN	endforendfunction plotChirpCyclesRelStim(stimParamsRef, respParamsRef,useSameRespVert, padVert, useMulOffset)	String stimParamsRef, respParamsRef; Variable useSameRespVert,padVert, useMulOffset		Variable padProportion = .5		//proportion of amplitude by which graphs are padded. Only matters when padVert !=0	Variable numDispCycles = 10		//Only matters when padVert !=0		Variable stimVertEnd = 0.15	Variable respVertStart = 0.17		String respChirpRef = respParamsRef[0,strlen(respParamsRef)-4]			//removed presumed ending of "_pa"	String stimChirpRef = stimParamsRef[0,strlen(stimParamsRef)-4]			Duplicate/O $respParamsRef, respParamsTemp	Duplicate/O $stimParamsRef, stimParamsTemp			Variable stimCycleStartColNum = 16	Variable stimCycleEndColNum = 18		Variable respCycleStartColNum = 32	Variable respCycleEndColNum = 34		Killwindowsbyname("*" + stimChirpRef + "*" + "chPOL" + "*")	Display/K=1/N=$(stimChirpRef+"chPOL")	Variable i	if (padVert)		Variable totalOffset = 0		Variable deltaOffset		Variable lastMag = 0		Variable longestPeriod = stimParamsTemp[0][14]		Variable shortestPeriod = stimParamsTemp[DimSize(stimParamsTemp,0)-1][14]		Variable periodRange = longestPeriod - shortestPeriod		Variable periodStep = periodRange / numDispCycles		Variable currPeriodThreshold = longestperiod 		Variable currPeriod, currBinNum = 0		String cyclesList = ""		for (i=0;i<DimSize(stimParamsTemp,0);i+=1)			currPeriod = stimParamsTemp[i][14]			if (currPeriod <= currPeriodThreshold)				cyclesList = addlistitem(cyclesList,num2str(i),";")				currBinNum+=1				currPeriodThreshold = currPeriod -  periodStep				if (currBinNum > numDispCycles/2)					periodStep/=2				endif			endif		endfor						Print itemsinlist(cyclesList,";")	endif		Variable stimCycleStartX, stimCycleEndX, respCycleStartX, respCycleEndX; String currStimTN, currRespTN, respVname = "LRc", cBname = "Bc", stimVname = "LSc"	Variable mulOffset = 0, currMag	Variable displayCycle	String cycleNums = ""	for (i=0;i<DimSize(stimParamsTemp,0);i+=1)		currStimTN = stimChirpRef + "c" + num2str(i)		currRespTN = respChirpRef + "c" + num2str(i)		cBname = "Bc" + num2str(i)		if ((!useSameRespVert) && (!padVert))			//if using padVert, cannot user multiple vertices			respVname = "Lc" + num2str(i)		endif				stimCycleStartX = stimParamsTemp[i][stimCycleStartColNum]			//align start to stim start X		stimCycleEndX = stimParamsTemp[i][stimCycleEndColNum]			//align end to response end X		respCycleStartX = respParamsTemp[i][respCycleStartColNum]		respCycleEndX = respParamsTemp[i][respCycleEndColNum]				if (padVert)			displayCycle = 0		else			displayCycle = 1		endif		if (padVert)			if (FindListItem( num2str(i),cyclesList,";") > -1)				displayCycle = 1					deltaOffset = lastMag * padProportion				totalOffset += deltaOffset			//will be 0 for first				lastMag = wavemax($respChirpRef,respCycleStartX,respCycleEndX) - wavemin($respChirpRef,respCycleStartX,respCycleEndX)			endif		endif		currMag = wavemax($respChirpRef,respCycleStartX,respCycleEndX) - wavemin($respChirpRef,respCycleStartX,respCycleEndX)				if (displayCycle)			if (useMulOffset)				mulOffset = 1/currMag			endif			AppendToGraph/L=$stimVname/B=$cBname $stimChirpRef[x2pnt($stimChirpRef,stimCycleStartX), x2pnt($stimChirpRef,stimCycleEndX)]/TN=$currStimTN			AppendToGraph/L=$respVname/B=$cBname $respChirpRef[x2pnt($respChirpRef,stimCycleStartX), x2pnt($respChirpRef,stimCycleEndX)]/TN=$currRespTN			ModifyGraph offset($currRespTN)={0,totalOffset},muloffset($currRespTN)={0,mulOffset}			ModifyGraph axisEnab($respVname) = {.22,1}			cycleNums = cycleNums + num2str(i) + "; "		endif	endfor	ModifyGraph axisEnab(LSc)={0,0.2}	//removeaxisstuff("",1)//	Print cycleNumsendfunction plotChirpCyclesFromList(stimParamsRef, respParamsRef, cycleNumsList)	String stimParamsRef, respParamsRef, cycleNumsList			Variable stimVertEnd = 0.1	Variable respVertStart = 0.05		//good to leave some overlap between start of this and end of the stim because the current algorithm doesn't use the full range of the response axis	Variable padProportion = .4		//proportion of signal that is non-overlapping		String respChirpRef = respParamsRef[0,strlen(respParamsRef)-4]			//removed presumed ending of "_pa"	String stimChirpRef = stimParamsRef[0,strlen(stimParamsRef)-4]			Duplicate/O $respParamsRef, respParamsTemp	Duplicate/O $stimParamsRef, stimParamsTemp			Variable stimCycleStartColNum = 16	Variable stimCycleEndColNum = 18		Variable respCycleStartColNum = 32	Variable respCycleEndColNum = 34		Killwindowsbyname("*" + stimChirpRef + "*" + "chPOL" + "*")	Display/K=1/N=$(stimChirpRef+"chPOL")	Variable i		Variable numDispCycles = ItemsInList(cycleNumsList,";")	Variable respVertRange = 1-respVertStart	Variable unscaledRangePerBin = respVertRange / numDispCycles	Variable unscaledStepPerBin = unscaledRangePerBin * padProportion	Variable unscaledTotalRange = (unscaledStepPerBin * numDispCycles) + unscaledRangePerBin 	Variable scaleFactor = respVertRange / unscaledTotalRange//	Print scaleFactor	Variable scaledStepPerBin = unscaledStepPerBin * scaleFactor//	Print scaledStepPerBin	Variable scaledRangePerBin = unscaledRangePerBin * scaleFactor//	Print scaledRangePerBin		Variable stimCycleStartX, stimCycleEndX, respCycleStartX, respCycleEndX; String currStimTN, currRespTN, respVname = "LRc", cBname = "Bc", stimVname = "LSc"	Variable currVertStart = 1	Print "--------"	for (i=DimSize(stimParamsTemp,0);i>-1;i-=1)		if (FindListItem( num2str(i),cycleNumsList,";") > -1)	//	Print num2str(currVertStart) + ", " + num2str(currVertStart-scaledRangePerBin)		currStimTN = stimChirpRef + "c" + num2str(i)		currRespTN = respChirpRef + "c" + num2str(i)		cBname = "Bc" + num2str(i)		respVName = "LRc" + num2str(i)						stimCycleStartX = stimParamsTemp[i][stimCycleStartColNum]			//align start to stim start X		stimCycleEndX = stimParamsTemp[i][stimCycleEndColNum]			//align end to response end X		respCycleStartX = respParamsTemp[i][respCycleStartColNum]		respCycleEndX = respParamsTemp[i][respCycleEndColNum]		AppendToGraph/L=$stimVname/B=$cBname $stimChirpRef[x2pnt($stimChirpRef,stimCycleStartX), x2pnt($stimChirpRef,stimCycleEndX)]/TN=$currStimTN				AppendToGraph/L=$respVname/B=$cBname $respChirpRef[x2pnt($respChirpRef,stimCycleStartX), x2pnt($respChirpRef,stimCycleEndX)]/TN=$currRespTN				ModifyGraph axisEnab($respVname) = {currVertStart-scaledRangePerBin, currVertStart}		currVertStart -= scaledStepPerBin				endif	endfor	ModifyGraph axisEnab($stimVname) = {0, stimVertEnd}	removeaxisstuff("",1)endfunction plotPairedChirpCyclesFromList(stimParamsRef, respAParamsRef, respBParamsRef, cycleNumsList, baselineOffset, noAmpScaling)	String stimParamsRef, respAParamsRef, respBParamsRef, cycleNumsList; Variable baselineOffset, noAmpScaling			Variable stimVertEnd = 0.1	Variable respVertStart = 0.05		//good to leave some overlap between start of this and end of the stim because the current algorithm doesn't use the full range of the response axis	Variable padProportion = .5		//proportion of signal that is non-overlapping		Variable axisDataBottomStart = 0		String respAChirpRef = respAParamsRef[0,strlen(respAParamsRef)-4]			//removed presumed ending of "_pa"	String respBChirpRef = respBParamsRef[0,strlen(respBParamsRef)-4]	String stimChirpRef = stimParamsRef[0,strlen(respAParamsRef)-4]				Duplicate/O $respAParamsRef, respAParamsTemp	Duplicate/O $respBParamsRef, respBParamsTemp	Duplicate/O $stimParamsRef, stimParamsTemp			Variable stimCycleStartColNum = 16	Variable stimCycleEndColNum = 18		Variable stimCycleMidPointColNum = 17	Variable respCycleStartColNum = 32	Variable respCycleEndColNum = 34	if (noAmpScaling)		Killwindowsbyname("*" + stimChirpRef + "*" + "chPOL" + "*")		Display/K=1/N=$(stimChirpRef+"chPOL")	else		Killwindowsbyname("*" + stimChirpRef + "*" + "chPOLs" + "*")		Display/K=1/N=$(stimChirpRef+"chPOLs")			endif	Variable i		Variable numDispCycles = ItemsInList(cycleNumsList,";")	Variable respVertRange = 1-respVertStart	Variable unscaledRangePerBin = respVertRange / numDispCycles	Variable unscaledStepPerBin = unscaledRangePerBin * padProportion	Variable unscaledTotalRange = (unscaledStepPerBin * numDispCycles) + unscaledRangePerBin 	Variable scaleFactor = respVertRange / unscaledTotalRange	Variable scaledStepPerBin = unscaledStepPerBin * scaleFactor	Variable scaledRangePerBin = unscaledRangePerBin * scaleFactor	//for constructing guide to where cycles came from	String stimTemplateSN = stimParamsRef + "G"	Duplicate/O $stimChirpRef, stimTemplate	stimTemplate = NaN	Variable currStimMidpoint		//for no amplitude scaling, find range of largest axis, replot all on same range	Variable maxVal = wavemax($respAChirpRef) -mean($respAChirpRef)	Variable minVal = wavemin($respAChirpRef)-mean($respAChirpRef)		String stimTextSN = stimTemplateSN + "T"	Make/O/T/N=(DimSize(stimTemplate,0)) stimText	stimText = ""		String currText			Variable stimCycleStartX, stimCycleEndX, respCycleStartX, respCycleEndX	String currStimTN, currRespATN, currRespBTN, respVname = "L_Rc", cBname = "B_c", stimVname = "L_Sc", currRespVName, currStimBName, currAxisLabel	Variable currRespAOffset = 0, currRespBOffset = 0, firstPassOccured = 0	String cmd, currLabelText	Variable currVertStart = 1	Print "--------"	for (i=DimSize(stimParamsTemp,0);i>-1;i-=1)		if (FindListItem( num2str(i),cycleNumsList,";") > -1)	//	Print num2str(currVertStart) + ", " + num2str(currVertStart-scaledRangePerBin)			currStimTN = stimChirpRef + "c" + num2str(i)		currRespATN = respAChirpRef + "c" + num2str(i)		currRespBTN = respBChirpRef + "c" + num2str(i)		currStimBName = cBname + num2str(i)		currRespVName = respVname + num2str(i)						stimCycleStartX = stimParamsTemp[i][stimCycleStartColNum]			//align start to stim start X		stimCycleEndX = stimParamsTemp[i][stimCycleEndColNum]			//align end to response end X		respCycleStartX = respAParamsTemp[i][respCycleStartColNum]		respCycleEndX = respAParamsTemp[i][respCycleEndColNum]						//update guide to where cycles came from		currStimMidpoint = stimParamsTemp[i][stimCycleMidPointColNum]			stimTemplate[x2pnt(stimTemplate,currStimMidpoint)] = stimParamsTemp[i][15] 		sprintf currText, "%.0f", stimParamsTemp[i][15]  		if (!firstPassOccured)			currText = currText + "Hz"			firstPassOccured = 1		endif				//	Print currText		stimText[x2pnt(stimTemplate,currStimMidpoint)] = currText				//if using offset, calculate it:		if (baselineOffset)			currRespAOffset = -mean($respAChirpRef, stimCycleStartX, stimCycleEndX)			currRespBOffset = -mean($respBChirpRef, stimCycleStartX, stimCycleEndX)		endif					//append stimulus grey		AppendToGraph/L=$stimVname/B=$currStimBName/C=(21760,21760,21760) $stimChirpRef[x2pnt($stimChirpRef,stimCycleStartX), x2pnt($stimChirpRef,stimCycleEndX)]/TN=$currStimTN			//append resp A (e.g. soma) black		AppendToGraph/L=$currRespVName/B=$currStimBName/C=(0,0,0) $respAChirpRef[x2pnt($respAChirpRef,stimCycleStartX), x2pnt($respAChirpRef,stimCycleEndX)]/TN=$currRespATN		ModifyGraph offset($currRespATN) = {0,currRespAOffset}					//append resp B (e.g. ped) red (default color)		AppendToGraph/L=$currRespVName/B=$currStimBName $respBChirpRef[x2pnt($respBChirpRef,stimCycleStartX), x2pnt($respBChirpRef,stimCycleEndX)]/TN=$currRespBTN		ModifyGraph offset($currRespBTN) = {0,currRespBOffset}				ModifyGraph axisEnab($currRespVName) = {currVertStart-scaledRangePerBin, currVertStart}, axisEnab($currStimBName) = {axisDataBottomStart,1}		ModifyGraph noLabel($currRespVName)=1,lblPos($currRespVName)=55,lblRot($currRespVName)=270;DelayUpdate				ModifyGraph tick($currRespVName) = 3,tick($currStimBName) = 3, nolabel($currStimBName) =2, axRGB($currStimBName)=(65535,65535,65535), axRGB($currRespVName) = (65535,65535,65535)		ModifyGraph lblpos($currRespVName)=10*strlen(currText)				currLabelText = "\"\\\K(21760,21760,21760)\\\\Z16" + currText + "\""		sprintf cmd, "Label %s, %s", currRespVName, currLabelText		Execute cmd		currVertStart -= scaledStepPerBin		if (noAmpScaling)			Setaxis $currRespVName, minVal,maxVal				endif		endif	endfor		ModifyGraph axisEnab($stimVname) = {0, stimVertEnd}, freepos = 0	ModifyGraph noLabel(L_Sc)=0,lblPos(L_Sc)=52,freePos(L_Sc)=0,axRGB(L_Sc)=(0,0,0);DelayUpdate	Label L_Sc "\\Z16\\U"	ModifyGraph fSize(L_Sc)=16,noLabel(L_Rc30)=1,lblPos(L_Sc)=55	//make dummy for bottom axis scale	Make/O/D/N=4 normalizedCycleDummy	normalizedCycleDummy = p/4		//set to 0 through 1	SetScale/P x, 0,1/3, normalizedCycleDummy	AppendToGraph/L=L_dummy/B=B_Dummy normalizedCycleDummy	ModifyGraph lblPos(B_dummy) =0, freepos(B_dummy) = 0, fsize=16, freePos(L_dummy)=200	ModifyGraph hideTrace(normalizedCycleDummy)=1	ModifyGraph hideTrace(normalizedCycleDummy)=2	ModifyGraph nticks(B_Dummy)=2	ModifyGraph lblPos(L_Sc)=60,lblPos(L_dummy)=2,lblPos(B_Dummy)=42;DelayUpdate	Label L_dummy "\\Z16Normalized\rTo Soma";DelayUpdate	Label B_Dummy "\\Z16Period"	modifygraph height=1.5*72, width=3*72			KillWindowsByName(stimTemplateSN + "*")	Duplicate/O stimTemplate, $stimTemplateSN	Duplicate/O stimText, $stimTextSN	Display/K=1/N=$stimTemplateSN	AppendToGraph/L=Lresp/C=(0,0,0) $respAChirpRef	AppendToGraph/L=Lresp $respBChirpREf	AppendToGraph/L=Lstim/C=(21760,21760,21760) $stimChirpRef	AppendToGraph/L=Lguide/C=(21760,21760,21760) $stimTemplateSN	ModifyGraph axisEnab(Lstim) = {0, stimVertEnd}, axisEnab(Lresp) = {0.32, 1}, axisEnab(Lguide) = {stimVertEnd + 0.02, 0.3}, freepos = 0, lblpos= 52	ModifyGraph mode($stimTemplateSN)=2, lsize($stimTemplateSN)=5	ModifyGraph log(Lguide)=1	//add text wave	ModifyGraph textMarker($stimTemplateSN)={$stimTextSN,"Arial",1,0,5,0.00,0.00}	ModifyGraph mode($stimTemplateSN)=3	modifygraph fsize=16	ModifyGraph noLabel(Lguide)=1,lblPos(Lresp)=62,lblPos(Lstim)=62,lblPos(Lguide)=56;DelayUpdate	ModifyGraph lblLatPos(Lguide)=-5,lblRot(Lguide)=270;DelayUpdate	Label Lresp "\\Z16\\u#2\\F'Wingdings 3'r\\F'Arial'\\U";DelayUpdate	Label Lguide "log(Hz)"	ModifyGraph axisEnab(Lresp)={0.22,1}	ModifyGraph lblPos(Lguide)=66,lblLatPos(Lstim)=10,lblLatPos(Lguide)=5	//for hiding bottom etc. SetDrawEnv xcoord= bottom,linethick= 2.00;DelayUpdate	modifygraph height=1.5*72, width=6.2*72	DrawLine 0,1.09027777777778,1,1.09027777777778	SetDrawEnv fsize= 16;DelayUpdate	DrawText 0.813445378151261,0.145833333333333,"1 sec"	ModifyGraph tick(bottom)=3,noLabel(bottom)=2,axRGB(bottom)=(65535,65535,65535)	endfunction fixChirpDisp()ModifyGraph lblPos(L_Rc300)=47,lblLatPos(L_Rc300)=-10,lblLatPos(L_Rc110)=-10;DelayUpdateModifyGraph lblLatPos(L_Rc70)=-10,lblLatPos(L_Rc50)=-10,lblLatPos(L_Rc30)=-10;DelayUpdateModifyGraph lblLatPos(L_Rc15)=-5,lblLatPos(L_Rc4)=-2,lblLatPos(L_Rc0)=5ModifyGraph lblPos(L_Rc300)=47,lblLatPos(L_Rc300)=-10,lblLatPos(L_Rc110)=-10;DelayUpdateModifyGraph lblLatPos(L_Rc70)=-10,lblLatPos(L_Rc50)=-10,lblLatPos(L_Rc30)=-10;DelayUpdateModifyGraph lblLatPos(L_Rc15)=-5,lblLatPos(L_Rc4)=-2,lblLatPos(L_Rc0)=5endfunction fixRightChirpDisp()ModifyGraph tick(L_Sc)=3,noLabel(L_Sc)=2,noLabel(L_Rc300)=2,noLabel(L_Rc110)=2;DelayUpdateModifyGraph noLabel(L_Rc70)=2,noLabel(L_Rc50)=2,noLabel(L_Rc30)=2;DelayUpdateModifyGraph noLabel(L_Rc15)=2,noLabel(L_Rc4)=2,noLabel(L_Rc0)=2;DelayUpdateModifyGraph noLabel(L_dummy)=2,lblPos(L_Rc300)=60,lblPos(L_Rc110)=60;DelayUpdateModifyGraph lblPos(L_Rc70)=60,lblPos(L_Rc50)=60,lblPos(L_Rc30)=60;DelayUpdateModifyGraph lblPos(L_Rc15)=60,lblPos(L_Rc4)=60,lblPos(L_Rc0)=60;DelayUpdateModifyGraph lblPos(L_dummy)=60,freePos(L_Sc)=200;DelayUpdateLabel L_Sc "\\u#2";DelayUpdateLabel L_Rc300 "\\u#2";DelayUpdateLabel L_Rc110 "\\u#2";DelayUpdateLabel L_Rc70 "\\u#2";DelayUpdateLabel L_Rc50 "\\u#2";DelayUpdateLabel L_Rc30 "\\u#2";DelayUpdateLabel L_Rc15 "\\u#2";DelayUpdateLabel L_Rc4 "\\u#2";DelayUpdateLabel L_Rc0 "\\u#2";DelayUpdateLabel L_dummy "\\u#2"endfunction getSingleExpFitValue(xVal, K0, K1, K2, C1)	Variable xVal, K0, K1, K2, C1		return K0 + K1*exp(-(xVal-C1)/K2)end///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////SUMMARY ANALYSIS/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////function summarizeFilters()	String rawFilterList = WaveList("*_CorC",";","TEXT:0")	graphTracesInList("Filter_Summary", "", 0,rawFilterList)endfunction graphTracesInList(gName, vertAxisName, useRightAxis, listofwaves)	String gName, vertAxisName, listofwaves; Variable useRightAxis		Variable specifyAxisName = 1, specifyGName = 1	if (strlen(vertAxisName) < 1)		specifyAxisName = 0	endif	if (strlen(gName) > 0)		if (WinType(gName) != 1)	//check if there is a graph by this name			Display/N=$gName		else			DoWindow/F gName	//just brings graph to front, now append will append to it		endif				endif		Variable i		if (specifyAxisName && useRightAxis)		for (i=0;i<ItemsInList(listofwaves,";");i+=1)			AppendToGraph/R=$vertAxisName $StringFromList(i,listofwaves,";")		endfor	elseif ((!specifyAxisName) && useRightAxis)		for (i=0;i<ItemsInList(listofwaves,";");i+=1)			AppendToGraph/R $StringFromList(i,listofwaves,";")		endfor			elseif ((!specifyAxisName) && (!useRightAxis))		for (i=0;i<ItemsInList(listofwaves,";");i+=1)			AppendToGraph/L $StringFromList(i,listofwaves,";")		endfor	else		for (i=0;i<ItemsInList(listofwaves,";");i+=1)			AppendToGraph/L=$vertAxisName $StringFromList(i,listofwaves,";")		endfor		endif			end//THESE two functions were testers to start with. I was using inputs with mean subtracted, and wave inputs should start at t = 0//NOTE: Output is not normalized to input size, which is standardly done. However, it is normalized to window function avgPowerSpectra(inWaveRef, ps_outRef, amp_outRef, useWindowing, startX, binSizeX, binStartGapX, [endX])	String inWaveRef, ps_outRef, amp_outRef		//ps stores power spectrum (if passed), amp stores amplitude (if passed), which is sqrt(ps)	Variable startX, binSizeX, binStartGapX	//size and spacing units of X scaling, e.g. 1 for 1s bins if x is time. Bin start gap is gap between START of bins, 	//so if you want non-overlapping 1s bins with e.g. 0.1 s space, then the input to these are 0, 1, 1.1	Variable useWindowing		//determines whether a Hanning window will be applied (could pick a differrent window function). Requires correction for the power removed by the window function		Variable endX			Duplicate/O/R=(startX, startX + binSizeX) $inWaveRef, tempBin		Variable binSizeP = DimSize(tempBin,0)	Variable deltax_td = DimDelta(tempBin,0)	Variable isOdd = mod(binSizeP,2)		//mod(x,2) returns 0 if even, 1 if odd	//	Print "binSizeP",binSizeP,"deltax_td",deltax_td, "isOdd", isOdd		if (isOdd)		binSizeX -= deltax_td		Duplicate/O/R=(startX, startX + binSizeX)[0] $inWaveRef, tempBin		//should now be even if it wasn't before		Redimension/N=(-1) tempBin		//in case passing a particular row of a 2d wave	//	Print "in IF, and binSizeP now = " + num2str(numpnts(tempBin))	endif		//make a place to store power spectra (using FFT magnitude to give a real wave with correct num points, scaling, or a complex wave is returnComplexForm > 0	fft/dest=currFFT tempBin	Duplicate/O currFFT, powerSpectraAvg	Redimension/R powerSpectraAvg		powerSpectraAvg = 0		Variable currBinPosX, binCount = 0	Variable endXUsed = ParamIsDefault(endX) ? DimSize($inWaveRef,0)*deltax_td : endX	endXUsed -= 2*binSizeX		//avoids potential overrun by last bin	//	Print "endXUsed",endXUsed	Variable currMean	Variable V_value	for (currBinPosX = startX; currBinPosX < endXUsed; currBinPosX += binStartGapX)	//	Print "startX = " + num2str(currBinPosX) + "End X = " + num2str(currBinPosX + binSizeX)		Duplicate/O/R=(startX, startX + binSizeX)[0] $inWaveRef, tempBin		//should now be even if it wasn't before		Redimension/N=(-1) tempBin		//in case passing a particular row of a 2d wave				if (mod(DimSize(tempBin,0),2)	)		//odd!			Print "odd sized td bin at", currBinPosX, "size=",DimSize(tempBin,0)		endif				currMean = mean(tempBin)		tempBin -= currMean		if (usewindowing)			Windowfunction/FFT hanning, tempBin		endif		fft/dest=currFFT/out=1 tempBin		powerSpectraAvg += real(currFFT * conj(currFFT))		binCount+=1				//for comparison to Igor's			//	Dspperiodogram/WIN=Hanning tempBin	//	WAVE W_Periodogram	//	powerSpectraFromPeriodogram += W_Periodogram	endfor	//	Print "V_value = ", V_value		Variable windowNormFactor	if (usewindowing)		windowNormFactor = V_Value	//set by windowfunction igor procedure	else		windowNormFactor = 1	endif		powerSpectraAvg /= binCount//	Print "bincount=",bincount		//normalize amplitude (see igor help file for dspperiodogram	powerSpectraAvg /= numpnts(tempBin) * windowNormFactor		if (strlen(ps_outRef) > 0)		Duplicate/O powerSpectraAvg, $ps_outRef	endif	if (strlen(amp_outRef) > 0)		Duplicate/O powerSpectraAvg, $amp_outRef		WAVE ampSpectra = $amp_outRef		ampSpectra = sqrt(powerSpectraAvg)	endif 		Killwaves/Z currFFT, powerSpectraAvg, currPowerSpectra, powerSpectraPlaceholder, powerSpectraAvgDivN, powerSpectraFromPeriodogramendfunction avgFilter(stimWaveRef, respWaveRef, outwaveRef, useWindowing, startX, binSizeX, binStartSpacingX)	String stimWaveRef, respWaveRef, outwaveRef	Variable startX, binSizeX, binStartSpacingX	//size and spacing units of X scaling, e.g. 1 for 1s bins if x is time	//Bin start gap is gap between START of bins, so if you want non-overlapping 1s bins with e.g. 0.1 s space, then the input to these are 0, 1, 1.1	Variable useWindowing		//applies a Hanning window to the data. Changes spectra A LOT. use caution!		Variable  endOfBand = 1000, startOfCutOff = 10000		//works well for preserving shape magnitude of linear filter, but removing weird transient at basically only t = 0, t=1		//check bin size is even, which is required by Igor's FFT	Duplicate/O/R=(startX, startX + binSizeX) $respWaveRef, respTDTemp	Duplicate/O/R=(startX, startX + binSizeX) $stimWaveRef, stimTDTemp		Variable binSizeP = DimSize(respTDTemp,0)	Variable isOdd = mod(binSizeP,2)		//mod(x,2) returns 0 if even, 1 if odd	if (isOdd)		binSizeX -= DimDelta(respTDTemp,0)		Duplicate/O/R=(startX, startX + binSizeX) $respWaveRef, respTDTemp		//should now be even if it wasn't before		Duplicate/O/R=(startX, startX + binSizeX) $stimWaveRef, stimTDTemp		Print "in IF, and binSizeX now = " + num2str(numpnts(respTDTemp))	endif		//make a place to sum the filters as they are generated	fft/dest=avgFilterFD respTDTemp		//avgFilterFD is a complex wave 	avgFilterFD = 0	fft/out=3/dest=avgPowerSpectraFD stimTDTemp		//avgPowerSpectraFD is a real wave	avgPowerSpectraFD = 0	Duplicate/O avgPowerSpectraFD, avgPowerSpectraPlaceholderFD		Variable currBinPosX, binCount = 0	for (currBinPosX = startX; currBinPosX < pnt2x($respWaveRef, DimSize($respWaveRef,0) -1) - binSizeX; currBinPosX += binStartSpacingX)		Duplicate/O/R=(currBinPosX, currBinPosX + binSizeX) $stimWaveRef, stimTDTemp		Duplicate/O/R=(currBinPosX, currBinPosX + binSizeX) $respWaveRef, respTDTemp		setscale/P x, 0, DimDelta(stimTDTemp,0), stimTDTemp, respTDTemp		//this particular line doens't seem to matter, but it makes me feel better!		if(useWindowing)			Hanning stimTDTemp			Hanning respTDTemp		endif		fft/dest=stimFDTemp stimTDTemp		fft/dest=respFDTemp respTDTemp		Duplicate/O/C stimFDTemp, stimFDTempC		stimFDTempC = conj(stimFDTemp)		//convert stimulus in frequency domain to its complex conjugate		avgFilterFD += stimFDTempC * respFDTemp		//this computes the cross-correlation, sums it with all others saved in avgFilterFD		avgPowerSpectraPlaceholderFD = magsqr(stimFDTemp)		avgPowerSpectraFD += avgPowerSpectraPlaceholderFD		binCount+=1	endfor	Variable numPs =  numpnts(stimTDTemp)	avgFilterFD = avgFilterFD[p] / binCount		//converts sum to average//	avgFilterFD *= 1/(numPs * .5) * 2//	avgFilterFD *= 2		avgPowerSpectraFD = avgPowerSpectraFD[p] / binCount	//	avgPowerSpectraFD *= 1/(numPs * 0.375)	//This is the proper weighting for power spectra with a hanning window//	avgPowerSpectraFD *= 1/(0.375)			Duplicate/O/C avgFilterFD, avgFilterFDNorm	avgFilterFDNorm = avgFilterFDNorm /avgPowerSpectraFD	//normalizes to power spectrum of light source	ifft/r/dest=avgFilterTD avgFilterFD	ifft/r/dest=avgFilterTDNorm avgFilterFDNorm	Duplicate/O avgFilterTDNorm, $outWaveRef		Display/K=1 $outwaveRef	AppendToGraph/R=R1 avgFilterTD		//convolve with stimulus to generate prediction	Duplicate/O $stimWaveRef, stimTDTempForConv, stimTDTempForConv_Filt//	if (useWindowing)//		Hanning stimTDTemp//		stimTDTemp *=2//	endif	Duplicate/O avgFilterTDNorm, avgFilterNormTDForConv, avgFilterNormTDForConv_Filt	filterLP("avgFilterNormTDForConv_Filt",  endOfBand, startOfCutOff) 	Convolve avgFilterNormTDForConv, stimTDTempForConv	Convolve avgFilterNormTDForConv_Filt, stimTDTempForConv_Filt	SetScale d, -1,1,"V", stimTDTempForConv, stimTDTempForConv_Filt	WAVE somaReal	Display/K=1	AppendToGraph/C=(0,0,0) somaReal	AppendToGraph/C=(0,0,5000) stimTDTempForConv	AppendtoGraph/C=(50000,0,0) stimTDTempForConv_Filtend//replaced filterLP_old on 5/4/16. Uses IIR filter for less ripplefunction filterLP(waveRef, endOfBand, startOfCutOff)	String waveRef; Variable endOfBand, startOfCutOFF	Make/O/D/N=0 coefs; DelayUpdate	FilterFIR/LO={0.05,0.125,500}/COEF coefs, $waveRef	//	Make/O/D/N=0 coefs; DelayUpdate//	FilterIIR/CASC/LO=0.1/ORD=4/COEF coefs, $waveRefendfunction filterLP_old(waveRef, endOfBand, startOfCutOff)	String waveRef; Variable endOfBand, startOfCutOFF		Duplicate/O $waveRef, toFilterTemp		Make/O/D/N=0 coefs; DelayUpdate	FilterFIR/DIM=0/LO={endOfBand*DimDelta(toFilterTemp,0),startOfCutOFF*DimDelta(toFilterTemp,0),101}/COEF coefs, toFilterTemp	Duplicate/O toFilterTemp, $waveRefend//Make/O/D/N=0 coefs; DelayUpdate//FilterIIR/CASC/LO=0.05/ORD=4/COEF coefs#include <FilterDialog> menus=0 //baseline subtraction should be performed on stimulus and response before passing into this functionfunction avgFilterAndConvolve(stimWaveRef,respWaveRef,outFilterTDRef,outFilterFDRef,outPredictionRef,useWindowing,startX,binSizeX,binStartSpacingX[subEachRep,subOrNormEachRep,baseSubOutput])	String stimWaveRef, respWaveRef, outFilterTDRef, outFilterFDRef, outPredictionRef	Variable startX, binSizeX, binStartSpacingX	//size and spacing units of X scaling, e.g. 1 for 1s bins if x is time	//Bin start gap is gap between START of bins, so if you want non-overlapping 1s bins with e.g. 0.1 s space, then the input to these are 0, 1, 1.1	Variable useWindowing		//applies a Hanning window to the data. Changes spectra A LOT. use caution!	Variable subEachRep			//if passed, DC subtraction is performed on each replicate	Variable subOrNormEachRep	//if passed and set to 0, DC is individually subtracted from the raw response at each bin. if set to 1, filter from each bin is normalized by stimulus power (instead of average normalization at end), if set to 2, both are performed	Variable baseSubOutput			//some residual DC signal sometimes remains, to subtract this pass and set this to 1		Variable baseSubOutputStartX = 0.85, baseSubOutputEndX = inf			//no longer used and currently disabled, although shouldnt take much to re-implement if needed//	Variable doLPFilterOnAvgFilter = 0		//end of Band and start of cutoff only used in this case	Variable  endOfBand = 1000, startOfCutOff = 3000		//works well for preserving shape magnitude of linear filter, but removing weird transient at basically only t = 0, t=1	Variable dpLPFilterOnInput = 0		if (dpLPFilterOnInput)		Duplicate/O $respWaveRef, respWave_LPFilterTemp; respWaveRef = "respWave_LPFilterTemp"		Duplicate/O $stimWaveRef, stimWave_LPFilterTemp; stimWaveRef = "stimWave_LPFilterTemp" 		filterLP(respWaveRef, endOfBand, startOfCutOff)		filterLP(stimWaveRef, endOfBand, startOfCutOff)	endif		//check bin size is even, which is required by Igor's FFT	Duplicate/O/R=(startX, startX + binSizeX) $respWaveRef, respTDTemp	Duplicate/O/R=(startX, startX + binSizeX) $stimWaveRef, stimTDTemp	Variable binSizeP = DimSize(respTDTemp,0)	Variable isOdd = mod(binSizeP,2)		//mod(x,2) returns 0 if even, 1 if odd	if (isOdd)		binSizeX -= DimDelta(respTDTemp,0)		Duplicate/O/R=(startX, startX + binSizeX) $respWaveRef, respTDTemp		//should now be even if it wasn't before		Duplicate/O/R=(startX, startX + binSizeX) $stimWaveRef, stimTDTemp	endif			//make a place to sum the filters as they are generated	fft/dest=avgFilterFD respTDTemp		//avgFilterFD is a complex wave 	avgFilterFD = 0	fft/out=3/dest=avgPowerSpectraFD stimTDTemp		//avgPowerSpectraFD is a real wave	avgPowerSpectraFD = 0	Duplicate/O avgPowerSpectraFD, avgPowerSpectraPlaceholderFD		Variable currBinPosX, binCount = 0, meanTemp	for (currBinPosX = startX; currBinPosX < pnt2x($respWaveRef, DimSize($respWaveRef,0) -1) - binSizeX; currBinPosX += binStartSpacingX)		Duplicate/O/R=(currBinPosX, currBinPosX + binSizeX) $stimWaveRef, stimTDTemp		Duplicate/O/R=(currBinPosX, currBinPosX + binSizeX) $respWaveRef, respTDTemp		setscale/P x, 0, DimDelta(stimTDTemp,0), stimTDTemp, respTDTemp		//this particular line doens't seem to matter, but it makes me feel better!			if (!ParamIsDefault(subEachRep) )				meanTemp = mean(stimTDTemp)			stimTDTemp -= meanTemp			meanTemp = mean(respTDTemp)			respTDTemp -= meanTemp					endif		if(useWindowing)		//			Hanning stimTDTemp			Hanning respTDTemp		endif				fft/dest=stimFDTemp stimTDTemp		fft/dest=respFDTemp respTDTemp		Duplicate/O/C stimFDTemp, stimFDTempC		stimFDTempC = conj(stimFDTemp)		//convert stimulus in frequency domain to its complex conjugate		avgPowerSpectraPlaceholderFD = magsqr(stimFDTemp)				if (ParamIsDefault(subOrNormEachRep) || (subOrNormEachRep < 1) )	//only case where this parameter IS passed and normalization is not performed is when subOrNormEachRep < 1			avgFilterFD += stimFDTempC * respFDTemp		//this computes the cross-correlation, sums it with all others saved in avgFilterFD		else			//subOrNormEachRep is passed and above 0, so normalization is performed			avgFilterFD += stimFDTempC * respFDTemp	 / avgPowerSpectraPlaceholderFD		//computes cross-correlation, and normalizes by the power spectrum of the same 1s bin		endif		avgPowerSpectraFD += avgPowerSpectraPlaceholderFD		binCount+=1	endfor	avgFilterFD = avgFilterFD[p] / binCount		//converts sum to average	avgPowerSpectraFD = avgPowerSpectraFD[p] / binCount	Duplicate/O/C avgFilterFD, avgFilterFDNorm	if (ParamIsDefault(subOrNormEachRep) || subOrNormEachRep < 1)			//do not normalize the average if normalization was performed on a rep by rep basis		avgFilterFDNorm = avgFilterFDNorm /avgPowerSpectraFD	//normalizes to power spectrum of light source. THIS ALIGNS UNITS BUT ALSO SIGNIFICANTLY CHANGES SHAPE OF FILTER	endif	//	ifft/r/dest=avgFilterTD avgFilterFD				//just calculating this in case needed for reference as the normalization changes the shape of the filter so much	ifft/r/dest=avgFilterTDNorm avgFilterFDNorm			//convolve with stimulus to generate prediction		//make extra copies of the stimulus and filter because convolution changes one of the two waves, so just in case we change the wrong one	Duplicate/O $stimWaveRef, stimTDTempForConv	Duplicate/O avgFilterTDNorm, avgFilterNormTDForConv		//low-pass filter the filter (an extremely mild low pass filter, bandpass until 1000 Hz, is enough to remove this horrible artifact of normalizing to the stimulus power spectrum		//igor's built in filter seems safe to use for this mild filtering step, and we are using its FIR filter which won't change phase relationship across frequency components, which also is playing it safe, I think//	if (doLPFilterOnAvgFilter)//		filterLP("avgFilterNormTDForConv",  endOfBand, startOfCutOff) //		fft/dest=avgFilterNormFilteredFD avgFilterNormTDForConv//	endif//		//save the final, used version of the filter	if (!ParamIsDefault(baseSubOutput) && baseSubOutput) 		wave_subMean(avgFilterNormTDForConv,baseSubOutputStartX,baseSubOutputEndX)	endif	Duplicate/O avgFilterNormTDForConv, $outFilterTDRef	fft/dest=$outFilterFDRef avgFilterNormTDForConv		//convolve the filter with the stimulus to generate a prediction of the response	convolution("avgFilterNormTDForConv", "stimTDTempForConv", outPredictionRef,"V")	KillWaves/Z stimTDTemp, stimFDTemp, stimFDTempC, respTDTemp, respFDTemp, avgPowerSpectraPlaceholderFD, avgPowerSpectraFD, avgFilterFDNorm, avgFilterTD	KillWAves/Z stimTDTempForConv, avgFilterNormTDForConv		return binSizeXend  //avgFilterAndConvolve()//may not be working because reverted wn functions to before this was implemented//try starting with 'GB Procedures (all) IGOR7 161212 buBeforeRestoringToDec2017WnAnalysisProcs_wnBrokenHere.ipf' might help remaking this if needed//however, chirps never made very good filters!function chirp_main_repeat(paramsWv,doDisplay,extraParamsRef)	WAVE paramsWv; variable doDisplay	String extraParamsRef		//pass to append extra params. Currently I use a 6 point 1D wave with stimSitEIsPed,stimBaselineHold,stimDuringHold,stimDuringAmplitude,bridgeFileNum,bridgeTypesVI	String notestr=note(paramsWv)		String stimRef=stringbykey("stimRef",notestr)	String respRef_S = stringbykey("respRef_S",notestr)	String respRef_P = stringbykey("respRef_P",notestr)	String notesCellName = stringbykey("notesCellName",notestr)		String infoAppendStr 	if (strlen(respRef_S) > 0)		infoAppendStr = "_S"	else	//hopefully at ped at least then		infoAppendStr = "_P"		endif	Variable startx=paramsWv[%$("startX"+infoAppendStr)]	Variable endx=paramsWv[%$("endx"+infoAppendStr)]	Variable baselineStartX=paramsWv[%$("baselineStartX"+infoAppendStr)]	Variable baselineEndX=paramsWv[%$("baselineEndX"+infoAppendStr)]			if ( (strlen(extraParamsRef) > 0) )		chirp_main(stimRef,respRef_S,respRef_P,startx,endx,baselineStartX,baselineEndX,notesCellName,doDisplay,extraParamsRef=extraParamsRef)	else		chirp_main(stimRef,respRef_S,respRef_P,startx,endx,baselineStartX,baselineEndX,notesCellName,doDisplay)	endifend//may not be working because reverted wn functions to before this was implemented//try starting with 'GB Procedures (all) IGOR7 161212 buBeforeRestoringToDec2017WnAnalysisProcs_wnBrokenHere.ipf' might help remaking this if needed//however, chirps never made very good filters!function/S chirp_main(stimRef,respRef_S,respRef_P,startx,endx,baselineStartX,baselineEndX,notesCellName,doDisplay,[extraParamsRef])	String stimRef,respRef_S,respRef_P	Variable startx,endx		//for the region to analyze	Variable baselineStartX,baselineEndX		//for recording holding current and resting potential	String notesCellName		//optionally pass to store this in param's note	Variable doDisplay	String extraParamsRef		//pass to append extra params. Currently I use a 6 point 1D wave with stimSitEIsPed,stimBaselineHold,stimDuringHold,stimDuringAmplitude,bridgeFileNum,bridgeTypesVI	Variable respAtS = strlen(respRef_S) > 0	Variable respAtP = strlen(respRef_P) > 0	Variable respAtB = respAtS && respAtP		if (numtype(startX))		startX = dimoffset($stimref,0)	endif	if (numtype(endX))		endX = indexToScale($stimref,DimSize($stimref,0),0)	endif	if (numtype(baselineStartX))		baselineStartX = dimoffset($stimref,0)	endif	if (numtype(baselineEndX))		baselineEndX = baselineStartX + 0.01		//10 ms after start	endif		variable delta=dimdelta($stimref,0)	Variable pnts=-((endx-startx)/delta)-1	if (mod(pnts,2))	//force even number of points		endx -= delta	endif	String notestr="ANALYSIS_FUNCTION:chirp_main;"	noteStr+="respAtS:"+num2str(respAtS)+";respAtP:"+num2str(respAtP)+";respAtB:"+num2str(respAtB)+";"	noteStr+="notesCellName:"+notesCellName+";stimRef:"+stimRef+";respRef_S:"+respRef_S+";respRef_P:"+respRef_P+";"	//low pass filtered save refs	String nb=stimRef[0,strlen("G16100100_0000")-1];notestr+="nameBase:"+nb+";"	String stimFiltRef=nb+"_stimFi";notestr+="stimFiltRef:"+stimFiltRef+";"	String respSFiltRef=nb+"_respSFi";notestr+="respSFiltRef:"+respSFiltRef+";"	String respPFiltRef=nb+"_respPFi";notestr+="respPFiltRef:"+respPFiltRef+";"		//power specta for comparison	String stimPowerRef=nb+"_stimPo";notestr+="stimPowerRef:"+stimPowerRef+";"	String respSPowerRef=nb+"_respSPo";notestr+="respSPowerRef:"+respSPowerRef+";"	String respPPowerRef=nb+"_respPPo";notestr+="respPPowerRef:"+respPPowerRef+";"		String stimFDRef=nb+"_stimFD";notestr+="stimFDRef:"+stimFDRef+";"		//somatic FFT and impedence, then smoothed components	String respSFDRef=nb+"_respSFD";notestr+="respSFDRef:"+respSFDRef+";"	String impedenceSFDRef=nb+"_impSFD";notestr+="impedenceSFDRef:"+impedenceSFDRef+";"	String realImpSFDRef=nb+"_realISFD";notestr+="realImpSFDRef:"+realImpSFDRef+";"	String phaseImpSFDRef=nb+"_phISFD";notestr+="phaseImpSFDRef:"+phaseImpSFDRef+";"	String realImpSSmFDRef=nb+"_realISSm";notestr+="realImpSSmFDRef:"+realImpSSmFDRef+";"	String phaseImpSSmFDRef=nb+"_phISSm";notestr+="phaseImpSSmFDRef:"+phaseImpSSmFDRef+";"		//ped FFT and impedence, then smoothed components	String respPFDRef=nb+"_respPFD";notestr+="respPFDRef:"+respPFDRef+";"	String impedencePFDRef=nb+"_impPFD";notestr+="impedencePFDRef:"+impedencePFDRef+";"	String impedencePFDSmoothRef=nb+"_impPFDSm";notestr+="impedencePFDSmoothRef:"+impedencePFDSmoothRef+";"		String realImpPFDRef=nb+"_realIPFD";notestr+="realImpPFDRef:"+realImpPFDRef+";"	String phaseImpPFDRef=nb+"_phIPFD";notestr+="phaseImpPFDRef:"+phaseImpPFDRef+";"	String realImpPSmFDRef=nb+"_realIPSm";notestr+="realImpPSmFDRef:"+realImpPSmFDRef+";"	String phaseImpPSmFDRef=nb+"_phIPSm";notestr+="phaseImpPSmFDRef:"+phaseImpPSmFDRef+";"	//diff and fold diff for complex impedence	String impDifFDRef=nb+"_impDFD";notestr+="impDifFDRef:"+impDifFDRef+";"	String impFDifFDRef=nb+"_impFDFD";notestr+="impFDifFDRef:"+impFDifFDRef+";"		//real and phase components of that 	String realDifFDRef=nb+"_realDFD";notestr+="realDifFDRef:"+realDifFDRef+";"	String realfDifFDRef=nb+"_realFDFD";notestr+="realfDifFDRef:"+realfDifFDRef+";"	String phaseDifFDRef=nb+"_phDFD";notestr+="phaseDifFDRef:"+phaseDifFDRef+";"	String phaseFDifFDRef=nb+"_phFDFD";notestr+="phaseFDifFDRef:"+phaseFDifFDRef+";"			//real and phase differences computed with smoothed impedence and phases	String realSmDifFDRef=nb+"_realSmDFD";notestr+="realSmDifFDRef:"+realSmDifFDRef+";"	String realSmfDifFDRef=nb+"_realSmFDFD";notestr+="realSmfDifFDRef:"+realSmfDifFDRef+";"	String phaseSmDifFDRef=nb+"_phSmDFD";notestr+="phaseSmDifFDRef:"+phaseSmDifFDRef+";"	String phaseSmFDifFDRef=nb+"_phSmFDFD";notestr+="phaseSmFDifFDRef:"+phaseSmFDifFDRef+";"		String paramsOutRef=nb+"_pars";notestr+="paramsOutRef:"+paramsOutRef+";"		Variable powerSmoothParam=21	Variable numFilterCoefs=10001	make/o/d/n=0/free coefs	duplicate/o $stimRef,$stimFiltRef/wave=stimFilt	filterFir/dim=0/lo={0.05,0.15,numFilterCoefs}/coef coefs,stimFilt	//	resample/down=20 stimFilt 	fft/dest=$stimFDRef/RX=(startx,endx) stimFilt	wave/C stimFD=$stimFDRef	Duplicate/o stimFD, $stimPowerRef/wave=stimPower	redimension/r stimPower	stimPower = real(stimFD * conj(stimFD))	Double fdDCStim=real(r2polar(stimfd[0]))		Variable fdLen=dimsize(stimFD,0)	Double holdingStim=mean($stimRef,baselinestartx,baselineendx)	Double holdingS=nan,holdingP=nan,holdingDiff=nan,holdingFDiff=nan	Double fdDCS=nan,fdDCP=nan,fdDCDiff=nan,fdDCFDiff=nan		//dc in frequency domain and soma and ped and diffs	Double fdDCIS=nan,fdDCIP=nan,fdDCIDiff=nan,fdDCIFDiff=nan								//dc impedence in frequency domain of soma and ped	Double fdDCPhS=nan,fdDCPhP=nan,fdDCPhDiff=nan,fdDCPhFDiff=nan		//dc / 1st pnt phase at soma and ped and diffs	if (respAtS)			//filter		duplicate/o $respRef_S,$respSFiltRef/wave=respSfilt		filterFir/dim=0/coef=coefs respSfilt			//resample/down=20 respSfilt			//fft		fft/dest=$respSFDRef/RX=(startx,endx) respSfilt		WAVE/C respSFD=$respSFDRef			//power		duplicate/o respSFD,$respSPowerRef/wave=respSPower		redimension/r respSPower		respSPower = real(respSFD*conj(respSFD))			//impedence		Duplicate/o/C $respSFDRef,$impedenceSFDRef/wave=imp_s		imp_s /= stimFD		duplicate/o imp_s, $realImpSFDRef/wave=realImp_S,$phaseImpSFDRef/wave=phaseImp_S		redimension/r realImp_S,phaseImp_S		realImp_S = real(r2polar(imp_s))		fdDCIS=realImp_S[0]		phaseImp_S=imag(r2polar(imp_s))		fdDCPhS=phaseImp_S[0]		duplicate/o realImp_s,$realImpSSmFDRef/wave=real_s_sm		duplicate/o phaseImp_S,$phaseImpSSmFDRef/wave=phase_s_sm			Smooth powerSmoothParam,real_s_sm,phase_s_sm				holdingS=mean($respRef_S,baselinestartx,baselineendx)		fdDCS = real(r2polar(respSFD[0]))	endif	if (respAtP)			//filter		duplicate/o $respRef_P,$respPFiltRef/wave=respPFilt		filterFir/dim=0/coef=coefs respPFilt		//resample/down=20 	respPFilt			//fft		fft/dest=$respPFDRef/RX=(startx,endx) respPFilt		WAVE/C respPFD=$respPFDRef			//power		duplicate/o respPFD,$respPPowerRef/wave=respPPower		redimension/r respPPower		respPPower = real(respPFD*conj(respPFD))			//impedence		Duplicate/o/C $respPFDRef,$impedencePFDRef/wave=imp_p		imp_p /= stimFD		duplicate/o imp_p, $realImpPFDRef/wave=realImp_P,$phaseImpPFDRef/wave=phaseImp_P		redimension/r realImp_P,phaseImp_P		realImp_P = real(r2polar(imp_P))		fdDCIP=realImp_P[0]		phaseImp_P=imag(r2polar(imp_P))		fdDCPhP=phaseImp_P[0]		duplicate/o realImp_P,$realImpPSmFDRef/wave=real_p_sm			duplicate/o phaseImp_P,$phaseImpPSmFDRef/wave=phase_p_sm			Smooth powerSmoothParam,real_p_sm,phase_p_sm				holdingP=mean($respRef_P,baselinestartx,baselineendx)		fdDCP =real(r2polar(respPFD[0]))	endif	if (respAtB)		//impendence diffs and its components for raw impedence traces		Duplicate/o/c imp_s,$impDifFDRef/wave=imp_d, $impFDifFDRef/wave=imp_fd		imp_d = imp_p - imp_s		imp_fd = imp_p / imp_s				duplicate/o imp_s,$realDifFDRef/wave=real_d,$realfDifFDRef/wave=real_fd,$phaseDifFDRef/wave=phase_d,$phasefDifFDRef/wave=phase_fd		redimension/r real_d,real_fd,phase_d,phase_fd		real_d=real(r2polar(imp_d))		real_fd=real(r2polar(imp_fd))		phase_d=imag(r2polar(imp_d))		phase_fd=imag(r2polar(imp_fd))				//impedence diffs and components for smoothed impedence traces		duplicate/o realImp_S,$realSmDifFDRef/wave=real_d_sm,$realSmfDifFDRef/wave=real_fd_sm,$phaseSmDifFDRef/wave=phase_d_sm,$phaseSmFDifFDRef/wave=phase_fd_sm		real_d_sm=real_p_sm-real_s_sm		real_fd_sm=real_p_sm/real_s_sm		phase_d_sm=phase_p_sm-phase_s_sm		phase_fd_sm=phase_p_sm/phase_s_sm						//some params		holdingDiff=holdingP-holdingS		holdingFDiff=holdingP/holdingS		//slightly meaningless		fdDCDiff = fdDCP-fdDCS		fdDCIFDiff=fdDCP/fdDCS		fdDCIDiff=fdDCIP-fdDCIS		fdDCIFDiff=fdDCIP/fdDCIS			fdDCPhDiff=fdDCPhP-fdDCPhS		fdDCPhFDiff=fdDCPhP/fdDCPhS	endif		make/o/d/n=(24) chirp_main_paramsTemp	//organized below into 5s for easy counting	variable ii=-1	ii+=1;dl_assignAndLbl(chirp_main_paramsTemp,ii,startx,"startx")	ii+=1;dl_assignAndLbl(chirp_main_paramsTemp,ii,endx,"endx")	ii+=1;dl_assignAndLbl(chirp_main_paramsTemp,ii,baselinestartx,"baselinestartx")	ii+=1;dl_assignAndLbl(chirp_main_paramsTemp,ii,baselineendx,"baselineEndx")	ii+=1;dl_assignAndLbl(chirp_main_paramsTemp,ii,holdingStim,"holdingStim")			ii+=1;dl_assignAndLbl(chirp_main_paramsTemp,ii,holdingS,"holdingS")	ii+=1;dl_assignAndLbl(chirp_main_paramsTemp,ii,holdingP,"holdingP")	ii+=1;dl_assignAndLbl(chirp_main_paramsTemp,ii,holdingDiff,"holdingDiff")	ii+=1;dl_assignAndLbl(chirp_main_paramsTemp,ii,holdingFDiff,"holdingFDiff")	ii+=1;dl_assignAndLbl(chirp_main_paramsTemp,ii,fdDCStim,"fdDCStim")		ii+=1;dl_assignAndLbl(chirp_main_paramsTemp,ii,fdDCP,"fdDCP")	ii+=1;dl_assignAndLbl(chirp_main_paramsTemp,ii,fdDCDiff,"fdDCDiff")	ii+=1;dl_assignAndLbl(chirp_main_paramsTemp,ii,fdDCFDiff,"fdDCFDiff")	ii+=1;dl_assignAndLbl(chirp_main_paramsTemp,ii,fdDCIS,"fdDCIS")	ii+=1;dl_assignAndLbl(chirp_main_paramsTemp,ii,fdDCIP,"fdDCIP")		ii+=1;dl_assignAndLbl(chirp_main_paramsTemp,ii,fdDCIDiff,"fdDCIDiff")	ii+=1;dl_assignAndLbl(chirp_main_paramsTemp,ii,fdDCIFDiff,"fdDCIFDiff")		ii+=1;dl_assignAndLbl(chirp_main_paramsTemp,ii,fdDCPhS,"fdDCPhS")	ii+=1;dl_assignAndLbl(chirp_main_paramsTemp,ii,fdDCPhP,"fdDCPhP")	ii+=1;dl_assignAndLbl(chirp_main_paramsTemp,ii,fdDCPhDiff,"fdDCPhDiff")		ii+=1;dl_assignAndLbl(chirp_main_paramsTemp,ii,fdDCPhFDiff,"fdDCPhFDiff")	ii+=1;dl_assignAndLbl(chirp_main_paramsTemp,ii,fdLen,"fdLen")	ii+=1;dl_assignAndLbl(chirp_main_paramsTemp,ii,powerSmoothParam,"powerSmoothParam")	ii+=1;dl_assignAndLbl(chirp_main_paramsTemp,ii,numFilterCoefs,"numFilterCoefs")			String keyedRefList	Variable finalParamLen1Site=nan	if (respATS)		Duplicate/o chirp_main_paramsTemp,chirp_main_paramsTemp_S		keyedRefList="paramsOutRef:"+nameofwave(chirp_main_paramsTemp_S)+";stimFromWinNDCSN:"+stimRef+";respWaveNoDC:"+respREF_s+";respPoweR_FD:"+realImpSSmFDRef+";filterPhase_FD:"+phaseImpSSmFDRef+";"		wn_myCorr3Params_v2("",keyedRefList=keyedRefList,skipFilter=1,powerSmoothParam=0)	//pass smoothing zero so that no further smoothing is performed				finalParamLen1Site=dimsize(chirp_main_paramsTemp_S,0)				if (!respAtP)	//make a placeholder for ped			Duplicate/o/free chirp_main_paramsTemp_S,chirp_main_paramsTemp_P			chirp_main_paramsTemp_P=nan			dl_appendToLbls(chirp_main_paramsTemp_P,0,"_P",0,0,inf)		endif		dl_appendToLbls(chirp_main_paramsTemp_S,0,"_S",0,0,inf)	endif	if (respATP)		Duplicate/o chirp_main_paramsTemp,chirp_main_paramsTemp_P		keyedRefList="paramsOutRef:"+nameofwave(chirp_main_paramsTemp_P)+";stimFromWinNDCSN:"+stimRef+";respWaveNoDC:"+respREF_P+";respPoweR_FD:"+realImpPSmFDRef+";filterPhase_FD:"+phaseImpPSmFDRef+";"		wn_myCorr3Params_v2("",keyedRefList=keyedRefList,skipFilter=1,powerSmoothParam=0)	//pass smoothing zero so that no further smoothing is performed		finalParamLen1Site=dimsize(chirp_main_paramsTemp_P,0)				if (!respAtS)	//make a placeholder for soma			Duplicate/o/free chirp_main_paramsTemp_P,chirp_main_paramsTemp_S			chirp_main_paramsTemp_P=nan			dl_appendToLbls(chirp_main_paramsTemp_S,0,"_S",0,0,inf)		endif		dl_appendToLbls(chirp_main_paramsTemp_P,0,"_P",0,0,inf)	endif			duplicate/o/free chirp_main_paramsTemp_S,outTemp_Diffs,outTemp_fDiffs	if (respAtB)		outTemp_Diffs=chirp_main_paramsTemp_P-chirp_main_paramsTemp_S		outTemp_fDiffs=chirp_main_paramsTemp_P/chirp_main_paramsTemp_S	else		outTemp_Diffs=nan		outTemp_fDiffs=nan	endif		dl_appendToLbls(outTemp_Diffs,0,"_D",0,0,inf)	dl_appendToLbls(outTemp_fDiffs,0,"_fD",0,0,inf)		if ( !ParamIsDefault(extraParamsRef) && (strlen(extraParamsRef) > 0) )		concatenate/np=0/dl/o {$extraParamsRef,chirp_main_paramsTemp_S,chirp_main_paramsTemp_P,outTemp_Diffs,outTemp_fDiffs}, $paramsOutRef/wave=out		else		concatenate/np=0/dl/o {chirp_main_paramsTemp_S,chirp_main_paramsTemp_P,outTemp_Diffs,outTemp_fDiffs}, $paramsOutRef/wave=out		endif		note/nocr out,noteStr		Print "chirp_main():noteStr",noteStr		if (doDisplay)		chirp_main_disp(paramsOutRef)	endif		return paramsOutRefendfunction chirp_main_disp(paramsRef)	String paramsRef		variable start_hz=1,end_hz=150	String notestr = note($paramsRef)		String nb=stringbykey("nameBase",noteStr)	String stimPowerRef=stringbykey("stimPowerRef",noteStr)	String respSPowerRef=stringbykey("respSPowerRef",noteStr)	String respPPowerRef=stringbykey("respPPowerRef",noteStr)		String realImpSFDRef=stringbykey("realImpSFDRef",noteStr)	String realImpPFDRef=stringbykey("realImpPFDRef",noteStr)	String realImpSSmFDRef=stringbykey("realImpSSmFDRef",noteStr)	String realImpPSmFDRef=stringbykey("realImpPSmFDRef",noteStr)		String realfDifFDRef=stringbykey("realfDifFDRef",noteStr)	String realSmfDifFDRef=stringbykey("realSmfDifFDRef",noteStr)		String phaseImpSFDRef=stringbykey("phaseImpSFDRef",noteStr)	String phaseImpSSmFDRef=stringbykey("phaseImpSSmFDRef",noteStr)	String phaseImpPFDRef=stringbykey("phaseImpPFDRef",noteStr)	String phaseImpPSmFDRef=stringbykey("phaseImpPSmFDRef",noteStr)	String phaseFDifFDRef=stringbykey("phaseFDifFDRef",noteStr)	String phaseSmFDifFDRef=stringbykey("phaseSmFDifFDRef",noteStr)		Variable respAtS=numberbykey("respAtS",noteStr)	Variable respAtP=numberbykey("respAtP",noteStr)	Variable respAtB=numberbykey("respAtP",noteStr)		//impedence magnitude	String impedGraphN=nb+"_chirpImp"	if (wintype(impedGraphN))		vis_clearGraph(impedGraphN)	else		display/k=1/n=$impedGraphN		impedGraphN=s_name	endif	if (respAtS)		appendtograph/W=$impedGraphN $realImpSFDRef,$realImpSSmFDRef		modifygraph/W=$impedGraphN rgb($realImpSFDRef)=(0,0,0,19661),rgb($realImpSSmFDRef)=(0,0,0)		//soma black and more translucent noisy version	endif	if (respAtP)		appendtograph/w=$impedGraphN $realImpPFDRef,$realImpPSmFDRef		modifygraph/W=$impedGraphN rgb($realImpPFDRef)=(65535,0,0,19661),rgb($realImpPSmFDRef)=(65535,0,0)	//terminal red	endif	if (respAtB)		appendtograph/R/W=$impedGraphN $realfDifFDRef,$realSmfDifFDRef		modifygraph/W=$impedGraphN rgb($realfDifFDRef)=(1,4,52428,19661),rgb($realSmfDifFDRef)=(1,4,52428)	//difference blue	endif	modifygraph/W=$impedGraphN mode=2,lsize=1.5	setaxis/W=$impedGraphN bottom,start_hz,end_hz	setaxis/W=$impedGraphN/a=2 left	setaxis/W=$impedGraphN/a=2 right		//phases	String phaseGraphN=nb+"_chirpPh"	if (wintype(phaseGraphN))		vis_clearGraph(phaseGraphN)	else		display/k=1/n=$phaseGraphN		phaseGraphN=s_name	endif	if (respAtS)		appendtograph/W=$phaseGraphN $phaseImpSFDRef,$phaseImpSSmFDRef		modifygraph/W=$phaseGraphN rgb($phaseImpSFDRef)=(0,0,0,19661),rgb($phaseImpSSmFDRef)=(0,0,0)		//soma black and more translucent noisy version	endif	if (respAtP)		appendtograph/W=$phaseGraphN $phaseImpPFDRef,$phaseImpPSmFDRef		modifygraph/W=$phaseGraphN rgb($phaseImpPFDRef)=(65535,0,0,19661),rgb($phaseImpPSmFDRef)=(65535,0,0)	//terminal red	endif	if (respAtB)		appendtograph/R/W=$phaseGraphN $phaseFDifFDRef,$phaseSmFDifFDRef		modifygraph/W=$phaseGraphN rgb($phaseFDifFDRef)=(1,4,52428,19661),rgb($phaseSmFDifFDRef)=(1,4,52428)	//difference blue		endif	modifygraph/W=$phaseGraphN mode=2,lsize=1.5	setaxis/W=$phaseGraphN bottom,start_hz,end_hz	setaxis/W=$phaseGraphN/a=2 left	setaxis/W=$phaseGraphN/a=2 right	ModifyGraph/W=$phaseGraphN offset($phaseFDifFDRef)={0,1}	//phase differecnes seem to cancel after division so this helps?	//input FFTs	String graphN=nb+"_chirpFFTs"	if (wintype(graphN))		vis_clearGraph(graphN)	else		display/k=1/n=$graphN		graphN=s_name	endif	appendtograph/w=$graphN/r/c=(30000,30000,30000) $stimPowerRef	if (respAtS)		appendtograph/W=$graphN $respSPowerRef		modifygraph/W=$graphN rgb($respSPowerRef)=(0,0,0)		//soma black and more translucent noisy version	endif	if (respAtP)		appendtograph/W=$graphN $respPPowerRef		modifygraph/W=$graphN rgb($respPPowerRef)=(65535,0,0)	//terminal red	endif	modifygraph/W=$graphN mode=2,lsize=1.5,cmplxmode=1,log=1	setaxis/W=$graphN bottom,start_hz,end_hz	setaxis/W=$graphN/a=2 left	setaxis/W=$graphN/a=2 right	end//baseline subtraction should be performed on stimulus and response before passing into this functionfunction analysis_avgPowerSpectraOrCross(inWaveRef,outWaveRef,windowKind,startX,endX,binSizeX,binStartSpacingX,normCrossCorr,[subEachRep,inWave2Ref,tdOutputRef,fdRepsOutputRef,tdRepsOutputRef])	String inWaveRef, outWaveRef	Double startX, endX, binSizeX, binStartSpacingX	//size and spacing units of X scaling, e.g. 1 for 1s bins if x is time	//Bin start gap is gap between START of bins, so if you want non-overlapping 1s bins with e.g. 0.1 s space, then the input to these are 0, 1, 1.1	Variable normCrossCorr	//pass true to normalize cross-correlation to variance of the signals (as in e.g., Ala-Laurila et al. Rieke 2011). Otherwise it's technically cross-covariance  it seems								//currently ignored for power spectra	String inWave2Ref		//optional ref to wave to use in cross power spectrum	String fdRepsOutputRef, tdRepsOutputRef		//pass a reference into which individual bin results (that are averaged for the main frequency or time domain outputs) 	String windowKind			//pass blank if no windowing is to be performed	Variable subEachRep			//if passed and set to 0, DC is individually subtracted from the raw response at each bin. if set to 1, filter from each bin is normalized by stimulus power (instead of average normalization at end), if set to 2, both are performed	String tdOutputRef			//pass a ref to save a time domain version of the output to; most applicable when wanting a cross-correlation			//determine whether to store reps	Variable storeReps_fd = !ParamIsDefault(fdRepsOutputRef) && (strlen(fdRepsOutputRef) > 0)	Variable storeReps_td = !ParamIsDefault(tdRepsOutputRef) && (strlen(tdRepsOutputRef) > 0)		//check start position	if ( (startX < DimOffset($inWaveRef,0)) || numtype(startX) )		startX =  DimOffset($inWaveRef,0)				//default is startX at beginning of wave	endif		//garauntee bin size is even, which is required by Igor's FFT	Variable binSizeP = binSizeX / dimdelta($inWaveRef,0)	if (mod(binSizeP,2))		//true for odd		binSizeP -=1	endif	//used to use endX rather than binSizeP, but every once a while a rounding issue can lead to changes in bin numbers (by one, switching from odd to even or vis versa)	Duplicate/O/R=[x2pnt($inWaveref,startX), x2pnt($inWaveref,startX) + binSizeP] $inWaveRef, inWaveTemp	if (mod(dimsize(inWaveTemp,0),2))		//true for odd		binSizeP -=1		Duplicate/O/R=[x2pnt($inWaveref,startX), x2pnt($inWaveref,startX) + binSizeP] $inWaveRef, inWaveTemp	endif		//determine whether this is a cross power spectrum	Variable crossPS	if (!ParamIsDefault(inWave2Ref))		if (DimDelta($inWaveRef,0) != DimDelta($inWave2Ref,0))			Print "currently avgPowerSpectraOrCross does not support waves with different sampling rates"			return 0		endif		crossPS = 1; Double currVar_s1, currVar_s2, totVar_s1 = 0, totalVar_s2 = 0		//latter two variables will track total variance		Duplicate/O/R=[x2pnt($inWaveref,startX), x2pnt($inWaveref,startX) + binSizeP] $inWaveRef, inWave2Temp		if (mod(dimsize(inWave2Temp,0),2))		//true for odd			binSizeP -=1			Duplicate/O/R=[x2pnt($inWaveref,startX), x2pnt($inWaveref,startX) + binSizeP] $inWaveRef, inWave2Temp		endif	else		crossPS = 0	endif			//make a place to sum the PSs as they are generated	if (crossPS)		fft/dest=avgPS inWaveTemp			//avgPS is complex for cross PS		Duplicate/O/C avgPS, avgPStempCross			//avoids errors from some incorrect type limitation in magsqr function	else		fft/out=3/dest=avgPS inWaveTemp		//out=3 causes avgPS to be a real wave, with proper scaling		Duplicate/O avgPS, avgPSTemp	endif	avgPS = 0		//determine endpoint 	Double lastBinStartX	Double inLenX = DimSize($inWaveRef,0) * DimDelta($inWaveRef,0); Print "inLenX", inLenX	if ( numtype(endX) || (endX > inLenX) )		//if larger than end of wave or not a real number		lastBinStartX = inLenX - DimDelta($inWaveRef,0)	- 1.2*binSizeX	//last bin must start one more point than one bin length from the end	else		lastBinStartX = endX - DimDelta($inWaveRef,0)	- 1.2*binSizeX	//last bin must start one more point than one bin length from user-input end	endif		Double currBinPosX, binCount = 0, meanTemp; Variable windowGain = 1	//default 1, but set to proper value if windowing is performed	for (currBinPosX = startX; currBinPosX < lastBinStartX; currBinPosX += binStartSpacingX)		//get bin(s)		Duplicate/O/R=[x2pnt($inWaveref,currBinPosX), x2pnt($inWaveref,currBinPosX) + binSizeP] $inWaveRef, inWaveTemp		setscale/P x, 0, DimDelta(inWaveTemp,0), inWaveTemp		//this particular line doens't seem to matter, but it makes me feel better! (shifts start time to zero for this component)		if (crossPS)			Duplicate/O/R=[x2pnt($inWaveref,currBinPosX), x2pnt($inWaveref,currBinPosX) + binSizeP] $inWave2Ref, inWave2Temp			setscale/P x, 0, DimDelta(inWave2Temp,0), inWave2Temp		//this particular line doens't seem to matter, but it makes me feel better! (shifts start time to zero for this component)		endif		//		Print "lastBinStartX",lastBinStartX,"inWaveTemp numpnts=",dimsize(inWaveTemp,0),"currBinPosX",currBinPosX,"currBinPosX+binLenX",currBinPosX+dimsize(inWaveTemp,0)*dimdelta(inWaveTemp,0)			//baseline substraction if needed		if (!ParamIsDefault(subEachRep)) 				meanTemp = mean(inWaveTemp)			inWaveTemp -= meanTemp				if (crossPS)				meanTemp = mean(inWave2Temp)				inWave2Temp-=meanTemp			endif				endif				//windowing if needed		if(strlen(windowKind) > 0)			WindowFunction/FFT $windowKind, inWaveTemp			//according to igor, one can correct for the loss in FFT amplitude of windowing by dividing the FFT by the coherent or incorent gain of the window function. 			//Coherent gain is the sum of the window coefficients over the window's interval. incoherent gain is the sum of squares of those coefficients.			//according to /NOR flag, normally one divides by this when windowing (not by the sqrt of it, which I would imagine might be what one would do with the FFT)			//one also divides by the numpnts of the time domain in either case			windowGain = V_value			if (crossPS)				WindowFunction/FFT $windowKind, inWave2Temp			endif		endif				fft/dest=inWaveFFT_forPS_temp inWaveTemp			//compute FFT. then PS is magsqr of FFT				if (crossPS)			//handles cross power spectrum			fft/dest=inWave2FFT_forPS_temp inWave2Temp				inWave2FFT_forPS_temp = conj(inWave2FFT_forPS_temp)			//cross PS is just like PS (which equals FFT1* conj(FFT1), same as magsqr(FFT), except that crossPS is FFT1 * conj FFT2			avgPStempCross = inWaveFFT_forPS_temp * inWave2FFT_forPS_temp			avgPStempCross /= binSizeP; avgPStempCross /= windowGain						//handle variance analysis and normalize to it if normCrossCorr			currVar_s1 = variance(inWaveTemp); currVar_s2 = variance(inWave2Temp)			totVar_s1 += currVar_s1; totalVar_s2 += currVar_s2		//stored in wave note			if (normCrossCorr)				avgPSTempCross /= sqrt(currVar_s1 * currVar_s2)			endif			avgPS += avgPSTempCross									//handle fd rep storage			if (storeReps_fd)				if (binCount == 0)		//first bin, create output wave					Duplicate/O avgPSTempCross, $fdRepsOutputRef				else					Concatenate/NP=1/DL {avgPSTempCross}, $fdRepsOutputRef		//concatenate, NP=1 along columns				endif			endif						//handle td rep storage			if (storeReps_td)				analysis_powerSpecToCorrelation(avgPSTempCross, "tdRepTemp")				if (binCount == 0)		//first bin, create output wave					Duplicate/O $"tdRepTemp", $tdRepsOutputRef				else					Concatenate/NP=1/DL "tdRepTemp;", $tdRepsOutputRef		//concatenate, NP=1 along columns				endif							endif					else		//handles power spectrum (autocorrelation in time domain)			avgPSTemp = magsqr(inWaveFFT_forPS_temp)			//for some absurd reason one has to obscure the type of avgPS from the compiler. avgPSTemp is just a duplicate of avgPS, but an inconsistent type error happens at compilation if avgPS is copied to directly 			avgPSTemp /= binSizeP; avgPSTemp /= windowGain			avgPS += avgPSTemp			//handle fd rep storage			if (storeReps_fd)				if (binCount == 0)		//first bin, create output wave					Duplicate/O avgPSTemp, $fdRepsOutputRef				else					Concatenate/NP=1/DL {avgPSTemp}, $fdRepsOutputRef		//concatenate, NP=1 along columns				endif			endif												//handle td rep storage			if (storeReps_td)				analysis_powerSpecToCorrelation(avgPSTemp, "tdRepTemp")				if (binCount == 0)		//first bin, create output wave					Duplicate/O $"tdRepTemp", $tdRepsOutputRef				else					Concatenate/NP=1/DL "tdRepTemp;", $tdRepsOutputRef		//concatenate, NP=1 along columns				endif			endif					endif				binCount+=1	endfor		Print "numbins = " + num2str(binCount)		avgPS /= binCount		if (strlen(windowKind) > 0)		//need to adjust amplitude of FFT to compensate for window function		if (storeReps_td)			WAVE tdRepsOutputWv = $tdRepsOutputRef		endif		if (storeReps_fd)			WAVE fdRepsOutputWv = $fdRepsOutputRef		endif		Print "Window normalized by: " + num2str(windowGain)	endif		Print "Frequency resolution (frequency bin size, Hz) = " + num2str(DimDelta(avgPS,0))		Duplicate/O avgPS, $outWaveRef		if (!ParamIsDefault(tdOutputRef))		analysis_powerSpecToCorrelation(avgPS, tdOutputRef)	endif		KillWaves/Z stimTDTemp, stimFDTemp, stimFDTempC, respTDTemp, respFDTemp, avgPowerSpectraPlaceholderFD, avgPowerSpectraFD, avgFilterFDNorm, avgFilterTD	KillWAves/Z stimTDTempForConv, avgFilterNormTDForConvend	//analysis_avgPowerSpectraOrCrossfunction/S analysis_autocorrelationStats(autoCorrelationWv, outRef)	WAVE autoCorrelationWv	String outRef		if (strlen(outRef) < 1)		outRef = NameOfwave(autoCorrelationWv) + "acp"	endif			wavestats/W/Q/C=1 autoCorrelationWv	WAVE M_wavestats	Duplicate/O/R=[][0] M_wavestats, $outRef	Redimension/N=(-1,0) $outRef		Double fwhmBaselineProportion = 0.1		//proportion of total length from start to count as baseline,since usually autocorrelations (as generated in analysis_avgPowerSpectraOrCross()/analysis_powerSpecToCorrelation() ceenter at zero)	Double totalLenX = DimSize(autoCorrelationWv,0)*DimDelta(autoCorrelationWv,0)	Double fwhmBaselineLen = totalLenX * fwhmBaselineProportion	Double fwhmBaselineStartX = DimOffset(autoCorrelationWv,0)		//first position_x	Double fwhmBaselineEndX = fwhmBaselineStartX + fwhmBaselineLen		Double fwhmPostBaselineEndX = DimOffset(autoCorrelationWv,0) + totalLenX	//last position_x	Double fwhmPostBaselineStartX =  fwhmPostBaselineEndX - fwhmBaselineLen		//total len - baselineProportionLen	analysis_fwhm(autoCorrelationWv, "analysis_fwhmInfoTemp", fwhmBaselineStartX, fwhmBaselineEndX, fwhmPostBaselineEndX, fwhmPostBaselineStartX)	WAVE analysis_fwhmInfoTemp	wave_cat_NP_withDimLabels("analysis_fwhmInfoTemp;",outRef,0, 1)		return outRefend//not functioning -- to do this, need to concatenate into a different wavefunction/S wave_cat_NP_withDimLabels(appendList,destRef,dimForCat, killAppendListWaves)	String destRef		//destination wave: if none is passed, first in appendList is duplicated into this to start with	String appendList	//appended to destRef in order from first to last	Variable dimForCat	//dimension along which to concatenate, e.g. 0 to add additional rows, 1 for additional columns, so on	Variable killAppendListWaves	//pass to delete appendList waves following their concatenation		if (strlen(destRef) < 1)		destRef = RemoveListItem(0, appendList)	endif		Variable destIndex = DimSize($destRef, dimForCat)	//start position for appending dimension labels		print "appendList", appendList		Concatenate/NP=(dimForCat)/DL appendList, $destRef/WAVE=dest		//result has dimension labels for destRef values only	Variable i,j,currDestIndexEnd	String labelStr		variable outIndex=0	for (i=0;i<ItemsInList(appendList);i+=1)		WAVE appendWv = $StringFromList(i,appendList)				for (j=0;j<DimSize(appendWv,dimForCat);j+=1)		//iterate destIndex until all labels has been transferred for current wave			labelStr = GetDimLabel(appendWv, dimForCat, j )			SetDimLabel dimForCat,outIndex,$labelStr,$destRef			outIndex+=1		endfor				if (killAppendListWaves)			killwaves/Z appendWv		endif	endfor	return destRefendfunction/S disp_winIDHandling(winN, doNewGraph, killOptions)	String winN; Variable doNewGraph	Variable killOptions		//what to do if graph exists and a new graph si requested?									//0=no kill, 1 = kill with user check, 2=kill without any further check		if (!doNewGraph)		//find top window 		if (strlen(winN) < 1)				//not doing a new graph and no winN passed, return top window name			winN = winname(0,1)				if (strlen(winN) < 1)		//no window found				display/k=1				//auto generate name				return S_name			//return that autogenerated name			endif		endif				if (wintype(winN) > 0)			//does the top win or passed win name exist? if so return for use		return winN	else								//otherwise make that window and send, should be no confict		//continue to display .. since need to make new win	endif			else					//new graph		if (!killOptions || !strlen(winN))		//display, if graph exists, a new name is generated by display			display/N=$winN /k=1					return S_Name 		elseif (killOptions == 1)		//kill after prompt			if (wintype(winN))				Variable reallyKillWindow = 1				prompt reallyKillWindow, "Request to kill and remake="+winN+ ". Do kill? [1: yes. 0: no.]"				doprompt "disp_winIDHandling()", reallyKillWindow				if (reallyKillWindow)					killWindowsByName(winN)					//continue to display				else					display/N=$winN /k=1					winN = S_name					return winN				endif			else				//win doesnt exist, continue to display			endif		else 	//kill options > 1 presumably			killWindowsByName(winN)			//continue to display		endif	endif		display/N=$winN /k=1		//should be no conflict but we can check that	if (!stringmatch(winN,s_name))		Print "disp_winIDHandling(): unexpected window name conflict. requested name",winN,"actual name (will be used)", S_name	endif	return S_Name 	endfunction vi_disp_summaries_all(paramWv,cellName)	WAVE paramWv; string cellName		String nstr = note(paramWv)		Variable steps_fS = str2num(stringbykey("steps_fs",nstr))	Variable resp_pfs = str2num(stringbykey("resp_pfs",nstr))	Variable steps_fP = str2num(stringbykey("steps_fP",nstr))	Variable resp_sfp = str2num(stringbykey("resp_sfp",nstr))		String testStep_outRef_SfS=stringbykey("testStep_outRef_SfS",	nstr)	//testStep_outRef_SfS:G16110209_0004_ts_SfS;steps_fs:1;steps_fP:0;	String testStep_outRef_PfS=stringbykey("testStep_outRef_PfS",	nstr);print "testStep_outRef_PfS",testStep_outRef_PfS	String testStep_outRef_PfP=stringbykey("testStep_outRef_PfP",	nstr)	String testStep_outRef_SfP=stringbykey("testStep_outRef_SfP",	nstr)		String winN	if (steps_fS)		winN = vi_disp_summaries($testStep_outRef_SfS,$testStep_outRef_SfS,0,cellName+"_SfS","b")		if (resp_pfs)			vi_disp_summaries($testStep_outRef_PfS,$testStep_outRef_PfS,1,cellName+"_PfS","R")		endif	endifendfunction/S vi_disp_summaries(yParamWv,xParamWv,appendtoTopWin,winN,colorStr)	WAVE yParamWv,xParamWv		//any param wave generated by VI_repsAndFamily2Site() should do	Variable appendtoTopWin;string winN	//see disp_rowsVsRows	String colorStr				//like accetped by vis_getColorForGraph		String yParams = "resp_ssBaselineDiff;resp_peakBaselineDiff;resp_threshProps_6_ssB_rDX;resp_lineBaselineCross_relStep;"	String yLabels = "ssToBaseline (V \\U);peakToBaseline (V \\U);Time to 1/e from final (S \\U);Line fit cross (S \\U);"	String yAxNs = "L_Vresp;L_vResp;L_riseTime;L_lineCross;"	String yLog = "0;0;0;0;"	String lineStyle =	"0;8;0;0;"			//vis_getColorForGraph	String colors = "z;z;z;z;"				//z is wildcard that will be switched with colors input		String xParam = "stim_ri_deltaMean"	String xLabel = "stim_step - baseline  (A \\U)"	String xAxN = "bottom"	String xLog = "0"		string dimLabelAxLabelLogPairs = ""	Variable i; string str	for (i=0;i<ITemsInList(yParams);i+=1)		dimLabelAxLabelLogPairs+=Stringfromlist(i,yParams)+","		dimLabelAxLabelLogPairs+=Stringfromlist(i,yLabels)+","		dimLabelAxLabelLogPairs+=Stringfromlist(i,yAxNs)+","		dimLabelAxLabelLogPairs+=Stringfromlist(i,yLog)+","		dimLabelAxLabelLogPairs+=Stringfromlist(i,lineStyle)+","		dimLabelAxLabelLogPairs+= ReplaceString("z",Stringfromlist(i,colors),colorStr)+","		dimLabelAxLabelLogPairs+=xParam+","		dimLabelAxLabelLogPairs+=xLabel+","		dimLabelAxLabelLogPairs+=xAxN+","		dimLabelAxLabelLogPairs+=xLog+","				dimLabelAxLabelLogPairs += ";"	endfor			return disp_rowsVsRows(nameofwave(yParamWv),nameofwave(xParamWv),dimLabelAxLabelLogPairs,appendtoTopWin,winN)end//example of what might be passed to this function for String dimLabelAxLabelLogPairs = ""//		dimLabelAxLabelLogPairs += "phase_rad_stim_v1,Ph stim (rad.),0,freq_Hz_stim,Frequency (Hz),0;"//		dimLabelAxLabelLogPairs += "phase_rad_resp_v1,Ph resp (rad.),0,freq_Hz_stim,Frequency (Hz),0;"function/S disp_rowsVsRows(yParamsRef,xParamsRef,dimLabelAxLabelLogPairs,appendToTopWin,winN)	String yParamsRef,xParamsRef		//param refs containing rows of data -- if xParamsRef = "" sets xParamsRef = yParamsRef by default	String dimLabelAxLabelLogPairs	//formatted list deciding what rows to plot. format:"[row0_yDimLabel],[row0_yAxLabel],[row0_yUsesLogScale],[row0_xDimLabel],[row0_xAxLabel],[row0_xUsesLogScale];[row1_yDimLAbel]..."	Variable appendToTopWin		//0 for new window, 1 for append to top win	String winN		Variable yDL=0,yL=yDL+1,yAx=yL+1,yLog=yAx+1,lineStyle=yLog+1,color=lineStyle+1		//color contains an input to vis_getColorForGraph	Variable xDL=color+1,xL=xDL+1,xAx=xL+1,xLog=xAx+1	//	Print yDL,yL,yAx,yLog,xDL,xl,xax,xlog		if (!strlen(xParamsRef))		xParamsRef = yParamsRef	endif		WAVE/D yAxWv = $yParamsRef	WAVE/D xAxWv = $xParamsRef				//get a unique basis for the trace names, considering that one might append data from more than one paramWv to the same graph	String traceNameBase = nameofwave(yAxWv)[strlen("G16110201_0015"),inf]	if (stringmatch(traceNameBase[0],"_"))		traceNameBase = traceNameBase[1,inf]	endif			if (appendToTopWin)		if (strlen(WinN) < 1)			winN = winname(0,1)		endif	else		if (strlen(winN) < 1)			display/k=1		else			display/k=1/N=$winN		endif		winN = S_name	endif	Variable numAxes = ItemsInList(dimLabelAxLabelLogPairs)	Variable axSpacing = 0.015	Variable totalAxSpacing	Variable totalAxRoom	Variable roomPerAx	Variable tn_rep,i,y_doLog,x_doLog,axStart,axEnd,yIndex,xIndex,lstyle; string pair,yParam, xParam	String colorStr; variable r,g,b	String yAxN, xAxN,yLbl,xLbl, tn	for (i=0;i<numAxes;i+=1)		pair = stringfromlist(i,dimLabelAxLabelLogPairs)		yParam = stringfromlist(yDL,pair,",")		yAxN = stringfromlist(yAx,pair,",")		if (!strlen(yAxN))			yAxN = "L_" + yParam		else			if (!stringmatch(yAxN[0],"L"))				yAxN = "L_"+yAxN			endif		endif		yAxN = text_makeStrPresentable(yAxN)		yIndex = FindDimLabel(yAxWv, 0, yParam)		xParam = stringfromlist(xDL,pair,",")		xAxN = stringfromlist(xAx,pair,",")		if (!strlen(yAxN))			xAxN = "L_" + xParam		else			if (!stringmatch(xAxN[0],"B"))				xAxN = "B_"+xAxN			endif		endif		xAxN = text_makeStrPresentable(xAxN)		xIndex = FindDimLabel(xAxWv, 0, xParam)		yLbl = stringfromlist(yL,pair,",")		xLbl = stringfromlist(xL,pair,",")		y_doLog = str2num(stringfromlist(yLog,pair,","))		x_doLog = str2num(stringfromlist(xLog,pair,","))		tn = text_makeStrPresentable(traceNameBase + yParam + "_"+num2str(y_doLog) + "_v_" + xParam)		lstyle = str2num(stringfromlist(lineStyle,pair,","))		colorStr = stringfromlist(color,pair,",")		vis_getColorForGraph(colorStr, r, g, b) 		appendtograph/W=$winN/L=$yAxN/B=$xAxN/c=(r,g,b) yAxWv[yIndex][]/TN=$tn vs xAxWv[xIndex][]		modifygraph/W=$winN log($yAxN)=y_doLog,log($xAxN)=x_doLog	,lstyle($tn)=lstyle//,mode($tn)=4,marker($tn)=marker,lstyle($tn)=lstyle_avg		Label/W=$winN $yAxN, yLbl		Label/W=$winN $xAxN, xLbl	endfor	modifygraph/W=$winN freepos=0,lblpos=50,fsize=8	SetAxis/A/N=1/W=$winN		// y average name conflict		String axisN,L_axisList = ListMatch(axislist(winN), "L*")	Variable L_numAxes = itemsinlist(L_axisList)//	Variable B_numAxes = itemsinlist(ListMatch(axislist(winN, "B*")))	totalAxSpacing = axSpacing * (L_numAxes-1)	totalAxRoom = 1 - totalAxSpacing	roomPerAx = totalAxRoom/L_numAxes	for (i=0;i<L_numAxes;i+=1)		axStart = i*axSpacing + i*roomPerAx		axend = axStart + roomPerAx		axisN = stringfromlist(i,L_axisList)		modifygraph/W=$winN axisenab($axisN)={axStart,axEnd}	endfor		return winNendfunction/s disp_cols_simple(wv,appendToTop,[r,axN,rgba,postCmdStr,skipCols,layer,layerLbl,byRows,startIndex,endIndex,chunk,lblByScaling,lblByScalingWv,xLayerLbl,hook,rev])	WAVE wv	Variable r //pass r to use right axis instead of left	Variable appendToTop		//pass to append to top graph	String axN		//foce an axis name	WAVE rgba	string postCmdStr	Variable skipCols		//for picking a subrange of start cols	Variable layer,chunk	String layerLbl	//pass this or a layer number for 3D waves..this supercedes layer if both are passed	Variable byRows	Variable startIndex,endIndex	Variable lblByScaling		//label each trace by the y scaling of the column (or x scaling of the row in case of byRow=1)	WAVE lblByScalingWv		//pass a wave of x scaling. Ignored unless lblByScaling is also passed. This is useful for non-uniform x steps	String xLayerLbl		//[only implemented with layerLbl passed as well (so far)] optionally pass an xLabelLayer specifying the layer from which x values should come							//x values will be assumed to be along columns if plotting y data along columns or along rows if plotting y data along rows	Variable hook	Variable rev		//reverse order		String tns=""		Variable hasLayerLbl=!paramIsdefault(layerLbl) && (strlen(layerLbl)>0)	Variable usedChunk = ParamIsDefault(chunk) ? 0 : chunk	Variable usedLayer		//only matters in absence of layerLbl	if (ParamIsDefault(layer) || numtype(layer))		usedLayer = 0 	else		usedLayer = layer	endif		Variable hasXLayer=!paramisDefault(xLayerLbl) && (strlen(xLayerLbl)>0)		Variable reverseOrder=!ParamIsDefault(rev) && rev		if (PAramIsDefault(rgba))		make/o/u/free ur={-1+2^16,0,0,-1+2^16}	else		duplicate/o/free/u rgba,ur	endif		if (!appendToTop)		display/k=1		String winN = S_name	else		winN = winname(0,1)	endif		Variable doRows=!paramIsDefault(byRows) && byRows	variable i,numCols = dimsize(wv,doRows?0:1)	Variable useRightAx=!ParamIsDefault(r) && r	String ua	if (ParamIsDefault(axN))		if (useRightAx)			ua="right"		else			ua="left"		endif	else		ua = axN	endif		Variable startP=Paramisdefault(startindex) || numtype(startindex) || (startIndex<0)? 0 : startIndex,endP=Paramisdefault(endIndex) || numtype(endIndex) || (endIndex>numCols)? numCols : endIndex	Variable ind	Variable iter=ParamIsDefault(skipCols)||(numtype(skipCols))?1:skipCols	Variable doLabelByScaling = !ParamIsDefault(lblByScaling) && lblByScaling	string tn	if (useRightAx)		for (i=startP;i<endP;i+=iter)			ind=reverseOrder? (endP-i-1) : i			if (doLabelByScaling)				if (!ParamIsDefault(lblByScalingWv))					tn=nameofwave(wv)+"_t"+text_num2str(lblByScalingWv[ind])				else					tn=nameofwave(wv)+"_t"+text_num2str(indextoscale(wv,ind,!doRows))				endif			else				tn=nameofwave(wv)+"_t"+num2stR(ind)			endif						if (hasLayerLbl)				if (doRows)					if (hasXLayer)						appendtograph/c=(ur[0],ur[1],ur[2],ur[3])/W=$winN/R=$ua wv[ind][][%$layerLbl][usedChunk]/tn=$tn vs wv[ind][][%$xLayerLbl][usedChunk] 					else							appendtograph/c=(ur[0],ur[1],ur[2],ur[3])/W=$winN/R=$ua wv[ind][][%$layerLbl][usedChunk]/tn=$tn					endif				else					if (hasXLayer)						appendtograph/c=(ur[0],ur[1],ur[2],ur[3])/W=$winN/R=$ua wv[][ind][%$layerLbl][usedChunk]/tn=$tn					else						appendtograph/c=(ur[0],ur[1],ur[2],ur[3])/W=$winN/R=$ua wv[][ind][%$layerLbl][usedChunk]/tn=$tn vs wv[][ind][%$xLayerLbl][usedChunk]					endif				endif			else				if (doRows)					appendtograph/c=(ur[0],ur[1],ur[2],ur[3])/W=$winN/R=$ua wv[ind][][usedLayer][usedChunk]/tn=$tn				else					appendtograph/c=(ur[0],ur[1],ur[2],ur[3])/W=$winN/R=$ua wv[][ind][usedLayer][usedChunk]/tn=$tn					endif			endif			tns+=tn+";"			endfor	else		for (i=startP;i<endP;i+=iter)			ind=reverseOrder? (endP-i-1) : i			if (doLabelByScaling)				if (!ParamIsDefault(lblByScalingWv))					tn=nameofwave(wv)+"_t"+text_num2str(lblByScalingWv[ind])				else					tn=nameofwave(wv)+"_t"+text_num2str(indextoscale(wv,ind,!doRows))				endif			else				tn=nameofwave(wv)+"_t"+num2stR(ind)			endif						if (hasLayerLbl)				if (doRows)					if (hasLayerLbl)						if (hasXLayer)							appendtograph/c=(ur[0],ur[1],ur[2],ur[3])/W=$winN/L=$ua wv[ind][][%$layerLbl][usedChunk]/tn=$tn	vs  wv[ind][][%$xLayerLbl][usedChunk]						else							appendtograph/c=(ur[0],ur[1],ur[2],ur[3])/W=$winN/L=$ua wv[ind][][%$layerLbl][usedChunk]/tn=$tn						endif					else						appendtograph/c=(ur[0],ur[1],ur[2],ur[3])/W=$winN/L=$ua wv[ind][][%$layerLbl][usedChunk]/tn=$tn						endif				else					if (hasLayerLbl)						if (hasxLayer)							appendtograph/c=(ur[0],ur[1],ur[2],ur[3])/W=$winN/L=$ua wv[][ind][%$layerLbl][usedChunk]/tn=$tn	vs wv[][ind][%$xLayerLbl][usedChunk]						else							appendtograph/c=(ur[0],ur[1],ur[2],ur[3])/W=$winN/L=$ua wv[][ind][%$layerLbl][usedChunk]/tn=$tn						endif					else						appendtograph/c=(ur[0],ur[1],ur[2],ur[3])/W=$winN/L=$ua wv[][ind][%$layerLbl][usedChunk]/tn=$tn						endif				endif			else				if (doRows)					appendtograph/c=(ur[0],ur[1],ur[2],ur[3])/W=$winN/L=$ua wv[ind][][usedLayer][usedChunk]/tn=$tn					else					appendtograph/c=(ur[0],ur[1],ur[2],ur[3])/W=$winN/L=$ua wv[][ind][usedLayer][usedChunk]/tn=$tn				endif			endif			tns+=tn+";"				endfor	endif		if (!PAramIsDefault(postCmdStr) && (strlen(postCmdStr) > 0))		disp_general_ta(postCmdStr,0,tns,winN,1)	endif		if (!ParamIsDefault(hook) && hook)		setwindow $winN hook(disp_cols_simple_winHook)=disp_cols_simple_winHook	endif		return tnsendfunction/s text_num2str(num)	Double num		String str = replacestring(".",num2str(num),"p")	str= replacestring("+",str,"a")	str= replacestring("-",str,"m")		return strendfunction text_str2num(str)	String str		if (stringmatch(str,"NaN"))		return NaN	endif	if (stringmatch(str,"inf"))		return inf	endif	if (stringmatch(str,"-inf"))		return -inf	endif		str=replacestring("p",str,".")	str=replacestring("a",str,"+")	str=replacestring("m",str,"-")	str=replacestring("n",str,"-")		return str2num(str)end//allows iteration through traces via left/right keyboard,turning the selected trace black and returning ones that were selected to original//pressing delete removes any changefunction disp_cols_simple_winHook(s)	STRUCT WMWinHookStruct &s		Variable cr=0,cg=0,cb=0,ca=-1+2^16		//colors for highlighting	Variable lstyle=1		//not yet used	Variable lsize=2.5	//not yet used	Variable normStepSize=1	VAriable shiftStepSize=normStepSize*10		if (s.eventcode != 11)	// need Keyboard event		return 0	endif		Variable leftArrow=s.keycode==28	Variable rightArrow=s.keycode==29	Variable delete=s.keycode==127	Variable ctrl=(s.eventmod & 2^3) > 0		//ignore with control key down		if (ctrl || ( !leftArrow && !rightArrow && !delete))		return 0	endif		Variable shift = (s.eventmod & 2^1) > 0	String traces=tracenamelist(s.winname,";",1)	Variable numTraces=itemsinlist(traces)	if (numTraces<1)		return 0	endif		String prevTraceName = getuserdata(s.winname,"","prevTraceName")	Variable prevtraceNum=whichlistitem(prevTraceName,traces), newTraceNum,oldAlpha	String prevTraceInfo,newTraceName,prevRgba	//figure out new trace number	if (prevtraceNum<0)		newTraceNum=0	else		prevTraceInfo=getuserdata(s.winname,"","prevTraceInfo")		newTraceNum=prevTraceNum+ (shift ? shiftStepSize : normStepSize)*(leftArrow ? -1 : 1)		//wrap around if needed		if (newTraceNum < 0)			newTraceNum = numTraces+newTraceNum		else			newTraceNum = mod(newTraceNum,numTraces-1)		endif			//revert old trace if necessary			prevRgba=stringbykey("rgb(x)",prevTraceInfo,"=")		prevRgba=replacestring("(",prevRgba,"")		prevRgba=replacestring("(",prevRgba,"")		prevRgba=replacestring(",",prevRgba,";")		oldAlpha = str2num(stringfromlist(3,prevRgba))		oldAlpha = numtype(oldAlpha) ? -1+2^16 : oldAlpha		modifygraph/w=$s.winname rgb($prevTraceName)=(str2num(stringfromlist(0,prevRgba)),str2num(stringfromlist(1,prevRgba)),str2num(stringfromlist(2,prevRgba)),oldAlpha);	endif		if (delete)		//just don't set anything now that we have undone last		return 1	endif		//update new trace, store its info	String currTraceName=stringfromlist(newtraceNum,traces)	String currTraceInfo=traceinfo(s.winname,currTraceName,0)	setwindow $s.winname,userdata(prevTraceName)=currTraceName	setwindow $s.winname,userdata(prevTraceInfo)=currTraceInfo		modifygraph/w=$s.winname rgb($currTraceName)=(cr,cg,cb,ca)		return 1		//do not shift control to command lineendfunction/S disp_columns(wv,winN,doNewGraph,sepPlotRows,forceVertAxisN,startRow,endRow,startCol,endCol[appendAxName,layer,chunk])	WAVE wv		//2D wave with multiple columns to be displayed as if they were individual rows	String winN	//winN, pass "" for top	Variable doNewGraph		//pass > 0 for new graph, otherwise appends based on winN	variable sepPlotRows			//pass > 0 for sepPlotRows. spacing is sepPlotRows / 100. e.g. 2 = 2% of graph space between each plot	Variable startRow,endRow	//pass NaN to have all rows	String appendAxName		//use L_ or R_ as a prefix for left or right axis names	String forceVertAxisN		//pass to force all to one horizontal axis	..only works with sepPlotRows == 0	Variable startCol,endCol	//cols to plot	Variable layer, chunk		//optionally specify a layer and chunk		if (numtype(startRow)==2)		startRow = 0	endif	if (numtype(endRow)==2)		endRow = dimsize(wv,0)	endif	if (numtype(startCol))		startCol = 0	endif	if (numtype(endCol))		endCol = dimsize(wv,1)	endif		string appendedTraces = ""		Variable l = ParamIsDefault(layer) ? 0 : layer	variable c = ParamIsDefault(chunk) ? 0 : chunk		winN = disp_winIDHandling(winN, doNewGraph,0)		//plots if necessary		Variable numCols = DimSize(wv,1),i	if (numCols == 0)		//single dim wave		appendtograph/W=$winN wv		appendedTraces=nameofwave(wv)+","	endif		String axStartStr	if (ParamIsDefault(appendAxName))		axStartStr = "L_"	else		axStartStr = appendAxName	endif		Variable isRightAxis = Stringmatch(axStartStr,"R*")	String currAxName	if (sepPlotRows > 0)		String colLbl		String rowLabelsSaveRef = nameofwave(wv) + "_r"		Make/O/T/N=(DimSize(wv,0)) $rowLabelsSaveRef/wave=rows		rows = getdimlabel(wv,0,p)				Variable defaultAxSpacing = sepPlotRows / 100		Variable totalSpacing = defaultAxSpacing * (numCols-1)		Variable totalAxSize = 1 - totalSpacing		Variable sizePerAx = totalAxSize / numCols		Variable currAxStart,currAxEnd		for (i=startCol;i<endCol+1;i+=1)			currAxStart = i*defaultAxSpacing + i*sizePerAx			currAxEnd = currAxStart + sizePerAx			colLbl = GetDimLabel(wv, 1, i)			currAxName=axStartStr + nameofwave(wv) + "_"+num2str(i)			if (isRightAxis)				appendtograph/W=$winN/R=$currAxName wv[startRow,endRow][i][l][c]/TN=$colLbl vs rows			else				appendtograph/W=$winN/L=$currAxName wv[startRow,endRow][i][l][c]/TN=$colLbl vs rows			endif			appendedTraces+=colLbl+","						modifygraph axisEnab($currAxName)={currAxStart,currAxEnd},lblpos=52,freepos=0			Label/W=$winN $currAxName colLbl			doupdate			getaxis/Q/W=$winN $currAxName			setaxis/W=$winN $currAxName, v_min < 0 ? V_min : 0, v_max > 0 ? V_max : 0		endfor				else		if (strlen(forceVertAxisN)>0)			currAxName = forceVertAxisN		else			currAxName = "left"		endif		for (i=startCol;i<endCol+1;i+=1)			if (Stringmatch(currAxName,"R*"))				appendtograph/W=$winN/R=$currAxName wv[startRow,endRow][i][l][c]/tn=$(nameofwave(wv)+"_"+num2str(i))			else				appendtograph/W=$winN/L=$currAxName wv[startRow,endRow][i][l][c]/tn=$(nameofwave(wv)+"_"+num2str(i))			endif			appendedtraces+=nameofwave(wv)+"_"+num2str(i)+","		endfor	endif		modifygraph lblpos=55,freepos=0		return "winN:"+winN+";appendedTraces:"+appendedTraces+";"endfunction/S disp_columnswithReflection(wv, winN, doNewGraph, reflectionPosX, [nonReflectedRGB, reflectedRGB, sendToBack])	WAVE wv		//2D wave with multiple columns to be displayed as if they were individual rows	String winN	//winN, pass "" for top	Variable doNewGraph		//pass > 0 for new graph, otherwise appends based on winN	double reflectionPosX	WAVE nonReflectedRGB, reflectedRGB		//optionally pass 3-point rgb color value waves for reflected and non-reflected traces	Variable sendToBack		//optionally pass as true to send each wave to the black (so pre-existing waves end up front-most		winN = disp_winIDHandling(winN, doNewGraph,1)		String reflectionTNAppendStr = "r"	String unreflectedTNStart = nameofwave(wv) + "u"	String reflectionTNStart = nameofwave(wv) + reflectionTNAppendStr		Double shift = 2 * reflectionPosX		//see explanation in disp_waveReflect()		Variable i; String currReflectionTN, currUnreflectedTN	for (i=0;i<DimSize(wv,1);i+=1)		currUnreflectedTN = unreflectedTNStart + num2str(i)		currReflectionTN = reflectionTNStart + num2str(i)		appendtograph/W=$winN wv[][i]/TN=$currUnreflectedTN		appendtograph/W=$winN wv[][i]/TN=$currReflectionTN		modifygraph muloffset($currReflectionTN) = {-1,1}, offset($currReflectionTN) = {shift,0}				//handle coloring		if (!ParamIsDefault(nonReflectedRGB))			modifyGraph/W=$winN rgb($currUnreflectedTN) = (nonReflectedRGB[0],nonReflectedRGB[1],nonReflectedRGB[2],nonReflectedRGB[3])		endif		if (!ParamIsDefault(reflectedRGB))			modifyGraph/W=$winN rgb($currReflectionTN) = (reflectedRGB[0],reflectedRGB[1],reflectedRGB[2],reflectedRGB[3])		endif					if (!ParamIsDefault(sendToBack) && sendToBack)			ReorderTraces _back_,{$currReflectionTN,$currUnreflectedTN}		endif	endfor		//set graph to start at reflection point (now showing each half of the data)	setaxis bottom, reflectionPosX, *	setaxis/A=2 left		return winNendfunction/S disp_waveReflect(wList, winN, doNewGraph, reflectionPosX, [nonReflectedRGB, reflectedRGB])	String wList		//waves to reflect about same point	String winN		//name of window to plot them	Variable doNewGraph	Double reflectionPosX		//x value for reflection. waves will be reflected about this point	WAVE nonReflectedRGB, reflectedRGB		//optionally pass 3-point rgb color value waves for reflected and non-reflected traces		winN = disp_winIDHandling(winN, doNewGraph,1)		String reflectionTNAppendStr = "_r"		Variable i; double currShift, currDelta; String currRef, currReflectionTN	for (i=0;i<ItemsInList(wList);i+=1)		currRef = StringFromList(i,wList)		currReflectionTN = currRef + reflectionTNAppendStr		currShift = 2 * reflectionPosX		//reflectionPosX is xoffset into wave							//when x units are reflected, the corresponding point is -reflectionPosX							//so shift one plot by twice that to bring the two reflectionPosX positions into register		print "offset", Dimoffset($currRef,0), "currDelta",currDelta,"currShift",currShift		appendtograph/W=$winN $currRef 		appendtograph/W=$winN $currRef/TN=$currReflectionTN		modifygraph muloffset($currReflectionTN) = {-1,1}, offset($currReflectionTN) = {currShift,0}				//handle coloring		if (!ParamIsDefault(nonReflectedRGB))			modifyGraph/W=$winN rgb($currRef) = (nonReflectedRGB[0],nonReflectedRGB[1],nonReflectedRGB[2],nonReflectedRGB[3])		endif		if (!ParamIsDefault(reflectedRGB))			modifyGraph/W=$winN rgb($currReflectionTN) = (reflectedRGB[0],reflectedRGB[1],reflectedRGB[2],reflectedRGB[3])		endif			endfor		//set graph to start at reflection point (now showing each half of the data)	setaxis bottom, reflectionPosX, *	setaxis/A=2 left		return winNendfunction analysis_powerSpecToCorrelation(powerSpecWv, outRef)	WAVE powerSpecWv; String outRef		//inverse FFT	ifft/dest=$outRef/R powerSpecWv	WAVE tdOutput = $outRef		//unwrap to peak at zero	Duplicate/O tdOutput, tdOutput_wrappedTemp	Variable len = dimsize(tdOutput,0)	Variable midpoint = len/2	tdOutput = p < midpoint ? tdOutput_wrappedTemp[p+midpoint] : tdOutput_wrappedTemp[p-midpoint]	variable offset = -midpoint * dimdelta(tdoutput,0)	setscale/P x,offset, dimdelta(tdoutput,0), tdOutput		killwaves/z tdOutput_wrappedTempendfunction convolution(convolutionFilter,toConvolveByFilter,outRef,unitStr,[baselineSub,startX,endX,removeStartingRegionFromOut,meanStartX,meanEndX])	String convolutionFilter, toConvolveByFilter, outRef, unitStr	Variable baselineSub, startX, endX	//optional inputs. Have function perform baseline subtraction on toConvolveByFilter, and only use subregion of 	Variable removeStartingRegionFromOut		//optional input; if passed, will excise length of convolution filter from output, as this is where the filter has not yet reached "steady state" for lack of a better term	Variable meanStartX, meanEndX		//optional input of region for mean for baseline subtraction (baselineSub passed and greater than zero)		Variable finalStartX = -inf, finalEndX = inf	if (!ParamIsDefault(startX))		finalStartX = startX	endif	if (!ParamIsDefault(endX))		finalEndX = endX	endif	if (ParamIsDefault(meanStartX))		meanStartX = finalStartX	endif	if (ParamIsDefault(meanEndX))		meanEndX = endX//until 180430 was seemingly mistakenly finalStartX .. but was really never applied and still isnt because baselineSub is not usually passed	endif		Duplicate/O/R=(finalStartX, finalEndX) $toConvolveByFilter, toConvolveByFilterTemp	If (!ParamIsDefault(baselineSub) && baselineSub > 0)		Variable baseline = mean(toConvolveByFilterTemp, meanStartX, meanEndX)		toConvolveByFilterTemp -= baseline	endif						Duplicate/O $convolutionFilter, convFilterTemp	Variable originalNumpnts = Dimsize(toConvolveByFilterTemp,0)		Convolve  convFilterTemp, toConvolveByFilterTemp	SetScale d, -1,1,unitStr, toConvolveByFilterTemp		Variable outWaveStart = 0	if (!ParamIsDefault(removeStartingRegionFromOut))		outWaveStart = DimSize(convFilterTemp, 0)		endif	Duplicate/O/R=[outWaveStart,originalNumpnts-1] toConvolveByFilterTemp, $outRef			KillWaves/Z toConvolveWithFilterTemp, convFilterTempend //convolution()function filterLPExtra(waveRef, endOfBand, startOfCutOff)	String waveRef; Variable endOfBand, startOfCutOFF		Duplicate/O $waveRef, toFilterTemp		Make/O/D/N=0 coefs; DelayUpdate	FilterFIR/DIM=0/LO={endOfBand*DimDelta(toFilterTemp,0),startOfCutOFF*DimDelta(toFilterTemp,0),201}/COEF coefs, toFilterTemp	Duplicate/O toFilterTemp, $waveRefendfunction filter_simple(wv,endOfBand,startOfCutOff,outRef)	WAVE wv; Variable endOfBand, startOfCutOFF	String outRef		if (strlen(outRef)>0)		Duplicate/O wv, $outRef/wave=out	else		WAVE out = wv	endif		Make/O/D/N=0 coefs; DelayUpdate	FilterFIR/DIM=0/LO={endOfBand*DimDelta(out,0),startOfCutOFF*DimDelta(out,0),201}/COEF coefs, outendfunction avgFFT(inWaveRef, outwaveRef, useWindowing, startX, binSizeX, binStartGapX)	String inWaveRef, outwaveRef; 	Variable startX, binSizeX, binStartGapX	//size and spacing units of X scaling, e.g. 1 for 1s bins if x is time. Bin start gap is gap between START of bins, 	//so if you want non-overlapping 1s bins with e.g. 0.1 s space, then the input to these are 0, 1, 1.1	Variable useWindowing		//determines whether a Hanning window will be applied (could pick a differrent window function). Requires correction for the power removed by the window function			Duplicate/O/R=(startX, startX + binSizeX) $inWaveRef, tempBin		Variable binSizeP = DimSize(tempBin,0)	Variable isOdd = mod(binSizeP,2)		//mod(x,2) returns 0 if even, 1 if odd	Print "isOdd",isOdd,"binSizeP",binSizeP	if (isOdd)		binSizeX -= DimDelta(tempBin,0)		Duplicate/O/R=(startX, startX + binSizeX) $inWaveRef, tempBin		//should now be even if it wasn't before		Print "in IF, and binSizeX now = " + num2str(numpnts(tempBin))	endif		//make a place to store power spectra (using FFT magnitude to give a real wave with correct num points, scaling, or a complex wave is returnComplexForm > 0	fft/dest=fftAvg tempBin	fftAvg = 0		Variable currBinPosX, binCount = 0	for (currBinPosX = startX; currBinPosX < pnt2x($inWaveRef, DimSize($inWaveRef,0) -1) - binSizeX; currBinPosX += binStartGapX)		Duplicate/O/R=(currBinPosX, currBinPosX + binSizeX) $inWaveRef, tempBin	, tempBinSave		if (useWindowing)			tempBin *=1/(0.5)			fft/dest=currPowerSpectra/winf=hanning tempBin		else			fft/dest=currPowerSpectra tempBin		endif				fftAvg +=  currPowerSpectra		binCount+=1	endfor	fftAvg /= binCount	//	Duplicate/O powerSpectraAvg, powerSpectraAvgDivN//	powerSpectraAvgDivN /= numpnts(tempBin) * 0.375		Duplicate/O fftAvg, $outWaveRef	endfunction analyzeNL(realResponseRef,predictedResponseRef,outputRef,numNonlinearityBins,appendToTopGraph,[baselineSub,startX,endX,noprint])	String realResponseRef, predictedResponseRef,outputRef	Variable numNonlinearityBins, appendToTopGraph	Variable baselineSub		//optional variable; if passed, will generate (temporarily) and use a subtracted form of realResponseRef. This is necessary if the predicted response is also baseline subtracted	Variable startX, endX		//start and end of analysis region, if passed. Otherwise, defaults to beginning and end of stimulus trace	Variable noprint		//default is to use entirety of wave	Variable startX_used,endX_used	if (ParamIsDefault(startX) || ( numType(startX) > 0) )		startX_used = DimOffset($predictedResponseRef, 0)	else		startX_used = startX	endif	if (ParamIsDefault(endX) || ( numType(endX) > 0) )		endX_used = startX + ( ( DimSize($predictedResponseRef, 0) - 1 ) * DimDelta($predictedResponseRef,0) )	else		endX_used = endX	endif		WAVE predictedResp=$predictedResponseRef	WAVE realResp=$realResponseRef	Duplicate/O/R=(startX_used, endX_used)/free predictedResp, predictedResponseTemp	Duplicate/O/R=(startX_used, endX_used)/free realResp, realResponseTemp			Double meanRealBaseline,meanPredBaseline	if (!ParamIsDefault(baselineSub) && baselineSub)		meanRealBaseline = mean(realResponseTemp)		realResponseTemp -= meanRealBaseline		meanPredBaseline = mean(predictedResponseTemp)		predictedResponseTemp -= meanPredBaseline	else		meanRealBaseline=nan		meanPredBaseline=nan		endif		Double pearsonR = getPearsonR(realResponseTemp,predictedResponseTemp)	if (Paramisdefault(noprint) || !noprint)		Print "analyzeNL() pearsonR=",num2str(pearsonR),"realResponseRef",realResponseRef,"predictedResponseRef",predictedResponseRef,"outputRef",outputRef,"numNonlinearityBins",numNonlinearityBins,"baselineSub",baselineSub,"startX_used",startX_used,"endX_used",endX_used	endif	//bin the pairwise comparisons between predicted and actual response for a more compact description , more amenable to curve fitting	//OLD VERSION: EQUAL RANGE PER BIN//	downSampleYXFromRange("realResponseTemp","predictedResponseTemp", startX_used, endX_used, numNonlinearityBins, outputRef,appendToTopGraph)	//CURRENT VERSION: EQUAL NUM PNTS PER BIN	downsampleYXFromRange_equalPs(realResponseTemp,predictedResponseTemp, startX_used, endX_used, numNonlinearityBins, outputRef,appendToTopGraph,0)	//note: predicted as independent variable, stored in column zero	WAVE out = $outputRef			//created by downSampleYX, 2 column wave; rows are bins, col 0 = xVal, col 1 = yVal		Make/O/D/N=(numNonlinearityBins) xValBinsTemp, yValBinsTemp	//cannot use the 2D wave binnedNonlinearitySoma because in one of igors horrible faults it has difficulty dealing with fitting one column vs another	xValBinsTemp = out[p][0]; yValBinsTemp = out[p][1]		Make/O/D/N=2 linearFitToBinsCoef		CurveFit/W=2/N=1/Q=1 line, kwCWave = linearFitToBinsCoef, yValBinsTemp/X=xValBinsTemp				//store fit results with original bin information (as column 3). First for normal (non-EV)	out[][2] = linearFitToBinsCoef[0] + linearFitToBinsCoef[1]*out[p][0]		//just using linear fit to predict y from x	SetDimLabel 1,2,linear_fit,out		String pearStr	sprintf pearStr,"nl_pearsonR:%20.20f;nl_meanRealBaseline:%20.20f;nl_meanPredBaseline:%20.20f;startX_used:%f;endX_used:%f;",pearsonR,meanRealBaseline,meanPredBaseline,startX_used,endX_used	note/nocr out,pearStr		KillWaves/Z xValBinsTemp, yValBinsTemp, linearFitToBinsCoef	return pearsonRendfunction analyzeNLRange(realResponseRef, predictedResponseRef,outputRef, startX, endX numNonlinearityBins, appendToTopGraph)	String realResponseRef, predictedResponseRef,outputRef	Variable numNonlinearityBins, appendToTopGraph	Variable startX, endX				Variable pearsonR = getPearsonRFromRange(realResponseRef,predictedResponseRef, startX, endX)	Print "R originalConv Soma = " + num2str(pearsonR)		//bin the pairwise comparisons between predicted and actual response for a more compact description (standard in the field), more amenable to curve fitting	//NOTE downSampleYXFromRange has changed 190225!, startX and endX became startP,endP and are optional	downSampleYXFromRange(realResponseRef,predictedResponseRef,numNonlinearityBins, outputRef,appendToTopGraph,startP=x2pnt($realResponseRef,startX),endP=x2pnt($realResponseRef,endX))	Duplicate/O $outputRef, outputTemp		//created by downSampleYX, 2 column wave; rows are bins, col 0 = xVal, col 1 = yVal		Make/O/D/N=(numNonlinearityBins) xValBinsTemp, yValBinsTemp	//cannot use the 2D wave binnedNonlinearitySoma because in one of igors horrible faults it has difficulty dealing with fitting one column vs another	xValBinsTemp = outputTemp[p][0]; yValBinsTemp = outputTemp[p][1]		Make/O/D/N=2 linearFitToBinsCoef		CurveFit/W=2/N=1/Q=1 line, kwCWave = linearFitToBinsCoef, yValBinsTemp/X=xValBinsTemp				//store fit results with original bin information (as column 3). First for normal (non-EV)	Redimension/N=(DimSize(outputTemp,0), 3) outputTemp	outputTemp[][2] = linearFitToBinsCoef[0] + linearFitToBinsCoef[1]*outputTemp[p][0]		//just using linear fit to predict y from x	Duplicate/O outputTemp, $outputRef		KillWaves/Z outputTemp, xValBinsTemp, yValBinsTemp, linearFitToBinsCoef	return pearsonRendfunction analysis_avgPower(waveRef, isFreq)	String waveRef; Variable isFreq	//Kravlor user igor exchange post	// Parseval's theorem (power in time-domain = power in frequency domain)	// is satisfied if you compare:	// time-domain average power ("mean squared amplitude" in Numerical Recipies) = 1/N * sum(t=0...N-1) w[t]^2	// frequency-domain average power= deltaf * sum(f=0...npsd/2) destw[f]^2		Duplicate/O $waveRef, intWave	Variable waveIsComplex = WaveType(intWave) & 0x01		Variable integralSum =0, i	if (waveIsComplex)		for (i=0;i<DimSize(intWave,0);i+=1)			integralSum +=magsqr(intWave[i]) // intWave[i]^2 //magsqr(r2polar((intWave[i])))		endfor		Print "cmplx"	else		for (i=0;i<DimSize(intWave,0);i+=1)			integralSum += intWave[i]^2		endfor		Print "real"	endif	if (isFreq)		integralSum *= DimDelta(intWave,0)		Print "DimDelta(intWave,0)",DimDelta(intWave,0)	else		integralSum *= 1/DimSize(intWave,0)			Print "DimSize(intWave,0)",DimSize(intWave,0)	endif	Print integralsum	return integralsumendfunction getNormalizedFFTMag(cmplxWaveIn, realWaveOut)	String cmplxWaveIn, realWaveOut		Duplicate/O/C $cmplxWaveIn, normFDWaveTemp	Redimension/R normFDWaveTemp			//seems necessary to convert to R. (with no r2polar in between) comes close to obeying parseval's theorem along with the following changes	Variable origN = 2* (DimSize(normFDWaveTemp,0) - 1)		//transforms have N+1 points whereas the real wave complement has 2N	normFDWaveTemp /= origN	Variable num=DimSize(normFDWaveTemp,0)	normFDWaveTemp[1,num-2] *= 2	Duplicate/O normFDWaveTemp, $realWaveOut	KillWaves normFDWaveTempendfunction crossCorrelateRelPS(stimRef,respRef, outRef, startX, endX, compensatePS, returnInTD, useWindowing,filter)	String stimRef, respRef, outRef; Variable compensatePS, returnInTD, useWindowing, startX, endX, filter		Variable endOfBand=1000, startOfCutOff=10000		//these work nicely to remove very high frequency artificats		Duplicate/O/R=(startX, endX) $stimRef, stimCCTemp_TD	Duplicate/O/R=(startX, endX) $respRef, respCCTemp_TD		Variable binSizeP = DimSize(stimCCTemp_TD,0)	Variable isOdd = mod(binSizeP,2)		//mod(x,2) returns 0 if even, 1 if odd	Print "binSizeP",binSizeP,"isOdd",isOdd	if (isOdd)		endX -= DimDelta(stimCCTemp_TD,0)		Duplicate/O/R=(startX, endX) $stimRef, stimCCTemp_TD		//should now be even if it wasn't before		Duplicate/O/R=(startX, endX) $respRef, respCCTemp_TD		Print "in IF, and binSizeX now = " + num2str(numpnts(stimCCTemp_TD))	endif		SetScale/P x, 0, DimDelta(stimCCTemp_TD,0), stimCCTemp_TD, respCCTemp_TD 		if (useWindowing)		Hanning stimCCTemp_TD		Hanning respCCTemp_TD	endif	fft/out=3/dest=stimCCPS_TempPlaceholder stimCCTemp_TD		//avgPowerSpectraFD is a real wave	stimCCPS_TempPlaceholder = 0	Duplicate/O stimCCPS_TempPlaceholder, stimCCPS_Temp			//for some reason this duplication is needed for magsqr not to throw an error below	KillWaves stimCCPS_TempPlaceholder		fft/dest=stimCCTemp_FD stimCCTemp_TD	fft/dest=respCCTemp_FD respCCTemp_TD	Duplicate/O/C stimCCTemp_FD, stimCCTempC_FD	stimCCTempC_FD = conj(stimCCTemp_FD)		//convert stimulus in frequency domain to its complex conjugate	stimCCPS_Temp = magsqr(stimCCTemp_FD)		Duplicate/O/C respCCTemp_FD, resultCC_FD	resultCC_FD = respCCTemp_FD * stimCCTempC_FD	ifft/r/dest=resultCC_TD resultCC_FD	if (filter)		filterLP("resultCC_TD",  endOfBand, startOfCutOff) 		fft/dest=resultCC_FD resultCC_TD	endif	if (compensatePS)			resultCC_FD /= stimCCPS_Temp	endif	if (returnInTD)		Duplicate/O resultCC_TD, $outRef	else		Duplicate/O resultCC_FD, $outRef	endif	KillWAves stimCCTemp_TD,  respCCTemp_TD, stimCCPS_Temp, stimCCTemp_FD, respCCTemp_FD, stimCCTempC_FD, resultCC_FD,  resultCC_TDend//GENERAL FILTER TESTING. ADAPTED FROM chF function for testing filters on chirp resposnes//assumes real stimulus, real somatic response, and real pedicle reponse are cols 1-3 in selection. Input is filter constructed on white noise response for soma and pedfunction testFilter(somaFilterRef, pedFilterRef, useAP, doPlotWithStim)	String somaFilterRef, pedFilterRef; Variable useAP, doPlotWithStim		if (fio_checkGlobalFilePath())			//check path returns non-zero if there are any problems with symbolic path		Print "aborted in analysis_SSVI because file save path not set! Use fio_setDataSavePath()"		return 0	endif	SVAR/Z dataSavePathName				//this should be a global string with the name of the path that is set by fio_setDataSavePath()		String savePrefix = "W1T"		//in this case for white noise test		Variable convolutionStartX = .5	Variable convolutionEndX = 10	Variable NLAnalysisStartX = convolutionStartX + .2	Variable numNonlinearityBins = 15		WAVE/T wavelistlistwave		String stimRef, somaRef, pedRef	if (!useAP)		stimRef = "G15041205_0012_1_AD1"			// Display root:G15041205_0012_1_AD2CoFPe		somaRef = "G15041205_0012_1_AD0"			//Display root:G15041205_0012_1_AD0CoFSo		pedRef = "G15041205_0012_1_AD2"//		stimRef = "G15041100_0018_1_AD1"//		somaRef = "G15041100_0018_1_AD0"//		pedRef = "G15041100_0018_1_AD2"	else		stimRef = wavelistlistwave[0][0]		somaRef =  wavelistlistwave[0][1]		pedRef =  wavelistlistwave[0][2]	endif		//excise region and baseline subtract	Duplicate/O/R=(convolutionStartX,convolutionEndX) $stimRef, stimChirpPredTemp	Duplicate/O/R=(convolutionStartX,convolutionEndX) $somaRef, somaChirpPredTemp	Duplicate/O/R=(convolutionStartX,convolutionEndX) $pedRef, pedChirpPredTemp		Variable stimMean = mean(stimChirpPredTemp)	Variable somaMean = mean(somaChirpPredTemp)	Variable pedMean = mean(pedChirpPredTemp)		stimChirpPredTemp -= stimMean	somaChirpPredTemp -= somaMean		pedChirpPredTemp -= pedMean			//convolve to predict chirp based on filters	String somaChirpPredSN = stimRef + savePrefix + "1SP"			//1 soma predicted	String pedChirpPredSN = stimREf + savePrefix  + "1PP"			//as above for ped	String somaChirpRealSN = stimRef + savePrefix 	+ "1SR"		//chirp filter 1 soma real	String stimSN = stimRef + savePrefix + "1StR"	String pedChirpRealSN = stimREf + savePrefix 	+	"1PR"	String somaChirpBinnedSN = stimRef + savePrefix+ 	"1SB"	//chirp filter 1 soma binned	String pedChirpBinnedSN = stimRef + savePrefix + "1PB"	//chirp filter 1 ped binned			convolution(somaFilterRef, "stimChirpPredTemp",somaChirpPredSN,"V")	convolution(pedFilterRef, "stimChirpPredTemp", pedChirpPredSN,"V")	Duplicate/O somaChirpPredTemp, $somaChirpRealSN	Note/K $somaChirpRealSN, note($somaRef) + " (Soma REAL " + savePrefix + " excised for prediction by LN Model. Filter = " + somaFilterRef +". Vavg:" + num2str(somaMean) + ".);"	Duplicate/O pedChirpPredTemp, $pedChirpRealSN	Note/K $pedChirpRealSN, note($pedRef) + " (Ped REAL " + savePrefix + "excised for prediction by LN Model. Filter = " + pedFilterRef +". Vavg:" + num2str(pedMean) + ".);"	Duplicate/O stimChirpPredTemp, $stimSN	Note/K $stimSN, note($stimRef ) +  " (Stim REAL " + savePrefix + "excised for prediction by LN Model. Soma resp  = " + somaChirpRealSN +". Ped resp = " + pedChirpRealSN + ".);"		Note/K $somaChirpPredSN,  note($somaRef) + " (Soma PREDICTION " + savePrefix + " by LN Model. Filter = " + somaFilterRef +". Vavg:" + num2str(somaMean) + ".);"	Note/K $pedChirpPredSN,  note($pedRef) +  " (Ped PREDICTION " + savePrefix + " by LN Model. Filter = " + pedFilterRef +". Vavg:" + num2str(pedMean) + ".);"				//test convolution results	Variable pearsonSoma = analyzeNLRange(somaChirpRealSN, somaChirpPredSN, somaChirpBinnedSN,NLAnalysisStartX, convolutionEndX, numNonlinearityBins,0)	Variable pearsonPed = analyzeNLRange(pedChirpRealSN, pedChirpPredSN, pedChirpBinnedSN,NLAnalysisStartX, convolutionEndX,numNonlinearityBins,0)	Note $somaChirpBinnedSN, "PEARSONR: " + num2str(pearsonSoma) + ";"	Note $pedChirpBinnedSN, "PEARSONR: " + num2str(pearsonPed) + ";"			//save results	Save/C/O/P=$dataSavePathName $somaChirpPredSN, $pedChirpPredSN , $somaChirpRealSN , $pedChirpRealSN , $somaChirpBinnedSN , $pedChirpBinnedSN, $stimSN	//display results	KillWindowsByName("*" + stimRef + saveprefix + "*")			//overlay				Variable overlayWinStartX = 8, overlayWinEndX = 8.5	Display/K=1/N=$somaChirpPredSN 	AppendToGraph/L=Lsoma/C=(0,0,0) $somaChirpRealSN, $somaChirpPredSN	ModifyGraph rgb($somaChirpPredSN) = (0,12800,52224)	AppendToGraph/L=Lped/C=(0,0,0) $pedchirpRealSN, $pedChirpPredSN	ModifyGraph rgb($pedChirpPredSN) = (0,12800,52224)		Make/O/D/N=5 dummyChirpPred	AppendToGraph/L=Ldummy dummyChirpPred	ModifyGraph axisEnab(Lsoma)={0,0.48},axisEnab(Lped)={0.52,1},freePos(Lsoma)=0;DelayUpdate	ModifyGraph freePos(Lped)=0	ModifyGraph fSize(Lsoma)=14,fSize(bottom)=14,fSize(Lped)=14,lblPos(Lsoma)=52;DelayUpdate	ModifyGraph lblPos(Lped)=52,lblPos(Ldummy)=50,lblLatPos(Ldummy)=20;DelayUpdate	ModifyGraph freePos(Ldummy)=300;DelayUpdate	Label Lsoma "\\Z14Soma\\u#2\r";DelayUpdate	Label bottom "Time (\\U)";DelayUpdate	Label Lped "\\Z14Terminal\\u#2\r";DelayUpdate	Label Ldummy "\\Z14 Voltage (mV) Real \\K(0,0,52224)Predicted"	ModifyGraph hideTrace(dummyChirpPred)=1	setaxis bottom, overlayWinStartX,overlayWinEndX			//pairwise		Variable startP = x2pnt($somaChirpPredSN, NLAnalysisStartX)		Variable endP = x2pnt($somaChirpPredSN, convolutionEndX)	Display/K=1/N=$somaChirpBinnedSN	AppendToGraph/C=(0,0,0) $somaChirpRealSN[startP,endP]/TN=soma vs $somaChirpPredSN[startP,endP]	AppendToGraph $pedChirpRealSN[startP,endP]/TN=ped vs $pedChirpPredSN[startP,endP]	AppendToGraph $somaChirpBinnedSN[][1]/TN=somaBinned vs $somaChirpBinnedSN[][0]	AppendToGraph $somaChirpBinnedSN[][2]/TN=somaFit vs $somaChirpBinnedSN[][0]		AppendToGraph $pedChirpBinnedSN[][1]/TN=pedBinned vs $pedChirpBinnedSN[][0] 	AppendToGraph $pedChirpBinnedSN[][2]/TN=pedFit vs $pedChirpBinnedSN[][0] 		//make fits circles with outer grey and inner black (soma) or red (ped)	ModifyGraph mode(soma)=2, mode(ped)=2	ModifyGraph mode(somaBinned)=3,marker(somaBinned)=19, mrkThick(somaBinned)=2,rgb(somaBinned)=(0,0,0), mrkStrokeRGB(somaBinned)=(34816,34816,34816), useMrkStrokeRGB(somaBinned)=1	ModifyGraph mode(pedBinned)=3,marker(pedBinned)=19, mrkThick(pedBinned)=2,rgb(pedBinned)=(65280,0,0), mrkStrokeRGB(pedBinned)=(34816,34816,34816), useMrkStrokeRGB(pedBinned)=1	ModifyGraph mode(somaFit)=0, lstyle(somaFit) = 1, lsize(somaFit)=5,rgb(somaFit)=(34816,34816,34816)	ModifyGraph mode(pedFit)=0, lstyle(pedFit) = 1, lsize(pedFit)=5,rgb(pedFit)=(34816,34816,34816)	ReorderTraces somaBinned,{somaFit,pedFit}	ModifyGraph fSize=14;DelayUpdate	Label left "\\Z14Measured \rSoma or \\K(65280,0,0)Terminal\\K(0,0,0) (\\U)"	Label bottom "\\Z14Linear Prediction (\\U)"		if (doPlotWithStim)		Display/K=1/N=$stimSN 		AppendToGraph/R=Rstim/C=(21760,21760,21760) $stimSN			//make this first so behind in order		AppendToGraph/L=Lsoma/C=(0,0,0) $somaChirpRealSN, $somaChirpPredSN		ModifyGraph rgb($somaChirpPredSN) = (0,12800,52224)		AppendToGraph/L=Lped/C=(0,0,0) $pedchirpRealSN, $pedChirpPredSN		ModifyGraph rgb($pedChirpPredSN) = (0,12800,52224)		Make/O/D/N=5 dummyChirpPred		AppendToGraph/L=Ldummy dummyChirpPred		ModifyGraph axisEnab(Lsoma)={0,0.48},axisEnab(Lped)={0.52,1},axisEnab(Rstim) = {0,0.48}		ModifyGraph freePos = 0, lblpos = 52		ModifyGraph fSize(Lsoma)=14,fSize(bottom)=14,fSize(Lped)=14,lblPos(Lsoma)=52;DelayUpdate		ModifyGraph lblPos(Lped)=52,lblPos(Ldummy)=50,lblLatPos(Ldummy)=20;DelayUpdate		ModifyGraph freePos(Ldummy)=300;DelayUpdate		Label Lsoma "\\Z14Soma\\u#2\r";DelayUpdate		Label bottom "Time (\\U)";DelayUpdate		Label Lped "\\Z14Terminal\\u#2\r";DelayUpdate		Label Ldummy "\\Z14 Voltage (mV) Real \\K(0,0,52224)Predicted"		Label Rstim "\\Z14\\K(21760,21760,21760)Stimulus (\\U)"		ModifyGraph hideTrace(dummyChirpPred)=1		setaxis bottom, overlayWinStartX,overlayWinEndX			endifend//find various statistics about chosen window and prints them//csr A should be on somatic wave and indicates start of window//csr B should be on ped wave (or somatic wave if only one) and indicates end of windowfunction/S windowStats()	Variable startX = xcsr(A)	Variable endX = xcsr(B)		if (startX < endX)		//backwards so flip		Variable temp = endX		endX = startX		startX = temp	endif		String somaRef = csrwave(A)	String pedRef = csrwave(B)		String savePathStr		String somaWvList = windowStatsG(somaRef, startX, endX, 1,1, pathStr=savePathStr)	String pedWvList = windowStatsG(pedRef, startX, endX, 1,2)		String diffAppendStr = "D"		Variable i; String somaRef_t, pedRef_t, outRef, outRefList = ""	for (i=0;i<ItemsInList(somaWvList);i+=1)		somaRef_t = StringFromList(i, somaWvList)		WAVE soma_t = $somaRef_t		pedRef_t = stringfromlist(i, pedWvList)		WAVE ped_t = $pedRef_t		outRef = somaRef_t + "D"		outRefList += outRef + ";"		Duplicate/O soma_t, $outRef/WAVE=diff_t		diff_t = ped_t - soma_t		Note diff_t, "FINALWV:"+pedRef +";INITIALWV:"+somaRef+";DIFFWV:"+outRef+";"		SAVE/C/O/P=$savePathStr $outRef	endfor		Print "Diff RefsList = " + outRefList		return outRefList		endfunction ic0_main_update(row)	Variable row		Variable noStreaming = 0		WAVE/T ic0_refs_main0 = $"ic0_refs_main0_orig"		String possibleStreamTags = "PUTATIVE_ROD;soma;ped;BLOCK;"		String key,streamTags="",info=ic0_refs_main0[row]	variable i	for (i=0;i<itemsinlist(possibleStreamTags);i+=1)		key = stringfromlist(i,possibleStreamTags)		streamTags += key + ":" + stringbykey(key,info) + ";"	endfor		String loadList = ""	String ref_S = stringbykey("s1_wave",info);loadList+=ref_S+";"	String ref_P = stringbykey("s2_wave",info);loadList+=ref_P+";"	String pars_S = stringbykey("s1_params",info);loadList+=pars_S+";"	String pars_P = stringbykey("s2_params",info);loadList+=pars_P+";"		fio_loadfiles("*",".ibw",pathName="ic0_path",loadWvListStr=loadList,skipPreExisting=1)//	fio_stream_loadIBF("ic0_refs_main0",loadList,skipPreExisting=1)		//DOESNT WORK ON HOME COMP		Variable has_S = strlen(ref_S) > 0	Variable has_P = strlen(ref_P) > 0		Variable startX_S,startX_P,endX_S,endX_P	if (has_S)		WAVE/Z parWv_S = $pars_S		if (!WaveExists(parWv_S))			Print "ic0_main_update(): row",row,"failed to load par wave",pars_S,"associated with original wave",ref_S,"aborting"			return 0		else			startX_S=parWv_S[%startX]			endX_S=parWv_S[%endX]		endif	endif	if (has_P)		WAVE/Z parWv_P = $pars_P		if (!WaveExists(parWv_P))			Print "ic0_main_update(): row",row,"failed to load par wave",pars_P,"associated with original wave",ref_P,"aborting"			return 0		else			startX_P=parWv_P[%startX]			endX_P=parWv_P[%endX]		endif	endif			if (!has_S && !has_P)		Print "ic0_main_update(): row",row,"no original input waves at soma or ped"		return 0	endif		String forceBaseName = getdimlabel(ic0_refs_main0,0,row)		ic0_main(0,streamTags,startX_S,endX_S,noStreaming,forceBaseName,forceSomaRef=ref_S,forcePedRef=ref_P)	end//automated way to call analysis_ic0_stats for paired recordings//csr(A) must be on soma, csr(B) on ped. if only one side, other csr must not be used//need to update for single site -- might addressfunction ic0_main(resetDataSavePath,streamTags,startX,endX,noStreaming,forceBaseName[forceSomaRef,forcePedRef])		//startx, endx  can be passed as 0 of NaN to get default settings	Variable resetDataSavePath; String streamTags		//info to save e.g. "block:1;"	Variable startX,endX,noStreaming	String forceBaseName 			//baseName for saving to fio_stream_savetoStream is waveRef by default; pass a non-zero length string to use the passed string instead	String forceSomaRef,forcePedRef	//optionally pass to supercede cursor selections		if ( (numtype(startX) == 2) || ( (startX < 0) && (startX != -inf) ) ) 		startX = 1.5		//often coming out of i-clamp, so impose a standard wait time before analysis begins	endif	Variable saveParamsAndSpectra = nostreaming ?  0 : 1 	//default to always save results. Current folder that should be chosen is i0 in analysis		String somaRef,pedRef	if (!ParamIsDefault(forceSomaRef))		somaRef=forceSomaRef	else		somaRef = csrwave(A)	endif	if (!ParamIsDefault(forcePedRef))		pedRef=forcePedRef	else		pedRef = csrwave(B)	endif			Variable somaResp = strlen(somaRef) > 0	Variable pedResp = strlen(pedRef) > 0	Variable bothResp = somaResp && pedResp		if ( !strlen(somaRef) && !strlen(pedRef) )		Print "ic0_main(): aborting bc neither somaRef or pedRef found. use somaRef = csrwave(A), pedRef = csrwave(B)"		return 0	endif	Variable saveToRefList_noSomaPedBoth	if (bothResp)		if ( (numtype(endX) == 2) || (endX <= 0) )			endX = dimdelta($pedRef,0)*(dimSize($pedRef,0)-1)		endif		saveToRefList_noSomaPedBoth = noStreaming ? 0 : 3		//get single site stats for ped first		String outputRefs = analysis_ic0_stats(pedRef, startX, endX, saveParamsAndSpectra, 0, resetDataSavePath, 2,streamTags,"")		//run on soma, generating single-site stats for it and difference stats compared to terminal results		analysis_ic0_stats(somaRef, startX, endX, saveParamsAndSpectra, saveToRefList_noSomaPedBoth, 0, 1,streamTags,forceBaseName,secondSiteWvRefList = outputRefs)	elseif (somaResp)	//soma only		saveToRefList_noSomaPedBoth = noStreaming ? 0 : 1		Print "ic0_main(): running analysis on soma only, somaRef=",somaRef		analysis_ic0_stats(somaRef, startX, endX, saveParamsAndSpectra, saveToRefList_noSomaPedBoth, resetDataSavePath, 1,streamTags,forceBaseName)		else					//ped only		saveToRefList_noSomaPedBoth = noStreaming ? 0 : 2		Print "ic0_main(): running analysis on terminal only, pedRef=",pedRef		analysis_ic0_stats(pedRef, startX, endX, saveParamsAndSpectra, saveToRefList_noSomaPedBoth, resetDataSavePath, 2,streamTags,forceBaseName)		endif	end//wType = 0, neither soma or ped, wType = 1 ==> soma, wType = 2 ==> pedfunction/S analysis_ic0_stats(waveRef, startX, endX, saveParamsAndSpectra, saveToRefList_noSomaPedBoth, resetDataSavePath, wType, streamTags,forceBaseName[secondSiteWvRefList])	Variable startX, endX, wType	Variable saveParamsAndSpectra		//pass true to store saveParams and spectra (handled by fio_saveWavesToDataSavePath())	Variable saveToRefList_noSomaPedBoth				//pass true to store refs to list: goes by name of waveRef, only allows one entry per waveRef					//for two site cells, only save once					//specifically, pass 0 for no save, 1 for save soma (single site), 2 for save ped (single site), 3 for save both (waveRef should be soma)	Variable resetDataSavePath		//if passing saveParamsAndSpectra true, pass this to prompt user to set dataSavePath, otherwise ignored	String waveRef	String streamTags		//info to save e.g. "block:1;"	String secondSiteWvRefList	//optionally pass to calculate "paired" parameters based on differences between two sites			//secondSiteWvRefList should be secondSiteRawDataRef;outList as returned by analysis_ic0_stats on that wave ref, which should use save startX, endX	String forceBaseName 			//baseName for saving to fio_stream_savetoStream is waveRef by default; pass a non-zero length string to use the passed string instead		STring baseName	if (strlen(forceBaseName))		baseName = forceBaseName	else		baseName = waveRef	endif		String outList = ""		//store waves generated		//time domain wave stats	WaveStats/C=1/R=(startX, endX)/Z/Q/W $waveRef	//generates M_wavestats	WAVE M_wavestats		String recStartTime = fd_note_getWaveTimeStr(waveRef,1)		//power spectral wave stats	Variable proportionWinOverlay = .25	Variable timeBin_s = 3		//standardly 1 second .. 3 second also interesting	Variable timeBin_p = round(timeBin_s/DimDelta($waveRef,0))//needed to avoid decimal errors with modulus	timeBin_p = mod(timeBin_p,2) != 0 ? timeBin_p-1:timeBin_p		//timeBin_p -1 : timeBin_p		//set 1s time bin or slightly less assuring even numpoints	String winf = "cos1"	String outRef_cosWin = waveRef + "_powcos"	String outRef_noWin = waveRef + "_pow"		//power spectra with cosine window		fft_power(waveRef,outRef_cosWin,"",startX,endX,timeBin_p,nan,proportionWinOverlay, winf)	Variable avgCol=finddimlabel($outRef_cosWin,1,"avg")	duplicate/o/r=[][avgCol]/free $outRef_cosWin,powerTemp;redimension/n=(-1) powerTemp	duplicate/o powerTemp,$outRef_cosWin/wave=power_win		//power spectra with no window (== a rectangular window)	fft_power(waveRef, outRef_noWin,"",startX,endX, timeBin_p,nan,proportionWinOverlay, "")	duplicate/o/r=[][avgCol]/free $outRef_noWin,powerTemp;redimension/n=(-1) powerTemp	duplicate/o powerTemp,$outRef_noWin/wave=power_noWin		Variable powerSpecScaling = DimDelta(power_noWin,0)		String generalAppendStr = "_O1"			//for observe params 0	String somaAppendStr = "S"	String pedAppendStr = "P"	String printPrefix = ""	String paramSaveRef = waveRef + generalAppendStr		if (wType == 1)		paramSaveRef += somaAppendStr		printPrefix = "SW: "	elseif (wType == 2)		paramSaveRef += pedAppendStr		printPrefix = "PW: "	endif		outList += waveRef + ";" + paramSaveRef + ";" + outRef_noWin + ";" + outRef_cosWin + ";"		//these waves are saved (if saveParamsAndSpectra)				//and this list can be used as input for secondSiteWvRefList		Variable numNonWaveStatsParams = 26	Variable numWaveStatsParams = DimSize(M_wavestats,0)	Duplicate/O M_wavestats, $paramSaveRef/WAVE=paramsWvTemp	Redimension/N=(numWaveStatsParams + numNonWaveStatsParams) paramsWvTemp		dl_assignAndLbl(paramsWvTemp,0 + numWaveStatsParams,startX,"startX")	dl_assignAndLbl(paramsWvTemp,1 + numWaveStatsParams,endX,"endX")	dl_assignAndLbl(paramsWvTemp,2 + numWaveStatsParams,DimDelta($waveRef,0),"inWv_DimDelta")	dl_assignAndLbl(paramsWvTemp,3 + numWaveStatsParams,power_noWin[0],"dc")	dl_assignAndLbl(paramsWvTemp,4 + numWaveStatsParams,sum(power_noWin),"power_total_noWin")	dl_assignAndLbl(paramsWvTemp,5 + numWaveStatsParams,sum(power_noWin,powerSpecScaling,x2pnt(power_noWin,10)),"power_to10_noWin")	dl_assignAndLbl(paramsWvTemp,6 + numWaveStatsParams,sum(power_noWin,x2pnt(power_noWin,10),x2pnt(power_noWin,20)-powerSpecScaling)	,"power_10to20_noWin")	dl_assignAndLbl(paramsWvTemp,7 + numWaveStatsParams,sum(power_noWin,x2pnt(power_noWin,20),x2pnt(power_noWin,30)-powerSpecScaling),"power_20to30_noWin")	dl_assignAndLbl(paramsWvTemp,8 + numWaveStatsParams,sum(power_noWin,x2pnt(power_noWin,30),x2pnt(power_noWin,40)-powerSpecScaling)	,"power_30to40_noWin")	dl_assignAndLbl(paramsWvTemp,9 + numWaveStatsParams,sum(power_noWin,x2pnt(power_noWin,40),x2pnt(power_noWin,60)-powerSpecScaling),"power_40to60_noWin")	dl_assignAndLbl(paramsWvTemp,10 + numWaveStatsParams,sum(power_noWin,x2pnt(power_noWin,60),x2pnt(power_noWin,100)-powerSpecScaling),"power_60to100_noWin")	dl_assignAndLbl(paramsWvTemp,11 + numWaveStatsParams,sum(power_noWin,x2pnt(power_noWin,100),x2pnt(power_noWin,200)-powerSpecScaling),"power_100to200_noWin")	dl_assignAndLbl(paramsWvTemp,12 + numWaveStatsParams,sum(power_noWin,x2pnt(power_noWin,200),inf),"power_200toInf_noWin")		dl_assignAndLbl(paramsWvTemp,13 + numWaveStatsParams,startX,"startX")	dl_assignAndLbl(paramsWvTemp,14 + numWaveStatsParams,endX,"endX")	dl_assignAndLbl(paramsWvTemp,15 + numWaveStatsParams,DimDelta($waveRef,0),"inWv_DimDelta")	dl_assignAndLbl(paramsWvTemp,16 + numWaveStatsParams,power_win[0],"dc")	dl_assignAndLbl(paramsWvTemp,17 + numWaveStatsParams,sum(power_win),"power_total_win")	dl_assignAndLbl(paramsWvTemp,18 + numWaveStatsParams,sum(power_win,powerSpecScaling,x2pnt(power_win,10)),"power_to10_win")	dl_assignAndLbl(paramsWvTemp,19 + numWaveStatsParams,sum(power_win,x2pnt(power_win,10),x2pnt(power_win,20)-powerSpecScaling)	,"power_10to20_win")	dl_assignAndLbl(paramsWvTemp,20 + numWaveStatsParams,sum(power_win,x2pnt(power_win,20),x2pnt(power_win,30)-powerSpecScaling),"power_20to30_win")	dl_assignAndLbl(paramsWvTemp,21 + numWaveStatsParams,sum(power_win,x2pnt(power_win,30),x2pnt(power_win,40)-powerSpecScaling)	,"power_30to40_win")	dl_assignAndLbl(paramsWvTemp,22 + numWaveStatsParams,sum(power_win,x2pnt(power_win,40),x2pnt(power_win,60)-powerSpecScaling),"power_40to60_win")	dl_assignAndLbl(paramsWvTemp,23 + numWaveStatsParams,sum(power_win,x2pnt(power_win,60),x2pnt(power_win,100)-powerSpecScaling),"power_60to100_win")	dl_assignAndLbl(paramsWvTemp,24 + numWaveStatsParams,sum(power_win,x2pnt(power_win,100),x2pnt(power_win,200)-powerSpecScaling),"power_100to200_win")	dl_assignAndLbl(paramsWvTemp,25 + numWaveStatsParams,sum(power_win,x2pnt(power_win,200),inf),"power_200toInf_win")		String noteStr = "wREF:" + waveRef + ";"	noteStr+= "power_noWinRef:"+outRef_noWin+";power_winRef:"+outRef_cosWin+";win_func:"+winf+";"	Note paramsWvTemp, noteStr; Note power_noWin, noteStr; Note power_win, noteStr; 	Print "noteStr ==", noteStr	String ic0_saveRefs_str = ""	String killedWaveList, successfullySavedList,successfullySavedList2		//used for handling wave killing	if (saveParamsAndSpectra)		//save spectra		String ic0_pathStr=""		fio_stream_getListWvRef("ic0", "",out_usedPathStr=ic0_pathStr)	//sets ic0_pathStr to proper name	//	Print "saved non-diff spectra refs:",fio_saveWavesToDataSavePath(outList, resetDataSavePath,1,strForPathNameReturn=ic0_pathStr)		//old version		fio_pathCheckAndCreateINB(ic0_pathStr,resetDataSavePath)		successfullySavedList = ""				fio_saveWavesByName(outList, ic0_pathStr, 1,out_saveListStr= successfullySavedList)		//save string by keys for easy look up -- these are stored by fio_ic0_saveRefs in text wave at row determined by waveRef		ic0_saveRefs_str=""		if (saveToRefList_noSomaPedBoth == 1)		//soma only			//first site = soma			ic0_saveRefs_str=ReplaceStringByKey("s1_wave", ic0_saveRefs_str, waveRef)			ic0_saveRefs_str=ReplaceStringByKey("s1_params", ic0_saveRefs_str, paramSaveRef)			ic0_saveRefs_str=ReplaceStringByKey("s1_powerWin", ic0_saveRefs_str, outRef_cosWin)			ic0_saveRefs_str=ReplaceStringByKey("s1_powerNoWin", ic0_saveRefs_str, outRef_noWin)			ic0_saveRefs_str=ReplaceStringByKey("pairStatus", ic0_saveRefs_str, "1")		//3 for both, 1 for soma only, 2 for ped only						fio_stream_saveToStream("ic0", baseName,ic0_saveRefs_str,streamTags,ic0_pathStr, 0,"",0)				display/k=1 $outRef_cosWin;setaxis bottom,1,100;setaxis/A=2 left;modifygraph log(left)=1		//	fio_ic0_saveRefs(waveRef,ic0_saveRefs_str,ic0_pathStr)		//saves refs to file		elseif (saveToRefList_noSomaPedBoth == 2)			//second site = ped			ic0_saveRefs_str=ReplaceStringByKey("s2_wave", ic0_saveRefs_str, waveRef)			ic0_saveRefs_str=ReplaceStringByKey("s2_params", ic0_saveRefs_str, paramSaveRef)			ic0_saveRefs_str=ReplaceStringByKey("s2_powerWin", ic0_saveRefs_str, outRef_cosWin)			ic0_saveRefs_str=ReplaceStringByKey("s2_powerNoWin", ic0_saveRefs_str, outRef_noWin)			ic0_saveRefs_str=ReplaceStringByKey("pairStatus", ic0_saveRefs_str, "2")		//3 for both, 1 for soma only, 2 for ped only			fio_stream_saveToStream("ic0", baseName,ic0_saveRefs_str,streamTags,ic0_pathStr, 0,"",0)				display/k=1 power_noWin		//	fio_ic0_saveRefs(waveRef,ic0_saveRefs_str,ic0_pathStr)		//saves refs to file -- see this call below for more details		endif	//if saveToRefList_noSomaPedBoth == 3, handled in diffs portion (all saved at once)	endif		Print "analysis wave list: " + outList		//currently assumes that the second wave is ped, so results are ped - soma throughout	if (!ParamIsDefault(secondSiteWvRefList) && strlen(secondSiteWvRefList))		String secondSiteWvRef = StringFromList(0,secondSiteWvRefList)		String secondSiteParamsWvRef = StringFromList(1,secondSiteWvRefList)		String secondSitePowerRef_noWin = StringFromList(2,secondSiteWvRefList) 		String secondSitePowerRef_win = StringFromList(3,secondSiteWvRefList)		WAVE secondSiteWv = $secondSiteWvRef		WAVE secondSiteParamsWv = $secondSiteParamsWvRef		WAVE secondSitePower_noWin = $secondSitePowerRef_noWin		WAVE secondSitePower_win = $secondSitePowerRef_win				//determine where to store results		String params_diff_ref = paramSaveRef + "_d"		String power_win_diff_ref = outRef_noWin + "_d"		String power_noWin_diff_ref = outRef_cosWin + "_d"		String crossPowerSpectrumRef = paramSaveRef + "xf"		//for some ped cross power in frequency domain		String crossCorrelationRef = paramSaveRef + "xt"	//for some ped cross correlation in time domain		String crossPowerSpectrumRepsRef = paramSaveRef + "xfr"		//for some ped cross power in frequency domain		String crossCorrelationRepsRef = paramSaveRef + "xtr"	//for some ped cross correlation in time domain				//calculate diff waves		Duplicate/O paramsWvTemp, params_diffWv_ic0Temp, params_fDiffWv_ic0Temp		params_diffWv_ic0Temp=secondSiteParamsWv-paramsWvTemp;dl_appendToLbls(params_diffWv_ic0Temp,0,"D_",1,-inf,inf)		params_fDiffWv_ic0Temp=secondSiteParamsWv / paramsWvTemp;dl_appendToLbls(params_fDiffWv_ic0Temp,0,"fD_",1,-inf,inf)				Duplicate/O power_win, $power_win_diff_ref/WAVE=power_win_diff_wv		power_win_diff_wv = secondSitePower_win / power_win 		Duplicate/O power_noWin, $power_noWin_diff_ref/WAVE=power_noWin_diff_wv		power_noWin_diff_wv = secondSitePower_noWin / power_noWin				//calculate cross-correlation + relevant parameters		analysis_avgPowerSpectraOrCross(waveRef,crossPowerSpectrumRef,"",startX,endX, timeBin_s,timeBin_s*proportionWinOverlay,1,subEachRep=1,inWave2Ref=secondSiteWvRef,tdOutputRef=crossCorrelationRef,fdRepsOutputRef=crossPowerSpectrumRepsRef,tdRepsOutputRef=crossCorrelationRepsRef)		String autocorrelationStatsRef = analysis_autocorrelationStats($crossCorrelationRef,"");dl_appendToLbls($autocorrelationStatsRef,0,"AC_",1,-inf,inf)		Print "autocorrelationStatsRef",autocorrelationStatsRef		disp_killWinsWithWave(params_diff_ref,0,1)		//killwaves $params_diff_ref		wave_cat_NP_withDimLabels("params_diffWv_ic0Temp;params_fDiffWv_ic0Temp;"+autocorrelationStatsRef +";",params_diff_ref,0, 0)		WAVE/D params_diff_wv = $params_diff_ref				//write down results		Note/nocr/k params_diff_wv, "DIFFWAVE_firstSite_wRef:"+waveRef+";DIFFWAVE_secondSite_wRef:"+secondSiteWvRef + ";"		Note/nocr params_diff_wv, "DIFFWAVE_firstSite_paramRef:"+paramSaveRef+";DIFFWAVE_secondSite_paramRef:"+secondSiteParamsWvRef+ ";"		Note/nocr params_diff_wv, "DIFFWAVE_params_diff_ref:"+params_diff_ref+";DIFFWAVE_power_win_diff_ref:"+power_win_diff_ref+";DIFFWAVE_power_noWin_diff_ref:"+power_noWin_diff_ref+";"		Note/nocr params_diff_wv, "DIFFWAVE_method:result=secondSite/firstSite;"		Note/nocr params_diff_wv, "DIFFWAVE_crossPowerSpectrumRef:"+crossPowerSpectrumRef+";DIFFWAVE_crossCorrelationRef:"+crossCorrelationRef+";"		Note/nocr params_diff_wv, "DIFFWAVE_crossPowerSpectrumRepsRef:"+crossPowerSpectrumRepsRef+";DIFFWAVE_crossCorrelationRepsRef:"+crossCorrelationRepsRef+";"				//display autocorrelation with its reflection (to see if one trace tends to lag/lead the other)		disp_ic0(params_diff_ref)				//save waves generated		if (saveParamsAndSpectra)			String diffSaveList = params_diff_ref + ";" + power_win_diff_ref + ";" + power_noWin_diff_ref + ";"			diffSaveList += crossPowerSpectrumRef + ";" + crossCorrelationRef + ";"   + crossPowerSpectrumRepsRef + ";"   + crossCorrelationRepsRef + ";" 						if  (saveToRefList_noSomaPedBoth == 3)				//save string by keys for easy look up -- these are stored by fio_ic0_saveRefs in text wave at row determined by waveRef					//first site				ic0_saveRefs_str=ReplaceStringByKey("s1_wave", ic0_saveRefs_str, waveRef)				ic0_saveRefs_str=ReplaceStringByKey("s1_params", ic0_saveRefs_str, paramSaveRef)				ic0_saveRefs_str=ReplaceStringByKey("s1_powerWin", ic0_saveRefs_str, outRef_cosWin)				ic0_saveRefs_str=ReplaceStringByKey("s1_powerNoWin", ic0_saveRefs_str, outRef_noWin)					//second site				ic0_saveRefs_str=ReplaceStringByKey("s2_wave", ic0_saveRefs_str, secondSiteWvRef)				ic0_saveRefs_str=ReplaceStringByKey("s2_params", ic0_saveRefs_str, secondSiteParamsWvRef)				ic0_saveRefs_str=ReplaceStringByKey("s2_powerWin", ic0_saveRefs_str, secondSitePowerRef_win)				ic0_saveRefs_str=ReplaceStringByKey("s2_powerNoWin", ic0_saveRefs_str, secondSitePowerRef_noWin)					//diffs							ic0_saveRefs_str=ReplaceStringByKey("params_diff_ref", ic0_saveRefs_str, params_diff_ref)				ic0_saveRefs_str=ReplaceStringByKey("diff_powerWin", ic0_saveRefs_str, power_win_diff_ref)				ic0_saveRefs_str=ReplaceStringByKey("diff_powerNoWin", ic0_saveRefs_str, power_noWin_diff_ref)				ic0_saveRefs_str=ReplaceStringByKey("diff_cc_td", ic0_saveRefs_str, crossCorrelationRef)				ic0_saveRefs_str=ReplaceStringByKey("diff_ccr_td", ic0_saveRefs_str, crossPowerSpectrumRef)				ic0_saveRefs_str=ReplaceStringByKey("diff_cc_fd", ic0_saveRefs_str, crossPowerSpectrumRepsRef)				ic0_saveRefs_str=ReplaceStringByKey("diff_ccr_fd", ic0_saveRefs_str, crossCorrelationRepsRef)					//other info				ic0_saveRefs_str=ReplaceStringByKey("pairStatus", ic0_saveRefs_str, "3")		//3 for both, 1 for soma only, 2 for ped only					//save to file				successfullySavedList2 = ""				fio_saveWavesByName(diffSaveList, ic0_pathStr, 1,out_saveListStr= successfullySavedList2)					successfullySavedList += successfullySavedList2				successfullySavedList = RemoveFromList(waveRef+";"+secondSiteWvRef+";", successfullySavedList2 )		//dont				fio_stream_saveToStream("ic0", baseName,ic0_saveRefs_str,streamTags,ic0_pathStr, 0,"",0)				endif		endif			endif		Print "analysis_ic0_stats():ic0_saveRefs_str",ic0_saveRefs_str		return outListend//analysis_ic0_stats()function fio_ic0_saveRefs(mainRef,refsStr, ic0_pathStr)	String mainRef	//used to index into the saved text file. Should be somatic ic0 ref except when recording is ped only	String ic0_pathStr		//name of symbolic path storing 	String refsStr					//keyword-string list of refs			String ic0_refListWvName = "ic0_refs_main0"	String listOfLoadedWvs = ""		//add useful info to refsStr	refsStr = fio_keyedRefsList_addInfo(refsStr)		//check if ic0 text wave already exists	Print "ic0_pathStr",ic0_pathStr	fio_loadfiles(ic0_refListWvName, "", pathName = ic0_pathStr, out_fileListStr=listOfLoadedWvs)		Variable rowToMod	if (ItemsInLisT(listOfLoadedWvs) < 1)		//failed to load any waves, make new load list		Make/O/T/N=1 $ic0_refListWvName/WAVE=ic0_refListWv		rowToMod = 0	else		WAVE/T ic0_refListWv = $ic0_refListWvName 		//wave was loaded into experiment, so declare it locally		//check for existance of data associated with this mainRef		rowToMod = FindDimLabel(ic0_refListWv, 0, mainRef )		if (rowToMod < 0)		//label not found, redimension and append to last row			rowToMod = DimSize(ic0_refListWv,0)			Redimension/N=(rowToMod+1) ic0_refListWv		endif	//otherwise row found so now update the row with the new data 	endif		//fill/overwrite rowtoMod	ic0_refListWv[rowToMod]=refsStr;SetDimLabel 0,rowToMod,$mainRef,ic0_refListWv		//save file	fio_saveWavesByName("ic0_refListWvName", ic0_pathStr, 1)		//seems like this should be ic0_refListWvName with no quotes? made general one in this fashionendfunction/S fio_stream_operation_g(optionsStr,streamNameStr, keyStr)	String optionsStr		//"list", "macroStr:[macro]","load"	String streamNameStr	//see fio_getStreamListWvRef for usage	String keyStr		//key to use		String pathStr = ""		String refListWvName = fio_stream_getListWvRef(streamNameStr,"",out_usedPathStr=pathStr)		//get standard refListWvName and pathStr		String list = text_keyedColumns2List($refListWvName,keyStr,0)		if (stringmatch(optionsStr,"list"))				return list	endif		if (stringmatch(optionsStr,"macroStr:*"))		//macro passed to run on waves (waves must be loaded already with optionsStr = "load" for example)		list_operation_g(StringFromList(1,optionsStr,":"), list)		return list	endif		String fullPath	if (!fio_pathCheckAndcreateINB(pathStr,0,full_path=fullPath))		return "ERROR:FAILED_TO_FIND_PATH;matchingList:"+ReplaceString(";",list,",")+";"	endif				strswitch(optionsStr)		case "load":			String listOfLoadedWvs = ""			Print "here list = ", list			fio_loadfiles("*", "", pathName = pathStr, out_waveListStr=listOfLoadedWvs,loadWvListStr=list)			return "matchingList:"+ReplaceString(";",list,",")+";loadedList:"+ReplaceString(";",listOfLoadedWvs,",")+";"		break		default:			return list	endswitch		return list	endfunction/S text_keyedColumns2List(listWv, keyStr, colNum)	WAVE/T listWv		//wave with columns containing string lists	String keyStr		//keyStr whose info is desired	Variable colNum		//column to draw from		variable i; string out = ""	for (i=0;i<DimSize(listWv,0);i+=1)		out += Stringbykey(keyStr, listWv[i][colNum]) + ";"	endfor		return out	endfunction/S fio_stream_getListWvRef(streamNameStr, typicalPathStr, [out_listOfLoadedWvs, out_fullPath, out_usedPathStr,resetPath,d])	String streamNameStr	String typicalPathStr		//pass path to also load the ref into Igor. pass any string of strlen 1 to have name auto-generated	String &out_listOfLoadedWvs	//pass to have list of loaded waves (usually just refListWvName) stored here. Ignored except if typicalPathStr passed and thus set to doLoad	String &out_fullPath				//same as out_listOfLoadedWvs but for full path for typicalPathStr	String &out_usedPathStr		//pass to autogenerate typicalPathStr	Variable d	//optionally pass true to display (simply edit/k=1 $refListWvName.ld)	Variable resetPath	//optionally pass to reset symbolic path mapping .. only matters if doLoad is set (strlen(typicalPathStr) > 0)		Variable doLoad = strlen(typicalPathStr) > 0	Variable autoTypicalPathStr = (strlen(typicalPathStr) < 2) || !ParamIsDefault(out_usedPathStr)		String refListWvName	strswitch(streamNameStr)	// string switch		case "ic0":	// "ic0":ic0_main()			refListWvName = "ic0_refs_main0"		//typicalPathStr = "wn_path"			if (autoTypicalPathStr)				typicalPathStr = "i0_path";			endif			break		case "vi":	// "vi":VI_main()			refListWvName = "vi_refs_main0"				if (autoTypicalPathStr)				typicalPathStr = "vi_path";			endif			break		case "wn":		//"wn":wn_main()			refListWvName = "wn_refs_main0"			if (autoTypicalPathStr)				typicalPathStr = "wn_path";			endif			break		case "cp":		//"cp":cp_main()			refListWvName = "cp_refs_main0"			if (autoTypicalPathStr)				typicalPathStr = "cp_path";			endif						break		case "scp":		//"scp":scp_main()			refListWvName = "scp_refs_main0"			if (autoTypicalPathStr)				typicalPathStr = "scp_path";			endif						break				case "ic_cp":	//"ic_cp":ic_cp_main()			refListWvName = "ic_cp_refs_main1"			if (autoTypicalPathStr)				typicalPathStr = "ic_cp_path";			endif						break			case "scp_bad":	//"scp_bad":scp_bad_main()			refListWvName = "scp_bad_refs_main0"			if (autoTypicalPathStr)				typicalPathStr = "scp_bad_path";			endif						break			case "sin":	//"sin":sin_main()			refListWvName = "sin_refs_main0"			if (autoTypicalPathStr)				typicalPathStr = "sin_path";			endif						break			case "trace":	//()			refListWvName = "trace_refs_main0"			if (autoTypicalPathStr)				typicalPathStr = "trace_path";			endif						break				default:			return "ERROR:FAILED_TO_FIND_refListWvName"	endswitch		if (!ParamIsDefault(out_usedPathStr))		out_usedPathStr = typicalPathStr	endif		if (!doLoad)		print "streamNameStr",streamNameStr,"refListWvName",refListWvName,"typicalPathStr",typicalPathStr		return refListWvName	endif		String listOfLoadedWvs_temp="", fullPath_temp=""		//check path and abort on failure to set one	Variable forcePathReset = !ParamIsDefault(resetPath) && resetPath	if (!fio_pathCheckAndcreateINB(typicalPathStr,forcePathReset,full_path=fullPath_temp))		return "ERROR:FAILED_TO_FIND_PATH. info:"+" streamNameStr "+streamNameStr+" refListWvName "+refListWvName+" typicalPathStr "+typicalPathStr	endif				print "streamNameStr",streamNameStr,"refListWvName",refListWvName,"typicalPathStr",typicalPathStr,"fullPath_temp",fullPath_temp	fio_loadfiles(refListWvName, "", pathName = typicalPathStr, out_waveListStr=listOfLoadedWvs_temp)		if (!ParamIsDefault(out_listOfLoadedWvs))		out_listOfLoadedWvs = listOfLoadedWvs_temp	endif	if (!ParamIsDefault(out_fullPath))		out_fullPath = fullPath_temp	endif	if ( !ParamIsDefault(d) && d && WaveExists($refListWvName) )		edit/k=1 $refListWvName.ld	endif			return refListWvNameend	//fio_getStreamListWvRef()function/S fio_stream_saveToStream(streamNameStr,mainRef,infoStr,streamTags,typicalPathStr,deleteRef,listOfRefsToSaveInPath, deleteSavedStreamRefs [out_savedWavesList])	String streamNameStr	//pass stream identifier, e.g. "ic0" or "vi"	String mainRef	//used to index into the saved text file. Should be somatic ref except when recording is ped only	String typicalPathStr		//str for symbolic path used for this analysis stream	String infoStr					//keyword-string list of refs	Variable deleteRef			//pass 1 to remove a reference. infoStr is ignored. Pass 2 to delete entire refListWv, mainRef+infoStr are ignored	String listOfRefsToSaveInPath	//pass either an empty string or a list of refs to save in same location	String &out_savedWavesList		//optionally pass to return list of waves saved -- ONLY includes those from listOfRefsToSaveInPath, so not the main refListWvName	Variable deleteSavedStreamRefs	//pass true to delete refs successfully saved to path (again only includes those on listOfRefsToSaveInPath	String streamTags			//e.g. "block:2;"		//check stream tag format: must end in ";" (and should be keyword list paired with ":" but this isn't checked	//check if streamTags has any length, if so check that it ends in ";" and if not add one	streamTags = text_appendStrIfAbsent(streamTags,";",0)		//appends semi colon if string has length (0 selector) and semi colon not already at the end)	//then add streamTags to front of infoStr	infoStr = streamTags + infoStr				String full_path="", listOfLoadedWvs=""	String refListWvName = fio_stream_getListWvRef(streamNameStr,"",out_listOfLoadedWvs=listOfLoadedWvs,out_fullPath=full_path,out_usedPathStr=typicalPathStr)			if (stringmatch(refListWvName,"ERROR*"))		Print "fio_stream_saveToStream(): Aborting on error =",refListWvName		return ""	endif	//add useful info to infoStr	infoStr = fio_keyedRefsList_addInfo(infoStr)	infoStr = ReplaceStringByKey("typicalPathStr", infoStr, typicalPathStr)		//check if refListWvName already exists (in file, not in experiment)	fio_loadfiles(refListWvName, "", pathName = typicalPathStr, out_waveListStr=listOfLoadedWvs,out_fullPathsListStr=full_path)	infoStr = ReplaceStringByKey("full_path", infoStr, full_path)	Print "fio_stream_saveToStream():  waves loaded from refListWvName",refListWvName,":",listOfLoadedWvs,"full_path",full_path		Variable rowToMod	if (deleteRef == 2)		Variable deleteCheck = 0		prompt deleteCheck, "Really delete stream ref="+refListWvName+"? (1 to delete, 0 to cancel)"		doprompt "fio_stream_saveToStream() complete deletion check", deleteCheck		Make/O/T/N=1 $refListWvName/WAVE=refListWv		//overwrite in any case		refListWv[0] = ""; SetDimLabel 0,0,$"",refListWv		return typicalPathStr	elseif ( !WaveExists($refListWvName) && (ItemsInLisT(listOfLoadedWvs) < 1) )		//failed to load any waves or wave not found		if (deleteRef == 1)		//ref not found even though delete was requested, do nothing			Print "fio_stream_saveToStream(): delete ref request failed, ref not found (no refListWv exists in folder). ref=",mainRef			return typicalPathStr		endif		Print "fio_stream_saveToStream(): refListWvName=",refListWvName,"not found. making new"		Make/T/N=1 $refListWvName/WAVE=refListWv		rowToMod = 0	endif			WAVE/T refListWv = $refListWvName 		//wave was loaded into experiment, so declare it locally	//check for existance of data associated with this mainRef	rowToMod = dl_finddimlbl(refListWv, 0, mainRef )	Print "rowToMod",rowToMod	if (rowToMod < 0)		//label not found, redimension and append to last row		if (deleteRef==1)		//ref not found even though delete was requested, do nothing			Print "fio_stream_saveToStream(): delete ref request failed, ref not found. ref=",mainRef			return typicalPathStr		endif				if ( (strlen(refListWv[0]) < 1) && (strlen(GetDimLabel(refListWv, 0, 0)) < 1 ) )		//is the first cell empty? if so start by  filling in row 0 (happens during first call after a deleteRef==2)			Print "fio_stream_saveToStream(): -- if didn't just delete", refListWvName, "then there might be an issue"			rowToMod = 0		else			rowToMod = DimSize(refListWv,0)			Redimension/N=(rowToMod+1) refListWv		endif	endif	//otherwise row found so now update the row with the new data 			if (!deleteRef)		//fill/overwrite rowtoMod		refListWv[rowToMod]=infoStr;SetDimLabel 0,rowToMod,$mainRef,refListWv	elseif (deleteRef == 1)		//handles most deletions		if (rowToMod < DimSize(refListWv,0)- 1)	//if row to mod is not the last row			Variable i			for (i=rowToMod;i<DimSize(refListWv,0)-1;i+=1)	//shift all rows after row to delete up by one, overwriting rowToMod				SetDimLabel 0,i,$GetDimLabel(refListWv,0,i+1),refListWv				refListWv[i] = refListWv[p+1]			endfor			//refListWv[rowToMod,DimSize(refListWv,0)-2] = refListWv[p+1]		//shift all rows after row to delete up by one, overwriting rowToMod		endif		Redimension/N=(DimSize(refListWv,0)-1,-1) refListWv		//remove one row (row N-1), which is rowToMod or is now duplicated in row N-2	endif	//save file	fio_saveWavesByName(refListWvName, typicalPathStr, 1)		if (strlen(listOfRefsToSaveInPath) > 0)		String savedWvList = ""		fio_saveWavesByName(savedWvList, typicalPathStr,1,saveListStr=listOfRefsToSaveInPath,deleteAfterSave=deleteSavedStreamRefs)		if (!ParamIsDefault(out_savedWavesList))			listOfRefsToSaveInPath = savedWvList		endif	endif		return typicalPathStrendfunction/S text_appendStrIfAbsent(str,appendStr,appendToZeroLenStr)	String str,appendStr	Variable appendToZeroLenStr	//pass true to append to zero length strings, otherwise zero length strings are returned unchanged		Variable len_appStr = strlen(appendStr)	Variable len_str = strlen(str)		//if !appendToZeroLenStr, check str len and return string if no change needed (len_str < 1)	if (!appendToZeroLenStr && (len_str < 1))		return str	endif		//add append str if appendStr does not already terminate str	if (!stringmatch(str[len_str-len_appStr,inf],appendStr))		str += appendStr	endif		return strendfunction/S fio_stream_loadStreamList(streamNameStr,[noDisp])	String streamNameStr;variable noDisp	String typicalPathStr="",full_path="",listOfLoadedWvs=""		String refListWvName = fio_stream_getListWvRef(streamNameStr,"",out_listOfLoadedWvs=listOfLoadedWvs,out_fullPath=full_path,out_usedPathStr=typicalPathStr)			if (stringmatch(refListWvName,"ERROR*"))		Print "fio_stream_saveToStream(): Aborting on error =",refListWvName		return ""	endif		//check if refListWvName already exists (in file, not in experiment)	fio_loadfiles(refListWvName, "", pathName = typicalPathStr, out_waveListStr=listOfLoadedWvs,out_fullPathsListStr=full_path)	Print "fio_stream_saveToStream():  waves loaded from refListWvName",refListWvName,":",listOfLoadedWvs,"pathStr",typicalPathStr,"full_path",full_path		String notestr = note($reflistwvname)	notestr = replacestringbykey("fio_loadpath",noteStr,full_path)	note/nocr $refListWvName,notestr		if (ParamIsDefault(noDisp) || !noDisp)		edit/k=1 $reflistwvname.ld	endif	return refListWvNameendfunction/S rowToListContigentOnRow(listRow,contingentRow,contigentMatchStr,textWvRef)	Variable listRow,contingentRow	String textWvRef,contigentMatchStr		WAVE/T wv = $textWvRef		variable i; string out = ""	for (i=0;i<dimsize(wv,0);i+=1)		if (stringmatch(wv[i][contingentRow],contigentMatchStr))			if (numtype(listRow) || (listRow < 0) )				out += getdimlabel(wv,0,i) + ";"			else				out += wv[i][listRow] + ";"					endif		endif	endfor		return outendfunction iterate_listWvFunc(ref,iterationDim,funcNameStr,passRefOrWaveToFunc)	String ref			//wave to iterate over	Variable iterationDim	//dimension of wave to iterate	String funcNameStr	Variable passRefOrWaveToFunc		Variable i,num_iterations = dimsize($ref,iterationDim)		if (passRefOrWaveToFunc == 1)		funcref iterate_listWvFuncProto_passWv f = $funcNameStr		for (i=0;i<num_iterations;i+=1)			f($ref,i)		endfor	elseif (passRefOrWaveToFunc == 2)		funcref iterate_listWvFuncProto_passRef g = $funcNameStr		for (i=0;i<num_iterations;i+=1)			g(ref,i)		endfor	else		funcref iterate_listWvFuncProto_noPass h = $funcNameStr		for (i=0;i<num_iterations;i+=1)			h(i)		endfor	endif	endfunction iterate_listWvFuncProto_noPass(index)	Variable indexendfunction iterate_listWvFuncProto_passWv(wv,index)	Variable index; WAVE wvendfunction iterate_listWvFuncProto_passRef(ref,index)	Variable index; String refend	 function fio_scp_addVCStatus(row)	VAriable row		WAVE/T scp_refs_main0		Variable defaultValueWhenNoRecFromSite = -1		String info = scp_refs_main0[row]		Variable somaPedBothOrBothRev = numberByKey("somaPedBothOrBothRev",info)		Variable soma_hs1 = (somaPedBothOrBothRev==0) || (somaPedBothOrBothRev==4)	variable ped_hs1 =  (somaPedBothOrBothRev==2) || (somaPedBothOrBothRev==5)		String somaRef = stringbykey("respRef_S",info)	String pedRef = stringbykey("respRef_P",info)	String somaFName,pedFName		Variable somaChan,pedChan,somaFNum,somaIsVC_fP,pedFNum,pedISVC_fS,pedChan_fS,somaChan_fP,somaFNum_fiw,pedFNum_fiw		if (strlen(somaRef))		somaFNum = text_getInfoFromWaveName_V(somaRef, 1)		somaChan = text_getInfoFromWaveName_V(somaRef, 3)		somaFName = text_getinfofromwavename_S(somaRef,9)		somaFNum_fiw = fd_getFIndexInFileInfoWave(somaFName+"*")		if (Strlen(pedRef))			if (somaChan == 0)				pedChan_fS = 2			elseif (somaChan == 2)				pedChan_fS = 0			else				Print "fio_scp_addVCStatus(): row",row,"unexpected somatic chan num",somaChan,"cannot assign ped chan num"			endif			pedIsVC_fS = stringmatch(fd_getChanStrFromFileInfoWave(somaFNum_fiw,pedChan_fS,1),"*A*")		else			pedIsVC_fS = 0		endif	else		somaFNum = inf		if (somaPedBothOrBothRev > 3)			Print "fio_scp_addVCStatus(): row",row,"unexpected lack of second site recording"		endif	endif		if (strlen(pedRef))		pedFNum = text_getInfoFromWaveName_V(pedRef, 1)		pedChan = text_getInfoFromWaveName_V(pedRef, 3)		pedFName = text_getinfofromwavename_S(pedRef,9)		pedFNum_fiw = fd_getFIndexInFileInfoWave(pedFName+"*")		if (Strlen(somaRef))			if (pedChan == 0)				somaChan_fP = 2			elseif (pedChan == 2)				somaChan_fP = 0			else				Print "fio_scp_addVCStatus(): row",row,"unexpected ped chan num",pedChan,"cannot assign ped chan num"			endif			somaIsVC_fP = stringmatch(fd_getChanStrFromFileInfoWave(pedFNum_fiw,somaChan_fP,1),"*A*")		else			pedIsVC_fS = 0		endif	else		pedFNum = inf		if (somaPedBothOrBothRev > 3)			Print "fio_scp_addVCStatus(): row",row,"unexpected lack of second site recording"		endif	endif		print "somaFNum",somaFNum,"pedFNum",pedFNum,"somaChan_fP",somaChan_fP,"somaFNum_fiw",somaFNum_fiw,"pedFNum_fiw",pedFNum_fiw		String fStr = "_fS"; Variable in_dc,in_wc,in_effectivelyClamped	if (strlen(somaRef))		in_dc = pedISVC_fS		in_wc = pedFNum <= somaFNum		in_effectivelyClamped=in_dc&&in_wc		scp_refs_main0[row]=ReplaceStringByKey("inDualClampDuringRec"+fStr,scp_refs_main0[row],num2str(in_dc));		scp_refs_main0[row]=ReplaceStringByKey("wcDistalSiteDuringRec"+fStr,scp_refs_main0[row],num2str(in_wc));		scp_refs_main0[row]=ReplaceStringByKey("effectiveClampStatus"+fStr,scp_refs_main0[row],num2str(in_effectivelyClamped));					else		scp_refs_main0[row]=ReplaceStringByKey("inDualClampDuringRec"+fStr,scp_refs_main0[row],num2str(defaultValueWhenNoRecFromSite));		scp_refs_main0[row]=ReplaceStringByKey("wcDistalSiteDuringRec"+fStr,scp_refs_main0[row],num2str(defaultValueWhenNoRecFromSite));		scp_refs_main0[row]=ReplaceStringByKey("effectiveClampStatus"+fStr,scp_refs_main0[row],num2str(defaultValueWhenNoRecFromSite));		endif		fStr = "_fP"	if (strlen(pedRef))		in_dc = somaISVC_fP		in_wc = somaFNum <= pedFNum		in_effectivelyClamped=in_dc&&in_wc		scp_refs_main0[row]=ReplaceStringByKey("inDualClampDuringRec"+fStr,scp_refs_main0[row],num2str(in_dc));		scp_refs_main0[row]=ReplaceStringByKey("wcDistalSiteDuringRec"+fStr,scp_refs_main0[row],num2str(in_wc));		scp_refs_main0[row]=ReplaceStringByKey("effectiveClampStatus"+fStr,scp_refs_main0[row],num2str(in_effectivelyClamped));					else		scp_refs_main0[row]=ReplaceStringByKey("inDualClampDuringRec"+fStr,scp_refs_main0[row],num2str(defaultValueWhenNoRecFromSite));		scp_refs_main0[row]=ReplaceStringByKey("wcDistalSiteDuringRec"+fStr,scp_refs_main0[row],num2str(defaultValueWhenNoRecFromSite));		scp_refs_main0[row]=ReplaceStringByKey("effectiveClampStatus"+fStr,scp_refs_main0[row],num2str(defaultValueWhenNoRecFromSite));		endif	endfunction fio_scp_storeInfo(row,fromPed,in_dc,in_wc)	Variable row,in_dc,in_wc,fromPed		WAVE/T scp_refs_main0		String fStr = "_f"	if (fromPeD)		fStr += "P"	else		fStr += "S"	endif		Variable in_effectivelyClamped=in_dc&&in_wc		scp_refs_main0[row]=ReplaceStringByKey("inDualClampDuringRec"+fStr,scp_refs_main0[row],num2str(in_dc));	scp_refs_main0[row]=ReplaceStringByKey("wcDistalSiteDuringRec"+fStr,scp_refs_main0[row],num2str(in_wc));	scp_refs_main0[row]=ReplaceStringByKey("effectiveClampStatus"+fStr,scp_refs_main0[row],num2str(in_effectivelyClamped));		end		function fio_stream_dispFileFromKey(refListWv,row,keyStrList)	WAVE/T refListWv; Variable row; String keyStrList		//loops through keyStrList until one comes up that's not blank		string info = refListWv[row]		variable i;string str	for (i=0;i<itemsinlist(keyStrList);i+=1)		str = stringbykey(stringfromlist(i,keyStrList),info)		if (strlen(str))			break		endif	endfor		if (!strlen(str))		return 0	endif		String fName = text_getInfoFromWaveName_S(str, 9)		da_fd_loadFile(fName,1,1,1)end//runs stringbyKey on multiple lists of cells/refs and returns a list of string names into which the output wave lists are saved (e.g. all corresponding param names)function/S fio_stream_wvListsFromRefLists(refListWvName,listOfRefListWvNames,saveAppendStrList,wv_keywordList,doLoad)	String refListWvName	String listOfRefListWvNames		//the string (list) stored in each of these is passed at label match strings	String saveAppendStrList		//strSaveName in fio_stream_listByKey is the string name from listOfRefListWvNames + the corresponding (by order) str here -- if blank then defaultSaveAppendStr="_kr" is appended for key ref	String wv_keywordList			//each of these gets passed as wv_keyword	Variable doLoad		String defaultSaveAppendStr="_kr"	string keyWordStrContigencies=""		//only handles blank for now	String displayParamsList=""		Variable i;string out="",strSaveName,wv_keyword,labelMatchStrs_strName,saveAppendStr	for (i=0;i<itemsinlist(listOfRefListWvNames);i+=1)		labelMatchStrs_strName=stringfromlist(i,listOfRefListWvNames)		SVAR/Z labelMatchStrs = $labelMatchStrs_strName		if (!Svar_exists(labelMatchStrs))			Print "fio_stream_wvListsFromRefLists(): failed to find global string named",labelMatchStrs_strName,"skipping"			continue		endif		saveAppendStr=stringfromlist(i,saveAppendStrList)		if (!strlen(saveAppendStr))			saveAppendStr=defaultSaveAppendStr		endif		strSaveName=labelMatchStrs_strName+saveAppendStr		wv_keyword=stringfromlist(i,wv_keywordList)				fio_stream_listByKey(refListWvName,strSaveName,wv_keyword,labelMatchStrs,keyWordStrContigencies,doLoad,displayParamsList)				out += strSaveName + ";"	endfor			return outendfunction/S fio_stream_listByKey(refListWvName,strSaveName,wv_keyword,labelMatchStrs,keyWordStrContigencies,doLoad,displayParamsList[returnIndicesInstead,noEmptyStrs,noLoadIfWaveExists,forceCellNameList,headerRefForRowLbls])	String refListWvName	String wv_keyword	//keyword string value to fetch into list	String labelMatchStrs		//list of acceptable label matchStrs .. "*" for no dimLabel requirements	String keyWordStrContigencies	//list of keywords to check, semicolon delim.,each contain comma delim list (len of 4) with keyStr,strFromKeyMatchStrList--"|" delim--,includeIfKeyNotFound,includeIfStrFromKeyEmpty,	Variable returnIndicesInstead	//optionally pass as true to have list of indices returned -- wv_keyword is ignored	Variable doLoad		//pass true to load waves in output list	String strSaveName		Variable noEmptyStrs	//pass to specify that no empty strings should be included in output	String displayParamsList		//pass to display resultant list with fio_disp_waves. winN = listItem 0;newOrAdd=listItem 1;color= 2;sepAxes = 3;dispCol = 4; appendStr = 5;leaving last two out is OK	Variable noLoadIfWaveExists	//optionally pass, if doLoad, then this will prevent overwrites of pre-existing waves by loading.	String forceCellNameList		//optionally pass pre-determined cell name order	String headerRefForRowLbls	//optionally pass a header ref to copy over to the row labels of each wave --only works if wv_keyword has length	String funcRepeatRef = ""	//sets to automatically not save the function -- used to be an input parameter but wasn't using it		WAVE/T refListWv = $refListWvName		Variable removeEmptyStrs = !PAramIsDefault(noEmptyStrs) && noEmptyStrs		Variable numKeyContigencies = Itemsinlist(keyWordStrContigencies)		Variable i,j	String out = ""	String keyContigencyStr,keyStr,strFromKeyMatchStrList	Variable includeStr = 0	Variable includeIfKeyNotFound,keyNotFound,includeIfStrFromKeyEmpty,strFromKeyEmpty	String dl, strFromKey,str	for (i=0;i<dimsize(refListWv,0);i+=1)		dl = GetDimLabel(refListWv,0,i)		//only include if dim label is a match		if (text_stringmatch_list(dl,labelMatchStrs))		//excluded and no further checking if this fails			includeStr = 1					//check each keyword contigency, return strByKey if contigencies are met	-- if no contigencies, this for loop is skipped			for (j=0;j<numKeyContigencies;j+=1)				includeStr = 1		//default is to include keywordStr in output, now check if string should be excluded				keyContigencyStr = stringfromlist(j,keyWordStrContigencies)				keyStr = stringfromlist(0,keyContigencyStr,",")				includeIfKeyNotFound = str2num(stringfromlist(2,keyContigencyStr,","))								//check if row should be excluded if this keywrod is not found, and exclude if keyword not found				if (!includeIfKeyNotFound)					keyNotFound = !stringmatch(refListWv[i],"*" + keySTr + "*")					if (keyNotFound)				//		Print "key not found! keyStr,",keyStr,"i",i						includeStr = 0						break	//exit j (key contigency) for loop					endif				endif						strFromKeyMatchStrList = stringfromlist(1,keyContigencyStr,",")				strFromKeyMatchStrList = replacestring("|",strFromKeyMatchStrList,";")				strFromKey = StringByKey(keyStr, refListWv[i])								//check if row should be excluded if strFromKey is empty, and exclude if empty				includeIfStrFromKeyEmpty = str2num(stringfromlist(3,keyContigencyStr,","))				if (!includeifStrFromKeyEmpty)		//do not include if string from key empty, check if that is so					strFromKeyEmpty = strlen(strFromKey) < 1					if (strFromKeyEmpty)				//		Print "strFromKeyEmpty! keyStr",keyStr,"i",i						includeStr = 0						break	//exit j (key contigency) for loop					endif				endif								//check if match strings match				if (!text_stringmatch_list(strFromKey,strFromKeyMatchStrList))				//	Print "!text_stringmatch_list! keyStr",keyStr,"i",i,"strFromKey",strFromKey,"strFromKeyMatchStrList",strFromKeyMatchStrList					includeStr = 0					break		//exit j (key contigency) for loop				endif							endfor						if (includeStr)				if (!ParamIsDefault(returnIndicesInstead) && returnIndicesInstead)					out += num2str(i) + ";"				elseif (strlen(wv_keyWord) > 0)					str = stringbykey(wv_keyword,refListWv[i])					if (removeEmptyStrs)						if (strlen(str))							out += str + ";"						endif					else						out += str + ";"					endif										if ( !ParamIsDefault(headerRefForRowLbls) && strlen(headerRefForRowLbls) && strlen(str) )						dl_headerToLabels(headerRefForRowLbls,str,0)					endif				else					out += dl + ";"				endif			endif						endif	endfor		if (doLoad)			Variable skipPreExisting = !PAramIsDefault(noLoadIfWaveExists) && noLoadIfWaveExists		fio_stream_loadIBF(refListWvName,out,skipPreExisting=skipPreExisting)	endif		//refListWvName,funcRepeatRef,wv_keyword,labelMatchStrs,keyWordStrContigencies,doLoad[returnIndicesInstead]	if (strlen(funcRepeatRef))		Make/O/T/N=(11) $funcRepeatRef/WAVE=funcRepeatWv		funcRepeatWv[0] = GetRTStackInfo(1)		funcRepeatWv[1] = "string"		funcRepeatWv[2] = "6"		funcRepeatWv[3] = "0"		funcRepeatWv[4] = "~"		funcRepeatWv[5] = refListWvName+"~"+"string"		funcRepeatWv[6] = funcRepeatRef+"~"+"string"		funcRepeatWv[7] = wv_keyword+"~"+"string"		funcRepeatWv[8] = labelMatchStrs+"~"+"string"		funcRepeatWv[9] = keyWordStrContigencies+"~"+"string"		funcRepeatWv[10] = num2str(doLoad)+"~"+"variable"	endif		string outNoNullStrs = text_removeListBlanks(out)	if (strlen(strSaveName))		String indicesSaveStr,excelNamesSaveStr,excelNamesList_local		String/G $strSaveName		SVAR saveStr = $strSaveName		saveStr = out		if (ParamIsDefault(returnIndicesInstead) || (!returnIndicesInstead) )		//automatically make a string containing indices unless indices were specifically requested			indicesSaveStr = strsaveName+"_i"			fio_stream_listByKey(refListWvName,indicesSaveStr,wv_keyword,labelMatchStrs,keyWordStrContigencies,doLoad,"",returnIndicesInstead=1,noEmptyStrs=removeEmptyStrs)			excelNamesSaveStr = strsaveName+"_e"			if (!ParamIsDefault(forceCellNameList) && strlen(forceCellNameList))				String/G $excelNamesSaveStr 				SVAR excelNamesList = $excelNamesSaveStr				excelNamesList = forceCellNameList				excelNamesList_local = excelNamesList			else				excelNamesList_local = excel_refsToExcelNames(out,!removeEmptyStrs,strSaveName=excelNamesSaveStr)			endif						if (strlen(displayParamsList))				Print "fio_stream_listByKey(): attempting display!"				String winN = stringfromlist(0,displayParamsList)				Variable newOrAdd = str2num(stringfromlist(1,displayParamsList))				String color = stringfromlist(2,displayParamsList)				Variable sepAxes = str2num(stringfromlist(3,displayParamsList))				Variable dispCol = str2num(stringfromlist(4,displayParamsList))				String appendStr = stringfromlist(5,displayParamsList)				fio_disp_waves(winN,newOrAdd,out,excelNamesList_local,color,sepAxes,dispCol=dispCol,appendStr=appendStr)			endif		endif			endif		if (returnIndicesInstead)		Print "fio_stream_listByKey(): out counting blanks",itemsinlist(out),"out no blanks",itemsinlist(outNoNullStrs),"strSaveName_ind",strSaveName,"out",out	else		Print "fio_stream_listByKey(): out counting blanks",itemsinlist(out),"out no blanks",itemsinlist(outNoNullStrs),"strSaveName",strSaveName,"out",out	endif	return outend	//fio_stream_listByKey//add a keyword from a param wavefunction fio_addStreamKey(refsListWv,wv_keyword,testParam,out_streamKeyword)	WAVE/T refsListWv; String wv_keyword,testParam,out_streamKeyword		Variable hasHeader = stringmatch(testParam,"*;*")	String headerRef = ""	Variable paramRow	if (hasHeader)		headerRef = stringfromlist(0,testParam)		testParam = replacestring(headerRef+ ";",testParam,"")		//remove header info from testParam		paramRow = findInHeader(testParam, headerRef)	endif	variable i,count=0;string saveStr,infoStr,ref	for (i=0;i<dimsize(refsListWv,0);i+=1)		infoStr = refsListWv[i]		ref = stringbykey(wv_keyword,infoStr)				if (!waveexists($ref))			fio_stream_loadIBF(nameofwave(refsListWv),ref)		endif				if (strlen(ref))			if (wavetype($ref,1) == 1)		//numeric				WAVE wv = $ref				if (hasHeader)					sprintf saveStr, "%8.64e\r", wv[paramRow]					//saveStr = num2str(wv[paramRow])				else					sprintf saveStr, "%8.64e\r", wv[%$testParam]					//saveStr = num2str(wv[%$testParam])				endif			elseif (wavetype($ref,1) == 2)	//text				WAVE/T wv_t = $ref				if (hasHeader)					saveStr = wv_t[paramRow]				else					saveStr = wv_t[%$testParam]				endif			endif		//else wave does not exist despite attempted load			saveStr = saveStr			count += 1		else			saveStr = ""		endif			refsListWv[i] = ReplaceStringByKey(out_streamKeyword,infoStr,saveStr)	endfor	Print "fio_addStreamKey(): total num rows",i,"numRows where replacement occured:",countend//fio_addStreamKey(refsListWv,wv_keyword,testParam,out_streamKeyword)//add a param wave from a keywordfunction fio_addParamsToWvsFromKeyStr(refsListWv,paramWvKey,paramKey,newParamKeyOrKeys)	WAVE/T refsListWv; String paramWvKey		//refsListWv and keyword to get wave into which param will be stored	String paramKey			//keyword to get params to be transferred into paramWv	STring newParamKeyOrKeys			//list of dimneions label(s) to use to store params in paramWv .. length sets how many params are expected		Variable numPAramsExpected = itemsinlist(newParamKeyOrKeys)		if (numParamsExpected < 1)		Print "fio_addParamsToWvsFromKeyStr(): no params expected, returning 0"		return 0	endif		Variable i,j,startRow,numNewParams,newParamRow; string info, paramVal,paramInfoStr,paramWvRef,newParamKey	Double sc_prod_fast,sc_prod_slow,sc_prod_tot,sc_quot_fast,sc_quot_slow,sc_quot_tot,sc_invquot_fast,sc_invquot_slow,sc_invquot_tot; string sc_lblStart	Variable isHSParams	//handles a special case	for (i=0;i<dimsize(refsListWv,0);i+=1)		info = refsListWv[i]		paramInfoStr = stringbykey(paramKey,info)		paramWvRef = stringbykey(paramWvKey,info)		fio_stream_loadIBF(nameofwave(refsListWv),paramWvRef,skipPreExisting=1)		if (wavetype($paramWvRef,1) == 1)	//numeric			WAVE wv = $paramWvRef			startRow = dimsize(wv,0)			for (j=0;j<numParamsExpected;j+=1)				paramVal = Stringfromlist(j,paramInfoStr,",")				newParamKey = stringfromlist(j,newParamKeyOrKeys)				newParamRow = finddimlabel(wv,0,newParamKey)								if (newParamRow < 0)		//add a row if key is not in dim labels; otherwise overwrites value at dim label if any					newParamRow = DimSize(wv,0)					redimension/N=(DimSize(wv,0) + 1,-1) wv				endif								if (stringmatch(paramVal,"hs1"))					paramVal = "1"					isHSParams = 1				elseif (stringmatch(paramVal,"hs2"))					paramVal = "0"					isHSParams = 1				endif								dl_assignAndLbl(wv,newParamRow, str2num(paramVal), stringfromlist(j,newParamKeyOrKeys))							endfor						if (isHSParams)		// sc_prod_fast,sc_prod_slow,sc_prod_tot				sc_lblStart = StringfromLisT(0,newParamKeyOrKeys)[0,1];Print "sc_lblStart",sc_lblStart				startRow = dimsize(wv,0)				sc_prod_fast = wv[%$StringfromLisT(1,newParamKeyOrKeys)]*wv[%$StringfromLisT(2,newParamKeyOrKeys)];dl_addVal(sc_prod_fast,sc_lblStart+"sc_prod_fast",nameofwave(wv),0)				sc_prod_slow = wv[%$StringfromLisT(3,newParamKeyOrKeys)]*wv[%$StringfromLisT(4,newParamKeyOrKeys)];dl_addVal(sc_prod_slow,sc_lblStart+"sc_prod_slow",nameofwave(wv),0)				sc_prod_tot = sc_prod_fast + sc_prod_slow;dl_addVal(sc_prod_tot,sc_lblStart+"sc_prod_tot",nameofwave(wv),0)				sc_quot_fast = wv[%$StringfromLisT(1,newParamKeyOrKeys)]/wv[%$StringfromLisT(2,newParamKeyOrKeys)];dl_addVal(sc_quot_fast,sc_lblStart+"sc_quot_fast",nameofwave(wv),0)				sc_quot_slow = wv[%$StringfromLisT(3,newParamKeyOrKeys)]/wv[%$StringfromLisT(4,newParamKeyOrKeys)];dl_addVal(sc_quot_slow,sc_lblStart+"sc_quot_slow",nameofwave(wv),0)				sc_quot_tot = sc_quot_fast + sc_quot_slow	;dl_addVal(sc_quot_tot,sc_lblStart+"sc_quot_tot",nameofwave(wv),0)				sc_invquot_fast = wv[%$StringfromLisT(1,newParamKeyOrKeys)]/wv[%$StringfromLisT(2,newParamKeyOrKeys)];dl_addVal(sc_invquot_fast,sc_lblStart+"sc_invquot_fast",nameofwave(wv),0)				sc_invquot_slow = wv[%$StringfromLisT(3,newParamKeyOrKeys)]/wv[%$StringfromLisT(4,newParamKeyOrKeys)];dl_addVal(sc_invquot_slow,sc_lblStart+"sc_invquot_slow",nameofwave(wv),0)				sc_invquot_tot = sc_invquot_fast + sc_invquot_slow;dl_addVal(sc_invquot_tot,sc_lblStart+"sc_invquot_tot",nameofwave(wv),0)											endif		elseif (wavetype($paramWvRef,1) == 1)	//text			WAVE/T wv_T = $paramWvRef			startRow = dimsize(wv_T,0)			redimension/N=(startRow + numParamsExpected,-1) wv_T			for (j=0;j<numParamsExpected;j+=1)				paramVal = Stringfromlist(0,paramInfoStr,",")				dl_assignAndLbl_T(wv_T,startRow+j, paramVal,  stringfromlist(j,newParamKeyOrKeys))			endfor		endif	endforendfunction/S sc2c(str,appendTrailingSemiColon)	String str	Variable appendTrailingSemiColon		return text_semiColonsToCommas(str,appendTrailingSemiColon)endfunction/S text_semiColonsToCommas(str,appendTrailingSemiColon)	String str	Variable appendTrailingSemiColon	//sometimes useful when making a list into a comma list and then adding to another comma list, with lists delimited by semi colons		if (appendTrailingSemiColon)		return replaceString(";",str,",") + ";"	endif			return replaceString(";",str,",")endfunction/S c2sc(str)	String str		return text_commasToSemiColons(str)endfunction/S text_commasToSemiColons(str)	String str		return replaceString(",",str,";")end	//ref has format: one row is funcNameStr, one row is funcParamStr, one row is isLiteralListfunction func_v_repeat2(ref,[outStr])	String ref	String &outStr		//for return values as str; if numeric return value, this is returned by the function		WAVE/T wv = $ref		String funcStr = wv[0]	String returnType = wv[1]	Variable numParams = str2num(wv[2])	Variable numOptionalParams = str2num(wv[3])	Variable totalNumParams = numParams + numOptionalParams	String paramInfoSepStr = wv[4]		Variable paramsStart_ind = 5	string execStr = "", currStr, paramStr, paramTypeStr, optionalParamNameStr	variable i,ind	String svar_tempStr = "func_repeat2_svar_",svar_temp,svar_list = ""; variable svar_count = 0		//handling of main params	for (i=0;i<totalNumParams;i+=1)		ind = paramsStart_ind + i		currStr = wv[ind]		paramStr = stringfromlist(0,wv[ind],paramInfoSepStr)		paramTypeStr = stringfromlist(1,wv[ind],paramInfoSepStr)				if (i >= numParams)		//now into optional params rather than standard params			optionalParamNameStr = stringfromlist(2,wv[ind],paramInfoSepStr)			currStr = optionalParamNameStr		else			currStr = ""		endif				strswitch (paramTypeStr)			case "string":				svar_temp = svar_tempStr + num2str(svar_count)				svar_list += svar_temp + ";"				String/G $svar_temp				SVAR svar_ref_temp = $svar_temp				svar_ref_temp = paramStr				//currStr += "\"" + paramStr + "\""				currStr += svar_temp				svar_count += 1				break			default:		//variable, wave, ... ?				currStr += paramStr		endswitch				execStr += currStr  + ","	endfor		execStr = execStr[0,strlen(execStr)-2]		//remove last comma		execStr = funcStr + "(" + execStr + ")"		String returnVarName = "func_repeat2_returnVar"	Variable/G $returnVarName	NVAR returnVar = $returnVarName		strswitch (returnType)		case "string":			returnVar = NaN			String returnStrName = "func_repeat2_returnString"			String/G $returnStrName			SVAR returnStr = $returnStrName			execStr = returnStrName + "=" + execStr			Execute execStr			Print "returnStr",returnStr			if (!ParamIsDefaulT(outStr))				outStr = returnStr				killstrings returnStr			endif			break		default:		//numeric: "variable" or ""			execStr = returnVarName + "=" + execStr	endswitch						Variable returnVarTemp = returnVar		killvariables returnVar	return returnVarTemp		end//ref has format: one row is funcNameStr, one row is funcParamStr, one row is isLiteralListfunction/S func_s_repeat2(ref)	String ref		WAVE/T wv = $ref		String funcStr = wv[0]	String returnType = wv[1]	Variable numParams = str2num(wv[2])	Variable numOptionalParams = str2num(wv[3])	Variable totalNumParams = numParams + numOptionalParams	String paramInfoSepStr = wv[4]		Variable paramsStart_ind = 5	string execStr = "", currStr, paramStr, paramTypeStr, optionalParamNameStr	variable i,ind	String svar_tempStr = "func_repeat2_svar_",svar_temp,svar_list = ""; variable svar_count = 0		//handling of main params	for (i=0;i<totalNumParams;i+=1)		ind = paramsStart_ind + i		currStr = wv[ind]		paramStr = stringfromlist(0,wv[ind],paramInfoSepStr)		paramTypeStr = stringfromlist(1,wv[ind],paramInfoSepStr)				if (i >= numParams)		//now into optional params rather than standard params			optionalParamNameStr = stringfromlist(2,wv[ind],paramInfoSepStr)			currStr = optionalParamNameStr		else			currStr = ""		endif				strswitch (paramTypeStr)			case "string":				svar_temp = svar_tempStr + num2str(svar_count)				svar_list += svar_temp + ";"				String/G $svar_temp				SVAR svar_ref_temp = $svar_temp				svar_ref_temp = paramStr				//currStr += "\"" + paramStr + "\""				currStr += svar_temp				svar_count += 1				break			default:		//variable, wave, ... ?				currStr += paramStr		endswitch				execStr += currStr  + ","	endfor		execStr = execStr[0,strlen(execStr)-2]		//remove last comma		execStr = funcStr + "(" + execStr + ")"		String returnVarName = "func_repeat2_returnVar"	Variable/G $returnVarName	NVAR returnVar = $returnVarName	String returnStrTemp = ""	strswitch (returnType)		case "string":			returnVar = NaN			String returnStrName = "func_repeat2_returnString"			String/G $returnStrName			SVAR returnStr = $returnStrName			execStr = returnStrName + "=" + execStr			Execute execStr			Print "returnStr",returnStr			returnStrTemp = returnStr			killstrings returnStr			break		default:		//numeric: "variable" or ""			execStr = returnVarName + "=" + execStr	endswitch						killvariables returnVar	return returnStrTemp		endfunction func_repeat(funcStr,funcParamsStr,isLiteralList)	String funcStr		//name of function to call	String funcParamsStr		//list of literal strings to use as parameter inputs; either "paramName" or "optionalParamName=paramName")	String isLiteralList		//list paired with funcParamsStr specifying string literals, "" will be appended		string execStr = "", currStr	variable i	for (i=0;i<itemsinlist(funcParamsStr);i+=1)		currStr = stringfromlist(i,funcParamsStr)		if (str2num(stringfromlist(i,isLiteralList)))			currStr = "\"" + currStr + "\""		endif		execStr += currStr  + ","	endfor		execStr = execStr[0,strlen(execStr)-2]		//remove last comma		execStr = funcStr + "(" + execStr + ")"		Execute execStr	end//no handling for headers yet or for choosing only a subset of parametersfunction fio_mParamVsExcelParams_set(initialCheckBeforeRun,paramsSaveRef,listOfParamListStrs,sourcesList,dlAppendList)	Variable initialCheckBeforeRun	String paramsSaveRef,listOfParamListStrs,sourcesList,dlAppendList		String paramLists = "" //tells fio_disp_mParamsVsExcelParams to use all params	String hasHeaderList = ""		//tells  fio_disp_mParamsVsExcelParams that there are no headers		//standard choices for excel parameters	string excelParamStrList = ""//rec_site_len;ax_len;isFoveal;DIV;hs_S;"	string excelParamBinList=""//100,;100,;.5,;.5,;1.5,;"	Variable numLists = itemsinlist(listOfParamListStrs)	String currParamNameStr	variable i; string excelNameList		Variable addDuplicateSources = itemsinlist(sourcesList) == 1	if (addDuplicateSources)		if (!stringmatch(sourcesList,"*;"))			sourcesList += ";"		endif	endif		String paramRefLists="",cellNameLists="",paramRefIndexList=""	for (i=0;i<numLists;i+=1)		currParamNameStr = stringfromlist(i,listOfParamListStrs)		SVAR/Z paramRefListStr = $currParamNameStr		SVAR/Z paramRefListIndexStr = $(currParamNameStr+"_i")		//standard naming from fio_stream_listByKey		SVAR/Z excel_localStr = $(currParamNameStr+"_e")		if (!Svar_exists(paramRefListStr) || !Svar_exists(paramRefListIndexStr) || !Svar_exists(excel_localStr) )			Print "fio_mParamVsExcelParams_set(): Aborting due to failure to find SVAR (from listOfParamListStrs) =",currParamNameStr 			return 0		endif		//		SVAR/Z excel_localStr = $(currParamNameStr+"_e")//		if (!strlen(excel_localStr))//			String/G $(currParamNameStr+"_e")//			Print "fio_mParamVsExcelParams_set(): excelNameList for currParamNameStr",currParamNameStr,"not found. attempting to create"//			excel_localStr = excel_refsToExcelNames(paramRefListStr,1)		//include blanks//		endif				paramRefLists += sc2c(paramRefListStr,1)		cellNameLists += sc2c(excel_localStr,1)		paramRefIndexList += sc2c(paramRefListIndexStr,1)				if (addDuplicateSources)			sourcesList += Stringfromlist(0,sourcesList) + ";"		endif	endfor		Print "paramRefLists",paramRefLists,"cellNameLists",cellNameLists,"paramRefIndexList",paramRefIndexList		if (initialCheckBeforeRun)		Variable doContinue = 1		prompt doContinue, "continue?"		doprompt "continue to make params wave?", doContinue				if (!doContinue)			Print "fio_mParamVsExcelParams_set(): user aborted."			return 0		endif	endif		fio_disp_mParamsVsExcelParams(paramsSaveRef,paramRefLists,dlAppendList,paramLists,hasHeaderList,cellNameLists,excelParamStrList,excelParamBinList,paramRefIndexList,sourcesList)endfunction fio_disp_mParamsVsExcelParams(paramsSaveRef,paramRefLists,dlAppendList,paramLists,hasHeaderList,cellNameLists,excelParamStrList,excelParamBinList,sourcesIndices,sourcesList[paramColList,genParamListFromMatchStr])	String paramsSaveRef		//save ref for generated output wave (which is in a good format for column vs column display)	String paramRefLists		//ordered lists of paramRefs. semi colon between lists, commas within lists. Lengths should be equal; otherwise output length is set based on length of first list	String dlAppendList			//ordered list of dim labels to append to param names corresponding to each paramRefList; this way similar param names can be extracted from the output when they come from different paramRefLists	String paramLists			//pass "" to automatiaclly use all available params based on dim labels or header waves, otherwise see next comment			//order list of params; one list for each list of paramRefs; or pass null for any given paramRefList and auto generate by passing genParamListFromMatchStr	String hasHeaderList		//ordered list, semi-colon delim, specifying where each paramList has a header; pass "" for no headers used throughout	String cellNameLists		//ordered list of cellNameRefs, length should match paramRef list; if only one list is passed, assumed that it represents all lists of param refs	String excelParamStrList	//name of excel param to plot against, e.g. "ax_len" "rec_site_len" "total_len"	String excelParamBinList	//paired with excelParamStrList, bin borders. e.g. pass 100 to cut off axon length at 100 -- num bins = numpnts + 1 as comma list, so one bin < 100 and one bin > 100	String paramColList			//optionally pass to use a param column other than the zeroth param col for each paramRefList, same rules as for genParamFromMatchStrList (i.e., 0 is used by default for empty string list items)	String genParamListFromMatchStr		//optionally pass to auto-generate comprehensive paramList for one or more paramRefLists, semi-colon delim and should be as long as paramRefList, null string within semi colon signifies that paramList in paramLists should be used	String sourcesIndices		//indexes in refsList from which paramRefLists came; semi colon delimited in matching order to paramRefLists, commas between indices (just like paramRefLists)	String sourcesList			//semi-colon delim list of the refsList from which paramRefLists came, order matching paramRefLists and sourcesIndices			Variable includeAllPossibleExcelNames = 1		//will make a row for each cell in excel_info, even if theres no data at all from these cells		if (!strlen(excelParamStrList))		excelParamStrList = "rec_site_len;ax_len;isFoveal;div;hs_S;pA_inj_issue;"	endif		if (!strlen(excelParamBinList))		excelParamBinList="100,;100,;.5,;.5,;1.5,;.5,;"	endif		Variable numParamRefLists = itemsinlist(paramRefLists,";")		if (strlen(dlAppendList) < 1)		dlAppendList = text_getRepeatedStr(";",numParamRefLists)		//default will to be append no additional labels	endif		if (strlen(hasHeaderList) < 1)		hasHeaderList = text_getRepeatedStr(";",numParamRefLists)		//if hasHeaderList = "", assume no headers used in any paramList	endif		Variable autoGenerateAllParamLists	if (strlen(paramLists) < 1)		paramLists = text_getRepeatedStr(";",numParamRefLists)		//if paramLists = "", assume no headers used in any paramList		autoGenerateAllParamLists = 1	else		autoGenerateAllParamLists = 0	endif		String usedGenParamFromMatchStrList	if (!ParamIsDefault(genParamListFromMatchStr))		usedGenParamFromMatchStrList = genParamListFromMatchStr	elseif (autoGenerateAllParamLists)		usedGenParamFromMatchStrList = text_getRepeatedStr("*;",numParamRefLists)		//select all available params for each paramRefList	else		usedGenParamFromMatchStrList = text_getRepeatedStr(";",numParamRefLists)		//defaul to blank for all lists, which will cause paramLists to be used instead of generating them	endif		String usedParamColList	if (!ParamIsDefault(paramColList))		usedParamColList = paramColList	else		usedParamColList = text_getRepeatedStr("0;",numParamRefLists)		//defaul to use 0th column for all param lists	endif				WAVE/T excel_info		Variable numExcelParams = itemsinlist(excelParamStrList)	Variable numExcelStrs = itemsinlist(cellNameLists)	Variable oneExcelCellNameList = numExcelStrs == 1		String allPossiblyUniqueExcelNames,allExcelNames	if (includeAllPossibleExcelNames)		allExcelNames = getDimLabels(excel_info,0,"")	else		allPossiblyUniqueExcelNames = text_removeListBlanks(c2sc(cellNameLists))		allExcelNames = text_removeStringListDuplicates(allPossiblyUniqueExcelNames, ";")	endif		Variable numExcelCells = itemsinlist(allExcelNames)			Variable numOutputCols = 2*numExcelParams			//2* num excels because one for each y value + 1 for each in bins	Variable numOutputRows = numExcelCells 	Make/O/D/N=(numOutputRows,numOutputCols) $paramsSaveRef/wave=out	out = nan		//param stuff	Variable excel_row; string paramRef,cellName,cellNameForSearch	String paramStr	Variable out_paramData_col	//excel stuff	Variable excelStr_ind,excel_col,excel_val,bin_val	Variable out_excel_binned_col, out_excel_rawData_col	String excelParamStr,excelBinStr	Variable bin_ind	Variable maxNumBins = 0		String noteStr=""	noteStr=ReplaceStringByKey("numExcelParamCols",noteStr,num2str(numOutputCols))	noteStr=ReplaceStringByKey("numExcelStrs",noteStr,num2str(numExcelStrs))	noteStr=ReplaceStringByKey("numOutputRows",noteStr,num2str(numOutputRows))	String paramRefLists_save = ReplaceString(";",paramRefLists,"|")	noteStr=ReplaceStringByKey("paramRefLists",noteStr,paramRefLists_save)	String dlAppendList_save = ReplaceString(";",dlAppendList,"|")	noteStr=ReplaceStringByKey("dlAppendList",noteStr,dlAppendList_save)	String cellNameList_save = ReplaceString(";",cellNameLists,"|")	noteStr=ReplaceStringByKey("cellNameLists",noteStr,cellNameList_save)		String excelParamStrList_save = ReplaceString(";",excelParamStrList,"|")	noteStr=ReplaceStringByKey("excelParamStrList",noteStr,excelParamStrList_save)		String excelParamBinList_save = ReplaceString(";",excelParamBinList,"|")	noteStr=ReplaceStringByKey("excelParamBinList",noteStr,excelParamBinList_save)		String usedParamColList_save = ReplaceString(";",usedParamColList,"|")	noteStr=ReplaceStringByKey("usedParamColList",noteStr,usedParamColList_save)	String genParamFromMatchStrList_Save = ReplaceString(";",usedGenParamFromMatchStrList,"|")	noteStr=ReplaceStringByKey("usedGenParamFromMatchStrList",noteStr,genParamFromMatchStrList_Save)	String hasHeaderList_save = ReplaceString(";",hasHeaderList,"|")	noteStr=ReplaceStringByKey("hasHeaderList",noteStr,hasHeaderList_save)	noteStr=ReplaceStringByKey("numExcelParamCols",noteStr,num2str(numOutputCols))		String sourcesIndices_save = Replacestring(";",sourcesIndices,"|")	noteStr=ReplaceStringByKey("sourcesIndices",noteStr,sourcesIndices_save)	String sourcesLisT_save = Replacestring(";",sourcesList,"|")	noteStr=ReplaceStringByKey("sourcesList",noteStr,sourcesLisT_save)		string paramLists_save = ""//tracks param lists and will be stored at end	String paramListColList = ""		//tracks which column came from what param list and at what position in that param list col,index|col,index|...	String paramDataColsList = ""		//make excel wave	Variable i	for (i=0;i<numExcelCells;i+=1)		//each cell/paramRef		cellName = stringfromlist(i,allExcelNames)		if (!strlen(cellName))			out[i][] = nan			continue		endif		Setdimlabel 0,i,$cellname,out				//find in excel wave		cellNameForSearch = Replacestring("G",cellname,"") 		cellNameForSearch = cellNameForSearch[0,7]		//0 to 7 is name portion without G		excel_row = FindDimLabel(excel_info,0, cellNameForSearch )		//excel labels don't have G prefix but I might sometimes use it		if (excel_row < 0)			out[i][] = inf		//	Print "fio_disp_paramVsExcelParam(): i",i,"could not find cellName",cellNameForSearch,"in excel_info wave",nameofwave(excel_info)						continue		endif				//fill in any requested excel params		for (excelStr_ind=0;excelStr_ind<Itemsinlist(excelParamStrList);excelStr_ind+=1)			out_excel_rawData_col = 2*excelStr_ind			out_excel_binned_col = 2*excelStr_ind + 1						excelParamStr = stringfromlist(excelStr_ind,excelParamStrList)			excel_col = FindDimLabel(excel_info, 1, excelParamStr)						//prep for binning			excelBinStr = c2sc(stringfromlist(excelStr_ind,excelParamBinList))		//make bin border list into semi colon list					if (excel_col < 0)				out[i][out_excel_rawData_col] = -inf				out[i][out_excel_binned_col] = -inf				Print "fio_disp_paramVsExcelParam(): i",i,"could not find excelParamStr",excelParamStr,"in excel_info wave",nameofwave(excel_info)							else				excel_val = str2num(excel_info[excel_row][excel_col])				if (itemsinlist(excelBinStr) < 1)		//no bins					bin_val = 0				else					excelBinStr = SortList(excelBinStr,";",2)					for (bin_ind=0;bin_ind<itemsinlist(excelBinStr);bin_ind+=1)						if (excel_val < str2num(stringfromlist(bin_ind,excelBinStr)))							break						endif					endfor				endif				out[i][out_excel_rawData_col] = excel_val				out[i][out_excel_binned_col] = bin_ind								if (itemsinlist(excelBinStr) > maxNumBins)					maxNumBins = itemsinlist(excelBinStr)				endif			endif						if ( (WhichListItem(num2str(out_excel_rawData_col), paramDataColsList) < 0)	)	//first time column is being dealt with				paramListColList += num2str(out_excel_rawData_col) + "," + excelParamStr + "," + "" + "," + nameofwave(excel_info) + "," + num2str(excel_row) + "," + num2str(excel_col) + "," + "" +","				paramListColList += num2str(nan) + "," + "|"		//no paramRefList index because excel				paramDataColsList += num2str(out_excel_rawData_col) + ";"			endif			if ( (WhichListItem(num2str(out_excel_binned_col), paramDataColsList) < 0)	)	//first time column is being dealt with				paramListColList += num2str(out_excel_binned_col) + "," + excelParamStr + "," + "" + "," + nameofwave(excel_info) + "," + num2str(excel_row) + "," + num2str(excel_col) + "," + "bin" + ","				paramListColList += num2str(nan) + "," + "|"		//no paramRefList index because excel				paramDataColsList += num2str(out_excel_binned_col) + ";"			endif										SetDimLabel 1,out_excel_rawData_col,$excelParamStr,out			SetDimLabel 1,out_excel_binned_col,$(excelParamStr+"_bin"),out		endfor	endfor			Variable paramRefList_ind, hasHeader,paramCol,param_ind,param_row,numParamStrs,badRef,newParamColCount	Variable out_paramData_col_start,out_row	String paramRefList,paramList,genParamListMatchStr,paramList_temp,exampleParamWvRef,paramStrTemp,dlAppendStr	String headerRef,headerAlertStr,headerRef_save,currParamWvRef, sourceRef, currExcelNameList, currCellName	Variable currNumCells	for (paramRefList_ind=0;paramRefList_ind<numParamRefLists;paramRefList_ind+=1)		//get current paramRefList and paramList		paramRefList = ReplaceString(",",stringfromlist(paramRefList_ind,paramRefLists),";")		paramList = ReplaceString(",",stringfromlist(paramRefList_ind,paramLists),";")		sourceRef = stringfromlist(paramRefList_ind,sourcesList)				//get excel cell names for this paramRefList		if (oneExcelCellNameList && (i==0))		//only need to run this once hence check (i==0)			currExcelNameList = allExcelNames		else			currExcelNameList = c2sc(stringfromlist(paramRefList_ind,cellNameLists))		endif				currNumCells = itemsinlist(currExcelNameList)				//get other current info		hasHeader = strlen(stringfromlist(paramRefList_ind,hasHeaderList)) > 0		genParamListMatchStr = stringfromlist(paramRefList_ind,usedGenParamFromMatchStrList)		paramCol = str2num(stringfromlist(paramRefList_ind,usedParamColList))		dlAppendStr = stringfromlist(paramRefList_ind,dlAppendList)				//set up paramList, if necessary		paramList_temp = ""				if (hasHeader)			headerRef = stringfromlist(paramRefList_ind,hasHeaderList)			if (strlen(genParamListMatchStr))				WAVE/T headerWv = $headerRef				for (i=0;i<dimsize(headerWv,0);i+=1)					if (stringmatch(headerWv[i][0],genParamListMatchStr))						paramList_temp += headerWv[i][0] + ";"					endif				endfor				paramList = paramList_temp; Print "fio_disp_paramsVsExcelParams(): generated paramList =",paramList			else				paramList = replaceString(headerRef+";",paramList,"")		//remove header string from list			endif		else			if (strlen(genParamListMatchStr))				exampleParamWvRef = Stringfromlist(0,ListMatch(paramRefList, "!" ) )		//select first non-empty string				for (i=0;i<dimsize($exampleParamWvRef,0);i+=1)					paramStrTemp = GetDimLabel($exampleParamWvRef, 0, i )					if (stringmatch(paramStrTemp,genParamListMatchStr))						paramList_temp += paramStrTemp + ";"					endif				endfor				paramList = paramList_temp; //Print "fio_disp_paramsVsExcelParams(): generated paramList =",paramList			endif		endif				//make room for and fill in any requrested data params		numParamStrs = itemsinlist(paramList)			out_paramData_col_start = dimsize(out,1)		Redimension/N=(-1,out_paramData_col_start + numParamStrs) out		if (numParamStrs > 0)			out[][out_paramData_col_start,] = nan		endif				Print "dlAppendStr",dlAppendStr,"numParamStrs",numParamStrs,"paramRefList",paramRefList				paramLists_save += ReplaceString(";",paramList,",") + "|"				//start iterating through each paramRef, grabbing the values for each specified param in paramList		for (i=0;i<currNumCells;i+=1)		//if one wanted to allow paramRefList lengths to vary, this would be a place to do it--redimension # rows to longest list			currParamWvRef = stringfromlist(i,paramRefList)			if (!strlen(currParamWvRef))				continue			endif			if (!WaveExists($currParamWvRef))				fio_stream_loadIBF(sourceRef,currParamWvRef)			endif			WAVE/Z paramWv = $currParamWvRef			if (!WaveExists(paramWv))				Print "fio_disp_mParamsVsExcelParams(): param wave ref failed. paramRefList_ind",paramRefList_ind,"paramWvRef index",i,"paramWvRef",stringfromlist(i,paramRefList),"expected cellName",stringfromlist(i,currExcelNameList)				//unfilled values are NaN by default (see line of redimension command)				continue			endif						//find row for this excel wave			cellName = stringfromlist(i,currExcelNameList)			out_row = WhichListItem(cellName, allExcelNames)			if (out_row < 0)				Print "fio_disp_mParamsVsExcelParams(): Someting went wrong, failed to find cellname=",cellname,"currParamWvRef",currParamWvRef				continue			endif						newParamColCount = 0			for (param_ind=0;param_ind<numParamStrs;param_ind+=1)				out_paramData_col = out_paramData_col_start+param_ind		//start from 0th new data column for each param				paramStr = stringfromlist(param_ind,paramList)				if (hasHeader)					param_row = findInHeader(paramStr, headerRef)					headerRef_save = headerRef				else					headerRef_save = ""					if (!badRef)						param_row = FindDimlabel(paramWv,0,paramStr)					endif				endif								if (param_row < 0)					out[out_row][out_paramData_col] = -inf					if (hasHeader)						headerAlertStr = "headerRef  " + headerRef					else						headerAlertStr = ""					endif		//			Print "fio_disp_paramVsExcelParam(): could not find paramStr",paramStr,"in paramRef",paramRef,headerAlertStr				else					newParamColCount += 1					if (!badRef)						out[out_row][out_paramData_col] = paramWv[param_row][paramCol]						if (paramWv[param_row][paramCol] == 0)			//				Print "here 0 found. paramWv",nameofwave(paramWv),"param_row",param_row,"paramCol",paramCol,"rowDL",GetDimLabel(paramWv,0,param_row),"colDL",GetDimLabel(paramWv,0,paramCol)						endif					else						out[out_row][out_paramData_col] = nan					endif				endif		//		if (i==0)		//happens once per param list					SetDimLabel 1,out_paramData_col,$(dlAppendStr+paramStr),out		//		endif				if ( (WhichListItem(num2str(out_paramdata_col), paramDataColsList) < 0)	)	//first time column is being dealt with					paramListColList += num2str(out_paramData_col) + "," + paramStr + "," + headerRef_save + "," + nameofwave(paramWv) + "," + num2str(param_row) + "," + num2str(paramCol) + ","+"," 					paramListColList += num2str(paramRefList_ind) +","  + "|"					paramDataColsList += num2str(out_paramdata_col) + ";"				endif			endfor //paramList iterator		endfor	//paraRefs iterator	endfor	//paramRefLists iterator		noteStr=ReplaceStringByKey("paramLists",noteStr,paramLists_save)	noteStr=ReplaceStringByKey("paramListColList",noteStr,paramListColList)		Note/nocr out, noteStr	end//fio_disp_mParamsVsExcelParamsfunction/S fio_disp_waves(winN,newOrAdd,list,excelNamesList,color,sepAxes[dispCol,appendStr])	String winN,list,color; variable newOrAdd	String excelNamesList	Variable sepAxes		//pass to plot each on its own axis	Variable dispCol		//optionally pass which column to display	STring appendStr	//append str before trace and axis name		Variable opac = (2^16 - 1) * .3		WAVE/T excel_info	Variable excel_colorContingentCol = FindDimLabel(excel_info, 1, "region" )	String colorMatchStrs = "F*,red,;P*,black,;"		Variable offsetXToZero = 1		Variable normRange_startPnts = 1	Variable normRange_endPnts = nan //50	Variable flip = 1		String usedNameAppendStr = ""	if (!ParamIsDefault(appendStr))		usedNameAppendStr = appendStr	endif		if (newOrAdd)		if (!strlen(winN))			winN = winname(0,1)		endif	else		display/k=1/N=$winN		winN = S_name	endif		if (!ParamIsDefault(dispCol) || numtype(dispCol))		dispCol = 0	endif		if (strlen(color))		WAVE c = vis_getCBColorForGraph(color,"colors_temp",opac)	endif		variable i,off_x; string ref, axN = "left", tn;double end_avg,start_avg,range,muloff_y,off_y	String colorMatchStr,colorInfo,excelSearchStr,usedColor,excelName	Variable j,excelRow,colorMatchFound	for (i=0;i<itemsinlist(list);i+=1)		ref=stringfromlist(i,list)		if (!strlen(ref))			Print "fio_disp_waves(): ref #",i,"is blank"			continue		endif		if (!waveexists($ref))			Print "fio_disp_waves(): ref #",i,"ref=",ref,"does not exist, skipping"			continue		endif				if (sepAxes)			axN = "L_"+usedNameAppendStr + ref		endif		tn = ref + usedNameAppendStr		//color determination from excelNameList --otherwise uses passed color		if (strlen(excelNamesList))			excelName = stringfromlist(i,excelNamesList)			excelRow = finddimlabel(excel_info,0,excelName)			if (excelRow < 0)				Print "fio_disp_waves(): failed to find excelName =",excelName,"i",i,"ref=",ref				continue			endif		//	Print "ref",ref,"excelName",excelNAme,"excelRow",excelRow,"region",excel_info[excelRow][excel_colorContingentCol]			colorMatchFound = 0			for (j=0;j<itemsinlist(colorMatchStrs);j+=1)				colorInfo = text_commasToSemiColons(stringfromlist(j,colorMatchStrs))				colorMatchStr = stringfromlist(0,colorInfo)				if (stringmatch(excel_info[excelRow][excel_colorContingentCol],colorMatchStr))					usedColor = stringfromlist(1,colorInfo)					colorMatchFound = 1					break				endif			endfor						if (!colorMatchFound)				Print "fio_disp_waves(): failed to find a corresponding color string for excelName =",excelName,"i",i,"ref=",ref				continue			endif									WAVE c = vis_getCBColorForGraph(usedColor,"colors_temp",opac)		endif				appendtograph/W=$winN/C=(c[0],c[1],c[2],c[3])/L=$axN $ref[][dispCol]/tn=$tn		if (sepAxes && (i>0))			//not handled yet		endif		if (offsetXToZero)			off_x = -dimoffset($ref,0)		else			off_x = 0		endif				if (!numtype(normRange_endpnts) && (normRange_endpnts > 0) )			end_avg = mean($ref,pnt2x($ref,dimsize($ref,0)-1-normRange_endpnts),pnt2x($ref,dimsize($ref,0)-1))			if (normRange_startPnts > 1)				start_avg = mean($ref,x2pnt($ref,0),x2pnt($ref,0) + normRange_startPnts)			else //normRange_startPnts likely = 1				WAVE wv = $ref				start_avg = wv[0]			endif						range = end_avg - start_avg			muloff_y = 1/range * (flip ? -1 : 1)			off_y = -end_avg * muloff_y		else			muloff_y = 0			off_y = 0		endif		modifygraph/W=$winN offset($tn) = {off_x,off_y},muloffset($tn) = {0,muloff_y}	endfor		return winN	endfunction/S excel_refsToExcelNames(refs,includeBlanks[strSaveName])	String refs	String strSaveName	//optionally pass to save output into a global string of passed name	Variable includeBlanks		WAVE/T excel_info		//cell names with potentially wrong file names .. add here to watch out for them	string possiblyAmbiguousExcelNames = "15091708;15091709;16081110;16081111;"	variable count16081110 = 0		string out="",ref;variable i	for (i=0;i<itemsinlist(refs);i+=1)		ref = stringfromlist(i,refs)		if (!strlen(ref))			if (includeBlanks)				out += ref + ";"			endif			continue			endif				if (stringmatch(ref[0],"G"))			ref = ref[1,inf]		endif		ref = ref[0,7]				if (WhichListItem(ref,possiblyAmbiguousExcelNames) > -1)			if (stringmatch(ref,"16081110"))				Print "excel_refsToExcelNames(): ref",ref,"pos",i,"should be cell 16081110 for files < 8; 16081111 for otherwise. changing by assuming this in order"				count16081110 += 1				if (count16081110 == 2)					ref="16081111"				endif			endif			print "excel_refsToExcelNames(): possibly ambiguous cell name encountered. listpos=",i,"ref=",ref		endif				out += ref + ";"				if (FindDimLabel(excel_info, 0, ref ) < 0)			print "excel_refsToExcelNames(): failed to find ref in excel_info. listpos=",i,"ref=",ref		endif	endfor		if (!ParamIsDefault(strSaveName) && strlen(strSaveName))		String/G $strSaveName		SVAR saveStr = $strSaveName		saveStr = out		Print "excel_refsToExcelNames(): output saved into global str=",strSaveName	endif	return outend//e.g. itemNum = 0 to return first non-empty string list itemfunction/S text_stringFromListIgnoreBlanks(itemNum,list)	Variable itemNum; string list		return Stringfromlist(itemNum,text_removeListBlanks(list) )	endfunction/S text_removeListBlanks(list)	String list		return ListMatch(list, "!" )endfunction fio_disp_paramsVsExcelParams(paramsSaveRef,paramRefList,paramList,hasHeader,cellNameList,excelParamStrList,excelParamBinList,[param_col,genParamListFromMatchStr])	String paramsSaveRef	String paramRefList,cellNameList		//ordered list of paramRefs and cellNameRefs	String paramList		//name of paramList. pass hasHeader=1 and headerName;paramList to use header	Variable hasHeader	String excelParamStrList		//name of excel param to plot against, e.g. "ax_len" "rec_site_len" "total_len"	String excelParamBinList		//paired with excelParamStrList, bin borders. e.g. pass 100 to cut off axon length at 100 -- num bins = numpnts + 1 as comma list, so one bin < 100 and one bin > 100	Variable param_col			//no need to pass if paramWvs are 1 column or first column of 2D	String genParamListFromMatchStr		Variable used_param_col	if (ParamIsDefault(param_col) || (numtype(param_col) == 2) || (param_col < 0) )		used_param_col = 0	else		used_param_col = param_col	endif		Variable i; string paramList_temp = ""	String headerRef = ""	if (hasHeader)		headerRef = stringfromlist(0,paramList)		if (!paramIsDefault(genParamListFromMatchStr))			WAVE/T headerWv = $headerRef			for (i=0;i<dimsize(headerWv,0);i+=1)				if (stringmatch(headerWv[i][0],genParamListFromMatchStr))					paramList_temp += headerWv[i][0] + ";"				endif			endfor			paramList = paramList_temp; Print "fio_disp_paramsVsExcelParams(): generated paramList =",paramList		else			paramList = replaceString(headerRef+";",paramList,"")		//remove header string from list		endif	else		if (!paramIsDefault(genParamListFromMatchStr))			String exampleParamWvRef = Stringfromlist(0,paramRefList)			String paramStrTemp			for (i=0;i<dimsize($exampleParamWvRef,0);i+=1)				paramStrTemp = GetDimLabel($exampleParamWvRef, 0, i )				if (stringmatch(paramStrTemp,genParamListFromMatchStr))					paramList_temp += paramStrTemp + ";"				endif			endfor			paramList = paramList_temp; Print "fio_disp_paramsVsExcelParams(): generated paramList =",paramList		endif	endif			WAVE/T excel_info		Variable numExcelStrs = itemsinlist(excelParamStrList)	Variable numParamsRefs = itemsinlist(paramRefList)	Variable numParamStrs = itemsinlist(paramList)		Print "paramList",paramList,"headerRef",headerRef,"numExcelStrs",numExcelStrs,"numParamsRefs",numParamsRefs,"numParamStrs",numParamStrs		Variable numOutputCols = 2*numExcelStrs + numParamStrs			//2* num excels because one for each y value + 1 for each in bins	Variable numOutputRows = numParamsRefs 	Make/O/D/N=(numOutputRows,numOutputCols) $paramsSaveRef/wave=out		//param stuff	Variable excel_row; string paramRef,cellName,cellNameForSearch	Variable param_ind,param_row	String paramStr, headerAlertStr	Variable out_paramData_col	//excel stuff	Variable excelStr_ind,excel_col,excel_val,bin_val	Variable out_excel_binned_col, out_excel_rawData_col	String excelParamStr,excelBinStr	Variable bin_ind	Variable maxNumBins = 0	Variable badRef	for (i=0;i<numParamsRefs;i+=1)		//each cell/paramRef		paramRef = stringfromlist(i,paramRefList)		WAVE/D/Z paramWv = $paramRef		if (!WaveExists(paramWv))			badRef = 1		else			badRef = 0		endif		cellName = stringfromlist(i,cellnameList)		Setdimlabel 0,i,$cellname,out				//find in excel wave		cellNameForSearch = Replacestring("G",cellname,"") 		cellNameForSearch = cellNameForSearch[0,7]		//0 to 7 is name portion without G		excel_row = FindDimLabel(excel_info,0, cellNameForSearch )		//excel labels don't have G prefix but I might sometimes use it		if (excel_row < 0)			out[i][] = inf			Print "fio_disp_paramVsExcelParam(): i",i,"could not find cellName",cellNameForSearch,"in excel_info wave",nameofwave(excel_info)						continue		endif				//fill in any requested excel params		for (excelStr_ind=0;excelStr_ind<numExcelStrs;excelStr_ind+=1)			out_excel_rawData_col = 2*excelStr_ind			out_excel_binned_col = 2*excelStr_ind + 1						excelParamStr = stringfromlist(excelStr_ind,excelParamStrList)			excel_col = FindDimLabel(excel_info, 1, excelParamStr)						//prep for binning			excelBinStr = Replacestring(",",stringfromlist(excelStr_ind,excelParamBinList),";")		//make bin border list into semi colon list					if (excel_col < 0)				out[i][out_excel_rawData_col] = -inf				out[i][out_excel_binned_col] = -inf				Print "fio_disp_paramVsExcelParam(): i",i,"could not find excelParamStr",excelParamStr,"in excel_info wave",nameofwave(excel_info)							else				excel_val = str2num(excel_info[excel_row][excel_col])				if (itemsinlist(excelBinStr) < 1)		//no bins					bin_val = 0				else					excelBinStr = SortList(excelBinStr,";",2)					for (bin_ind=0;bin_ind<itemsinlist(excelBinStr);bin_ind+=1)						if (excel_val < str2num(stringfromlist(bin_ind,excelBinStr)))							break						endif					endfor				endif				out[i][out_excel_rawData_col] = excel_val				out[i][out_excel_binned_col] = bin_ind								if (itemsinlist(excelBinStr) > maxNumBins)					maxNumBins = itemsinlist(excelBinStr)				endif			endif							SetDimLabel 1,out_excel_rawData_col,$excelParamStr,out			SetDimLabel 1,out_excel_binned_col,$(excelParamStr+"_bin"),out					endfor				//fill in any requrested data params		out_paramData_col = out_excel_binned_col + 1				for (param_ind=0;param_ind<numParamStrs;param_ind+=1)			paramStr = stringfromlist(param_ind,paramList)			if (hasHeader)				param_row = findInHeader(paramStr, headerRef)			else				if (!badRef)					param_row = FindDimlabel(paramWv,0,paramStr)				endif			endif						if (param_row < 0)				out[i][1] = -inf				if (hasHeader)					headerAlertStr = "headerRef  " + headerRef				else					headerAlertStr = ""				endif				Print "fio_disp_paramVsExcelParam(): could not find paramStr",paramStr,"in paramRef",paramRef,headerAlertStr			else				if (!badRef)					out[i][out_paramData_col] = paramWv[param_row][used_param_col]				else					out[i][out_paramData_col] = nan				endif			endif					SetDimLabel 1,out_paramData_col,$paramStr,out			out_paramData_col += 1		endfor	endfor		end//fio_disp_paramsVsExcelParamsfunction disp_plotReps_2D(wv, xCol, yColStart)	WAVE wv	Variable xCol,yColStart		Variable fsize = 6		Display/K=1	modifygraph/W=$S_name fsize=6		Variable num_plots = dimsize(wv,1) - yColStart		Variable num_graphs = num_plots		Variable num_graph_cols = floor(sqrt(num_graphs))	Variable num_graph_rows = ceil(sqrt(num_graphs))		Variable col_spacing = 0.02	variable row_spacing = 0.02		Variable col_spacing_total = 0.02 * (num_graph_cols - 1)	Variable row_spacing_total = 0.02 * (num_graph_rows - 1)		Variable col_graphsize_total = 1 - col_spacing_total	Variable row_graphsize_total = 1 - row_spacing_total		Variable col_graphsize = col_graphsize_total / num_graph_cols	Variable row_graphsize = row_graphsize_total / num_graph_rows		Variable i,j,count = 0, currColStart,currColEnd,currRowStart,currRowEnd	String yAx, xAx	for (i=0;i<num_graph_cols;i+=1)		currColStart = i*col_graphsize + i*col_spacing		currColEnd = currColStart + col_graphsize		for (j=0;j<num_graph_rows;j+=1)			if (count > num_plots)				break			endif						currRowStart = j*row_graphsize + j*row_spacing			currRowEnd = currRowStart + row_graphsize				yAx = "L_"+num2str(count)			xAx = "B_"+num2str(count)			appendtograph/W=$S_name/B=$xAx/L=$yAx wv[][yColStart+count] vs wv[][xCol]			modifygraph/W=$S_name axisEnab($xAx) = {currColStart,currColEnd} , axisEnab($yAx) = {currRowStart,currRowEnd} 			count += 1						endfor		endforend//disp_plotReps_2Dfunction disp_plotReps_2D2(wv,excludeXAxList)	WAVE wv	String excludeXAxList		//semi colon list,one for each x ax NOT counting bins		Variable fsize = 6		String binStringForCatagories = "isFoveal_bin"		Display/K=1		//find last bin col	Variable i, lastBinCol = -1, catCol = -1	for (i=0;i<Dimsize(wv,1);i+=1)		if (stringmatch(getdimlabel(wv,1,i),"*bin"))			lastBinCol = i		endif				if (stringmatch(getdimlabel(wv,1,i),binStringForCatagories))			catCol = i		endif			endfor		Variable useCatCol		String catRef = nameofwave(wv) + "_catRef"	if (catCol >= 0)		useCatCol = 1		make/O/N=(dimsize(wv,0)) $catRef/wave=catWv		catWv = wv[p][catCol]	else		useCatcol = 0	endif		Print "catCol",catCol,"catRef",catRef		Variable numExcludedAxes_x = itemsinlist(excludeXAxList)		Variable yStartCol = lastBinCol + 1	Variable num_xVals = floor((lastBinCol+1)/2) - numExcludedAxes_x	Variable num_yVals = dimsize(wv,1) - yStartCol		Print "num_xVals",num_xVals,"num_yVals",num_yVals,"yStartCol",yStartCol		Variable num_plots = num_xVals * num_yVals	Variable num_graphs = num_plots		Variable num_graph_cols = num_xVals	Variable num_graph_rows = num_yVals		Variable col_spacing = 0.02	variable row_spacing = 0.005		Variable col_spacing_total = col_spacing * (num_graph_cols - 1)	Variable row_spacing_total = row_spacing * (num_graph_rows - 1)		Variable col_graphsize_total = 1 - col_spacing_total	Variable row_graphsize_total = 1 - row_spacing_total		Variable col_graphsize = col_graphsize_total / num_graph_cols	Variable row_graphsize = row_graphsize_total / num_graph_rows		Variable propOfColForMainPlot = 0.8	Variable propOfColForBinPlot = 0.15		Variable j, currColStart,currColEnd,currColEnd_main,currColStart_bin,currRowStart,currRowEnd	Variable xDataCol,xBinCol,yDataCol	String xLabel,xBinLabel, yLabel	String yAx, xAx, xAx_bin	for (i=0;i<num_xVals;i+=1)		if (WhichListItem(num2str(i),excludeXAxList) >= 0)			continue		endif			currColStart = i*col_graphsize + i*col_spacing		currColEnd = currColStart + col_graphsize		currColEnd_main = currColStart + (col_graphsize * propOfColForMainPlot)		currColStart_bin = currColEnd - (col_graphsize * propOfColForBinPlot)		xDataCol = 2*i		xBinCol = (2*i)+1; print "xBinCol",xBinCol		xLabel = text_makeStrPresentable(getdimlabel(wv,1,xDataCol))		xBinLabel = text_makeStrPresentable(getdimlabel(wv,1,xBinCol))		xAx = "B_" + xLabel		xAx_bin = "B_" + xBinLabel				for (j=0;j<num_yVals;j+=1)			currRowStart = j*row_graphsize + j*row_spacing			currRowEnd = currRowStart + row_graphsize						yDataCol = yStartCol + j			yLabel = text_makeStrPresentable(getDimlabel(wv,1,yDataCol))			yAx = "L_"+yLabel							appendtograph/W=$S_name/B=$xAx/L=$yAx wv[][yDataCol] vs wv[][xdataCol]			modifygraph/W=$S_name axisEnab($xAx) = {currColStart,currColEnd_main} , axisEnab($yAx) = {currRowStart,currRowEnd} 						appendtograph/W=$S_name/B=$xAx_bin/L=$yAx wv[][yDataCol] vs wv[][xBinCol]			modifygraph/W=$S_name axisEnab($xAx_bin) = {currColStart_bin,currColEnd} , axisEnab($yAx) = {currRowStart,currRowEnd} 						Label $yAx, yLabel+"\\U"			modifygraph/W=$S_name lblrot($yAx) = -90,freepos($yAx)=0,lblpos($yAx)=110,mirror($yAx)=1		//gives more room								endfor				Label $xAx, xLabel+"\\U"		modifygraph/W=$S_name freepos($xAx)=0,lblpos($xAx)=40,mirror($xAx) = 1		modifygraph/W=$S_name freepos($xAx_bin)=0,lblpos($xAx_bin)=40,mirror($xAx_bin) = 1		setaxis/W=$S_name/A/N=2 $xAx_bin	endfor		modifygraph/W=$S_name fsize=6,mode=3,marker=19,msize=1,rgb=(0,0,0), btLen=2,stLen=2,zColor = {$catRef,0,2.8,Red,0}		//0 to 2.8 range with 0,1 catagory data gives black and ~redend//disp_plotReps_2D2//for param waves that are 2 dimensional, e.g. from response families in V(I)s or sin waves across frequencies (rather than 2D param waves that are combined across cells)//pass in a list of these, and the params for the dimensions to be plotted (using disp_plotRep_2D), results will be overlaid //pass an ordered list of the corresponding cell names, and a match string to bin by to color by exel wave infofunction disp_plotReps_2DParams(y_paramRefsList,x_paramRefsList,xDL,yDL,rowsNotCols,cellNamesList,traceColorInfoStr,newWinOrAppendToTop,[win,doLog])	String y_paramRefsList,xDL,yDL,win	String x_paramRefsList		//same len as y, useful for difference waves where you want to plot e.g. against freq but freqeucy diff is 0. pass "" to use row/col from y wave	Variable rowsNotCols,newWinOrAppendToTop	String cellNamesList		//cell names in same order as y_paramRefsList	String traceColorInfoStr	//excel dim label for color decision; match string for black color, if not a match color will be black e.g., "region;"*P*";"	Variable doLog		//optionally do log plot: 1 for x, 2 for y, 3 for both		String winN	if (newWinOrAppendToTop)		if (!paramIsDefault(win) && strlen(win))			winN = win		else			winN = winname(0,1)		endif				if (Wintype(winN) != 1)		//not a graph or no graphs exist			Display/K=1			winN = S_name		endif	else		if (!paramIsDefault(win) && strlen(win))			Display/K=1/N=$win		else			Display/K=1		endif		winN = S_name	endif			Variable noBinPlot = 1	Variable noCorrCalcs = 1 //unclear how these would be useful for 2D param waves		Variable dataDim = rowsNotCols ? 0 : 1		Variable xDimIndex,yDimIndex	String y_exampleParamRefForLbls = Stringfromlist(0,y_paramRefsList)	String x_exampleParamRefForLbls = Stringfromlist(0,x_paramRefsList)		if (!strlen(yDL))		yDimIndex = 0	//useful for handling what's actually a 1D wave	else		yDimIndex = FindDimLabel($y_exampleParamRefForLbls,dataDim,yDL)	endif	if (!strlen(xDL))		xDimIndex = 0	//useful for handling what's actually a 1D wave	else		xDimIndex = FindDimLabel($x_exampleParamRefForLbls,dataDim,xDL)	endif		Variable excelColoring = strlen(traceColorInfoStr) > 0	if (excelColoring)		WAVE/T excel_info		String excelLabel = stringfromlist(0,traceColorInfoStr)		String excelMatchStr = stringfromlist(1,traceColorInfoStr)		Variable excel_col = finddimlabel(excel_info,1,excelLabel)		if (excel_col < 0)			print "disp_plotReps_2DParams(): failed to find excel_col, no coloring will be performed"			excelColoring = 0		endif	endif		String matchColorStr = "black"	String nonMatchColorSTr = "red"	Variable opacityVal = 1		Variable i,usePreExistingHorizontalAxis,excel_row;string y_ref,x_ref,tn,cellName,excelTestSTr,colorStr	for (i=0;i<itemsinlisT(y_paramRefsList);i+=1)		y_ref = stringfromlist(i,y_paramRefsList)		if (!strlen(y_ref))			continue		endif		if (!waveexists($y_ref))			Print "disp_plotReps_2DParams(): y_ref wave",y_ref,"does not exist. Skipping..."			continue		endif		x_ref = stringfromlist(i,x_paramRefsList)		tn = y_ref		//print tn		usePreExistingHorizontalAxis = i==0? 0 : 1		tn=disp_plotRep_2D($y_ref,"",0,xDimIndex,yDimIndex,rowsNotCols,1,usePreExistingHorizontalAxis,noBinPlot,noCorrCalcs,win=winN,tn=tn,x_ref=x_ref);doupdate		//print tn		if (excelColoring)			cellName = stringfromlist(i,cellNamesList)			if (strlen(cellName))				excel_row = finddimlabel(excel_info,0,cellName)				if (excel_row > -1)					excelTestStr = excel_info[excel_row][excel_col]					if (stringmatch(excelTestStr,excelMatchStr))						colorStr=matchColorStr					else						colorStr=nonMatchColorSTr					endif										WAVE c=vis_getCBColorForGraph(colorStr,"",opacityVal)					modifygraph/W=$winN rgb($tn) = (c[0],c[1],c[2],c[3])				endif			endif		endif	endfor		if (!ParamIsDefault(doLog))		if ( (doLog==1) || (doLog>2) )			modifygraph/W=$winN log(bottom) = 1		endif				if (doLog > 1)			modifygraph/W=$winN log(left) = 1		endif	endif		modifygraph/W=$winN  marker=8,mrkThick=1,mode=4,mirror=0endfunction/S disp_plotRep_2D(wv,catRef,makeCatRef,xDataCol,yDataCol,rowsNotCols,newWinOrAppendToTop,usePreExistingHorizontalAxis,noBinPlot,noCorrCalcs[win,tn,x_ref,forceNewCorrelationMat,forceCatRef])	WAVE/D wv	Variable xDataCol,yDataCol	Variable rowsNotCols		//pass to plot across rows rather than columns ..e.g. yDataCol becomes yDataRow	Variable newWinOrAppendToTop	String catRef	Variable makeCatRef	//ignored if cat ref does not exist	Variable usePreExistingHorizontalAxis	Variable noBinPlot	String win,tn	Variable noCorrCalcs	String x_ref	//optionally pass a different wave to plot xDataCol from. useful when plotting a difference wave and e.g. a param like frequency is 0 across the board in the difference wave but in the originals	Variable forceNewCorrelationMat	//optionally pass as true to overwrite pre-existing correlation matrix	String forceCatRef		//optionally pass to force catagories for statistics from disp_plotRep_appendPearson. Should be ref to wave ssame size as # rows, with a category designation in each row for each row		if (strlen(x_ref))		WAVE/D x_wv = $x_ref	else		WAVE/D x_wv = wv	endif		Variable simpleAxNames = 1		//true for axis names = left,bottom, false for names by param names		if (xDataCol < 0)		Print "disp_plotRep_2D(): xDataCol < 0, equal to",xDataCol,". aborting display"	endif	if (yDataCol < 0)		Print "disp_plotRep_2D(): yDataCol < 0, equal to",yDataCol,". aborting display"	endif		Variable fsize = 8.5		String binStringForCatagories = "isFoveal_bin"		Variable dataDim = rowsNotCols ? 0 : 1		String winN	if (newWinOrAppendToTop)		if (!paramIsDefault(win) && strlen(win))			winN = win		else			winN = winname(0,1)		endif				if (Wintype(winN) != 1)		//not a graph or no graphs exist			Display/K=1			winN = S_name		endif	else		if (!paramIsDefault(win) && strlen(win))			Display/K=1/N=$win		else			winN = text_makeStrPresentable(NAmeOfwave(wv) + "_" + GetDimLabel(wv,dataDim, yDataCol ) + "_" + GetDimLabel(x_wv,dataDim, xDataCol ))			Display/K=1/N=$winN//attempts to come up with window name as sensible combination of input wave name and yData col label		endif		winN = S_name	endif		//find last bin col -- if need to catagorize by bin -- not supported for displaying rows	Variable useCatRef = strlen(catRef) > 0	if (useCatRef && !rowsNotCols)		Variable i, lastBinCol = -1, catCol = -1		for (i=0;i<Dimsize(wv,dataDim);i+=1)			if (stringmatch(getdimlabel(wv,dataDim,i),"*bin"))				lastBinCol = i			endif						if (stringmatch(getdimlabel(wv,dataDim,i),binStringForCatagories))				catCol = i			endif				endfor				Variable useCatCol					if (!waveExists($catRef) || makeCatRef)					if (catCol >= 0)				useCatCol = 1				Duplicate/O/R=[*] wv, $catRef/wave=catWv				Redimension/N=(-1) catWv				catWv = wv[p][catCol]			else				useCatcol = 0				noBinPlot = 1			endif		else			WAVE catWv = $catRef			if (catCol < 0)				useCatcol = 0				noBinPlot = 1			endif		endif				Print "catCol",catCol,"catRef",catRef	else		noBinPlot = 1	endif			Variable propOfColForMainPlot = noBinPlot ? 1 : 0.8 	Variable propOfColForBinPlot = 0.15		Variable j, currColStart,currColEnd,currColEnd_main,currColStart_bin,currRowStart=0,currRowEnd=1	Variable xBinCol	String xDL,yDL,xLabel,xBinLabel, yLabel	String yAx, xAx, xAx_bin	Double pearson		Variable col_graphsize = 1 	currColStart = 0	currColEnd = 1	currColEnd_main = currColStart + ((currColEnd-currColStart) * propOfColForMainPlot)	currColStart_bin = currColEnd - ((currColEnd-currColStart) * propOfColForBinPlot)	xBinCol = xDataCol+1;	xDL = getdimlabel(x_wv,dataDim,xDataCol)	xLabel = text_makeStrPresentable(xDL)	xBinLabel = text_makeStrPresentable(getdimlabel(x_wv,dataDim,xBinCol))		if (simpleAxNames)		xAx = "bottom"		xAx_bin = "bottom" + xBinLabel	else		xAx = "B_" + xLabel		xAx_bin = "B_" + xBinLabel	endif	yDL = 	getDimlabel(wv,dataDim,yDataCol)	yLabel = text_makeStrPresentable(getDimlabel(wv,dataDim,yDataCol))			if (simpleAxNames)		yAx = "left"	else		if (usePreExistingHorizontalAxis)			yAx = stringfromlist(0,ListMatch(AxisList(winN), "L*"))		else			yAx = "L_"+yLabel		endif	endif		string main_tn	if (!ParamIsDefault(tn))		main_tn = tn	else		main_tn = yLabel	endif	string bin_tn = main_tn+"_bin"		if (rowsNotCols)		appendtograph/W=$winN/B=$xAx/L=$yAx wv[yDataCol][]/TN=$main_tn vs x_wv[xdataCol][]	else		appendtograph/W=$winN/B=$xAx/L=$yAx wv[][yDataCol]/TN=$main_tn vs x_wv[][xdataCol]	endif	modifygraph/W=$winN axisEnab($xAx) = {currColStart,currColEnd_main} , axisEnab($yAx) = {currRowStart,currRowEnd} 		if (!noBinPlot)		appendtograph/W=$winN/B=$xAx_bin/L=$yAx wv[][yDataCol]/TN=$bin_tn vs x_wv[][xBinCol]		modifygraph/W=$winN axisEnab($xAx_bin) = {currColStart_bin,currColEnd} , axisEnab($yAx) = {currRowStart,currRowEnd}	endif 			if (!usePreExistingHorizontalAxis)		modifygraph/W=$winN freepos($yAx)=0,lblpos($yAx)=110,mirror($yAx)=1		//gives more room		Label $yAx, yLabel + " \\U"	endif			Label $xAx, xLabel+" \\U"	modifygraph/W=$winN freepos($xAx)=0,lblpos($xAx)=40,mirror($xAx) = 1		if (!noBinPlot)		modifygraph/W=$winN freepos($xAx_bin)=0,lblpos($xAx_bin)=40,mirror($xAx_bin) = 1		setaxis/W=$winN/A/N=2 $xAx_bin	endif		modifygraph/W=$winN fsize=10,mode=3,marker=8,msize=2, btLen=2,stLen=2,fsize=fsize,rgb=(65535,0,0,52428)	if (useCatRef)		modifygraph/W=$winN zColor($main_tn) = {catWv,0,2.8,Green,0}		//0 to 2.8 range with 0,1 catagory data gives black and ~green		modifygraph/W=$winN zColorMin($main_tn) = NaN		//make points below min val transparent -- easy way to exclude points temporarily		modifygraph/W=$winN zColor($bin_tn) = {catWv,0,2.8,green,0}		//0 to 2.8 range with 0,1 catagory data gives black and ~green		modifygraph/W=$winN zColorMin($bin_tn) = NaN		//make points below min val transparent -- easy way to exclude points temporarily	endif		setwindow $winN, hook(disp_cursorClickHook)=disp_cursorClickHook	SetAxis/A/N=2/w=$winN	String catAvgRef	if (!noCorrCalcs)		//determine correlation coeffs		String corrMatAppendStr = "_corr"		String corrMatrixRef=nameofwave(wv)+corrMatAppendStr		Variable forceNewOutputWave = !ParamIsDefault(forceNewCorrelationMat) && forceNewCorrelationMat		if (noBinPlot)			string inputCatRef 			if (ParamIsDefault(forceCatRef))				inputCatRef = ""			else				inputCatRef = forceCatRef			endif			disp_plotRep_appendPearson(winN,nameofwave(wv),xDl,yDL,xLabel,yLabel,0,forceNewOutputWave,inputCatRef)		//"" for no catagorization wave		else			catAvgRef = disp_plotRep_appendPearson(winN,nameofwave(wv),xDl,yDL,xLabel,yLabel,0,forceNewOutputWave,catRef)		//"" for no catagorization wave			String catAvgWvRef = stringfromlist(0,catAvgRef)			WAVE catAvgWv = $catAvgWvRef			String catAvgCatWvRef = stringfromlist(1,catAvgRef)			WAVE catAvgCatWv = $catAvgCatWvRef			string avgBin_tn = main_tn+"_bina"			appendtograph/W=$winN catAvgWv[][1]/TN=$avgBin_tn vs catAvgWv[][0]			modifygraph/W=$winN zColor($avgBin_tn) = {catAvgCatWv,0,2.8,green,0}		//0 to 2.8 range with 0,1 catagory data gives black and ~green			modifygraph/W=$winN zColorMin($avgBin_tn) = NaN		//make points below min val transparent -- easy way to exclude points temporarily			ModifyGraph/W=$winN mode($avgBin_tn)=3,marker($avgBin_tn)=16,msize($avgBin_tn)=2,lsize($avgBin_tn)=2					endif	endif		if (!noBinPlot)			endif		return main_tn	end//disp_plotRep_2D()function/S disp_plotRep_appendPearson(winN,dataWvRef,xDL,yDL,xLbl,yLbl,appendToYNotX,forceNewOutputWave,categoryWvRef)	STring winN		//window to append to	String dataWvRef	String xDL,yDL		//name of dimensions	String xLbl,yLbl		//labels for x and y axes, if any	Variable appendToYNotX	//pass 1 to append to y label, 0 to append to x label	Variable forceNewOutputWave		//pass to foce overwriting of output correlation matrix	String categoryWvRef			//ref to wave with as many points as rows as rows in dataWvRef, 0 or 1 for group 0 or group 	WAVE/D dwv=$dataWvRef	WAVE cwv = $categoryWvRef	Variable yCol = FindDimLabel($dataWvRef,1,yDL)	Variable xCol = FindDimLabel($dataWvRef,1,xDL)	Variable ro=xCol,co=yCol		//auto naming -- unique for each ro/col pair	String corrMatAppendStr="_cst_" + num2str(ro) + "_" + num2str(co)		//for correlation stats	String corrMatrixRef=dataWvRef+corrMatAppendStr	String fitRef = corrMatrixRef + "f"	Variable expectedNumParams_compStats = 8		//this can be incorrect and is checked if a wave has to be created and filled in	Variable finalNumParams_compStats	Variable expctedNumParams_lineFit = 7		//determined below	Variable totalNumParams=expectedNumParams_compStats+expctedNumParams_lineFit		Variable numPermutations = 1000//100000	Variable numCols=dimsize($dataWvRef,1)		String axisStartStr, axLabel, pearsonStr, pValStr, line_a_str, line_b_str, line_ssRes_str	if (appendToYNotX)		axisStartStr = "L"		axLabel = yLbl	else		axisStartStr = "B"		axLabel = xLbl	endif	Variable corrMatrixJustCreated	if (forceNewOutputWave || !waveexists($corrMatrixRef))		Make/O/D/N=(totalNumParams) $corrMatrixRef/wave=cm		cm = NaN		corrMatrixJustCreated = 1		//will append layer dim labels	else		WAVE/D cm = $corrMatrixRef		corrMatrixJustCreated = 0	endif						if (corrMatrixJustCreated || (FindDimLabel(cm, 0,"numPointsInclNaN" ) < 0) || numtype(cm[%numPointsInclNaN]) ) //if no dim labels or num points is not a real number, analysis needs to be performed		wave_2D_getPearsonPValDist($dataWvRef,ro,co,numPermutations,categoryWvRef,"compStats","")		//get pearons stats		WAVE compStats				//assign dim labels to correlation matrix layers if needed (this cant be done with rows and cols because need to get these by calling the wave_2D_getPearsonPValDist function		if ( corrMatrixJustCreated )			dl_lblsToLbls(nameofwave(compStats),0,0,nan,corrMatrixRef,0,0,"",0)		//assign layer dimension labels		endif				//assign stats to the correlation matrix		finalNumParams_compStats = dimsize(compStats,0)+expctedNumParams_lineFit		Duplicate/O compStats, $corrMatrixRef		Redimension/N=(finalNumParams_compStats,-1) $corrMatrixRef				//add line fit results		if (corrMatrixJustCreated)			Variable r=dimsize(compStats,0)-1			r+=1;SetDimLabel 0,r,line_a,cm			r+=1;SetDimLabel 0,r,line_b,cm			r+=1;SetDimLabel 0,r,ssRes,cm			r+=1;SetDimLabel 0,r,V_FitError,cm			r+=1;SetDimLabel 0,r,V_FitQuitReason,cm			r+=1;SetDimLabel 0,r,V_Pr,cm			r+=1;SetDimLabel 0,r,V_r2,cm		endif				Make/O/D/N=(2) W_coef;Double V_FitError,V_Pr,V_r2,V_FitQuitReason		Curvefit/Q/W=2/N=1 line,dwv[*][yCol]/X=dwv[*][xCol]		cm[%line_a][0]=W_coef[0]		cm[%line_b][0]=W_coef[1]		cm[%V_FitError][0]=V_FitError		cm[%V_FitQuitReason][0]=V_FitQuitReason		cm[%V_Pr][0]=V_Pr		cm[%V_r2][0]=V_r2				Make/O/D/N=(dimsize(dwv,0)) $fitRef/wave=fit		Duplicate/O fit, fitres_temp		fit = w_coef[0] + W_coef[1]*dwv[p][xCol]		fitres_temp = (dwv[p][yCol] - fit[p])^2		matrixop/O fitres_temp = replaceNaNs(fitres_temp,0)		//NaNs will not contribute to sum, without doing this sum() function returns NaN		cm[%ssRes][0] = sum(fitres_temp)		killwaves fitres_temp	else		WAVE/D fit = $fitRef			endif		String pVal_Str 	sprintf pVal_Str, "%e",cm[%pVal][0]	ModifyGraph/W=$winN margin(bottom)=50	Print/D "disp_plotRep_appendPearson(): pearsonRef", corrMatrixRef,"pearson",cm[%pearson][0],"pVal",cm[%pVal][0],pVal_Str,"nUsed",cm[%pVal][0],"yCol",yCol,"xCol",xCol,"corrMatrixRef",corrMatrixRef	Print/D "disp_plotRep_appendPearson(): line_a",cm[%line_a][0],"line_b",cm[%line_b][0],"ssRes",cm[%ssRes][0]		sprintf pearsonStr, "%f", cm[%pearson][0]	sprintf pValStr, "%f", cm[%pVal][0]	sprintf line_a_str, "%4.3e", cm[%line_a][0]	sprintf line_b_str, "%4.3e", cm[%line_b][0]	sprintf line_ssRes_str, "%4.3e", cm[%ssRes][0]		String axN = stringfromlist(0,listmatch(AxisList(winN),axisStartStr+"*"))	axLabel += " \\U\r[R= \\f01" + pearsonStr +"\\f00; p=\\f01" + pValStr +"\\f00]\r[b= \\f01" + line_a_str +"\\f00; m= \\f01" + line_b_str+"\\f00]" //+"\\f00; ssRes= \\f01" + line_ssRes_str +"\\f00]"	Label/W=$winN $axN, axLabel		appendtograph/W=$winN fit vs dwv[*][xCol]	modifygraph/W=$winN height=2.5*72,width=2.5*72;doupdate;modifygraph/W=$winN height=0,width=0,lstyle($fitRef)=8,rgb($fitRef)=(0,0,0,19661)		//display catagory averages if present	Variable numCalculatedCats =dimsize(cm,1) - 1,i,col;string catLabelStr,outStr = ""	if (numCalculatedCats > 0)				Make/O/D/N=(numCalculatedCats,2) $( corrMatrixRef + "C" )/WAVE=cmca		//for catagory averages ... 0th column for x vals, 1st column for y vals		Make/O/D/N=(numCalculatedCats) $( corrMatrixRef + "D" )/WAVE=cmcac	//for catagory averages cat labels .. matches colors to colors of cats on plots		outStr += corrMatrixRef + "C;"+corrMatrixRef + "D;"		for (i=0;i<numCalculatedCats;i+=1)			col = i+1			catLabelStr=ReplaceString("cat_",GetDimLabel(cm, 1, col ),"")			cmca[i][0] = cm[%c0_avg][col]			cmca[i][1] = cm[%c1_avg][col]			cmcac[i] = str2num(catLabelStr)		endfor	endif		Print "numCalculatedCats",numCalculatedCats		return outStr	endfunction/S wave_2D_getPearsonPValDist(wv,c0,c1,numPermutations,categoryWvRef,outRef,transforms,[outlierRulesWv,out_dataRef])	WAVE/D wv; Variable numPermutations		//num permutations to run	Variable c0,c1		//column numbers to compare .. for consistency pass as xCol,yCol, though doesnt actually matter	String categoryWvRef			//ref to wave with as many points as rows as rows in dataWvRef, 0 or 1 for group 0 or group 1	String outRef			//contains stats	WAVE/T outlierRulesWv		//optionally pass a wave that sets outlier rules, rules that are checked to remove rows (rows with at least one NaN are automatically removed)				//format is 0th column is a column label in the wave, 1st, 2nd, etc. columns are expressions like "%f < 0", an sprintf command replaces %f with each row's value at the column of the label. If the expression evaluates false, the row is not used 	String out_dataRef		//optionally pass the name of a reference to store the data waves after applying rules		String transforms		//"" or pass transform to try in stats_ksNormalityTest..wv0 transform goes in 0th element of string list, wv1 transform goes in 1st element of string list		Variable numRows=dimsize(wv,0)	string c0Lbl=getdimlabel(wv,1,c0)	String c1Lbl=getdimlabel(wv,1,c1)	String usedRowsList,outSelData=selectstring(ParamIsDefault(out_dataRef),out_dataRef,"")	if (ParamIsDefault(outlierRulesWv))		usedRowsList=wave_getColsWithoutNaNsOutliers(wv,c0,c1,"c0_temp","c1_temp",outSelData)	else		usedRowsList=wave_getColsWithoutNaNsOutliers(wv,c0,c1,"c0_temp","c1_temp",outSelData,outlierRulesWv=outlierRulesWv)	endif	WAVE/D c0_temp,c1_Temp	Variable numUsedRows = itemsinlist(usedRowsList)	Variable numNaNPnts = numRows - numUsedRows	Variable hasCatWv = (strlen(categoryWvRef) > 0) && waveExists($categoryWvRef)	make/o/d/n=(numUsedRows) cat_temp	if (hasCatWv)		WAVE catWv = $categoryWvRef		cat_temp=catWv[str2num(stringfromlist(p,usedRowsList))]	else		cat_temp=0	endif			//calculate pearson and significance	Print "calculating pearson on raw data across all categories:"	stats_pearson(c0_temp,c1_temp,numPermutations,outRef,transforms=transforms)	WAVE out=$outRef	Variable numPearsonParams=dimsize(out,0)	redimension/n=(numPearsonParams+5) out	Variable r=numPearsonParams,j,i,k,row	r+=0;dl_assignAndLbl(out, r, numUsedRows, "numPointsTested")	r+=1;dl_assignAndLbl(out, r, numRows, "numPointsInclNaN")	r+=1;dl_assignAndLbl(out, r, numNaNPnts, "numNaNPnts")	r+=1;dl_assignAndLbl(out, r, nan, "col0Lbl(xCol):"+c0Lbl)	r+=1;dl_assignAndLbl(out, r, nan, "col1Lbl(yCol):"+c1Lbl)			//since we have all the real values of interest picked out anyway, run and store wave stats on both real waves, calculating differences and fold differences	Wavestats/Q/W c0_temp	WAVE M_wavestats //from wave stats	Duplicate/O/D M_wavestats, c0_wStats_temp, c1c0_diffWStats_temp, c1c0_fDiffWStats_temp	Wavestats/Q/W c1_temp	Duplicate/O/D M_wavestats, c1_wStats_temp	c1c0_diffWStats_temp = c1_wStats_temp - c0_wStats_temp	c1c0_fDiffWStats_temp = c1_wStats_temp / c0_wStats_temp	Variable numWaveStats=DimSize(c0_wStats_temp,0)	Variable currNumParams=dimsize(out,0)	Variable c0_statsStartRow = currNumParams, c1_statsStartRow=currNumParams+numWaveStats,c0c1_diffStartRow=currNumParams+2*numWaveStats,c0c1_fDiffStartRow=currNumParams+3*numWaveStats	Redimension/N=(c0_statsStartRow + (4*numWaveStats)) out	dl_lblsToLbls("c0_wStats_temp",0,0,inf,outRef,0,c0_statsStartRow,"c0_",1)	dl_lblsToLbls("c0_wStats_temp",0,0,inf,outRef,0,c1_statsStartRow,"c1_",1)	dl_lblsToLbls("c0_wStats_temp",0,0,inf,outRef,0,c0c1_diffStartRow,"c1c0D_",1)	dl_lblsToLbls("c0_wStats_temp",0,0,inf,outRef,0,c0c1_fDiffStartRow,"c1c0F_",1)		out[c0_statsStartRow,c0_statsStartRow+numWaveStats-1]=c0_wStats_temp[p-c0_statsStartRow][0]	out[c1_statsStartRow,c1_statsStartRow+numWaveStats-1]=c1_wStats_temp[p-c1_statsStartRow][0]	out[c0c1_diffStartRow,c0c1_diffStartRow+numWaveStats-1]=c1c0_diffWStats_temp[p-c0c1_diffStartRow][0]	out[c0c1_fDiffStartRow,c0c1_fDiffStartRow+numWaveStats-1]=c1c0_fDiffWStats_temp[p-c0c1_fDiffStartRow][0]				if	(hasCatWv)		//weird catagories might have text number precision issues -- stick to integers. not much tested beyond two groups		//STATS BY CATEGORY		String catsAsList = text_getStrListFromWave($"cat_temp", 0)		String uniqueCatsList = text_removeStringListDuplicates(catsAsList, ";")		Variable numCats = itemsinlist(uniqueCatsList)		Redimension/N=(-1,1+numCats) out; out[][1,] = nan		//new values to NaN		Variable outCol		Make/O/T/N=(numCats) indexesMatchingCats_temp		indexesMatchingCats_temp = ""		String currCat,currMatchingIndexes		Variable foundCatNum,numIndexesMatchingCat		//find rows in each catagory and store in indexesMatchingCats_temp		for (i=0;i<numUsedRows;i+=1)			currCat = stringfromlist(i,catsAsList)			foundCatNum = WhichListItem(currCat, uniqueCatsList)			indexesMatchingCats_temp[foundCatNum] += num2str(i) + ";"		endfor		SetDimLabel 1,0,$"cat_all",out		Make/O/D/N=(numUsedRows,numCats) allCatVals_c0,allCatVals_c1		//store all values for statistics		for (i=0;i<numCats;i+=1)			outCol = i + 1		//first column is for overall params, these columns are for within catagory params			SetDimLabel 1,outCol,$"cat_"+stringfromlist(i,uniqueCatsList),out			currMatchingIndexes=indexesMatchingCats_temp[i]			numIndexesMatchingCat = itemsinlist(currMatchingIndexes)			Make/O/D/N=(numIndexesMatchingCat) currCatVals_c0,currCatVals_c1			currCatVals_c0 = c0_temp[str2num(stringfromlist(p,currMatchingIndexes))]			currCatVals_c1 = c1_temp[str2num(stringfromlist(p,currMatchingIndexes))]						allCatVals_c0[][i] = p < dimsize(currCatVals_c0,0) ? currCatVals_c0[p] : NaN		//store real values, rest NaN			allCatVals_c1[][i] = p < dimsize(currCatVals_c1,0) ? currCatVals_c1[p] : NaN						//PEARSON WITHIN CATEGORY			Print "calculating pearson on cat",i			stats_pearson(currCatVals_c0,currCatVals_c1,numPermutations,"pearsonCat_temp",transforms=transforms)			if (i==0)				WAVE/D pearsonCaTemp=$"pearsonCat_temp"			endif			numPearsonParams=dimsize(pearsonCaTemp,0)			out[0,numPearsonParams-1][outCol]=pearsonCaTemp[p]		//numUsedRows,numRows,numNaNPnts true across all and so not copied						//wavestats (mean etc.)			WaveStats/Q/W currCatVals_c0			Duplicate/O M_wavestats, c0_wStats_temp, c1c0_diffWStats_temp, c1c0_fDiffWStats_temp			Wavestats/Q/W currCatVals_c1			Duplicate/O M_wavestats, c1_wStats_temp			c1_wStats_temp = M_wavestats			c1c0_diffWStats_temp = c1_wStats_temp - c0_wStats_temp			c1c0_fDiffWStats_temp = c1_wStats_temp / c0_wStats_temp							//stored same rows as for non-categorical			out[c0_statsStartRow,c0_statsStartRow+numWaveStats-1][outCol]=c0_wStats_temp[p-c0_statsStartRow][0]			out[c1_statsStartRow,c1_statsStartRow+numWaveStats-1][outCol]=c1_wStats_temp[p-c1_statsStartRow][0]			out[c0c1_diffStartRow,c0c1_diffStartRow+numWaveStats-1][outCol]=c1c0_diffWStats_temp[p-c0c1_diffStartRow][0]			out[c0c1_fDiffStartRow,c0c1_fDiffStartRow+numWaveStats-1][outCol]=c1c0_fDiffWStats_temp[p-c0c1_fDiffStartRow][0]			endfor			//comparison stats --labeling is imperfect, but all comparisons should be saved.		Variable startIndex = dimsize(out,0),currRows		Variable numComparisons		String comparisonStr		//stores i[col#]_j[col#]		String comparisonParmStr		Variable endIndex		Variable numParamsPerComparison		for (i=0;i<numCats;i+=1)			outCol =  i + 1		//first column is for overall params, these columns are for within catagory params			//stats_cols(allCatVals_c0,"allColStats_temp",singleCol=i)			stats_cols($("allCatVals_c"+num2str(i)),"allColStats_temp",singleCol=i)			WAVE/Z allColStats_temp			if (!waveexists(allColStats_temp))				print "failed to find cat num",i,"skipping"			endif			numParamsPerComparison = dimsize(allColStats_temp,0)			numComparisons = dimsize(allColStats_temp,1)			endIndex = startIndex + numParamsPerComparison * numComparisons			currRows=dimsize(out,0)			if (currRows < endIndex)				redimension/N=(endIndex,-1) out; out[currRows,][]=nan			endif			for (j=0;j<numComparisons;j+=1)				comparisonStr =GetDimLabel(allColStats_temp, 1, j)				out[startIndex+(j*numParamsPerComparison),startIndex+((j+1)*numParamsPerComparison)-1][outCol] = allColStats_temp[p-startIndex+(j*numParamsPerComparison)]				if (i==0)		//assign row dim labels					for (k=0;k<numParamsPerComparison;k+=1)						comparisonParmStr = GetDimLabel(allColStats_temp, 0, k )						row = startIndex + (j*numParamsPerComparison) + k						SetDimLabel 0,row,$( comparisonStr + comparisonParmStr ),out					endfor							endif			endfor		endfor		endif		String infoStr="pearson_usedRowList:"+sc2c(out_dataRef,1)	if (!paramisdefault(out_dataRef) && strlen(out_dataRef))		note/nocr $out_dataRef,infoStr	endif		return infostrendfunction/s wave_getColsWithoutNaNsOutliers(wv,col0,col1,col0_outRef,col1_outRef,outSelData,[outlierRulesWv])	WAVE wv	Variable col0,col1	String col0_outRef,col1_outRef	String outSelData		//a place to store the raw data columns (col0 as col 0, col1 as col 1) with excluded rows set to NaN at all points	WAVE/T outlierRulesWv//optionally pass a wave that sets outlier rules, rules that are checked to remove rows (rows with at least one NaN are automatically removed)				//format is that 0th column is a column label in the data wave, 1st is a column with an expression like "%f < 0", an sprintf command replaces %f with each row's value at the column of the label."				//only one escape code is allowed per row, but it may be repeated multiple times within the expression. If it is used multiple times, the escape code must be stored in column 2.									//old format (no longer supported)				//format is 0th column is a column label in the wave, 1st, 2nd, etc. columns are expressions like "%f < 0", an sprintf command replaces %f with each row's value at the column of the label. If the expression evaluates false, the row is not used 				Variable selDataRequested = strlen(outSelData) > 0	if (seldataRequested)		duplicate/o/r=[][col0] wv,$outSelData/wave=out		redimension/n=(-1) out		duplicate/o/r=[][col1]/free wv,temp		redimension/n=(-1) temp		concatenate/dl/np=1 {temp}, out		setdimlabel 1,0,$getdimlabel(wv,1,col0),out		setdimlabel 1,1,$getdimlabel(wv,1,col1),out	endif		variable numRows=dimsize(wv,0),i,j,k,row; string realRowsList = ""	for (i=0;i<numRows;i+=1)		if (!numtype(wv[i][col0]) && !numtype(wv[i][col1]))			realRowsList += num2str(i) + ";"		else			if (selDataRequested)				out[i][] = nan			endif		endif	endfor		String usedRowsList = realRowsList,lbl,failedRows=""	if (!ParamIsDefault(outlierRulesWv) && waveexists(outlierRulesWv))		Variable currNumRows=itemsinlist(usedRowsList),moreThanOneEscapeStr		Variable numRules=dimsize(outlierRulesWv,0),col		Double val		Variable/G expressionTester		string ruleExp,rowstr,testExp="",escapeStr		for (i=0;i<numRules;i+=1)			lbl=outlierRulesWv[i][0]			col=finddimlabel(wv,1,lbl)			if (col < 0)				print "wave_2D_getPearsonPValDist() outlierRulesWv lbl at row",i,"couldnt find label=",lbl,"in any column"				continue			endif			ruleExp = outlierRulesWv[i][1]			if (strlen(ruleExp) < 1)				break		//no more rules			endif			ruleExp = "expressionTester="+ruleExp			if (dimsize(outlierRulesWv,1) < 3)				escapeStr=""			else				escapeStr=outlierRulesWv[i][2]	//column 2 (from zero) can specify how many times the escape code is used e.g., numtype (%d) || (%d < 1) would have 2			endif			moreThanOneEscapeStr = (strlen(escapeStr) > 0) && stringmatch(ruleExp,"*"+escapeStr+"*"+escapeStr+"*") 			for (k=0;k<numRows;k+=1)					rowstr = stringfromlist(k,usedRowsList)				row = str2num(rowstr)				val = wv[k][col]				testExp=""				if (moreThanOneEscapeStr)					testExp = sprintf_reps(testExp,escapeStr,val,"")				else					sprintf testExp,ruleExp,val				endif				testExp=testExp//+";print \""+ruleExp+". true? \",expressionTester" 				execute/q testExp								if (!expressionTester)					if (whichlistitem(num2str(k),failedRows) < 0)//if (whichlistitem(num2str(k),failedRows))						failedRows+=num2str(k)+";"					endif					if (selDataRequested)						out[k][] = nan					endif				endif							endfor		endfor	endif		//remove failed rows from usedRowsList	Variable numFailedRows=itemsinlist(failedRows)	for (i=0;i<numFailedRows;i+=1)		usedRowsList=RemoveFromList(stringfromlist(i,failedRows), usedRowsList)	endfor		Print "wave_2D_getPearsonPValDist(): numusedrows",itemsinlist(usedrowsList),"usedRowsList,",usedRowsList		//gather the real, non NaN values	Variable numUsedRows=itemsinlist(usedRowsList)	Make/O/D/N=(numUsedRows) $col0_outRef/wave=col0_out, $col1_outRef/wave=col1_out		col0_out = wv[str2num(stringfromlist(p,usedRowsList))][col0]	col1_out = wv[str2num(stringfromlist(p,usedRowsList))][col1]	return usedRowsListend//allows some uses of sprintf with variable numbers of a single escape codefunction/S sprintf_reps(regExpStr,escapeCodeStr,val,valStr)	STring regExpStr,valSTr,escapeCodeStr	Double val			String outValStr	if (strlen(valStr) < 1)		//use val not valStr		sprintf outValStr,escapeCodeStr,val	else		sprintf outValStr,escapeCodeStr,valStr	endif		return replacestring(escapeCodeStr,regExpStr,outValStr)end//pearson correlation coef and permutation test for signfiicance of that correlationfunction stats_pearson(wv0,wv1,numPermutations,outRef,[transforms])	WAVE wv0,wv1	Variable numPermutations	String outRef	String transforms		//pass transform to try in stats_ksNormalityTest..wv0 transform goes in 0th element of string list, wv1 transform goes in 1st element of string list		String transform0="",transform1=""	if (!paramIsDefault(transforms))		transform0=stringfromlist(0,transforms)		transform1=stringfromlist(1,transforms)	endif		stats_ksNormalityTest(wv0,0.05,"ksStats_wv0",outRef_normalized="wv0_normTemp",transform=transform0)	stats_ksNormalityTest(wv1,0.05,"ksStats_wv1",outRef_normalized="wv1_normTemp",transform=transform1)	WAVE ksStats_wv0,ksStats_wv1	WAVE/D wv0_normTemp,wv1_normTemp	Make/O/D/N=(numPermutations)/free r_permutations	//ON RAW DATA -- PROBABLY NOT AS VALID AS ON NORMALIZED DATA	Double r_crit,pVal,r_crit_abs	pVal = stats_pearson_shuffle(wv0,wv1,numPermutations,r_crit_out=r_crit)	r_crit_abs=abs(r_crit)		Variable numPearsonParams = 5,r	Make/O/D/N=(numPearsonParams*2) $outRef/wave=out	r=0;dl_assignAndLbl(out, r, r_crit, "pearson")	r+=1;dl_assignAndLbl(out, r, r_crit_abs, "abs_pearson")	r+=1;dl_assignAndLbl(out, r, pVal, "pval")	r+=1;dl_assignAndLbl(out, r, numPermutations, "numPermutations")	r+=1;dl_assignAndLbl(out, r, pVal*numPermutations, "num_pEqualOrGreaterThanObs")		Print "stats_pearson() on raw values: r_crit",r_crit,"numPermutations",numPermutations,"pval", pVal		//ON NORMALIZED DATA -- ONLY POTENTIALLY VALID IF VALUES PASS NORMALITY TEST		pVal = stats_pearson_shuffle(wv0_normTemp,wv1_normTemp,numPermutations,r_crit_out=r_crit)	r_crit_abs=abs(r_crit)			r+=1;dl_assignAndLbl(out, r, r_crit, "pearson_N")	r+=1;dl_assignAndLbl(out, r, r_crit_abs, "abs_pearson_N")	r+=1;dl_assignAndLbl(out, r, pVal, "pval_N")	r+=1;dl_assignAndLbl(out, r, numPermutations, "numPermutations_N")	r+=1;dl_assignAndLbl(out, r, pVal*numPermutations, "num_pEqualOrGreaterThanObs_N")		dl_appendToLbls(ksStats_wv0,0,"ks0_",1,0,inf)	dl_appendToLbls(ksStats_wv1,0,"ks1_",1,0,inf)	concatenate/np=0/dl {ksStats_wv0,ksStats_wv1},out		Print "stats_pearson() on normalized data: r_crit",r_crit,"pval",pVal,"wv0 Fits Normal?",ksStats_wv0[%ks0_isNormal],"wv1 Fits Normal (1==yes)?",ksStats_wv1[%ks1_isNormal]	endfunction/D stats_pearson_shuffle(wv0,wv1,numPermutations,[r_crit_out])	WAVE wv0,wv1	Double numPermutations	Double &r_crit_out		//optionally pass variable to return r_crit		Variable nthreads=threadprocessorcount	Variable tgID=ThreadGroupCreate(nthreads)		Variable thread,test,jj,threadStatus,j		Double r_crit = statsCorrelation(wv0,wv1)		//real r	Double r_crit_abs = abs(r_crit)	Double count_rValAboveRCrit=0	for (j=0;j<numPermutations;j+=nthreads)		for (jj=0;jj<nthreads;jj+=1)			test = j+jj			if ( test >=numPermutations)				break			endif						threadstart tgID,jj,stats_pearson_shuffle_tsDriver(wv0,wv1,r_crit_abs)		endfor				// Wait for the two curve fits to finish.		threadStatus = ThreadGroupWait(tgID, inf)		if (threadStatus)			print "There was a problem with a thread. Aborting! j",j,"test",test			break;		endif				//sum up return values		for (jj=0;jj<nthreads;jj+=1)			count_rValAboveRCrit += threadreturnvalue(tgID,jj)		endfor		endfor		Variable releaseOutput=threadgrouprelease(tgID)	Double pVal = count_rValAboveRCrit / numPermutations		if (!ParamIsDefault(r_crit_out))		r_crit_out = r_crit	endif		return pVal	endthreadsafe function stats_pearson_shuffle_tsDriver(wv0,wv1,r_crit_abs)	WAVE wv0,wv1	Double r_crit_abs		matrixop/O/free wv0_shtemp = wv0	matrixop/O/free wv1_shtemp = wv1	shuffle(wv0_shtemp)	shuffle(wv1_shtemp)	Double rVal = statsCorrelation(wv0_shtemp,wv1_shtemp)	return r_crit_abs <= abs(rVal) end	//returns some basic statitics for column by column comparisons. NaNs,+/- inf completely ignored (they don't even contribute to counts for N)//analyses are not pairedfunction/S stats_cols(w,outRef[singleCol])	WAVE/D w	String outRef	Variable singleCol	//optionally pass one column index to compare against all others (instead of all comparison)		Variable numCols = dimsize(w,1)	Variable maxNumRows = dimsizE(w,0)		Variable i,j,k	String realPositions_c0,realPositions_c1	Variable numReal_c0,numReal_c1	Variable comparisonCount = 0	Make/O/D/N=(1) realVals_c0, realVals_c1		//resized as needed		Variable startCol,exclusiveEndCol	if (ParamIsDefault(singleCol))		startCol = 0		exclusiveEndCol = numCols	else		startCol=singleCol		exclusiveEndCol = singleCol + 1	endif		//for each column vs each column	for (i=startCol;i<exclusiveEndCol;i+=1)		//i=0;i<numCols; unless singleCol is passed		for (j=0;j<numCols;j+=1)			if (i==j)				continue		//skip comparison against self			endif						if (j > 1)				break				endif						//find positions of reals			realPositions_c0 = "",realPositions_c1=""			for (k=0;k<maxNumRows;k+=1)				if (numtype(w[k][i]) < 1)					realPositions_c0 += num2str(k) + ";"				endif				if (numtype(w[k][j]) < 1)					realPositions_c1 += num2str(k) + ";"				endif							endfor						//grab real values from their positions			numReal_c0 = itemsinlist(realPositions_c0)						Redimension/N=(numReal_c0) realVals_c0			realVals_c0 = w[str2num(stringfromlist(p,realPositions_c0))][i]						numReal_c1 = itemsinlist(realPositions_c1)			Redimension/N=(numReal_c1) realVals_c1			realVals_c1 = w[str2num(stringfromlist(p,realPositions_c1))][j]								stats_2w(realVals_c0,realVals_c1,"stats_c0c1")			WAVE stats_c0c1			if (comparisonCount == 0)				Duplicate/O stats_c0c1, $outRef/wave=out				Redimension/N=(-1,comparisonCount+1) out			else				Redimension/N=(-1,comparisonCount+1) out				out[][comparisonCount] = stats_c0c1[p]			endif			SetDimLabel 1,comparisonCount,$( "i"+num2str(i)+"_j"+num2str(j) ),out				endfor	endfor		Print "stats_cols(): name of wave w:",nameofwave(W)		return outRefend//stats for 2 waves, NaNs not necessarily ignored. could use stats_cols() to be rid of them firstfunction stats_2w(w0,w1,outRef)	WAVE/D w0,w1	String outRef		//for debugging//	NVAR/Z stats_2w_count//	if (!NVar_Exists(stats_2w_count))//		Variable/G stats_2w_count = 0//	endif//	String w0Ref="stats_2w_w0_"+num2str(stats_2w_count)//	String w1Ref="stats_2w_w1_"+num2str(stats_2w_count)//	duplicate/o w0, $w0Ref//	duplicate/o w1, $w1Ref//	stats_2w_count+=1		Print "stats_2w() w0:",nameofwave(w0),"N",dimsize(w0,0),"mean",mean(w0),"w1:",nameofwave(w1),"N",dimsize(w1,0),"mean",mean(w1)//	print "stats_2w() w0 ref",w0ref,"vals:",w0//	print "stats_2w() w1 ref",w1ref,"vals:",w1		Variable tailType=4		//4 is two tailed	Double alpha = 0.05 		//standard t test	killwaves/Z $"W_StatsTTest"	StatsTTest/ALPH=(alpha)/CI/TAIL=(tailType)/Q w0,w1	WAVE/D W_StatsTTest		//created by statsTTest	dl_appendToLbls(W_StatsTTest,0,"tt_",1,-inf,inf)		//normality tests	stats_ksNormalityTest(w0,alpha,"normality_c0")	WAVE normality_c0	dl_appendToLbls(normality_c0,0,"ks0_",1,-inf,inf)	stats_ksNormalityTest(w1,alpha,"normality_c1")	WAVE normality_c1	dl_appendToLbls(normality_c1,0,"ks1_",1,-inf,inf)		//ranked test (non-parametric) performed regardless of normality test results	Variable totalPnts=dimsize(w0,0) + dimsize(w1,0)	StatsWilcoxonRankTest/ALPH=(alpha)/TAIL=(tailType)/Q/aprx=((totalPnts>30)?2:1)  w0, w1	WAVE/D W_WilcoxonTest		//created by StatsWilcoxonRankTest		variable numWilParams = dimsize(W_WilcoxonTest,0)	Double wilcoxonP=W_WilcoxonTest[%P_TwoTail]	Variable accept = wilcoxonP > alpha		//accept the null hypothesis that there's no difference between the distributions? (same as the accept included in ttesT)			dl_appendToLbls(W_WilcoxonTest,0,"wr_",1,-inf,inf)		concatenate/O/DL/NP=0 {W_StatsTTest,normality_c0,normality_c1,W_WilcoxonTest}, $outRef	wave out=$outref	dl_addVal(alpha, "Stats_2w_alpha", outRef,0)		Print "stats_2w(): t-test(2T) p (w0 vs w1):", W_StatsTTest[%tt_P][1], "WilcoxonRank(2T):",wilcoxonP	//should be row 9	end//based on https://www.wavemetrics.com/products/igorpro/dataanalysis/statistics/tests/statistics_pxp17.htm //more notes below with stats_ksNormalityTest_cl function which is easier to run from command linefunction/wave stats_ksNormalityTest(w,alpha,outref,[outref_normalized,transform,perColumn])	WAVe/D w; Double alpha	Variable perColumn		//pass to calculate on a per-column basis, output is 2D: one column with stats along rows	string outref			String outref_normalized	//optionally pass to save the normalized values  ..not yet supported for perColumn	String transform		//optionally pass a transformation to do to the data -- see options below ..not yet supported for perColumn			if (perColumn)		Variable i,cols = dimsize(w,1)		for (i=0;i<cols;i+=1)			duplicate/o/free/r=[][i] w,temp			WAVE statsTemp = stats_ksNormalityTest(temp,alpha,"")			if (i==0)				if (strlen(outRef) > 0)					duplicate/o statsTemp,$outRef/wave=out2d				else					duplicate/o/free statsTemp,out2d				endif				redimension/n=(-1,1) out2d			else				concatenate/dl/np=1 {statsTemp},out2d			endif			setdimlabel 1,i,$getdimlabel(w,1,i),out2d		endfor			return out2d	endif		Variable expectedKSTestSize = 5+1		//should dimsize(W_KSResults,0) + 1	Duplicate/O/D/free w, stats_ksNormalityTest_temp		if (Paramisdefault(transform) || (strlen(transform)<1))		//do nothing!	elseif (stringmatch(transform,"log"))		stats_ksNormalityTest_temp = log(stats_ksNormalityTest_temp)			elseif (stringmatch(transform,"ln"))		stats_ksNormalityTest_temp = ln(stats_ksNormalityTest_temp)	elseif (stringmatch(transform,"logPlus:*"))		Double plus = str2num(stringfromlist(1,transform,":"))		stats_ksNormalityTest_temp = log(plus+stats_ksNormalityTest_temp)	elseif (stringmatch(transform,"inv"))		stats_ksNormalityTest_temp = 1/stats_ksNormalityTest_temp	elseif (stringmatch(transform,"power:*"))		Double power = str2num(stringfromlist(1,transform,":"))		stats_ksNormalityTest_temp = stats_ksNormalityTest_temp^power	endif		wavestats/q stats_ksNormalityTest_temp	stats_ksNormalityTest_temp -= V_avg		//subtract mean (mean now 0)	stats_ksNormalityTest_temp /= V_sdev	//normalize to standard dev, standard dev now 1		if (!ParamIsDefault(outref_normalized) && (strlen(outRef_normalized) > 0) )		duplicate/o stats_ksNormalityTest_temp, $outRef_normalized	endif	killwaves/z W_ksresults	Variable V_flag	StatsKSTest/ALPH=(alpha)/CDFF=stats_getNormalCDF/Q/Z stats_ksNormalityTest_temp	Variable isNormal,numparams	if ( (V_flag == -1) || (dimsize(w,0) < 2) )		//error		isNormal = nan		if (strlen(outRef) > 0)			make/o/d/n=(expectedKSTestSize) $outref/wave=out		else			make/o/d/n=(expectedKsTestSize)/free out		endif		dl_assignAndLbl(out, numparams, isNormal, "isNormal")		out=nan	else		WAVE W_KSResults		//created by StatsKSTest		if (strlen(outRef) > 0)			Duplicate/O W_KSResults, $outRef/wave=out		else			duplicate/o/free W_ksResults,out		endif			numparams=dimsize(out,0)		isNormal = out[%PValue]>=out[%alpha]		Redimension/N=(numparams + 1) 	out;dl_assignAndLbl(out, numparams, isNormal, "isNormal")	endif		if (!Paramisdefault(transform) && (strlen(transform)>0))		note/nocr out,"stats_ksNormalityTest_transform:"+transform+";"	endif	return outend//based on https://www.wavemetrics.com/products/igorpro/dataanalysis/statistics/tests/statistics_pxp17.htm //runs better than stats_ksNormalityTest() from command line because does not return a wave//not sure this is working right: I think if p < 0.05 you should reject because the data and the normal CDF are significantly different//I have written the opposite way//mostly better to use stats_ksNormalityTest() not this!function stats_ksNormalityTest_cl(w,alpha,outRef)	WAVe/D w; Double alpha; string outRef		Variable expectedKSTestSize = 5+1	wavestats/q w	Duplicate/O/D w, stats_ksNormalityTest_temp	stats_ksNormalityTest_temp -= V_avg		//subtract mean (mean now 0)	stats_ksNormalityTest_temp /= V_sdev	//normalize to standard dev, standard dev now 1	killwaves/z W_ksresults	Variable V_flag	StatsKSTest/ALPH=(alpha)/CDFF=stats_getNormalCDF/Q/Z stats_ksNormalityTest_temp	Variable accept,numparams	if ( (V_flag == -1) || (dimsize(w,0) < 2) )		//error		accept = nan		make/o/d/n=(expectedKSTestSize) $outRef/wave=dummy	else		WAVE/D W_KSResults		//created by StatsKSTest		Duplicate/O W_KSResults, $outRef/wave=ksResult		numparams=dimsize(ksResult,0)		Redimension/N=(numparams + 1) 	ksResult		accept = ksResult[%D]<ksResult[%Critical]		killwaves/z stats_ksNormalityTest_temp		dl_assignAndLbl(ksResult, numparams, accept, "Accept")	endif		return acceptend//for use on "_a" waves from step_exciseAndNorm_avgI -- select the column of interest and normalize all reps//to test if residuals are normally distributedfunction stats_timeSeriesNormality(wv,col,outRef)	WAVE wv		//wave with one row per time point, replicates in layers	Variable col	String outRef		Variable expectedKSTestOutSize = 6	variable i,rows = dimsize(wv,0)	variable layers = dimsize(wv,2)	make/o/free/d/n=(layers) temp	make/o/d/n=(rows,expectedKSTestOutSize) $outref/wave=out	for (i=0;i<rows;i+=1)		temp = wv[i][0][p]		stats_ksNormalityTest_cl(temp,0.05,"stats_timeSeriesNorm_temp")		if (i==0)			WAVE stats_timeSeriesNorm_temp		endif		out[i][] = stats_timeSeriesNorm_temp[q]		if (i==0)			dl_lblsToLbls("stats_timeSeriesNorm_temp",0,0,nan,"outref",1,0,"",0)		endif	endfor	end//returns value at x from continuous normal distribution with mean of 0 and stdev of 1function stats_getNormalCDF(x) : CDFFunc	Variable x		return statsNormalCDF(x,0,1)end//from http://www.igorexchange.com/node/1614threadsafe function shuffle(inwave)	//	in-place random permutation of input wave elements	wave inwave	variable N	=	numpnts(inwave)	variable i, j, emax, temp		for(i = N; i>1; i-=1)		emax = i / 2		j =  floor(emax + enoise(emax))		//	random index		temp		= inwave[j]		inwave[j]		= inwave[i-1]		inwave[i-1]	= temp	endforendfunction wave_2D_getColVsColStats(wv,outRef)	WAVE/D wv; string outRef		Variable saveTimeBySkippingRedundants = 1		String nForEachStatRef = outRef + "_stats_n"		Variable numCols = dimsize(wv,1)	Variable numRows = dimsize(wv,0)		Make/O/N=(numCols,numCols) $nForEachStatRef/wave=n_out	n_out = -inf	Make/O/D/N=(numCols,numCols) $outRef/wave=out	out = nan		Variable i,j,k,numNaNs; double c0_avg,c1_avg,c0_res,c1_res,res_tot,c0_res_sqr_tot,c1_res_sqr_tot	Variable nCount	for (i=0;i<dimsize(wv,1);i+=1)		SetDimLabel 0,i,$GetDimLabel(wv,1,i),out,n_out		for (j=0;j<dimsize(wv,1);j+=1)			if (i==0)		//only need to be done once				SetDimLabel 1,j,$GetDimLabel(wv,1,j),out,n_out			endif			if (saveTimeBySkippingRedundants)				if ( (i <= j) )					continue				endif			endif						if ( (i==j) && (numtype(n_out[i][j]) != 1) )		//intersect no longer -inf, so already been calculated				continue			endif						nCount=0;c0_avg=0;c1_Avg=0;res_tot=0;c0_res_sqr_tot=0;c1_res_sqr_tot=0			for (k=0;k<numRows;k+=1)				if (numtype(wv[k][i]) || numtype(wv[k][j]))		//skips NaNs,+/-infs					continue				endif								c0_avg += wv[k][i]				c1_avg += wv[k][j]				nCount += 1			endfor						c0_avg /= nCount			c1_avg /= nCount						for (k=0;k<numRows;k+=1)				if (numtype(wv[k][i]) || numtype(wv[k][j]))		//skips NaNs,+/-infs					continue				endif								c0_res = wv[k][i] - c0_avg				c1_res = wv[k][j] - c1_avg				res_tot += c0_res * c1_res				c0_res_sqr_tot +=  c0_res^2				c1_res_sqr_tot +=  c1_res^2				endfor						if (nCount > 0)				out[i][j] = res_tot / sqrt(c0_res_sqr_tot * c1_res_sqr_tot)				n_out[i][j] = nCount			else				n_out[i][j] = nan			endif		endfor	endforendfunction wave_2D_rankRowsByCol(wv,outRef)	WAVE/D wv; String outRef			variable numCols = dimsize(wv,1)	variable numRows = dimsize(wv,0)		Duplicate/O wv, sortTemp		Make/O/T/N=(numCols,numRows) $outRef/wave=labelsToSort	//	Make/O/D/N=(numRows) sortKeyTemp	labelsToSort[][] = GetDimLabel(wv, 0, p)		SortColumns keyWaves={wv}, sortWaves={labelsToSort}	SortColumns keyWaves={wv}, sortWaves={sortTemp}			end//fails on NaNs,+/- infsfunction wave_2D_getColVsColStats_igor(wv,outRef)	WAVE/D wv; string outRef		Duplicate/O wv, wave_2D_getColVsColStats_temp		wave_2D_getColVsColStats_temp = numtype(wave_2D_getColVsColStats_temp[p])		Variable whatever = statsCorrelation(wave_2D_getColVsColStats_temp)	WAVE/D M_Pearson		//created by stats correlation		Duplicate/O M_Pearson,$outRef		dl_lblsToLbls(nameofwave(wv),1,0,nan,outRef,0,0,"",0)	dl_lblsToLbls(nameofwave(wv),1,0,nan,outRef,1,0,"",0)		killwaves/z wave_2D_getColVsColStats_temp	return whatever	//just in case?endfunction calcDiffRefs(diffOrFoldDiff,proximalRefs,distalRefs)	Variable diffOrFoldDiff	String proximalRefs,distalRefs	//result will be out = distal - (or / ) proximal		String out_appendStr	if (diffOrFoldDiff)	//fold diff		out_appendStr = "_F"	else		out_appendStr = "_D"	endif		variable i; string proxRef,distRef	for (i=0;i<itemsinlist(proximalRefs);i+=1)		proxRef = stringfromlist(i,proximalREfs)		distRef = stringfromlist(i,distalRefs)		if (waveExists($proxRef) && waveExists($distRef))			WAVE/D prox = $proxRef			WAVE/D dist = $distRef			Duplicate/O prox, $(proxRef + out_appendStr)/wave=out			if (diffOrFoldDiff)				out = dist/prox			else				out = dist-prox			endif		endif		endfor	endfunction disp_swapRep_2D(swapXNotY,dataCol,dl)	Variable swapXNotY, dataCol	String dl	//if has length, function will attempt to search column labels for this dimension label and use column with matching label; if label unfound dl = "", uses dataCol		Variable i, usedDataCol	STring list = TraceNameList("", ";", 1)	String tn,info,xCmd,yCmd,rec,xWv,yWv,xRange,yRange,pl1,pl2	String xAx, xLabel,yAx,yLabel	Variable currX, currY	String winN = winname(0,1)		if (swapXNotY)			for (i=0;i<itemsinlist(list);i+=1)			tn = stringfromlist(i,list)			info = traceinfo("",tn,0)			xWv = StringByKey("XWAVE", info)			yWv = StringByKey("YWAVE", info)			if (!strlen(xWv) && strlen(yWv))				xWv = yWv			endif			if (!strlen(yWv) && strlen(xWv))				yWv = xWv			endif					if (!strlen(xWv) && !strlen(yWv))				continue			endif						xRange = StringByKey("XRANGE", info)			sscanf ReplaceString("*",xRange,""), "%g", currX						if (strlen(dl))				usedDataCol = FindDimLabel($xWv, 1, dl )				if (usedDataCol < 0)					usedDataCol = dataCol				endif			else				usedDataCol = dataCol			endif						replacewave/X trace=$tn, $xWv[*][usedDataCol]						xAx = stringbykey("XAXIS",info)			xLabel = GetDimLabel($xWv, 1, usedDataCol )			Label/W=$winN $xAx, (xLabel + " \\U")		endfor			else				for (i=0;i<itemsinlist(list);i+=1)			tn = stringfromlist(i,list)			info = traceinfo("",tn,0)			xWv = StringByKey("XWAVE", info)			yWv = StringByKey("YWAVE", info)			if (!strlen(xWv) && strlen(yWv))				xWv = yWv			endif			if (!strlen(yWv) && strlen(xWv))				yWv = xWv			endif					if (!strlen(xWv) && !strlen(yWv))				continue			endif									yRange = StringByKey("YRANGE", info)			sscanf ReplaceString("*",yRange,""), "%g", currY						if (strlen(dl))				usedDataCol = FindDimLabel($yWv, 1, dl )				if (usedDataCol < 0)					usedDataCol = dataCol				endif			else				usedDataCol = dataCol			endif						replacewave trace=$tn, $yWv[*][usedDataCol]			yAx = stringbykey("YAXIS",info)			yLabel = GetDimLabel($yWv, 1, usedDataCol )			Print "yWv",yWv,"yLabel",yLabel			Label/W=$winN $yAx, (yLabel + " \\U")		endfor	endif		setaxis/A/N=2endfunction/S text_listToWave(list,outRef)	String list,outRef		Variable i,len = itemsinlist(list)	Make/O/D/N=(len) $outRef/wave=out	out[] = str2num(stringfromlist(p,list))	return outrefend//load a bunch of excel rows/cols into a 2d text wavefunction excel_load2D(outRef,excelRowLblsStartCellStr,excelRowLblsEndCellStr,excelColLabelsRow,excel_typeExemplarColumn,excelSheetNameStr,dataStartCellStr,dataEndCellStr)	String outRef	//place to store 2d wave	String excelSheetNameStr		//first sheet is used if "" is passed	String excelRowLblsStartCellStr,excelRowLblsEndCellStr; variable excelColLabelsRow	String dataStartCellStr,dataEndCellStr	Variable excel_typeExemplarColumn			XLLoadWave/S=excelSheetNameStr/R=($dataStartCellStr,$dataEndCellStr)/C=(excel_typeExemplarColumn)/W=(excelColLabelsRow)/O/D/V=0		Print "itemsinlist(s_wavenames),S_wavenames",itemsinlist(s_wavenames),S_wavenames	String loadedWaves = s_wavenames	Make/O/T/N=(dimsize($stringfromlist(0,s_wavenames),0),itemsinlist(s_wavenames)) $outRef/wave=out		Variable i,j;string ref	for (i=0;i<itemsinlist(loadedWaves);i+=1)		ref = stringfromlist(i,loadedwaves)		SetDimLabel 1,i,$ref,out		if (wavetype($ref,1) == 2)	//text wave			WAVE/T wv_t = $ref			out[][i] = wv_t[p]		else			WAVE wv = $ref			for (j=0;j<dimsize(wv,0);j+=1)				if (numtype(wv[j]) == 2)					out[j][i] = ""				else					out[j][i] = num2str(wv[j])				endif			endfor		endif		killwaves/Z $ref	endfor		XLLoadWave/S=S_worksheetName/R=($excelRowLblsStartCellStr,$excelRowLblsEndCellStr)/COLT="T"/N=$"excel_load2d_dl_temp"/O/V=0 S_path		WAVE/T rowLabels = $Stringfromlist(0,S_wavenames)	for (i=0;i<dimsize(rowLabels,0);i+=1)		setdimlabel 0,i,$rowLabels[i],out	endfor		killWavesByName(S_wavenames)endfunction/S fio_stream_loadByKey(refListWvName,wv_keyword,row,dimLabel)	String refListWvName,wv_keyword		//wv_keyword is keyword for list pair containing wave ref to load		Variable row		///row to use, pass Nan to use dimlabel instead	String dimLabel //ignored unless row is nan		WAVE/T refListWv = $refListWvName			String str	if (numtype(row)==2)		//nan		str = refListWv[%$dimlabel]	else		str = refListWv[row]	endif		String keyStr = stringbykey(wv_keyword,str)		Print "keystr",keystr		return fio_stream_loadIBF(refListWvName,keyStr)end//load one or more waves saved with an fio_stream refListfunction/S fio_stream_loadIBF(refListWvName,refList,[cw,skipPreExisting])	String refListWvName,refList	variable cw			//pass optionally to check whether each wave exists after load	Variable skipPreExisting		//optionally pass to avoid reloading pre-existing waves		WAVE/T refListWv = $refListWvName	String loadPath = stringbykey("fio_loadpath",note(refListWv))		if (!strlen(loadPath))		loadpath = stringbykey("fio_savepath",note(refListWv))	endif		String out_waveListStr = ""		Variable skipPreExisting_used = !ParamIsDefault(skipPreExisting) && skipPreExisting		fio_loadfiles("*",".ibw",fullPathStr=loadPath,out_waveListStr=out_waveListStr,loadWvListStr=refList,skipPreExisting=skipPreExisting_used)	Print "fio_stream_loadIBF(): loadPath",loadpath,"out_waveListStr",out_waveListStr		if (!ParamIsDefault(cw) && cw)		Variable i		for (i=0;i<itemsinlist(refList);i+=1)			if (!waveexists($stringfromlist(i,refList)))				Print "fio_stream_loadIBF(): failed to load requested wave, wave =", stringfromlist(i,refList)			endif		endfor	endif		return out_waveListStrendfunction/S fio_keyedRefsList_addInfo(keyedRefsList)	String keyedRefsList		String igorExpName = igorinfo(1)	String dateOfLastSave = date()	String timeOfLastSave = time()		keyedRefsList = ReplaceStringByKey("igorExpName", keyedRefsList, igorExpName)	keyedRefsList = ReplaceStringByKey("dateOfLastSave", keyedRefsList, dateOfLastSave)	keyedRefsList = ReplaceStringByKey("timeOfLastSave", keyedRefsList, timeOfLastSave)		return keyedRefsListendfunction fa_saveCPRefs(paramsrefList, somaPedBothOrBothRev,streamTags,forceMainRef)	String paramsrefList	Variable somaPedBothOrBothRev	//0	-soma(hs1) only, 1-soma(hs2) only, 2-ped(hs1) only, 3-ped(hs2) only, 4-both(soma:hs1,ped:hs2), 5-both(soma:hs2,ped:hs1)"rev"	String streamTags,forceMainRef		String somaRef, pedRef	Variable somaIsHS1, pedIsHs1	switch (somaPedBothOrBothRev)		case 0:			somaRef = stringfromlist(0,paramsrefList)			pedRef = ""			somaIsHS1 = 1; pedIsHS1 = NaN			break		case 1:			somaRef = stringfromlist(0,paramsrefList)			pedRef = ""			somaIsHS1 = 0; pedIsHS1 = NaN			break		case 2:			somaRef = ""			pedRef = stringfromlist(0,paramsrefList)			somaIsHS1 = NaN; pedIsHS1 = 1			break		case 3:			somaRef = ""			pedRef = stringfromlist(0,paramsrefList)			somaIsHS1 = NaN; pedIsHS1 = 0			break					case 4:			somaRef = stringfromlist(0,paramsrefList)			pedRef = stringfromlist(1,paramsrefList)			somaIsHS1 = 1; pedIsHS1 = 0			break				case 5:			somaRef = stringfromlist(1,paramsrefList)			pedRef = stringfromlist(0,paramsrefList)			somaIsHS1 = 0; pedIsHS1 = 1			break			endswitch		Variable hasSomaRef = strlen(somaRef) > 0	Variable hasPedRef = strlen(pedRef) > 0	Variable dualSite = hasSomaRef && hasPedRef		String mainRef	if (dualSite || hasSomaRef)		mainRef = somaRef		//save by soma in case of dual site	else	//hasPedRef only		mainRef = pedRef	endif		if (strlen(forceMainRef))		mainRef = forceMainRef	else		mainRef = text_getInfoFromWaveName_S(mainRef, 9)	endif		String refsStr = ""	refsStr = ReplaceNumberByKey("somaPedBothOrBothRev", refsStr, somaPedBothOrBothRev)	refsStr = ReplaceNumberByKey("somaIsHS1", refsStr, somaIsHS1)	refsStr = ReplaceNumberByKey("pedIsHS1", refsStr, pedIsHS1)	refsStr = ReplaceNumberByKey("hasSomaRef", refsStr, hasSomaRef)	refsStr = ReplaceNumberByKey("hasPedRef", refsStr, hasPedRef)	refsStr = ReplaceNumberByKey("dualSite", refsStr, dualSite)		refsStr = ReplaceStringByKey("somaRef", refsStr, somaRef)	refsStr = ReplaceStringByKey("pedRef", refsStr, pedRef)	refsStr = ReplaceStringByKey("paramsrefList", refsStr, replacestring(";",paramsrefList,","))	refsStr = ReplaceStringByKey("mainRef", refsStr, mainRef)		Print "refsStr ==",refsStr		String pathStr = fio_stream_saveToStream("cp", mainRef,refsStr,streamTags,"", 0,"",0)		if (strlen(pathStr))	//path good because fio_stream_saveToStream completed		fio_saveWavesByName(somaRef + ";" + pedRef + ";",pathStr,1)	else		Print "could not save cell params refs, likely failed to get path in fio_stream_saveToStream()"	endifendfunction/S disp_replaceWaves(matchStr,replacementRef)		String matchStr		//matchStr of waves to be replaced	String replacementRef	//ref to wave to replace them with		String list = wavelist(matchStr,";","WIN:")		return wave_replaceWaves(list,replacementRef)	endfunction/S wave_replaceWaves(listOfWavesToRepalce,replacementref)	String listOfWavesToRepalce		//waves to be replaced by replacementRef	String replacementref		Variable i; string out = "", ref	for (i=0;i<ItemsInList(listOfWavesToRepalce);i+=1)		ref = StringFromList(i,listOfWavesToRepalce) 		Duplicate/O $replacementref, $ref		out += ref + ";"	endforendfunction disp_ic0(diffRef)	String diffRef		String diffNote = note($diffRef)	String somaRef = Stringbykey("DIFFWAVE_firstSite_wRef",diffNote)	String pedRef = Stringbykey("DIFFWAVE_secondSite_wRef",diffNote)	String somaParamsRef = Stringbykey("DIFFWAVE_firstSite_paramRef",diffNote)	String pedParamsRef = Stringbykey("DIFFWAVE_secondSite_paramRef",diffNote)	String pow_diff = Stringbykey("DIFFWAVE_power_noWin_diff_ref",diffNote)		String cc_td = Stringbykey("DIFFWAVE_crossCorrelationRef",diffNote)	String ccr_td = Stringbykey("DIFFWAVE_crossCorrelationRepsRef",diffNote)	String cc_fd = Stringbykey("DIFFWAVE_crossPowerSpectrumRef",diffNote)	String ccr_fd = Stringbykey("DIFFWAVE_crossPowerSpectrumRepsRef",diffNote)		String somaNote = note($somaParamsRef)	String pedNote = note($pedParamsRef)	String soma_pow = stringbykey("power_noWinRef", somaNote)	String ped_pow = stringbykey("power_noWinRef", pedNote)		String cc_winN = somaParamsRef + "cc";killwindowsbyname(cc_winN + "*")	String pow_winN = somaParamsRef + "cc";killwindowsbyname(pow_winN + "*")	String overlay_winN = somaParamsRef + "ic0";killwindowsbyname(overlay_winN + "*")		//display cross correlation, reflected about 0 	cc_winN = disp_waveReflect(cc_td+";", cc_winN, 1, 0, nonReflectedRGB = {0,0,0,num_cMax()*.5},reflectedRGB = {num_cMax(),0,0,num_cMax()*.5})	modifygraph/W=$cc_winN lsize=2	disp_columnswithReflection($ccr_td, cc_winN, 0, 0, nonReflectedRGB = {0,0,0,num_cMax()*.15}, reflectedRGB = {num_cMax(),0,0,num_cMax()*.15}, sendToBack=1)		//label and make reflections clear	ModifyGraph mirror(bottom)=3;DelayUpdate	Label left "Correlation\\u#2";DelayUpdate	Label bottom "Time forward from zero"		//leaving out units puts the units with the last tick (main and mirror axis)	ShowTools/A arrow	SetDrawEnv textrgb= (65535,0,0);DelayUpdate	DrawText 0.335697399527187,-0.21264367816092,"Time reverse from zero"	HideTools/A		//display power spectra and difference	display/k=1/N=$pow_winN $soma_pow, $ped_pow; pow_winN = S_name	modifygraph/W=$pow_winN rgb($soma_pow) = (0,0,0), log(left)=1	appendtograph/W=$pow_winN/R/C=(0,0,num_cMax()) $pow_diff	setaxis bottom, 1,100; setaxis/A=2 left; setaxis/A=2 right	Label left "Power";DelayUpdate;Label bottom "Frequency";DelayUpdate;Label right "Fold change at terminal"		//display overlays	display/k=1/N=$overlay_winN $somaRef, $pedRef; overlay_winN = S_name	modifygraph/W=$overlay_winN rgb($somaRef) = (0,0,0)	Label left "I\\Bclamp\\M=0 (\\U)";Label bottom "Time (\\U)"endfunction num_cMax()	return -1 + 2^16		//color max is largest 16-bit base 2 numberendfunction dl_labelsFromWvToWv(fromWv,fromDim,fromStartIndex,numIndexes,toWv,toDim,toStartIndex)	WAVE fromWv, toWv	Variable fromDim,fromStartIndex,numIndexes	Variable toDim,toStartIndex		String bleh		Variable i,fromIndex,toIndex,fromLimit=dimsize(fromWv,fromDim),toLimit=dimsize(toWv,toDim)	for (i=0;i<numIndexes;i+=1)		fromIndex = i+fromStartIndex		toIndex= i+toStartIndex		if (fromIndex>=fromLimit)			Print "dl_labelsFromWvToWv(): reached end of fromWv (",nameofwave(fromWv),") before completion, aborting"			break		endif		if (toIndex>=toLimit)			Print "dl_labelsFromWvToWv(): reached end of toLimit (",nameofwave(toWv),") before completion, aborting"			break		endif			bleh=GetDimLabel(fromWv, fromDim, fromIndex)		SetDimLabel toDim,toIndex,$bleh,toWv	endfor		endfunction dl_findDimLbl(wv,dim,matchStr)	WAVE wv; variable dim;string matchSTr		variable i	for (i=0;i<dimsize(wv,dim);i+=1)		if (stringmatch(GetDimLabel(wv, dim, i),matchStr))			return i		endif	endfor	return -1end//for a list of waves, find labels that are the same across themfunction/s dl_getNonUniqueLbls(wvList,dim)	String wvList; Variable dim	String lbls="",lblWaves="",wavesWithRepeatedLbl="",ref,lbl,thisLblsWaves,dupLbls=""	variable i,iw,numw=itemsinlist(wvlist),dimlen,listpos	for (iw=0;iw<numw;iw+=1)		ref=stringfromlist(iw,wvlist)		dimlen=dimsize($ref,dim)		for (i=0;i<dimlen;i+=1)			lbl=GetDimLabel($ref, dim, i)			listpos = WhichListItem(lbl,lbls)			if (listpos < 0)		//not present, add to main list				lbls+=lbl+";"				thisLblsWaves=ref+","			else				if (WhichListItem(lbl,dupLbls) < 0)	//not counted as a duplicate yet						dupLbls+=lbl+";"				endif				thisLblsWaves=stringbykey(lbl,lblwaves) + ref+","					endif			lblWaves=ReplaceStringByKey(lbl, lblWaves,thisLblsWaves)					endfor	endfor		print "numduplicates",itemsinlist(dupLbls),"duplicate labels:",dupLbls	return dupLblsendfunction dl_replaceRepeatedLbls(wvList,dim,newLabelStartStr,newVal)	string wvList,newLabelStartStr	Variable dim	Double newVal		String lbls,lbl,ref	variable i,iw,numw=itemsinlist(wvlist),dimlen,listpos,count	for (iw=0;iw<numw;iw+=1)		ref=stringfromlist(iw,wvlist)		WAVE wv = $ref		dimlen=dimsize($ref,dim)		lbls=""		count=0		for (i=0;i<dimlen;i+=1)			lbl=GetDimLabel($ref, dim, i)			listpos = WhichListItem(lbl,lbls)			if (listpos < 0)		//not present, add to main list				lbls+=lbl+";"			else				SetDimLabel dim,i,$(newLabelStartStr+num2str(count)),$ref				switch (dim)					case 0:						wv[i][][][]=newVal						break					case 1:						wv[][i][][]=newVal						break					case 2:						wv[][][i][]=newVal						break					case 3:						wv[][][][i]=newVal						break				endswitch				count+=1				endif		endfor	endfor	Print "dl_replaceRepeatedLbls() count",countendfunction dl_setdimLbls(wv,dim,newLbl)	WAVE wv	Variable dim		//dim to label	String newLbl	//new label to assign to ALL indices in this dim		variable i,num=dimsize(wv,dim)	for (i=0;i<num;i+=1)		setdimlabel dim,i,$newLbl,wv	endforendfunction/S dl_assign_list(wvList,row,val,labelStr,createIfMissing,[noChangeToVal])	String wvList	Variable row		//nan to go by label	Double val	String labelStr	//blank to go by row .. pass both to assign and label	Variable createIfMissing,noChangeToVal		//if dl not found, create	variable setVal = ParamIsDefault(noChangeToVal) || !noChangeToVal	Variable assignAndLbl = !numtype(row) && (strlen(labelStr) > 0) && !createIfMissing && setVal	Variable nrows,lblRow	String setList=""		Variable i,num=itemsinlist(wvList)	if (assignAndLbl)		for (i=0;i<num;i+=1)			dl_assignAndLbl($stringfromlist(i,wvList),row,val,labelStr)		endfor	else		if (strlen(labelStr) < 1)			// assign by row			for (i=0;i<num;i+=1)				WAVE wv=$stringfromlist(i,wvList)				nrows=dimsize(wv,0)				if (row >= nrows)					if (createIfMissing)						redimension/n=(nrows+1) wv						if (setVal)							wv[nrows][]=val						endif						setList+="2;"					else						setList+="0;"					endif				else					if (setVal)						wv[nrows][]=val					endif					setList+="1;"				endif							endfor		else		//assign by label			Variable col			for (i=0;i<num;i+=1)				WAVE wv=$stringfromlist(i,wvList)				lblRow=finddimlabel(wv,0,labelStr)				if (lblRow<0)					if (createIfMissing)						nrows=dimsize(wv,0)						redimension/n=(nrows+1,-1,-1,-1) wv						setdimlabel 0,nrows,$labelStr,wv						setList+="2;"						if (setVal)							wv[%$labelStr]=val						endif					else						setList+="0;"					endif				else					if (setVal)						wv[%$labelStr]=val					endif					setList+="1;"				endif			endfor		endif		endif			return setListendfunction dl_createIfMissing(wvList,lblList,dimList)	String wvList,lblList,dimList 		/// dim list pairs with label list, if shorter than lbl list, last index is used for any others		Variable i,j,numWvs=itemsinlist(wvList),numLbls=itemsinlist(lblList),dim,ind	make/o/free/n=(4) ugh = -1		//an attempt attempt to leave other dimensions unchanged in size, values, and existance	String ref,lbl	for (i=0;i<numWvs;i+=1)		ref = stringfromlist(i,wvList)		for (j=0;j<numLbls;j+=1)			lbl=stringfromlisT(j,lblList)			dim=str2num(text_stringFromList_trunc(j,dimList))			ind=finddimlabel($ref,dim,lbl)			if (ind < 0)				ind = dimsize($ref,dim)				ugh[dim]=ind+1				redimension/n=(ugh[0],ugh[1],ugh[2],ugh[3]) $ref				ugh[dim]=-1				SetDimLabel dim,ind,$lbl,$ref 			endif		endfor	endforend//for 1 dimensional numeric waves: set a row value and its labelfunction dl_assignAndLbl(wv,row,val,labelStr)	WAVE/D wv	Variable row			//row to be set	Double val			//value at row	String labelStr		//dimension label for row		wv[row] = val	SetDimLabel 0,row,$labelStr,wv		return valend//for 1 dimensional text waves: set a row value and its labelfunction dl_assignAndLbl_T(wv,row,val,labelStr)	WAVE/T wv	Variable row			//row to be set	String val			//value at row	String labelStr		//dimension label for row		wv[row] = val;SetDimLabel 0,row,$labelStr,wvend//easier for loops than built in functionfunction/T dl_lbl2D_T(wv,dim,row,labelStr)	WAVE/T wv	Variable dim		//0 for rows, 1 for cols, etc.	Variable row			//row to be set	String labelStr		//dimension label for row		SetDimLabel dim,row,$labelStr,wv		return labelStrendfunction dl_assignLblsFromList(wv,dim,startIndex,list,appendStr,appendBeforeLblNotAfter[reuseLast])	WAVE wv	Variable dim		//dim to label	Variable startIndex	//index to start at in dim to label (end index is based on length of list)	String list			//list of labels to assign	String appendStr	Variable appendBeforeLblNotAfter	Variable reuseLast		//optionally pass to coninue using the last in the list until the end of the dimension		variable i,num=itemsinlisT(list),maxIndex = dimsize(wv,dim),index,count=0	String lb=stringfromlist(0,list)	for (i=0;(i+startIndex)<maxIndex;i+=1)		//loop through from startIndex til end of dimension ..		index = i+startIndex		if (i >= num)			if (ParamIsDefault(reuseLast) || !reuseLast)				break			endif			SetDimLabel dim,index,$lb,wv;count+=1		endif								if (appendBeforeLblNotAfter)			lb=appendStr + stringfromlist(i,list)		else			lb=stringfromlist(i,list) + appendStr		endif		SetDimLabel dim,index,$lb,wv;count+=1	endfor	return countendfunction dl_appendToLbls(wv,dim,appendStr,appendBeforeLblNotAfter,startIndex,endIndex)	WAVE wv; String appendStr	Variable appendBeforeLblNotAfter	Variable dim	Variable startIndex	//first position	Variable endIndex	//lastPosition (inclusive--the label at this position will change if in range of the wave)		if ( (startIndex < 0 ) || numtype(StartIndex))		startIndex = 0	endif		Variable dimLen = DimSize(wv,dim)		if ( (endIndex > dimLen - 1) || numtype(endIndex) )		endIndex = dimLen-1	endif		variable i; string lbl	if (appendBeforeLblNotAfter)			for (i=startIndex;i<=endIndex;i+=1)			lbl = appendStr + GetDimLabel(wv, dim, i)			SetDimLabel dim,i,$lbl,wv			endfor	else		for (i=startIndex;i<=endIndex;i+=1)			lbl = GetDimLabel(wv, dim, i) + appendStr			SetDimLabel dim,i,$lbl,wv			endfor		endif		return endIndex - startIndex + 1endfunction dl_cat(dim,wvRefsList,appendToLblList,appendBeforeLblNotAfter,outRef) 	Variable dim	//dim to concatenate along	STring wvRefsList 		//waves to concatenate, in order	String appendToLblList	Variable appendBeforeLblNotAfter	String outRef		String tempWvNameBase = "dl_cat_temp_"		Variable i; string tempRef, lbl, ref, killList = "", catRef, catList = ""	for (i=0;i<itemsinlist(wvRefsList);i+=1)		tempRef = tempWvNameBase + num2str(i)		lbl = Stringfromlist(i,appendToLblList)		ref = Stringfromlist(i,wvRefsList)		Print "tempRef",tempRef,"lbl",lbl		if (strlen(lbl))			Duplicate/o $ref, $tempRef			dl_appendToLbls($tempRef,0,lbl,appendBeforeLblNotAfter,-inf,inf)			catRef = tempREf		else			catRef = ref		endif				catList += catRef + ";"	endfor			concatenate/dl/np=(dim)/o catList, $outref		killwavesbyname(tempWvNameBase + "*")end//auto label dimensions by waveName and dim indexfunction dl_lblByIndAndWvName(wv,dim,preAppendStr)	WAVE wv; Variable dim		//dim to label, e.g. 0 = rows, 1 = cols	String preAppendStr		//string to put between wave name and dim index		String labelStr = NameOfWave(wv) + preAppendStr		dl_lblByInd(nameofwave(wv),dim,labelStr,1)	endfunction dl_lblByInd(ref,dim,appendStr,appendBeforeDimIndexNotAfter,[startPos,num,countFromStartPos])	String ref; Variable dim		//dim to label, e.g. 0 = rows, 1 = cols	String appendStr				//string (if any) to append along with num2str(dim index)	Variable appendBeforeDimIndexNotAfter	//specify whether to append string after (0) or before (1) dim index	Variable startPos,num	Variable countFromStartPos		//default is to label by absolute index in wave, pass this as 1 to get count from startPos .. ignored without startPos		if (ParamIsDefault(startPos))		startPos = 0	endif		Variable numel = dimsize($ref,dim),endPos	if (ParamIsDefault(num) || ( startPos + num >= numel) )		endPos = numel - 1	else		endPos = startPos + num - 1	endif		WAVE/Z wv = $ref	if (!waveexists(wv))		return 0	endif	Variable i	Variable labelCountOffset = ( !ParamIsDefault(startPos) && !ParamIsDefault(countFromStartPos) && (numtype(countFromStartPos)==0) ) ? startPos : 0	if (appendBeforeDimIndexNotAfter)		for (i=startPos;i<=endPos;i+=1)			SetDimLabel dim,i,$(appendStr+num2str(i-labelCountOffset)),wv		endfor		else		for (i=startPos;i<=endPos;i+=1)			SetDimLabel dim,i,$(num2str(i-labelCountOffset)+appendStr),wv		endfor		endifend//return a list of values for dims with label matching lblMatchStr//only good for rows or columns, not good for 2- or more dimensionalfunction/S dl_matchingLabelValues(ref,dim,secondDim_index,lblMatchStr,listKeyedListOrIndices)	String lblMatchStr	String ref; variable dim		//wave and dimension of labeling. uses ref instead of wave so that text or numeric can be instanteated as appropriate	variable secondDim_index		//e.g. if dim == 0, get label from each row and return value from rows with matching label at column = secondDim_index	Variable listKeyedListOrIndices		//0 for a list of the values, 1 for a key-word paired list of each label with its value, 2 for list of matching indices		if (numtype(secondDim_index) == 2)		//NaN		secondDim_index = 0	endif		Variable isNumeric = wavetype($ref,1) == 1	Variable isText = wavetype($ref,1) == 2		String keySepStr = ":", listSepStr = ";"		String out = "", lbl	Variable i	if (isNumeric)		WAVE wv = $ref				if (dim)		//dim > 0 = columns					for (i=0;i<DimSize(wv,1);i+=1)				lbl = getdimlabel(wv,1,i)					if (stringmatch(lbl,lblMatchStr))					switch (listKeyedListOrIndices)						case 1:							out += lbl + keySepStr + num2str(wv[secondDim_index][i]) + listSepStr							break						case 0:							out +=  num2str(wv[secondDim_index][i]) + listSepStr							break						case 2:							out += num2str(i) + listSepStr							break					endswitch				endif				endfor					else			//dim == 0 = rows					for (i=0;i<DimSize(wv,0);i+=1)				lbl = getdimlabel(wv,0,i)					if (stringmatch(lbl,lblMatchStr))					switch (listKeyedListOrIndices)						case 1:							out += lbl + keySepStr +  num2str(wv[i][secondDim_index]) + listSepStr							break						case 0:							out +=  num2str(wv[i][secondDim_index]) + listSepStr							break						case 2:							out += num2str(i) + listSepStr							break					endswitch				endif				endfor					endif			return out	endif		if (isText)		WAVE/t wv_t = $ref		if (dim)		//dim > 0 = columns					for (i=0;i<DimSize(wv_t,1);i+=1)				lbl = getdimlabel(wv_t,1,i)					if (stringmatch(lbl,lblMatchStr))					switch (listKeyedListOrIndices)						case 1:							out += lbl + keySepStr + wv_t[secondDim_index][i] + listSepStr							break						case 0:							out += wv_t[secondDim_index][i] + listSepStr							break						case 2:							out += num2str(i) + listSepStr							break					endswitch				endif				endfor					else			//dim == 0 = rows					for (i=0;i<DimSize(wv_t,0);i+=1)				lbl = getdimlabel(wv_t,0,i)					if (stringmatch(lbl,lblMatchStr))					switch (listKeyedListOrIndices)						case 1:							out += lbl + keySepStr + wv_t[i][secondDim_index] + listSepStr							break						case 0:							out += wv_t[i][secondDim_index] + listSepStr							break						case 2:							out += num2str(i) + listSepStr							break					endswitch				endif				endfor					endif			return out				endif	end	//wType = 0, neither soma or ped, wType = 1 ==> soma, wType = 2 ==> pedfunction/S windowStatsG(waveRef, startX, endX, saveVars, wType, [pathStr])	Variable saveVars, startX, endX, wType	String waveRef	String &pathStr 	//optinally pass to store used path		String outList = ""		//store waves generated		//time domain wave stats	WaveStats/R=(startX, endX)/Z/Q $waveRef	Variable wAvg = 	V_avg	Variable wSD = V_sdev	Variable wRMS = V_rms	Variable wSEM = V_sem		String recStartTime = fd_note_getWaveTimeStr(waveRef,1)		//power spectral wave stats	Variable proportionWinOverlay = .25	Variable timeBin_s = 1	Variable timeBin_p = timeBin_s/DimDelta($waveRef,0)	String winf = "cos1"	String outRef_cosWin = waveRef + "_powcos"	fft_power(waveRef,outRef_cosWin,"",startX,endX,timeBin_p,nan,proportionWinOverlay, winf)	Variable avgCol=finddimlabel($outRef_cosWin,1,"avg")	duplicate/o/r=[][avgCol]/free $outRef_cosWin,powerTemp;redimension/n=(-1) powerTemp	duplicate/o powerTemp,$outRef_cosWin/wave=power_win		String outRef_noWin = waveRef + "_pow"	fft_power(waveRef, outRef_noWin,"",startX,endX, timeBin_p,nan,proportionWinOverlay, "")	duplicate/o/r=[][avgCol]/free $outRef_noWin,powerTemp;redimension/n=(-1) powerTemp	duplicate/o powerTemp,$outRef_noWin/wave=power_noWin		Variable powerSpecScaling = DimDelta(power_noWin,0)		Variable numParams = 24		String generalAppendStr = "_O1"	String somaAppendStr = "S"	String pedAppendStr = "P"	String printPrefix = ""	String saveName = waveRef + generalAppendStr	if (wType == 1)		saveName += somaAppendStr		printPrefix = "SW: "	elseif (wType == 2)		saveName += pedAppendStr		printPrefix = "PW: "	endif	outList += saveName + ";" + outRef_noWin + ";" + outRef_cosWin + ";"		Make/O/D/N=(numParams) $saveName/WAVE=paramsWvTemp 		paramsWvTemp[0] = wAvg	paramsWvTemp[1] = wSD	paramsWvTemp[2] = wRMS	paramsWvTemp[3] = wSEM	paramsWvTemp[4] = startX	paramsWvTemp[5] = endX	paramsWvTemp[6] = DimDelta($waveRef,0)	paramsWvTemp[7] = power_noWin[0]		//dc	paramsWvTemp[8] = sum(power_noWin)	//total power (should roughly equal variance)	paramsWvTemp[9] = sum(power_noWin,powerSpecScaling,x2pnt(power_noWin,10))		//power below 10 Hz, excluding DC	paramsWvTemp[10] = sum(power_noWin,x2pnt(power_noWin,10),x2pnt(power_noWin,20)-powerSpecScaling)		//10 to 20 Hz power (excluding 20, max of range)	paramsWvTemp[11] = sum(power_noWin,x2pnt(power_noWin,20),x2pnt(power_noWin,30)-powerSpecScaling)		//20 to 30 Hz (excluding max of range)	paramsWvTemp[12] = sum(power_noWin,x2pnt(power_noWin,30),x2pnt(power_noWin,40)-powerSpecScaling)		//30 to 40 Hz (excluding max of range)	paramsWvTemp[13] = sum(power_noWin,x2pnt(power_noWin,40),x2pnt(power_noWin,60)-powerSpecScaling)		//40 to 60 Hz (excluding max of range)	paramsWvTemp[14] = sum(power_noWin,x2pnt(power_noWin,60),x2pnt(power_noWin,100)-powerSpecScaling)		//60 to 100 Hz (excluding max of range)	paramsWvTemp[15] = sum(power_noWin,x2pnt(power_noWin,100),x2pnt(power_noWin,200)-powerSpecScaling)		//100 to 200 Hz (excluding max of range)	paramsWvTemp[16] = sum(power_noWin,x2pnt(power_noWin,200),inf)		//> 200	paramsWvTemp[17] = sum(power_win,x2pnt(power_win,10),x2pnt(power_win,20)-powerSpecScaling)		//10 to 20 Hz power (excluding 20, max of range)	paramsWvTemp[18] = sum(power_win,x2pnt(power_win,20),x2pnt(power_win,30)-powerSpecScaling)		//20 to 30 Hz (excluding max of range)	paramsWvTemp[19] = sum(power_win,x2pnt(power_win,30),x2pnt(power_win,40)-powerSpecScaling)		//30 to 40 Hz (excluding max of range)	paramsWvTemp[20] = sum(power_win,x2pnt(power_win,40),x2pnt(power_win,60)-powerSpecScaling)		//40 to 60 Hz (excluding max of range)	paramsWvTemp[21] = sum(power_win,x2pnt(power_win,60),x2pnt(power_win,100)-powerSpecScaling)		//60 to 100 Hz (excluding max of range)	paramsWvTemp[22] = sum(power_win,x2pnt(power_win,100),x2pnt(power_win,200)-powerSpecScaling)		//100 to 200 Hz (excluding max of range)	paramsWvTemp[23] = sum(power_win,x2pnt(power_win,200),inf)		//> 200		String noteStr = "wREF:" + waveRef + ";wNOTE:" + note($waveRef) + ";PARAMS:wAvg,wSD,wRMS,wSEM,startX,endX,DimDelta($waveRef,0),power...;"	noteStr+= "power_noWinRef:"+outRef_noWin+";power_winRef:"+outRef_cosWin+";win_func:"+winf+";"	Note paramsWvTemp, noteStr; Note power_noWin, noteStr; Note power_win, noteStr; 	Print "noteStr ==", noteStr	KillWindowsByName(saveName + "*")	Edit/K=1/N=$saveName $saveName		if (saveVars)		//check file save path and move on, first declaring the global string that stores the save path, only if this path has been set using fio_setDataSavePath()		if (fio_checkGlobalFilePath())			//check path returns non-zero if there are any problems with symbolic path			Print "ABORTED SAVE TO FILE analysis_SSVI because file save path not set! Use fio_setDataSavePath()"			if (!ParamIsDefault(pathStr))				pathStr = ""			endif		else			SVAR/Z dataSavePathName				//this should be a global string with the name of the path that is set by fio_setDataSavePath()			Save/C/O/P=$dataSavePathName $saveName, power_win, power_noWin			if (!ParamIsDefault(pathStr))				pathStr = dataSavePathName			endif		endif	endif		Print "analysis wave list: " + outList	return outListend//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////SUMMARY ANALYSIS////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// function/S listMatchingFiles(recogStr)	String recogStr    	    	String outputPaths = openForFileType("Igor Binary Waves", "ibw")		return listmatch(outputPaths, recogStr,"\r")endfunction/S openForFileType(fileTypeLong, fileTypeExtension)	String fileTypeLong		//description of file type, e.g. Igor binary waves	String fileTypeExtension			//file extension, e.g. ibw, abf. Leave out periods		Variable refNum    	String fileFilters    	sprintf fileFilters, "%s (*.%s):.%s;All Files:.*;", fileTypeLong, fileTypeExtension,fileTypeExtension			//leave out after second %s if all files option not wanted    	Print "fileFilters",fileFilters			        	Open/D/R/MULT=1/F=fileFilters refNum			//creates dialogue box for user to select files. Does not open files    	return S_fileName			//carriage-return delimited list of file pathsendfunction sortFilesByCellNameKey(filePathsListStr, fileDelimiterStr, cellListRef, outputRef)	String filePathsListStr, fileDelimiterStr, cellListRef, outputRef	String outputDelimiterStr		Duplicate/O/T $cellListRef, cellListTemp, outputTemp		//load in the first row of the input, also make output of same dimensionality	NewPath/O/M="Use same folder" loadIndexedFilePath	String currFPath = "loadIndexedFilePath"		Variable i,j	Variable currIndex		//stores the index into filePathsListStr in which the current cell name is found	String currFilePath, currCellName,	currPath, currFileName	for (i=0;i<DimSize(cellListTemp,0);i+=1)		currCellName = cellListTemp[i]		if (strlen(currCellName) > 0)			currIndex = 0			outputTemp[i] = listMatch(filePathsListStr, "*" + currCellName + "*","\r")			outputTemp[i] = num2str(ItemsInList(outputTemp[i],"\r")) + outputTemp[i]			for (j=1;j<ItemsInList(outputTemp[i],"\r");j+=1)		//start at 1 because 0 is now the number of items in list				currPath = StringFromList(j,outputTemp[i],"\r")				currFileName = getFileNameFromPath(currPath) 				loadwave/Q/P=$currFPath/h currFileName				if (V_flag == 0)					Print "Vflag 0 break1"					break				endif			endfor			if (V_flag == 0)				Print "Vflag 0 break2"				break			endif		endif	endfor		Duplicate/O outputTemp, $outputRef	KillWaves/Z cellListTemp, outputTempend//function testfunc()////	String listOfLoadedWvs//	print fio_loadfiles("wn_refs_main0","",pathName="wn_path", out_waveListStr=listOfLoadedWvs)//end //lllllllllllllllllllllllllllllllllllllllllllllll //fio_loadfiles("*",".ibw",fullPathStr=loadPath,out_waveListStr=out_waveListStr,loadWvListStr=refList)Function/S fio_loadfiles(matchStr,extensionStr,[pathName,loadWvListStr,doNotloadWvListStr,out_fileListStr,out_waveListStr,out_fullPathsListStr,out_extensionsListStr,fullPathStr,unloadEachNewWave,out_usedExtensionStr,skipPreExisting])	String extensionStr					//file type identifier: e.g. ".ibw" for igor binary, or ".txt", or ".abf. At present, if empty string, set to ".ibw"	String matchStr 					// File name matching, e.g. *150917*. extension string is used in matching; if not included, its added		String pathName		// Name of an Igor symbolic path or "" or default to get a dialog	String loadWvListStr	//optionally pass to load specific waves	String doNotloadWvListStr		//optionally pass to skip loading specific waves	String &out_fileListStr		//optionally pass to have list of FILES actually loaded (including those skipped with skip load) returned in this variable	String &out_waveListStr		//optionally pass to have list of WAVES actually loaded (including those skipped with skip load) returned in this variable	String &out_fullPathsListStr, &out_extensionsListStr		//same for paths and extensions..wave by wave list	String &out_usedExtensionStr	//optionally pass to have extension of files loaded set in this variable	String fullPathStr	//pass a complete path (e.g. for bringing back waves into a different file where the same path under the same name may not exist	Variable unloadEachNewWave	//pass true to do everything but actually load wave -- helpful for mapping	Variable skipPreExisting	//optionally pass to skip waves that already exist in this instance of igor			if (strlen(matchStr) == 0)		matchStr = "*"	endif			if (strlen(extensionStr) == 0)		extensionStr = ".ibw"			//igor binary wave is default. This would have to be modified to load a wave without an extension	endif			if (!ParamIsDefault(loadWvListStr) && strlen(loadWvListStr) )		loadWvListStr = text_appendStrIfAbsent(loadWvListStr,";",0)		loadWvListStr = replacestring(";",loadWvListStr,".ibw;")		//will look for matches to file names not wave names	endif	if (!ParamIsDefault(doNotloadWvListStr) && strlen(doNotloadWvListStr) )		doNotloadWvListStr = text_appendStrIfAbsent(doNotloadWvListStr,";",0)		doNotloadWvListStr = replacestring(";",doNotloadWvListStr,".ibw;")		//will look for matches to file names not wave names	endif				if (!ParamIsDefault(fullPathStr))		//fullPathStr passed == used if so		pathName = "LoadIndexedFilePath"		NewPath/Q/O $pathName, fullPathStr	elseif (ParamIsDefault(pathName) || (strlen(pathName) == 0))		NewPath/Q/O/M="Choose a folder containing data files" LoadIndexedFilePath		if (V_flag != 0)			return "" //User cancelled						endif		pathName = "LoadIndexedFilePath"	else		//pathName passed		PathInfo $pathName		if (!V_flag)		//no path exists, so prompt user; otherwise use this pathName			Print "fio_loadFiles(): pathName,", pathName, "passed but could not be found. Prompting user to choose path"			NewPath/Q/O/M="Choose a folder containing data files" $pathName			if (V_flag != 0)				return "" //User cancelled							endif 		endif	endif	string filesLoadedList = "",filesLoadedExtensionList = "", wavesLoadedList = "", filePathsList = "" 		//tracks files actually loaded	variable numFilesLoaded = 0 	String fileNames = IndexedFile($pathName, -1, extensionStr)	//-1 leads to returning all of them, semi-colon delimited list 	String completeMatchStr 	if (stringmatch(matchStr, "*" + extensionStr))	//matchstring already has extension string 		completeMatchStr = matchStr 	else 		completeMatchStr = matchStr + extensionStr 	endif 	String matchingFileNames = ListMatch(fileNames, completeMatchStr, ";")		//makes list of just matches 	//iterate through matchingFileNames, and load those waves 	Variable i, currIndex,j; String currFileName		//j used to add extra waves to list	for (i=0;i<ItemsInList(matchingFileNames,";");i+=1)		currFileName = StringFromList(i,matchingFileNames,";")		if (!ParamIsDefault(loadWvListStr))			if (WhichListItem(currFileName, loadWvListStr) == -1)		//if not in list, skip load				continue			endif		endif		if (!ParamIsDefault(doNotloadWvListStr))			if (WhichListItem(currFileName, doNotloadWvListStr) > -1)				continue			endif		endif		killvariables/Z V_flag		//so that no matter what this is reset by loadwave		if (!ParamIsDefault(skipPreExisting) && skipPreExisting)			if (waveExists($ReplaceString(extensionStr,currFileName,"")))				continue			endif		endif		LoadWave/H/Q/W/O/P=$pathName currFileName			numFilesLoaded += V_flag		wavesLoadedList += s_waveNames		//waves loaded; this is semi-colon delimited'		for (j=0;j<V_flag;j+=1)		//make sure that there's a file full path and a file name with extension for each wave			filePathsList += S_path + ";"				//file full path			filesLoadedList += s_fileName + ";"		//file name with extension			filesLoadedExtensionList += StringFromList(1,s_fileName, ".") + ";"		//loaded extension only		endfor		if (!ParamIsDefault(unloadEachNewWave) && unloadEachNewWave)			killWavesByName(s_wavenames)		endif	endfor	if (!ParamIsDefault(out_fileListStr))		//currently no checking to see that waves were saved successfully, believe this would need getRTError or whatever		if (numtype(strlen(out_fileListStr)))			out_fileListStr = filesLoadedList		else			out_fileListStr += filesLoadedList		endif	endif		if (!ParamIsDefault(out_waveListStr))		//currently no checking to see that waves were saved successfully, believe this would need getRTError or whatever		if (numtype(strlen(out_waveListStr)))			out_waveListStr = wavesLoadedList		else			out_waveListStr += wavesLoadedList		endif	endif		if (!ParamIsDefault(out_fullPathsListStr))		//currently no checking to see that waves were saved successfully, believe this would need getRTError or whatever		if (numtype(strlen(out_fullPathsListStr)))				out_fullPathsListStr = filePathsList		else			out_fullPathsListStr += filePathsList		endif	endif		if (!ParamIsDefault(out_extensionsListStr))		//currently no checking to see that waves were saved successfully, believe this would need getRTError or whatever		if (numtype(strlen(out_extensionsListStr)))			out_extensionsListStr = filesLoadedExtensionList		else			out_extensionsListStr += filesLoadedExtensionList		endif	endif		if (!ParamIsDefault(out_usedExtensionStr))		out_usedExtensionStr= extensionStr	endif	return pathNameendfunction/S fio_loadBinaryFromFullPath(fileWithFullPathList,fType,wType,namesByFolderHierarchy)	String fileWithFullPathList	Variable fType,wType	//see gbLoadWave	Variable namesByFolderHierarchy	//naming scheme I implemented for one particular set of data		variable i; string fileWithFullPath; string currList,loadedWaveList = "", saveName, temp	Variable isSinusoid, cellNamePos,numArraysInData	for (i=0;i<itemsinlist(fileWithFullPathList);i+=1)		fileWithFullPath = stringfromlist(i,fileWithFullPathList)		isSinusoid = namesByFolderHierarchy && stringmatch(fileWithFullPath,"*:sinusoids:*")				if (isSinusoid)			gbloadwave/Q/T={fType,wType}/O/B=1 fileWithFullPath		else			gbloadwave/Q/T={fType,wType}/O/B=1/U=(4200/3)/W=3 fileWithFullPath			currList = S_waveNames		endif				Variable numItems = itemsinlist(fileWithFullPath,":")		if (stringmatch(	fileWithFullPath,"*peripheral*"))			saveName = "P"		elseif (stringmatch(fileWithFullPath,"*central*"))			saveName = "C"		elseif (stringmatch(fileWithFullPath,"*foveal*"))			saveName = "F"		else			saveName = "U"		endif				cellNamePos = isSinusoid ? 4 : 3				saveName += ReplaceString(".bin",stringfromlist(numItems-1,fileWithFullPath,":"),"") 	//frequency,contrast,sampleRate,stimOrResp				if (isSinusoid)	//get background which is either 5000 or 50000 so far			saveName+= ReplaceString("000",stringfromlist(numItems-2,fileWithFullPath,":"),"")+"b"		endif				saveName +=  ReplaceString("2016_",stringfromlist(numItems-cellNamePos,fileWithFullPath,":"),"")	//cell name		if (isSinusoid)			Duplicate/O $StringFromLisT(0,S_waveNames),$saveName		else			concatenate/NP=1/O/D currList,$saveName		endif		loadedWaveList += saveName + ";"					note/nocr $saveName, fileWithFullPath						//C:Users:Alan:Documents:MATLAB:sinusoids_data:peripheral_data:2016_12_14_20_1_4:sinusoids:50000:24c10s10K_R.bin;		if (isSinusoid)				Variable srateEndIndex=strsearch(fileWithFullPath,"K_",0)-1			Variable srateStartIndex = strsearch(fileWithFullPath,"s",srateEndIndex,1)+1			Variable srate = str2num(fileWithFullPath[srateStartIndex,srateEndIndex])*1000			Print "saveName",saveName,"fileWithFullPath",fileWithFullPath,ReplaceString("000",stringfromlist(numItems-2,fileWithFullPath,":"),"b_")			SetScale/P x, 0, 1/srate, "s", $saveName		endif	endfor	return loadedWaveListend//make or add to a listbox containing files that one could loadfunction fio_FT_addToFileTable(listWvRef, matchStr, extensionStr, pathName, unloadEachNewWave, newWindow, avoidRepeats)	String listWvRef	//name of list wave containing file information	String matchStr, extensionStr		//specify file info, user prompted to select a folder	String pathName		//pass "" to autogenerate name of symbolic path and allow user to use	Variable unloadEachNewWave		//pass to map wave to location but avoid actually loading (for now at least)	Variable newWindow	Variable avoidRepeats			//when adding to pre-eisting table, pass this to avoid indexing a file/wave twice		String selectionIndicatorString = "\f04\K(55555,0,0)"		//appended ahead of wave name to indicate selection			if (strlen(pathName) < 1)		pathName = listWvRef + "_FTPath"		killpath/Z $pathName	endif		String defaultWinAppendStr = "_FTWin"	String defaultListBoxAppendStr = "_lb"	String defaultSelWvAppendStr = "_lbsw"	String defaultByNumsAppendStr = "_lbswn"		String lb_selWaveName = listWvRef + defaultSelWvAppendStr;	String lb_selWaveByNumsName = listWvRef + defaultByNumsAppendStr		String loadedFiles="", loadedFileExtensions="", loadedFilePaths="", loadedFileWaves=""	Variable i	if (avoidRepeats && WaveExists($listWvRef))		String listOfCurrentWaves = 	""		WAVE/T listWv = $listWvRef		for (i=0;i<DimSize(listWv,0);i+=1)			listOfCurrentWaves += GetDimLabel(listWv, 0, i) + ";"		endfor		fio_loadfiles(matchStr,extensionStr,doNotloadWvListStr=listOfCurrentWaves,pathName=pathName,out_fileListStr=loadedFiles,out_waveListStr=loadedFileWaves,out_fullPathsListStr=loadedFilePaths,out_extensionsListStr=loadedFileExtensions,unloadEachNewWave=unloadEachNewWave)	else		fio_loadfiles(matchStr,extensionStr,pathName=pathName,out_fileListStr=loadedFiles,out_waveListStr=loadedFileWaves,out_fullPathsListStr=loadedFilePaths,out_extensionsListStr=loadedFileExtensions,unloadEachNewWave=unloadEachNewWave)	endif		Variable numNewlyLoadedFiles = ItemsInList(loadedFiles)		if (numNewlyLoadedFiles > 0)		PathInfo $pathName		String newFilesCurrPath = S_path				Variable newFileStartIndex, numCols = 5				String windowName		if (!WaveExists($listWvRef))			Make/O/T/N=(numNewLyLoadedFiles,numCols) $listWvRef/WAVE=listWv			newFileStartIndex = 0			windowName = listWvRef + defaultWinAppendStr		else			WAVE/T listWv = $listWvRef			newFileStartIndex = DimSize(listWv,0)			Redimension/N=(newFileStartIndex +numNewLyLoadedFiles , -1) listWv			windowName = Stringbykey("windowName",note(listWv))		endif				//update list box waves		Make/O/N=(DimSize(listWv,0)) $lb_selWaveName		Make/O/N=1 $lb_selWaveByNumsName				listWv[newFileStartIndex,newFileStartIndex + numNewLyLoadedFiles-1][0] = StringFromList(p-newFileStartIndex,loadedFileWaves)		//0-wave name		listWv[newFileStartIndex,newFileStartIndex + numNewLyLoadedFiles-1][1] = StringFromList(p-newFileStartIndex,loadedFileExtensions)	//1-file extension		listWv[newFileStartIndex,newFileStartIndex + numNewLyLoadedFiles-1][2] = StringFromList(p-newFileStartIndex,loadedFiles)				//2-full name of file		listWv[newFileStartIndex,newFileStartIndex + numNewLyLoadedFiles-1][3] = StringFromList(p-newFileStartIndex,loadedFilePaths)		//3-full path to file		listWv[newFileStartIndex,newFileStartIndex + numNewLyLoadedFiles-1][4] = newFilesCurrPath		//4-path to folder				SetDimLabel 1,0,$"WvName-dblClickTogglesLoad",listWv		SetDimLabel 1,1,$"ext",listWv		SetDimLabel 1,2,$"fileName",listWv		SetDimLabel 1,3,$"filePath",listWv		SetDimLabel 1,4,$"folderName",listWv					//also store wave name in row dimension labels, since we will append selectionIndicatorString ahead of wave name in column 0 to indicate loads		for (i=newFileStartIndex;i<newFileStartIndex+numNewLyLoadedFiles;i+=1)			SetDimLabel 0,i,$StringFromList(i-newFileStartIndex,loadedFileWaves),listWv			endfor	endif		if (newWindow)		String lb_helpStr = "Double click (in column 0 header) to load waves in selected rows. Shift-click to update loaded/unloaded status/ Ctrl-click to load from any new files from same folders."		lb_helpStr += " Note on selecting: right-click in list area to select all [selecting handled by guiC_SL_lbSelectionHandling()]."			String currWvNote = note(listWv)		NewPanel/k=1/N=$windowName/W=(100,100,550,500)  				String lbName = listWvRef + defaultListBoxAppendStr		ListBox $lbName,proc=fio_ft_lbAction,win=$S_name,listWave=listWv,selWave=$lb_selWaveName,userdata(selListByNumsRef)=lb_selWaveByNumsName,size={450,400},userColumnResize=1,mode=4,pos={0,0},widths={200,25,200,25}		ListBox $lbName,win=$S_name, userdata(selectionIndicatorString)=selectionIndicatorString,help={lb_helpStr}		//save selection indicator string		String newWvNote = ReplaceStringByKey("windowName",currWvNote, S_name)		newWvNote = ReplaceStringByKey("lbName",currWvNote, lbName)		note/NOCR/k listWv, newWvNote			endifendfunction fio_ft_lbAction(s) : ListboxControl	STRUCT WMListboxAction &s		Variable clickType = guiC_SL_lbSelectionHandling(s, "", "")		if ( (s.row == -1) && (s.col == 0) )		//event in first column of header		String listWvRef		if (s.eventcode == 3)		//dbl click			Print "fio_ft_lbAction: loading waves from selected files."			String selWaveByNumsRef = guiC_lb_getSelWaveByNumsRef(s)			listWvRef = NameOfwave(s.listWave)			String selectionIndicatorString = GetUserData(s.win, s.ctrlname, "selectionIndicatorString" )						if (strlen(selectionIndicatorString) < 1)				selectionIndicatorString = "\f04\K(55555,0,0)"		//sets new default for selectionIndicatorString				ListBox $s.ctrlname,win=$s.win, userdata(selectionIndicatorString)=selectionIndicatorString		//save selection indicator string			endif								fio_ft_fileLoadAction_nonGuiC(listWvRef, selWaveByNumsRef, selectionIndicatorString)		elseif ((s.eventCode == 1) && (s.eventmod & 2^1))		//cell selection + shift key			Print "fio_ft_lbAction: updating status."			listWvRef = NameOfwave(s.listWave)			fio_ft_fileLoad("updateStatus", listWvRef, -1)		//status update for all files		elseif ((s.eventCode == 1) && (s.eventmod & 2^3))		//cell selection + ctrl key			Print "fio_ft_lbAction: updating wave list in case of new files in indexed folders."			listWvRef = NameOfwave(s.listWave)			fio_ft_update(listWvRef, "", "")		endif	endifendfunction fio_ft_fileLoadAction_nonGuiC(ft_listWvRef, ft_selWaveByNumsRef,selectionIndicatorString)	String ft_listWvRef, ft_selWaveByNumsRef, selectionIndicatorString		Print "fio_ft_fileLoadAction_nonGuiC starting"		String ft_listWvRefNote = note($ft_listWvRef)	if (strlen(selectionIndicatorString))		//selectionIndicatorString passed, use this one		ft_listWvRefNote = ReplaceStringByKey("selectionIndicatorString", ft_listWvRefNote, selectionIndicatorString)		note/nocr/k $ft_listWvRef, ft_listWvRefNote	else		selectionIndicatorString = StringByKey("selectionIndicatorString", ft_listWvRefNote)	endif		WAVE selWaveByNums = $ft_selWaveByNumsRef		Variable i, fileLoadStatus, fNum	for (i=0;i<DimSize(selWaveByNums,0);i+=1)		fNum = selWaveByNums[i]		fileLoadStatus = fio_ft_fileLoad("toggleLoad",ft_listWvRef, fnum)		endfor	endfunction fio_ft_fileLoad(optionStr, ft_listWvRef, fNum)	String optionStr, ft_listWvRef	Variable fNum	//row of file in ft_listWvRef. -1 to affect all		String selectionIndicatorString = StringByKey("selectionIndicatorString", note($ft_listWvRef))		WAVE/T listWv = $ft_listWvRef		if (fNum < 0)		Variable i		for (i=0;i<DimSize($ft_listWvRef,0);i+=1)			fio_ft_fileLoad(optionStr,ft_listWvRef,i)		endfor				return -1	endif		String currWvRef = GetDimLabel(listWv, 0, fNum)	Variable isSetAsLoaded = stringmatch(listWv[fNum][0], selectionIndicatorString + "*")	Variable waveIsLoaded = WaveExists($currWvRef)	Variable status = isSetAsLoaded * 2^0 + waveIsLoaded * 2^1 //0 -- neither, 1 -- setBut not loaded, 2 -- loaded but not set, 3 -- loaded and set		Variable operationPErformed = 1	strswitch (optionStr)			case "forceLoad"	:			//load no matter the current status; updates status according to results			fio_loadfiles(listWv[fNum][2], "." + listWv[fNum][1], fullPathStr=listWv[fNum][3])			if (WaveExists($currWvRef))		//load successful?				listWv[fNum][0] = selectionIndicatorString + currWvRef			else				listWv[fNum][0] = currWvRef				Print "fio_ft_fileLoad(): failed to load wave at index",fNum,"waveName:",currWvRef, "file may no longer exist in folder?"			endif								break					case "forceUnload":			//unload no matter the current status; updates status according to results			killWaves/Z $currWvRef			if (WaveExists($currWvRef))		//unload successful?				listWv[fNum][0] = selectionIndicatorString + currWvRef				Print "fio_ft_fileLoad(): failed to wave at index",fNum,"waveName:",currWvRef			else				listWv[fNum][0] = currWvRef			endif								break					case "toggleLoad":				if (isSetAsLoaded && waveIsLoaded)		//unload				fio_ft_fileLoad("forceUnload", ft_listWvRef, fNum)								elseif (isSetAsLoaded && !waveIsLoaded)		//wave not loaded and want it not to be, show wave as unloaded and do nothing else				listWv[fNum][0] = currWvRef						elseif (!isSetAsLoaded && waveIsLoaded)		//do nothing, wave already loaded -- use optionsStr= "forceLoad" to load regardless							else		// remaining case is (!isSetAsLoaded && !waveIsLoaded) -- load wave and show as loaded if successful				fio_ft_fileLoad("forceLoad", ft_listWvRef, fNum)			endif						break					case "updateStatus":			if (!(isSetAsLoaded == waveIsLoaded))		//disagreement between whether wave is loaded and how that's represented, change to reflect whether wave is present				if (waveIsLoaded)					listWv[fNum][0] = selectionIndicatorString + currWvRef				else					listWv[fNum][0] = currWvRef				endif			endif								default: 					operationPerformed = 0	endswitch			if (operationPerformed)		//update status		isSetAsLoaded = stringmatch(listWv[fNum][0], selectionIndicatorString + "*")		waveIsLoaded = WaveExists($currWvRef)		status = isSetAsLoaded * 2^0 + waveIsLoaded * 2^1 //0 -- neither, 1 -- setBut not loaded, 2 -- loaded but not set, 3 -- loaded and set	endif		return statusend//currently called by ctrl+click in col 0 headerfunction fio_ft_update(listWvRef, matchStr, extensionStr)	String listWvRef, matchStr, extensionStr		//latter two default to "*" and ".ibw" if passed as ""		if (!strlen(listWvRef))		listWvRef = fio_ft_getWvRefList("")	endif	//list all unique paths on listWvRef	WAVE/T listWv = $listWvRef	Variable i; string currPath,indexedPathsList = "", availableUniqueFolders="", unavaibleUniqueFolders=""	String currFolder, currSubFolder	for (i=0;i<DimSize(listWv,0);i+=1)		currPath = listWv[i][3]		if (WhichListItem(currPath, indexedPathsList) < 0) 			indexedPathsList += currPath	+ ";"			NewPath/O/Q/Z fio_ft_update_temp, currPath		//make a symbolic path for curr path			PathInfo $"fio_ft_update_temp"			Print "fio_ft_update(): goal path",currPath,"set path", S_path						currFolder = text_strFromList_rev(1,currPath,":")			currSubFolder = text_strFromList_rev(0,currPath,":") 						if (!V_flag)		//path no longer good				Print "fio_ft_update(). In",listWvRef, ", indexed folder ",GetDimLabel(listWv, 0, i),"[index=",i,"] no longer found. re-index of folder aborted" 				Print "full path was", currPath								unavaibleUniqueFolders += currFolder + ":" + currSubFolder + "|"			else				//path good, re-index the folder				fio_FT_addToFileTable(listWvRef, matchStr, extensionStr, "fio_ft_update_temp", 1, 0, 1)								availableUniqueFolders += currFolder + ":" + currSubFolder + "|"			endif		endif		endfor		String noteStr = note(listWv)	noteStr = ReplaceStringByKey("availableUniqueFolders", noteStr, availableUniqueFolders)	noteStr = ReplaceStringByKey("unavaibleUniqueFolders", noteStr, unavaibleUniqueFolders)	note/k/nocr listWv, noteStr		Print "noteStr",noteStrendfunction fio_ft_docmd(macroStr, winN, ctrlName, colNum)	String macroStr, winN,ctrlName; Variable colNum		//cmd to perform (see list_operation_g), window and name of listbox, column of list box in which waves are listed		if (strlen(winN) < 1)		winN = winname(0,64)	endif		if (strlen(ctrlName) < 1)		ctrlName = fio_ft_getLBName(winN)	endif			String wlist = guiC_lb_getSelWaveList_g(winN, ctrlName, colNum)		list_operation_g(macroStr, wList)	endfunction/S fio_ft_getWvRefList(winN)	String winN		//"" for top win, handled by fio_ft_getLBName	String lbName = fio_ft_getLBName(winN)	ControlInfo/W=$winname(0,64) $lbName	return S_valueendfunction/S fio_ft_getLBName(winN)	String winN		//"" for top win	if (!strlen(winN))		winN = winname(0,64)	endif	return StringFromLisT(0,ControlNameList(winN,";","*_lb"))endfunction/S text_strFromList_rev(itemNum, list,listSepStr)	Variable itemNum	String list, listSepSTr		if (strlen(listSepStr) < 1)		listSepStr = ";"	endif		Variable reversed_index = ItemsInList(list, listSepStr) - itemNum - 1	return StringFromList(reversed_index, list , listSepStr)end//iterates through strList, substituting any %s in macroStr with the current list item//and substituting any %i with the current list index, then executing macroStrfunction list_operation_g(macroStr,strList,[start,num,delim,iterateWaveColInstead,iterateWaveRowInstead,replaceStr,altEscapeStrs,skipBlanks])	String macroStr		//macro to execute e.g, display/k=1 %s to plot waves in list	String strList		//list to iterate over (e.g., names of waves), or "" with num (and optionally start) to just use %i, or the name of a wave to use either iterateWaveColInstead,iterateWaveRowInstead	Variable start,num		//for specifying a subrange of strList	variable iterateWaveColInstead	//optionally pass to iterate down a wave column, column number is passed and wave name is in strList.. pass -1 to use row labels	Variable iterateWaveRowInstead	//optionally pass to iterate across a wave row..row number is passed here, pass -1 to use row labels	String delim		//expects semi-colon delimited strList, pass to use another delimiter	String replaceStr		//optionally pass a replace string in the form of "replaceThisStr;withThisStr"								//if passed, any %r will be replaced with replacestring(replaceThisString,listItem,withThisString)	String altEscapeStrs	//default is %s is replaced by the current item from strList, %i is replaced by the item's index, and %r is replaced by the item after running replaceStr on the item (if that is passed)								//sometimes it is useful to override the defaults (e.g., dimension labels starting with s), to do so pass "escapeStrName0,altEscapeStr0;escapeStrName1,altEscapeStr1;..." etc.	Variable skipBlanks		//pass to skip blank strings in strList, these blanks will also be ignored for %i, which will continue to track the list index, unless skipBlanks==2		make/o/free/t escapeStrs = {"%s","%i","%r"}	String escapeStrNames="listItem;listIndex;replacedStrListItem;"		//matched order to escapeStrs	dl_assignLblsFromList(escapeStrs,0,0,escapeStrNames,"",0)		Variable i,numAltEscapes	String escapeStrName,newEscapeStr,escapeInfo	if (!ParamIsDefault(altEscapeStrs))		numAltEscapes=itemsinlist(altEscapeStrs)		for (i=0;i<numAltEscapes;i+=1)			escapeInfo = stringfromlist(i,altEscapeStrs)			escapeStrName = stringfromlist(0,escapeStrName,",")			newEscapeStr = stringfromlist(1,escapeStrName,",")			escapeStrs[%$escapeStrName]=newEscapeStr		endfor	endif		Variable doSkipBlanks = !ParamIsDefault(skipBlanks) && (skipBlanks>0)	Variable skippedBlanksCountTowardsInds = doSkipBlanks && (skipBlanks==2)		String delimUsed	if (ParamIsDefault(delim))		delimUsed=";"	else		delimUsed=delim	endif		Variable ind; String executeStr, listStr,ref	//set up iterate wave col instead	if (!ParamIsDefault(iterateWaveColInstead) && !numtype(iterateWaveColInstead) && (iterateWaveColInstead>-2))		ref=strList		WAVE/T wv=$strList		strList=""		Variable rows=dimsize(wv,0)		if (iterateWaveColInstead < 0)	//==-1 so row labels			for (i=0;i<rows;i+=1)				strList+=getdimlabel(wv,0,i)+delimUsed			endfor				else			for (i=0;i<rows;i+=1)				strList+=wv[i][iterateWaveColInstead]+delimUsed			endfor		endif	//setup for iterate wave row instead	elseif (!ParamIsDefault(iterateWaveRowInstead) && !numtype(iterateWaveRowInstead) && (iterateWaveRowInstead>-2))		ref=strList		WAVE/T wv=$strList		strList=""		Variable cols=dimsize(wv,1)		if (iterateWaveRowInstead < 0)	//==-1 so row labels			for (i=0;i<cols;i+=1)				strList+=getdimlabel(wv,1,i)+delimUsed			endfor				else			for (i=0;i<cols;i+=1)				strList+=wv[iterateWaveRowInstead][i]+delimUsed			endfor		endif	endif		String replaceThisStr,withThisStr,currReplacedStr	Variable hasReplaceStr = !ParamIsDefault(replaceStr) && (itemsinlist(replaceStr) > 1)	if (hasReplaceStr)		replaceThisStr = stringfromlist(0,replaceStr)		withThisStr = stringfromlist(1,replaceStr)	endif		Variable startInd = ParamIsDefault(start) ? 0 : start	Variable numItems=ItemsInList(strList,delimUsed) 	Variable maxItems=numItems-startInd	Variable numInds	if ( (strlen(strList) < 1) && !ParamisDefault(num) )		numInds = num	else		numInds = ParamISDefault(num) ? maxItems : min(startInd+num,maxItems) 	endif		Variable skips=0,printInd	for (i=0;i<numInds;i+=1)		ind=i+startInd		listStr=stringfromlist(ind,strList,delimUsed)		if ( doSkipBlanks && (strlen(listStr) < 1) )			skips+=1			continue		endif				executeStr = replacestring("%s",macroStr,listStr,1)		printInd = i - skippedBlanksCountTowardsInds*skips		//skips will be zero if no skipping blanks or skipped blanks aren't counting towards prited index		executeStr = replacestring("%i",executeStr,num2str(printInd),1)		if (hasReplaceStr)			currReplacedStr = replaceString(replaceThisStr,listStr,withThisStr)			executeStr = replaceString(escapeStrs[%replacedStrListItem],executeStr,currReplacedStr,1)		endif		Execute/q executeStr	endforend////function list_operation_g(macroStr,strList,[start,num,iterateWaveColInstead,replaceStr,altEscapeStrs])//	String macroStr, strList//	Variable start,num//	variable iterateWaveColInstead	//optionally pass to iterate down a wave column, column number is passed and wave name is in strList.. pass -1 to use row labels//	String replaceStr		//optionally pass a replace string in the form of "replaceThisStr;withThisStr"//								//if passed, any %r will be replaced with replacestring(replaceThisString,listItem,withThisString)//	String altEscapeStrs	//default is %s is replaced by the current item from strList, %i is replaced by the item's index, and %r is replaced by the item after running replaceStr on the item (if that is passed)//								//sometimes it is useful to override the defaults (e.g., dimension labels starting with s), to do so pass "escapeStrName0,altEscapeStr0;escapeStrName1,altEscapeStr1;..." etc.//								//	make/o/free/t escapeStrs = {"%s","%i","%r"}//	String escapeStrNames="listItem;listIndex;replacedStrListItem;"		//matched order to escapeStrs//	dl_assignLblsFromList(escapeStrs,0,0,escapeStrNames,"",0)//	//	Variable i,numAltEscapes//	String escapeStrName,newEscapeStr,escapeInfo//	if (!ParamIsDefault(altEscapeStrs))//		numAltEscapes=itemsinlist(altEscapeStrs)//		for (i=0;i<numAltEscapes;i+=1)//			escapeInfo = stringfromlist(i,altEscapeStrs)//			escapeStrName = stringfromlist(0,escapeStrName,",")//			newEscapeStr = stringfromlist(1,escapeStrName,",")//			escapeStrs[%$escapeStrName]=newEscapeStr//		endfor//	endif//	//	//	Variable ind; String executeStr, listStr//	if (!ParamIsDefault(iterateWaveColInstead) && !numtype(iterateWaveColInstead) && (iterateWaveColInstead>-2))//		String ref=strList//		WAVE/T wv=$strList//		strList=""//		Variable rows=dimsize(wv,0)//		if (iterateWaveColInstead < 0)	//==-1 so row labels//			for (i=0;i<rows;i+=1)//				strList+=getdimlabel(wv,0,i)+";"//			endfor		//		else//			for (i=0;i<rows;i+=1)//				strList+=wv[i][iterateWaveColInstead]+";"//			endfor//		endif//	endif//	//	Variable startInd = ParamIsDefault(start) ? 0 : start//	//	String searchTemp = macroStr + " "		//add space so that if it ends in %s, itemsinlist will still count a trailing item//	Variable numItems=ItemsInList(strList) //	Variable maxItems=numItems-startInd//	Variable numInds = ParamISDefault(num) ? maxItems : min(startInd+num,maxItems) //	//	String replaceThisStr,withThisStr,currReplacedStr//	Variable hasReplaceStr = !ParamIsDefault(replaceStr) && (itemsinlist(replaceStr) > 1)//	if (hasReplaceStr)//		replaceThisStr = stringfromlist(0,replaceStr)//		withThisStr = stringfromlist(1,replaceStr)//	endif//	//	for (i=0;i<numInds;i+=1)//		ind=i+startInd//		listStr=stringfromlist(ind,strList)//		executeStr = replacestring(escapeStrs[%listItem],macroStr,listStr)//		executeStr = replacestring(escapeStrs[%listIndex],executeStr,num2str(i))//		if (hasReplaceStr)//			currReplacedStr = replaceString(replaceThisStr,listStr,withThisStr)//			executeStr = replaceString(escapeStrs[%replacedStrListItem],executeStr,currReplacedStr)//		endif//		Execute/q executeStr//	endfor//end//includes dspfunction wave_dspOrOther_cols(wv,outRef,statStr)	String outRef	WAVE wv	String statStr			//could be "dsp" for dspperiodogram, "ws" for wavestats, "phase" for converting impulse responses to phase spectra 		Variable cols=dimsize(wv,1),i	for (i=0;i<cols;i+=1)		duplicate/o/r=[][i]/free wv,temp		redimension/n=(-1) temp		strswitch (statStr)			case "dsp":		//periodoram				make/o/free/n=(1) results						dspperiodogram/PARS/nodc=1/Q/dest=results temp				break							case "phase":								make/o/free/n=(1)/c phaseTemp		//cannot be pre-defined real						fft/dest=phaseTemp temp				make/o/free/n=(dimsize(phaseTemp,0)) results					setscale/p x,dimoffset(phaseTemp,0),dimdelta(phaseTemp,0),waveunits(phaseTemp,0),results					results = imag(r2polar(phaseTemp))				results[0] = results[1]; Unwrap 2*pi, results				break			case "ws":				wavestats/w/q temp				WAVE results=$"M_wavestats"				break		endswitch					if (i==0)			Duplicate/o results,$outRef/wave=out		else			concatenate/np=1/dl {results},out		endif	endfor	endfunction list_meanOfWaves(wList)	String wList		Variable num=itemsinlist(wList),i	String ref	Double out=0	for (i=0;i<num;i+=1)		ref=stringfromlist(i,wList)		out+=mean($ref)	endfor		out/=num		return outendfunction list_operation_gg(macroStr,subCodesWv,stringListsWv)	String macroStr		//macro string with substitution codes	WAVE/T subCodesWv	//list of substitution codes by row.. rows are paired with the list in the same row of stringListsWv	WAVE/T stringListsWv	//list of waves to replace the subCode with (from the corresponding row of subCodesWv)		Variable numCodes=dimsize(subCodesWv,0)	Variable numLists=dimsize(stringListsWv,0)	Variable finalNumCodes=min(numCodes,numLists)		Variable numListItems = itemsinlist(stringListsWv[0])		Variable i,j,numReps	String cmd,codeStr,listStr	for (i=0;i<numListItems;i+=1)		cmd=macroStr		for (j=0;j<finalNumCodes;j+=1)			codeStr=subCodesWv[j]			listStr=stringfromlist(i,stringListsWv[j])			cmd=ReplaceString(codeStr, cmd, listStr)		endfor		execute cmd	endforend//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////STIMULUS WRITING/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	//STIMULUS GENERATION FOR CLAMPEX///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////function saveWave(waveRef, includeTiming)	String waveRef; Variable includetiming		String fileNameString = waveRef	+".txt"	//sets save file name as wave ref. Path determined by fio_setDataSavePath()	SVAR/Z dataSavePathName				//this should be a global string with the name of the path that is set by fio_setDataSavePath()	if (SVAR_Exists(dataSavePathName))		//checks that the global string exists		PathInfo/S $dataSavePathName	else		return 0		Print "Global string containing symbolic path for saving sin wave data not found"	endif	if (!V_Flag)								//this checks that the global string 		Print "Symbolic path for saving sin wave data not found!"		return 0	endif		Variable fileRefNum	Open/P=$dataSavePathName fileRefNum as fileNameString		if (includeTiming)	//	Duplicate/O $waveRef, waveTimingTemp	//	waveTimingTemp[] = x	//	wfprintf fileRefNum, "%f %f\n", waveTimingTemp, $waveRef		else	//	wfprintf fileRefNum, "%f \r", $waveRef		Duplicate/O $waveRef, waveToSave		Variable i		for (i=0;i<numpnts(waveToSave);i+=1)			fprintf fileRefNum, "%f \n" waveToSave[i]		endfor	endif	Close fileRefNum	//	Variable totalDuration = numpnts(finalSinEpoch)/sampleRate//	printf "makeSinWaveStim saved file: %s. sampleRate: %d, NumPnts: %d, length: %f (s).\r", fileNameString, sampleRate, numpnts(finalSinEpoch), totalDuration //	if (totalDuration > 51.5)//		Print "Warning! Total duration is very near or exceeds allowed length in pClamp (if sampleRate is ~20 kHz or greater)"//	endifendfunction makeSinWaveStim(sampleRate, fileNameString)	Variable sampleRate	String fileNameString 	//sets name of file to save to		Variable numRepsPerFreq = 5	Variable ramps = 1		//if ramps = 1 then will ramp from 0 to mean beforehand and from mean to 0 after	Variable frequencyOrder = 3		//frequency order 1 = upward only, frequency order 2 = downward only, frequency order 3 = up then down, 4 = down then up	Variable rampDur = 1				//duration of ramp in cycles	Variable rampUpToMean = 0		//rampUpToMean = 1 will mean ramps go from min to mean, = 0 means ramps go from max to mean	Make/O/D frequenciesWave = {0.5,1,2,3,6,8,10,15,20,30,50,60,80,100,130,160,180,200,250}		Variable includeTiming = 0		SVAR/Z dataSavePathName				//this should be a global string with the name of the path that is set by fio_setDataSavePath()	if (SVAR_Exists(dataSavePathName))		//checks that the global string exists		PathInfo/S $dataSavePathName	else		return 0		Print "Global string containing symbolic path for saving sin wave data not found"	endif	if (!V_Flag)								//this checks that the global string 		Print "Symbolic path for saving sin wave data not found!"		return 0	endif		//makes a wave called finalSinEpoch that will hold reps of listed frequencies (in order as listed)	Variable i, currentFreq, currentNumPnts	for (i=0;i<numpnts(frequenciesWave);i+=1)		currentFreq = frequenciesWave[i]		currentNumPnts = (1/currentFreq) * numRepsPerFreq * sampleRate		//calcuates the length of the current set of cycle replicates		Make/O/D/N=(currentNumPnts) currentFreqWave		SetScale/P x, 0, (1/sampleRate), "s", currentFreqWave		currentFreqWave = sin(2*Pi*currentFreq*x)		//actually calculates and stores in the current wave the sin wave of currentFreq		if (i==0)			Duplicate/O currentFreqWave, finalSinEpoch		else			Concatenate/NP {currentFreqWave}, finalSinEpoch		//appends current wave to the end of the finalSinEpoch		endif	endfor		finalSinEpoch /= 2	//sin wave range starts -1 to +1, so this makes it -0.5 to 0.5, then next line bumps the range up from 0 to 1	finalSinEpoch += .5		if (frequencyOrder == 2)		Reverse/DIM=-1 finalSinEpoch		//reverses in place finalSinEpoch	elseif (frequencyOrder > 2)			//specifies an up and down version		Duplicate/O finalSinEpoch, finalSinEpochRev		Reverse/DIM=-1 finalSinEpochRev/D=finalSinEpochRev		//stores reverse in finalSinEpochRev		finalSinEpochRev = 1 - finalSinEpochRev					//flips the values of finalSinEpochRev, because the sin function is an odd function, flipping and reversing gives you the same sin wave at a given freq, but now the order of frequencies is reversed as desired		if (frequencyOrder != 4)		//"Default" is that it's set to 3 and it's going to go up then down			Concatenate/NP {finalSinEpochRev}, finalSinEpoch		else		//must equal 4 so go down then up			Concatenate/NP {finalSinEpoch}, finalSinEpochRev		endif		KillWaves/Z finalSinEpochRev	endif		if (ramps)		Variable numRampPnts= rampDur*sampleRate		Make/D/O/N=(numRampPnts) startRamp		SetScale/P x, 0, (1/sampleRate), "s", startRamp		Variable meanVal = mean(finalSinEpoch)	//for now, should always be 0.5 but just in case		Variable initialVal, rampValRange		if (rampUpToMean)			initialVal = wavemin(finalSinEpoch)		else			initialVal = wavemax(finalSinEpoch)		endif		rampValRange = meanVal - initialVal						Duplicate/O startRamp, endRamp		//now both up and down ramp are set to the mean			startRamp[] = initialVal + (rampValRange * (p/(numRampPnts-1)))		endRamp[] = meanVal - (rampValRange * (p/(numRampPnts-1)))		//		meanVal * ((p/(numRampPnts-1))	//(p/(numRampPnts-1)) starts at 0 and goes to 1 in proportion to how far into ramp we are, so makes a ramp when multipled by mean value//		endRamp[] = meanVal - (meanVal *  (p/(numRampPnts-1)))		Concatenate/NP {endRamp}, finalSinEpoch		//put down ramp after final sin epoch		Concatenate/NP {finalSinEpoch}, startRamp				//put up ramp before final sin epoch, unfortunately saves in startRamp, so next line will duplicate this back into finalSinEpoch		Duplicate/O startRamp, finalSinEpoch	endif			Variable fileRefNum	Open/P=$dataSavePathName fileRefNum as fileNameString		if (includeTiming)		Duplicate/O finalSinEpoch, sinWaveTiming		sinWaveTiming[] = x		wfprintf fileRefNum, "%f %f\n", sinWaveTiming, finalSinEpoch		else		wfprintf fileRefNum, "%f\n", finalSinEpoch	endif	Close fileRefNum		Variable totalDuration = numpnts(finalSinEpoch)/sampleRate	printf "makeSinWaveStim saved file: %s. sampleRate: %d, NumPnts: %d, length: %f (s).\r", fileNameString, sampleRate, numpnts(finalSinEpoch), totalDuration 	if (totalDuration > 51.5)		Print "Warning! Total duration is very near or exceeds allowed length in pClamp (if sampleRate is ~20 kHz or greater)"	endifendfunction/S makeWNStim(duration,refreshRate,sampleRate,seed,gnoiseMean,gnoiseSD,fileNameString,outWvName)	//changed parameter types from variable to double 171013	Double duration, refreshRate, sampleRate, seed		//duration in seconds, freshrate, sample rate in Hz, seed is seed value for random number generator (same number will give same values over and over)	String fileNameString 	//sets name of file to save to	Double gnoiseMean,gnoiseSD		//SD 0.25 was my standard before and meant 95% of values are between -1 of mean and 1 of mean	String outWvName	//name to save wave to		//my old standards until 171013 was gnoise mean 0.5, sd 0.25.. 		if (numtype(gnoiseMean))		gnoiseMean = 0.5	endif		if ((seed < 0) || (seed >=1))		Print "Seed must be no less than 0 and not 1 or greater than 1"		Return ""	endif		Variable includeTiming = 0		Variable numFrames = duration*refreshRate	Variable numSamples = duration*sampleRate		Make/O/D/N=(numFrames)/free WNWaveAtFrameRate	SetScale/P x, 0, (1/refreshRate), "s", WNWaveAtFrameRate	Make/O/D/N=(numSamples) $outWvName/wave=finalWNWave	SetScale/P x, 0, (1/sampleRate), "s", finalWNWave		SetRandomSeed/BETR seed		WNWaveAtFrameRate = gnoise(gnoiseSD,2) + gnoiseMean		//gnoise generates numbers that in series have on average a mean 0 and stdev of gnoiseSD, adding gnoiseMean shifts to this mean	Variable conversionFactor = refreshRate/sampleRate	Print "conversionFactor",conversionFactor	finalWNWave = WNWaveAtFrameRate[floor(p*conversionFactor)]		if (strlen(fileNameString))		//save appropriately named text file with values in finalWNWave:		//prompt user for save path selection		SVAR/Z dataSavePathName				//this should be a global string with the name of the path that is set by fio_setDataSavePath()		if (SVAR_Exists(dataSavePathName))		//checks that the global string exists			PathInfo/S $dataSavePathName		else			return ""			Print "Global string containing symbolic path for saving sin wave data not found"		endif		if (!V_Flag)								//this checks that the global string 			Print "Symbolic path for saving sin wave data not found!"			return ""		endif				//save wave in path		Variable fileRefNum		Open/P=$dataSavePathName fileRefNum as fileNameString				if (includeTiming)			Duplicate/O finalWNWave, WNWaveTiming			WNWaveTiming[] = x			wfprintf fileRefNum, "%f %f\n", WNWaveTiming, finalWNWave			else			wfprintf fileRefNum, "%f\n", finalWNWave		endif		Close fileRefNum	endif		Variable totalDuration = numpnts(finalWNWave)/sampleRate	printf "makeWNStim saved file: %s. sampleRate: %d, NumPnts: %d, length: %f (s).\r", fileNameString, sampleRate, numpnts(finalWNWave), totalDuration 		return "finalWNWave"endfunction/S fio_setDataSavePath()	String/G dataSavePathName = "dataSavePath"	NewPath/M="Symbol path name is dataSavePath"/O $dataSavePathName	return dataSavePathNameendfunction/S fio_getDataSavePathStr()	SVAR/Z dataSavePathName	if (!SVAR_Exists(dataSavePathName ) )		return fio_setDataSavePath()	endif		return dataSavePathNameend//Function determines if the global variable dataSavePathName exists and has been set to a valid data path to read and write files. Returns 0 if everything ok, 1 if no global string exists, 2 if global string exists but path invaldfunction fio_checkGlobalFilePath()	SVAR/Z dataSavePathName		if (SVAR_Exists(dataSavePathName))		//checks that the global string exists		PathInfo/S $dataSavePathName	else		return 1		Print "Global string containing symbolic path for saving sin wave data not found. Use fio_setDataSavePath()"	endif		if (!V_Flag)								//this checks that the global string dataSavePathName actually corresponded to a working data path		Print "Symbolic path for saving sin wave data not found! Use setDataSavePath()"		return 2	endif	return 0end//now not used://should be able to use this function exclusively to save wavesfunction/S fio_saveWavesToDataSavePath(matchStrOrWvList, resetDataSavePath, appendSavePath [strForPathNameReturn])	String matchStrOrWvList	Variable resetDataSavePath	//pass to first prompt user to set dataSavePath	Variable appendSavePath	String &strForPathNameReturn		String pathName	if (resetDataSavePath)		pathName = fio_setDataSavePath()	else		pathName = fio_getDataSavePathStr()	endif		if (fio_checkGlobalFilePath())		return ""		//do nothing if this check fails	endif		String successfullySavedWavesList = ""		String usedPathName = fio_saveWavesByName(matchStrOrWvList, pathName, appendSavePath,out_saveListStr=successfullySavedWavesList)		if (!ParamIsDefault(strForPathNameReturn))		strForPathNameReturn = usedPathName	endif		return successfullySavedWavesListend //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////GRAPHING ETC////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ///////////////////// GB functions for messing with graphs///////////////////function removeAxisStuff(graphName, doRemove)	String graphName; Variable doRemove		if (doRemove)		ModifyGraph/W=$graphName nolabel = 2, axRGB=(65535,65535,65535), tick = 3	else		ModifyGraph tick=0,noLabel=0,axRGB=(0,0,0)	endifendfunction chAmp()ModifyGraph lblPos(absAmpL)=55,lblPos(relAmpL)=55,prescaleExp(absAmpL)=3;DelayUpdateModifyGraph prescaleExp(relAmpL)=3,notation(relAmpL)=1,axisEnab(absAmpL)={0.33,1};DelayUpdateModifyGraph axisEnab(relAmpL)={0,0.29};DelayUpdateLabel absAmpL "\\Z14 Amplitude (mV)\\u#2";DelayUpdateLabel bottom "\\Z14Frequency (Hz)\\u#2";DelayUpdateLabel relAmpL "\\Z14 Difference (mV)\\u#2"ModifyGraph fsize=14endfunction chLat()modifygraph fsize=14ModifyGraph prescaleExp(absLatL)=3,prescaleExp(relLatL)=3;DelayUpdateModifyGraph axisEnab(absLatL)={0.33,1},axisEnab(relLatL)={0,0.29};DelayUpdateLabel absLatL "\\Z14 Latency (ms)\\u#2";DelayUpdateLabel bottom "\\Z14 Frequency (Hz)\\u#2";DelayUpdateLabel relLatL "\\Z14 Difference (ms)\\u#2"endfunction cfdips()ModifyGraph fSize=14,axisEnab(L_abs)={0.33,1},axisEnab(L_sub)={0,0.29};DelayUpdateLabel L_abs "\\Z14Impedence (M\\"Label bottom "\\Z14 Frequency (\\U)";DelayUpdateLabel L_sub "\\Z14Difference  (M\\"endfunction setVILabel(isBS)	Variable isBS		Label Left0 "Membrane voltage (\\U)"	Label Left1 "Injected\rcurrent (\\U)"	Label Bottom "Time (\\U)"	ModifyGraph prescaleExp(Left0)=-3ModifyGraph fSize=14Label bottom "\\Z14Time (\\U)";DelayUpdateModifyGraph lblPos(Left0)=52,lblPos(Left1)=52,lblLatPos(Left0)=-14;DelayUpdateModifyGraph lblLatPos(Left1)=8;DelayUpdateLabel Left1 "\\Z14Current (\\U)"	if (isBS)		Label Left0 "\\Z14\\u#2\\F'Wingdings 3'r\\F'Arial' Voltage (\\U)";DelayUpdate	else		Label Left0 "\\Z14Voltage (\\U)";DelayUpdate	endif	ModifyGraph axisEnab(left0) = {.2,1}, axisEnab(left1)={0,.16}endfunction setVIIn(settingNum)		//0 = for plots used for June data talk. 1 = for R21	Variable settingNum		if (settingNum == 0)		setAxis bottom, -.04, .4	elseif (settingNum == 1)		setAxis bottom, -0.02,.2	endifendfunction setVIOut()	setAxis bottom, -.3,2.5endfunction bsStandardPairedSSVI()	baselineSubtract("*",1,1,1)		//offsets all traces to cursor B	baselineSubtract("!*AD1",1,0,1)	//subtracts baseline from all traces except stimulus traces (*AD1)endfunction setVIBSLabel()	Label Left0 "Membrane voltage (\\U)"	Label Left1 "Injected\rcurrent (\\U)"	Label Bottom "Time (\\U)"	ModifyGraph prescaleExp(Left0)=-3		ModifyGraph fSize=14,lblLatPos(Left0)=-15,lblLatPos(Left1)=10;DelayUpdateLabel bottom "\\Z14 Time (\\U)";DelayUpdateLabel Left1 "\\Z14 Current (\\U)"endfunction ssAmpPlot()		//ALSO EXPAND AXIS 5% 2x	//deals with marker shapesModifyGraph mode=3,mrkThick=2,useMrkStrokeRGB=1,marker(HS1_SS)=19;DelayUpdateModifyGraph marker(HS1_peak)=8,marker(HS2_SS)=19,rgb(HS2_SS)=(65280,0,0);DelayUpdateModifyGraph mrkStrokeRGB(HS2_SS)=(65280,0,0),marker(HS2_peak)=8;DelayUpdateModifyGraph rgb(HS2_peak)=(65280,0,0),mrkStrokeRGB(HS2_peak)=(65280,0,0);DelayUpdateModifyGraph marker(Sub_SS)=19,marker(Sub_peak)=8,marker(Div_SS)=19;DelayUpdateModifyGraph marker(Div_peak)=8ModifyGraph mrkThick=1.5	//deal with axis labelsModifyGraph lblPos(L_sub)=60,lblPos(L_div)=60,lblLatPos(L_raw)=40;DelayUpdateModifyGraph lblLatPos(L_sub)=30,lblLatPos(L_div)=-10;DelayUpdateLabel L_raw "\\u#2\\F'Wingdings 3'r\\F'Arial'Voltage";DelayUpdateLabel bottom "\\u#2\\F'Wingdings 3'r\\F'Arial'Current (pA)";DelayUpdateLabel L_sub "\\u#2\\F'Wingdings 3'r\\F'Arial'V\\BPed\\M\r-\\u#2\\F'Wingdings 3'r\\F'Arial'V\\BSoma";DelayUpdateLabel L_div "\\f04\\u#2\\F'Wingdings 3'r\\F'Arial'V\\f00\\BPed\\M\r\\u#2\\F'Wingdings 3'r\\F'Arial'V\\BSoma"ModifyGraph lblLatPos(L_raw)=0,lblLatPos(L_sub)=5,lblLatPos(L_div)=-5;DelayUpdateLabel L_raw "\\Z14\\u#2\\F'Wingdings 3'r\\F'Arial'Voltage";DelayUpdateLabel bottom "\\Z14\\u#2\\F'Wingdings 3'r\\F'Arial'Current (pA)";DelayUpdateLabel L_sub "\\Z14\\u#2\\F'Wingdings 3'r\\F'Arial'V\\BP\\M\r\\Z14-\\u#2\\F'Wingdings 3'r\\F'Arial'V\\BS";DelayUpdateLabel L_div "\\Z14\\f04\\u#2\\F'Wingdings 3'r\\F'Arial'V\\f00\\BP\\M\r\\Z14\\u#2\\F'Wingdings 3'r\\F'Arial'V\\BS"ModifyGraph fSize=14,lblPos(L_raw)=65,lblPos(L_sub)=75,lblPos(L_div)=75;DelayUpdateModifyGraph lblLatPos(L_raw)=10,axisEnab(L_raw)={0,0.5};DelayUpdateModifyGraph axisEnab(L_sub)={0.54,0.75},axisEnab(L_div)={0.79,1}//more adjustmentsModifyGraph lblPos(L_raw)=85,lblPos(L_sub)=90,lblPos(L_div)=83;DelayUpdateModifyGraph lblLatPos(L_raw)=20;DelayUpdateLabel L_raw "\\Z14\\u#2\\F'Wingdings 3'r\\F'Arial'Voltage (mV)\r\\Z12\\W519SS\\BS \\K(65280,0,0)P\r\\M\\K(0,0,0)\\Z12\\W508Peak\\BS \\K(65280,0,0)P";DelayUpdateLabel L_sub "\\Z14\\u#2\\F'Wingdings 3'r\\F'Arial'V\\BP\\M\r\\Z14-\\u#2\\F'Wingdings 3'r\\F'Arial'V\\BS\r\\Z14(mV)"endfunction ssKineticsPlot()	//deals with labelsModifyGraph fSize=14,lblPos(L_raw)=80,lblPos(L_sub)=95,lblPos(L_div)=85;DelayUpdateModifyGraph lblLatPos(L_raw)=20,lblLatPos(L_sub)=15,lblLatPos(L_div)=1;DelayUpdateLabel L_raw "\\Z1450% Peak\rTime (ms)\\u#2";DelayUpdateLabel bottom "\\Z14\\u#2\\F'Wingdings 3'r\\F'Arial'Current";DelayUpdateLabel L_sub "\\Z14T\\B50%,P\r-\\M\\Z14T\\B50%,S\r\\M\\Z18 (\\Z14\\"Label L_div "\\f04\\Z14T\\f00\\B50%,P\r\\M\\Z14T\\B50%,S"Label L_raw "\\Z1450% Peak\rTime (ms)\\u#2\r\\K(0,0,0)Soma\\K(65280,0,0) Ped\r"	//deals with trace markers	ModifyGraph mode=3,marker=19,mrkThick=1.5,useMrkStrokeRGB(HS2_raw)=1;DelayUpdateModifyGraph mrkStrokeRGB(HS2_raw)=(65280,0,0)SetAxis bottom -6.3627888e-11,8.392464e-11endfunction modChirpAmpGraph()	ModifyGraph axisEnab(absAmpL)={0,0.5},axisEnab(relAmpL)={0.52,0.75};DelayUpdate	ModifyGraph axisEnab(foldAmpL)={0.77,1}	Label absAmpL "Chirp response \ramplitude (ms)\\u#2";  Label relAmpL "Amplitude difference \rat pedicle \r(pedicle - soma)"; Label foldAmpL "Fold change \rin amplitude \rat terminal \r(terminal / soma)"ModifyGraph lblPos(absAmpL)=73,lblPos(relAmpL)=70,lblPos(foldAmpL)=83; Label relAmpL "\\u#2Difference (mV\rterminal - soma)"; Label foldAmpL "Fold change\r(terminal/\rsoma)"Label absAmpL "Chirp response \ramplitude (mV)\\u#2"; 	Label bottom "Average frequency of cycle (Hz)"endfunction modChirpLatGraph()ModifyGraph lblPos(absLatL)=73,lblPos(relLatL)=73,lblPos(foldLatL)=87;DelayUpdateModifyGraph axisEnab(absLatL)={0,0.5},axisEnab(relLatL)={0.52,0.75};DelayUpdateModifyGraph axisEnab(foldLatL)={0.77,1};DelayUpdateLabel absLatL "Chirp response latency\rrelative to stimulus (ms)\\u#2";DelayUpdateLabel bottom "Average frequency of cycle (Hz)\\u#2";DelayUpdateLabel relLatL "Difference (ms\rterminal - soma)\\u#2";DelayUpdateLabel foldLatL "Fold change\r(terminal/\rsoma)"endfunction bsOrOffset(matchString, bs, offsetToCsrB, addedYOffset, useTNs) //must select baseline region with two cursors. Function will start with wave on cursor A and subtract baseline from all waves with name matching matchstr	String matchString; Variable offsetToCsrB,bs	,addedYOffset, useTNs		//if makeNewWaves = 1 will save copy of background subtracted wave		Variable baseStartX = xcsr(a)	Variable baseEndX =  xcsr(b)	Variable xOffsetX = 0	if (offsetToCsrB)		xOffsetX = -xcsr(b)	endif		String listOfWavesForBSName = "listOfWavesForBS"		graph_getWaveList("", matchString, listOfWavesForBSName, useTNs)		//sets listOfWavesForBS as a reference to a text wave with references to matching waves displayd on top graph		WAVE/T listOfWavesForBS	Variable i,  baselineYLevel, yAverage = 0	for (i=0;i<DimSize(listOfWavesForBS,0);i+=1)		if (bs)			baselineYLevel = mean($listOfWavesForBS[i][0],baseStartX, baseEndX)			yAverage+=baselineYLevel		else			baselineYLevel=0		endif		ModifyGraph offset($listOfWavesForBS[i][1]) = {xOffsetX,-baselineYLevel + addedYOffset}	endfor	KillWaves/Z listOfWavesForBS, baselineSubFromGraphTempWave	return yAverage /iend// Label Left0 "\\Z14\\u#2\\F'Wingdings 3'r\\F'Arial' Voltage (\\U)"function chirpPartPlot(stim, soma, ped)	String stim, soma, ped		Display	AppendToGraph/R=right/B=bottom $stim	AppendToGraph/R=right/B=bottom1 $stim	AppendToGraph/R=right/B=bottom2 $stim	AppendToGraph/L=left/B=bottom $soma,$ped	AppendToGraph/L=left/B=bottom1 $soma,$ped	AppendToGraph/L=left/B=bottom2 $soma,$ped		ModifyGraph rgb($stim)=(26112,26112,26112);DelayUpdateModifyGraph rgb($(stim+"#1"))=(26112,26112,26112);DelayUpdateModifyGraph rgb($(stim+"#2"))=(26112,26112,26112);DelayUpdateModifyGraph rgb($soma)=(0,0,0),rgb($(soma+"#2"))=(0,0,0);DelayUpdateModifyGraph rgb($(soma+"#2"))=(0,0,0)ModifyGraph fSize=14,lblMargin(left)=10,lblPos(bottom)=41,lblPos(bottom1)=41;DelayUpdateModifyGraph lblPos(bottom2)=41,prescaleExp(left)=3,notation(left)=1;DelayUpdateModifyGraph axisEnab(bottom)={0,0.28},axisEnab(bottom1)={0.33,0.62};DelayUpdateModifyGraph axisEnab(bottom2)={0.67,1},freePos(bottom1)=0,freePos(bottom2)=0;DelayUpdateLabel right "\\K(17408,17408,17408)\\Z14Current (grey) (\\U)";DelayUpdateLabel bottom "\\Z14Time (\\U)";DelayUpdateLabel bottom1 "\\Z14Time (\\U)";DelayUpdateLabel bottom2 "\\Z14Time (\\U)";DelayUpdateLabel left "\\Z14\\u#2\\F'Wingdings 3'r\\F'Arial' Voltage (\\U)"setAxis bottom, 1.1,2.5setAxis bottom1, 3.3,4.2setAxis bottom2, 6.6,6.72endfunction normalChirpDisplay()ModifyGraph fSize=14,lblLatPos(Left0)=-10,lblLatPos(Left1)=10;DelayUpdateLabel Left0 "\\Z14Voltage (\\U)";DelayUpdateLabel bottom "\\Z14 Time (\\U)";DelayUpdateLabel Left1 "\\Z14Current (\\U)"end//assumes top graph with abs axis = Labs, subaxis = lsubfunction addToSSAmpPlot(somaRef, pedRef)	String somaRef, pedRef		String subtractionRef = somaRef +"S"		String nameBase = somaRef[0,9]	//abs amp soma ss and peak	AppendToGraph/C=(0,0,0)/L=Labs $somaRef[4][]/TN=$("ss_soma" + nameBase) vs $pedRef[5][]	AppendToGraph/C=(0,0,0)/L=Labs $somaRef[17][]/TN=$("peak_soma" + nameBase) vs $pedRef[5][]	ModifyGraph lstyle($("peak_soma" + nameBase)) = 7	//abs amp ped ss and peak	AppendToGraph/L=Labs $pedRef[4][]/TN=$("ss_ped" + nameBase) vs $pedRef[5][]	AppendToGraph/L=Labs $pedRef[17][]/TN=$("peak_ped" + nameBase) vs $pedRef[5][]	ModifyGraph lstyle($("peak_ped" + nameBase)) = 7		//rel amp	AppendToGraph/C=(0,0,0)/L=Lsub $subtractionRef[4][]/TN=$("ss_sub" + nameBase) vs $pedRef[5][]	AppendToGraph/C=(0,0,0)/L=Lsub $subtractionRef[17][]/TN=$("peak_sub" + nameBase) vs $pedRef[5][]	ModifyGraph lstyle($("peak_sub" + nameBase)) = 7	endfunction addToSSKineticsPlot(somaRef, pedRef)	String somaRef, pedRef		String subtractionRef = somaRef +"S"		String nameBase = somaRef[0,8]	//abs time to threshold soma	AppendToGraph/C=(0,0,0)/L=Labs $somaRef[18][]/TN=$("soma" + nameBase) vs $pedRef[5][]	//abs time to threshold ped	AppendToGraph/L=Labs $pedRef[18][]/TN=$("ped" + nameBase) vs $pedRef[5][]	//rel time to threshold	AppendToGraph/C=(0,0,0)/L=Lsub $subtractionRef[18][]/TN=$("pedSoma" + nameBase) vs $pedRef[5][]end//NOMOGRAMS (TO END OF THIS SECTION)function makeBaylor(lambdaMax, samplesPerNm, wRef)	Variable lambdaMax, samplesPerNm; String wRef		Variable nmStart = 300	Variable nmEnd = 950		Variable nmRange = nmEnd - nmStart + 1			Variable numSamples = nmRange * samplesPerNm		Variable mStart = nmStart * 10^-9	Variable samplesPerM = samplesPerNm * 10^9		Make/O/D/N=(numSamples) baylorTemp		SetScale/P x, mStart, (1/samplesPerM), "m", baylorTemp	baylorTemp = 0		//all this explained in Eq. 6 of Baylor, Nunn, and Schanpf, J Physiol,1987	//coefsList is a0-6 in their text	Make/O/D coefsList = {-5.2734,-87.403,1228.4,-3346.3,-5070.3,30881,-31607}		//lambdaRed is Lambda(subscript R) in text	Variable lambdaRed = 561		Variable i, currCoefIndex, currCoefVal, currLambdaVal; String noteStr = "Coefs: "		for (i=0;i<numpnts(baylorTemp);i+=1)		//currLambdaVal is lambda in the wave number 1 / lambda, needs units of 1 / micron		currLambdaVal = pnt2x(baylorTemp,i) * 10^6			//want units of 1 / micron, the inverse portion comes by having this in the dividend, the micron comes by taking m * 10 ^6		for (currCoefIndex = 0; currCoefIndex <numpnts(coefsList); currCoefIndex +=1)			baylorTemp[i] += coefsList[currCoefIndex] *((log(lambdaMax/(currLambdaVal*lambdaRed)))^currCoefIndex)			if (i==0)				noteStr += num2str(coefsList[currCoefIndex]) + ";"				Print "currLambdaVal",currLambdaVal			endif		endfor		endfor		Duplicate/O baylorTemp, $wRef	Note $wRef, noteStr + "lambdaRef: " + num2str(lambdaRed)		KillWaves/Z coefsList, baylorTempend//from alan -- modified for double precision and to return name of created wave (GB)function/S nomograms(lambdamax, suffix)	double lambdamax	string suffix		double nomoA, nomoB, nomoC, nomoD, nomo_a, nomo_b, nomo_c	nomoA= 69.7; nomoB=28; nomoC=-14.9; nomoD=0.674; nomo_a=0.88; nomo_b=0.922; nomo_c=1.104 // govardovskii	//nomoA = 41.503; nomoB = 3.1795; nomoC = -4.1853; nomoD = -7.5036; nomo_a = 0.90527; nomo_b = 1.4739; nomo_c = 0.68364 // extramelanospin from personal communication with Matsuyama T; lambdamax = 444.27	//nomoA= 41.047; nomoB=12.679; nomoC=-15.768; nomoD = 0.45454; nomo_a=.91961; nomo_b=.91671; nomo_c=1.1055 // melanopsin values from Matsuyama et al 2012 use 476.62 lambdamax	//nomoA=44.402; nomoB=11.768; nomoC=-14.088; nomoD=0.2554; nomo_a=.90595; nomo_b=.87117; nomo_c=1.1367 // metamelanopsin values from Matsuyama et al 2012 use 483.49 lambdamax	make/o/D/n = 10000 nomo	SetScale/I x 290, 800,"",nomo	nomo = 1/ ((exp(nomoA*(nomo_a-(lambdamax/x)))) + (exp(nomoB*(nomo_b-(lambdamax/x)))) + (exp(nomoC*(nomo_c-(lambdamax/x))) + nomoD))	duplicate/o nomo $("nomogram_"+suffix)		return "nomogram_"+suffixendfunction/S nomogramsbeta(lambdamax, suffix)	double lambdamax	string suffix		double nomoA, nomoB, nomoC, nomoD, nomo_a, nomo_b, nomo_c, beta_mb, beta_b	nomoA= 69.7; nomoB=28; nomoC=-14.9; nomoD=0.674; nomo_a=0.88; nomo_b=0.922; nomo_c=1.104 // govardovskii	beta_mb = 189+0.315*lambdamax	beta_b = -40.5 + 0.195*lambdamax	make/o/D/n = 10000 nomo	SetScale/I x 350, 800, "", nomo	nomo = 1/ ((exp(nomoA*(nomo_a-(lambdamax/x)))) + (exp(nomoB*(nomo_b-(lambdamax/x)))) + (exp(nomoC*(nomo_c-(lambdamax/x))) + nomoD)) + 0.26*exp(-((x-beta_mb)/beta_b)^2)	duplicate/o nomo $("nomogram_"+suffix)		return "nomogram_"+suffixend//end from alan//version scaled to match sampling of cie photopic  ..sr2 for sampling rate 2function/S nomogramsbeta_sr2(lambdamax, suffix)	double lambdamax	string suffix		Variable len = 	70	//4401	Variable delta = 5//0.1		//nm	Variable start = 355 //390		//nm		double nomoA, nomoB, nomoC, nomoD, nomo_a, nomo_b, nomo_c, beta_mb, beta_b	nomoA= 69.7; nomoB=28; nomoC=-14.9; nomoD=0.674; nomo_a=0.88; nomo_b=0.922; nomo_c=1.104 // govardovskii	beta_mb = 189+0.315*lambdamax		//equation 5	beta_b = -40.5 + 0.195*lambdamax	//equation 6	make/o/D/n = (len) nomo	SetScale/P x start, delta, "nm", nomo	nomo = 1/ ((exp(nomoA*(nomo_a-(lambdamax/x)))) + (exp(nomoB*(nomo_b-(lambdamax/x)))) + (exp(nomoC*(nomo_c-(lambdamax/x))) + nomoD)) + 0.26*exp(-((x-beta_mb)/beta_b)^2)	//govardovskii eq. 1 and eq. 4 s(x)=1 / ...[first 3 terms, from equation 1] + ...[last term from equation 4]	duplicate/o nomo $("nomogram_"+suffix)		Print "saved nomogram as", ("nomogram_"+suffix)		return "nomogram_"+suffixend//parameterized scaling for a specified govardovskii nomogram using the nomo_x() functionfunction/S nomo_make(lambdamax_nm,start_nm,len_nm,delta_nm,outRef)	double lambdamax_nm	Double start_nm,len_nm,delta_nm	string outRef		//save ref		//specify wave	Variable len_p = len_nm / delta_nm	make/o/D/n = (len_p) $outref/wave=out	SetScale/P x start_nm, delta_nm, "nm", out	out = nomo_x(lambdamax_nm,x)	//govardovskii eq. 1 and eq. 4 s(x)=1 / ...[first 3 terms, from equation 1] + ...[last term from equation 4]			return outRefend//returns govardovskii value at x (peak value of 1 at lambdaMax)function nomo_x(lambdaMax_nm,x_nm)	Double lambdaMax_nm	Double x_nm	//value to calculate x at		double nomoA, nomoB, nomoC, nomoD, nomo_a, nomo_b, nomo_c, beta_mb, beta_b	nomoA= 69.7; nomoB=28; nomoC=-14.9; nomoD=0.674; nomo_a=0.88; nomo_b=0.922; nomo_c=1.104 // govardovskii	beta_mb = 189+0.315*lambdaMax_nm		//equation 5	beta_b = -40.5 + 0.195*lambdaMax_nm	//equation 6			return 1/ ((exp(nomoA*(nomo_a-(lambdaMax_nm/x_nm)))) + (exp(nomoB*(nomo_b-(lambdaMax_nm/x_nm)))) + (exp(nomoC*(nomo_c-(lambdaMax_nm/x_nm))) + nomoD)) + 0.26*exp(-((x_nm-beta_mb)/beta_b)^2)end//effective irradiance for a square window (E.g. bandpass filter) based on govardovskii (nomo_make() function)function nomo_integrateUniform(totalIrradiance,startX_nm,endX_nm,centerX_nm,widthX_nm,delta_nm,lambdaMAx_nm)	Double totalIrradiance		//e.g. irradiance in ph/um^2/s, output will be effective total irradiance for the receptor										//multiply that by effective collecting area to get isomerizations/s/receptor	Double startX_nm,endX_nm	//pass this or centerX_nm,widthX_nm as bounds of light	Double centerX_nm,widthX_nm		//alternative bounds specification	Double delta_nm				//if not passed, uses 10% of the total window	Double lambdaMax_nm			//receptor lambda max		Double defaultDeltaFraction = 0.1		//handle 4 cases of input : startX/endX (simple case), centerX/widthX (just convert to startX/endX), centerX only (use center value only for calculation), and none (abort)	//nan inf causes parameters  to be ignored	Variable calcFromCenterOnly = 0	if (numtype(startX_nm) || numtype(endX_nm))		if (numtype(centerX_nm))			Print "nomo_integrateUniform(): no startX_nm/endX_nm or centerX_nm specified! aborting."			return 0		endif				if (numtype(widthX_nm))			calcFromCenterOnly = 1		else					startX_nm = centerX_nm - (widthX_nm/2)			endX_nm = centerX_nm + (widthX_nm/2)		endif	else		widthX_nm = endX_nm - startX_nm	endif		Double len_nm = endX_nm - startX_nm	if (numtype(delta_nm))		delta_nm = widthX_nm * defaultDeltaFraction	endif		if (calcFromCenterOnly)		Double value = nomo_x(lambdaMAx_nm,centerX_nm)		return value * totalIrradiance	endif		String nomoTemp = "nomo_spectraTemp"	nomo_make(lambdaMax_nm,startX_nm,len_nm,delta_nm,nomoTemp)		Double integral= area($nomoTemp,startX_nm,endX_nm)	killwaves/z $nomoTemp	return integral * totalIrradiance / widthx_nmendfunction nomoToPhPerMicronSqPerSec(nomoWv,collectingArea_um2,rStarsPerPrPerSec)	// in photon per micron^s per s	WAVE/D nomoWv		//normalized for max at 1 so this is an action spectrum	Double collectingArea_um2		//collecting area has units of square microns	Double rStarsPerPrPerSec		//r stars per photoreceptor per second		//make the integral of the action spectrum equal to rStarsPerPrPerSec	Double origSum = area(nomoWv)	Double normFactor = rStarsPerPrPerSec/origSum		nomoWv *= normFactor		Double finalSum_rStar = area(nomoWv)			//units are now rStarPerPrPerSec(lambda), so divide by collecting area to get ONE (of infinite possible) spectrum of light that would have driven the cell to the input rStarsPerPrPerSec	nomoWv/=collectingArea_um2//units now ph/um^2/s across spectrum, aka spectral irradiance 		Double finalSum_phPerMicronSq = area (nomoWv); Double expectedFinalSum_phPerMicronSq = rStarsPerPrPerSec / collectingArea_um2		Print "origSum",origSum,"finalSum",finalSum_rStar,"targetSum=rStarsPerPrPerSec=",rStarsPerPrPerSec,"finalSum_phPerMicronSq",finalSum_phPerMicronSq,"expectedFinalSum_phPerMicronSq",expectedFinalSum_phPerMicronSqendfunction photoreceptorFluxToLux(lambda_peak,collectingArea_um2,rStarsPerPrPerSec,luminosityWv)	Double lambda_peak		//peak wavelength of PR	Double collectingArea_um2		//collecting area has units of square microns	Double rStarsPerPrPerSec		//r stars per photoreceptor per second		WAVE/D luminosityWv	//like an action spectrum 1 => vals > 0	STring nomo = nomogramsbeta_sr2(lambda_peak, "toLux_"+num2str(lambda_peak))	nomoToPhPerMicronSqPerSec($nomo,collectingArea_um2,rStarsPerPrPerSec)	phPerMicSqPerSecToWattPerMSq($nomo)	Print "nomo",nomo	return WattPerMSqToSpectralLux($nomo,luminosityWv)endfunction bpFluxToLux(bandpassVal,bandStart,bandEnd,luminosityWv)	Double bandpassVal,bandStart,bandEnd	WAVE/D luminosityWv	//like an action spectrum 1 => vals > 0	Duplicate/O luminosityWv, bpTemp	bpTemp = (x >= bandStart ) && (x <= bandEnd) ? bandpassVal : 0	phPerMicSqPerSecToWattPerMSq(bpTemp)	Print "bpTemp"	return WattPerMSqToSpectralLux(bpTemp,luminosityWv)endfunction phPerMicSqPerSecToWattPerMSq(nomoWv)	WAVE/D nomoWv		//assumes units are output from spec_nomogramToSpectralIrradiance, photon per micron^s per s		//needed constants	Double h_JxS = 6.62606957*(10^(-34))		//J*s	Double c_mPerS = 299792458					//m per s	Double c_nmPerS = c_mPerS * 10^9	//um^2 to m	nomoWv = nomoWv * (10^6)^2		//10^6 microns per meter .. twice  .. now units are ph/s/m^2		//ph/s to Watts	nomoWv = nomoWv * h_JxS * c_nmPerS / x			//ph/s/m^2 * j*s * nm/s * (1/nm) * (1/ph) = J/s/m^2 = W/m^2		endfunction WattPerMSqToSpectralLux(nomoWv,luminosityWv)	WAVE/D nomoWv		//assumed in W/m^2	WAVE/D luminosityWv	//like an action spectrum 1 => vals > 0 -- download from e.g. https://web.archive.org/web/20070927222337/http://www.cvrl.org/database/text/lum/ssvl2.htm		Double luxPerWPerMSq = 683.002		//lux per W/m^2	nomoWv = nomoWv * luxPerWPerMSq * luminosityWv		Double totalLux = area(nomoWv)				Print/D "totalLux",totalLux	return totalLuxendfunction bpForRStar(nomogramWv,collectingArea,rStars,bpStart_nm,bpEnd_nm,outRef)	WAVE/D nomogramWv; Double collectingArea,rStars,bpStart_nm,bpEnd_nm; String outRef		Duplicate/O nomogramWv, $outRef/wave=out, tempNomo		out = (x < bpStart_nm) || (x > bpEnd_nm) ? 0 : 1			//unit bandpass: 1 ph/um2/s in band (assuming collecting area in um^2)		tempNomo *= out			//unit response (to 1 ph/um2/s)	tempNomo *= collectingArea			// R*/cone/s for 1 ph/um2/s	Double scaleFactor = rStars / area(tempNomo)			//what factor would one have to multiply by to get target rStars instead of unit rStars?		out *= scaleFactor		//check the work		tempNomo = out * nomoGramWv		//tempNomo is now ph/um2/s weighted by action spectrum	tempNomo *= collectingArea		//tempNomo is now R*/cone/s weighted by action spectrum	Double rStar_final = area(tempNomo)		//integral of tempNomo is total R* from bandpass		Double bpPeakVal = wavemax(out)	Double bpTotal = area(out)		Print "rStar_final",rStar_final,"bpPeakVal (ph/um2/s)",bpPeakVal,"bpTotal",bpTotalend//new functions may 2017function/D cornealToRetinalIrradiance(cornealVal)	Double cornealVal	//e.g. ph/um^2/s in which case output is still ph/um^2/s		//these could all be input parameters	Double pupilDia_mm	= 2		//2 is the low end, good for direct sunlight	Double eyeDia_mm = 19		//maybe more for monkey. got this from Hass et al. Rieke horwitz and didnt check their ref. others (webvision) say 22 mm for human	Double propOfEyeThatIsRetina = 0.72		//prop of eye covered by retina -- 72% according to webvision via a book I cant get, Michels et al. retinal detachment 	//end input parameters		//calculation	Double pupilArea_mm2 = pi*(pupilDia_mm/2)^2		Double eyeSA_mm2 = 4*pi*(eyeDia_mm/2)^2	Double retinaSA_mm2 = eyeSA_mm2 * propOfEyeThatIsRetina			return cornealVal*(pupilArea_mm2/retinaSA_mm2)		//for diffuse illumination, we're assuming that all the light coming into the pupil is evenly distruted across the retinaendfunction/D getPhotoisomerizations(absorptionSpectrum,irradSpectrum_phPerUm2PerS,collectingArea,outRef)	WAVE absorptionSpectrum,irradSpectrum_phPerUm2PerS	//these should have proper units/scaling and aligned x scaling	Double collectingArea		//e.g. 0.6 um^2 as Rieke lab uses	String outRef		//optionally save multiplied spectrum		matrixop/FREE/O multiplied = absorptionSpectrum * irradSpectrum_phPerUm2PerS * collectingArea		Double areaResult = area(multiplied)	Print "area under curve:",areaResult		if (strlen(outRef) > 0)		duplicate/o multiplied,$outRef	endif		return areaResult	endfunction placeCsrsG()	Variable hairLine = 0		// 0 = none, 1 = vert and horiz, 2 = vert, 3 = horiz	String topWindowTrace = StringFromList(0,TraceNameList("",";",2),";")	Wave topWindowWave = traceNameToWaveRef("", topWindowTrace)	Variable numPntsInWave = numpnts(topWindowWave)	Variable csrSpacing = numPntsInWave/5		Cursor A, $topWindowTrace, .1	Cursor B, $topWindowTrace, .7	Cursor/H=(hairLine)/P/S=1 C, $topWindowTrace, csrSpacing	Cursor/H=(hairLine)/P/S=1 D, $topWindowTrace, 2*csrSpacing	Cursor/H=(hairLine)/P/S=1 E, $topWindowTrace, 3*csrSpacing	Cursor/H=(hairLine)/P/S=1 F, $topWindowTrace, 4*csrSpacing	showinfoendfunction removeCsrs(BStruct) : ButtonControl	STRUCT WMButtonAction &BStruct	if (BStruct.eventCode != 1)		//only continues if button down		return 0	endif	Cursor/K C//, $StringFromList(0,topWindowTraces,";"), 0	Cursor/K D//, $StringFromList(0,topWindowTraces,";"), 0	Cursor/K E//, $StringFromList(0,topWindowTraces,";"), 0	Cursor/K F//, $StringFromList(0,topWindowTraces,";"), 0endfunction guiC_lb_setListByNumsTo(newNum, byNumsWaveName)	Variable newNum; String byNumsWaveName		Make/O/I/N=(1) $byNumsWaveName/wave=temp	temp[0] =  newNum	endfunction addToListByNums(addedNum, byNumsWaveName)	Variable addedNum; String byNumsWaveName		Duplicate/O/free $byNumsWaveName, byNumsWaveNameTempB 	redimension/i byNumsWaveNameTempB	Variable V_value		//find value stores the location of the specified value 	FindValue/I=(addedNum) byNumsWaveNameTempB	if (V_Value < 0)		Variable newNumPnts = numpnts(byNumsWaveNameTempB) + 1		Redimension/N=(newNumPnts) byNumsWaveNameTempB		byNumsWaveNameTempB[newNumPnts-1] = addedNum		Sort byNumsWaveNameTempB, byNumsWaveNameTempB		Duplicate/O byNumsWaveNameTempB, $byNumsWaveName		endifendfunction removeFromListByNums(removedNum, byNumsWaveName)	Variable removedNum; String byNumsWaveName	Duplicate/O $byNumsWaveName, byNumsWaveNameTempC 	Variable V_value		//find value stores the location of the specified value 	FindValue/I=(removedNum)/z byNumsWaveNameTempC 	if (V_Value != -1)		//then the number really is in the wave and really needs to be removed		DeletePoints V_Value, 1, byNumsWaveNameTempC 		Duplicate/O byNumsWaveNameTempC , $byNumsWaveName		endif	KillWaves/Z byNumsWaveNameTempC 	KillVariables/Z V_valueendfunction selectInclusiveSubsetNew(byNumsWaveName, selListWaveName)	String byNumsWaveName, selListWaveName		Duplicate/O $byNumsWaveName, byNumsWaveNameTempC	Duplicate/O $selListWaveName, selListWaveNameTempC	Variable firstPos = byNumsWaveNameTempC[0]	Variable oldNumPnts = dimsize(byNumsWaveNameTempC,0)	Variable lastPos = byNumsWaveNameTempC[oldNumPnts-1]	Variable numPntsIfFilled = lastPos - firstPos + 1	if (lastPos > (firstPos + 1) && (oldNumPnts < numPntsIfFilled))			//assures that we have at least one row to fill in		Make/O/I/N=(numPntsIfFilled) $"byNumsWaveNameTempC"		Variable i	//	for (i=0; i<numPntsIfFilled-1; i+=1)		for (i=0; i<numPntsIfFilled; i+=1)				byNumsWaveNameTempC[i] = firstPos + i			if (firstPos + i < dimsize(selListWaveNameTempC,0) )				selListWaveNameTempC[firstPos+i][0] = 1			endif		endfor	Duplicate/O byNumsWaveNameTempC, $byNumsWaveName	Duplicate/O selListWaveNameTempC, $selListWaveName	endif		KillWaves/Z byNumsWaveNameTempC, selListWaveNameTempCendfunction updateWaveListBox()		WAVE/T/Z codeList		if (strlen(codeList[0]) < 1)		//avoids issues when there are 0 wave lists made up		Print "Put a wave code in the code box!"		return 0	endif			KillWaves/Z finalWaveListTemp 					//makes sure nothing is stored in the wave in which each list wave will be combined	String waveCodeTemp, waveListString	Variable numCodes = numpnts(codeList)	Make/T/O/N=(1, numCodes) finalWaveListTemp	Variable i,j, numWavesWithCode, maxNumWaves = 0	for (i=0; i<numCodes;i+=1)		waveCodeTemp = codeList[i]		waveListString = WaveList(waveCodeTemp,";","text:0")		//text:0 specifies to ignore text waves		numWavesWithCode = ItemsInList(waveListString, ";")		//numWaves will be assumed to be equal!?		Make/O/T/N=(numWavesWithCode) currentWaveListTemp		for (j=0;j<numWavesWithCode;j+=1)			currentWaveListTemp[j] = StringFromList(j,waveListString)		endfor		if (numWavesWithCode > maxNumWaves)			maxNumWaves = numWavesWithCode			Redimension/N=(maxNumWaves,numCodes) finalWaveListTemp			//expands the number of rows in finalWaveListTemp if necessary to accomodate new list		endif		finalWaveListTemp[0,numWaveswithCode][i] = currentWaveListTemp[p]			//transfers each point in currentWaveListTemp to each row, starting at row 0, of column i in finalWaveListTemp	endfor		Duplicate/O finalWaveListTemp, waveListListWave	Make/O/N=(DimSize(waveListListWave,0), DimSize(waveListListWave,1)) waveListSelWave		//make a selection wave for the waveListListWave, with same dimensions		Variable numColumns = numpnts(codeList)	Make/O/T/N=(numColumns) waveListTitleWave			//title wave must match the number of columns	for (i=0;i<numColumns;i+=1)		waveListTitleWave[i] = "Code " + num2str(i)	endfor	ListBox waveListBox, listWave = waveListListWave, selWave = waveListSelWave, titleWave = waveListTitleWave, mode=4, win=mainPanel2	KillWaves/Z finalWaveListTemp, currentWaveListWaveTemp, finalSelListTemp, currentWaveSelListTemp, currentWaveListTempendfunction updateOverlayListBox()	WAVE/T/Z codeList, overlayListWave		Variable i,j, numGraphs = numpnts(codeList)	if (strlen(codeList[0]) < 1)		//avoids issues when there are 0 wave lists made up		Print "Put a wave code in the code box!"		return 0	endif		if (WaveExists(overlayListWave))	//	Duplicate/O/T overlayListWave, oldOverlayListWave	endif		Make/T/O/N=(numGraphs,7) overlayListWave	Make/O/N=(numGraphs,7) overlaySelWave	Make/O/T overlayTitleWave = {"Graph #","Overlay String", "axis % Start", "axis % End", "R", "G", "B"}	overlaySelWave[][1,7] = 2 //sets as editable	overlaySelWave[][0] = 0	String overlayStringTemp	for (i=0; i<numGraphs;i+=1)//		if (WaveExists(oldOverlayListWave) && (i < DimSize(oldOverlayListWave,0)))		//many programming languages return 0 if the first of two && statements is 0, hopefully true here so we dont get an error when oldOverlayWaveList doesnt exist...//			overlayListWave[i][1,6] = oldOverlayListWave[i][p]								//copies axis start and axis end settings only//		else			overlayListWave[i][2,3] = ""			if (i==0)			//color = red				overlayListWave[i][4] = "65280"				overlayListWave[i][5] = "0"				overlayListWave[i][6] = "0"			elseif (i==1)		//color = black				overlayListWave[i][4] = "0"				overlayListWave[i][5] = "0"				overlayListWave[i][6] = "0"						elseif (i==2)		//color = blue				overlayListWave[i][4] = "0"				overlayListWave[i][5] = "12800"				overlayListWave[i][6] =  "52224"					elseif(i==3)		//color = green				overlayListWave[i][4] = "0"				overlayListWave[i][5] = "26112"				overlayListWave[i][6] = "0"						elseif(i==4)		//color = magenta thing				overlayListWave[i][4] = "39168"				overlayListWave[i][5] ="0"				overlayListWave[i][6] = "31232"					endif	//		endif		overlayStringTemp = ""		overlayListWave[i][0] = num2str(i)		for (j=0;j<numGraphs;j+=1)		//make default string which is 0 for all graphs except the graph of the corresponding row. There is certainly a faster way to do this but I'm not going to bother right now			if (j==i)				overlayStringTemp += "1"			else				overlayStringTemp += "0"			endif		endfor		overlayListWave[i][1] = overlayStringTemp			endfor	KillWaves/Z oldOverlayListWave	ListBox overlayListBox, listWave=overlayListWave, selWave=overlaySelWave, titleWave=overlayTitleWave, mode=4,  win=mainPanel2endfunction updateMainGraph()	WAVE/Z waveListSelListByNums;WAVE/T waveListListWave, overlayListWave	SVAR currentGraphName			clearMainGraph()		if (numpnts(waveListSelListByNums) <1)		return 0	endif		Variable i,j=0	Variable numAxes = getAxisNum()			//number of axes with at least 1 in overlay code	Variable numPotentialOverlays = DimSize(overlayListWave,0)			//total number of wave lists that might be overlaid	Make/O/N=(numAxes, 3) axesPosList		//first point is actual axis num so that the proper overlay string can be taken		for (i=0;i<numPotentialOverlays;i+=1)		if (isAxisInUse(i))			axesPosList[j][0] = str2num(overlayListWave[i])			j+=1		endif	endfor		if (isAxisInputCorrect())		axesPosList[][1,2] = str2num(overlayListWave[axesPosList[p][0]][q+1])	else		Variable axisStart,axisEnd		Variable currentAxisEnd = 1		Variable axisSpacerSize = 0.02		Variable totalSizeForSpacers = axisSpacerSize*(numAxes-1)				//units for numbers will be % total graph height, subtract 1 because with 1 graph no spacer is needed, with 2 graphs, 1 is needed etc.		Variable axisSize = (1-totalSizeForSpacers)/numAxes		for (i=0;i<numAxes;i+=1)			axisEnd = currentAxisEnd			axisStart = axisEnd - axisSize			currentAxisEnd = axisStart - axisSpacerSize			if (axisStart < 0.01)		//avoids annoying precision errors where axisStart can be just a hair less than zero				axisStart = 0			endif			axesPosList[i][1] = axisStart			axesPosList[i][2] = axisEnd		endfor	endif		Variable sweepForAxisFound, currentWaveListIndex, waveNum, actualAxisNum, currR, currB, currG	String currentOverlayCode, currentAxisName, currentWaveRef	for (i=0;i<numAxes;i+=1)		sweepForAxisFound = 0		actualAxisNum = axesPosList[i][0]		currentOverlayCode = overlayListWave[actualAxisNum][1]		currentAxisName = "Left" + num2str(actualAxisNum)		for (j=0;j<strlen(currentOverlayCode);j+=1)			if (stringmatch(currentOverlayCode[j],"1"))				currR = str2num(overlayListWave[j][4])				currG = str2num(overlayListWave[j][5])				currB = str2num(overlayListWave[j][6])					for (waveNum=0;waveNum<DimSize(waveListSelListByNums,0);waveNum+=1)					currentWaveListIndex = waveListSelListByNums[waveNum]					currentWaveRef = waveListListWave[currentWaveListIndex][j]					if (strlen(currentWaveRef) > 0)						AppendToGraph/L=$currentAxisName/W=$currentGraphName/C=(currR, currG, currB) $currentWaveRef							sweepForAxisFound = 1					endif									endfor			endif		endfor		if (sweepForAxisFound)			ModifyGraph/W=$currentGraphName axisEnab($currentAxisName) = {axesPosList[i][1], axesPosList[i][2]}			ModifyGraph/W=$currentGraphName lblPos($currentAxisName)=52, freePos($currentAxisName) = 0		endif	endforendfunction getAxisNum()	//returns how many overlay strings are set to be used in the overlay listbox	WAVE/T overlayListWave		Variable i,j,numRowsWithOnePresent = 0, numOnesPresent = 0, numCodesInUse = DimSize(overlayListWave,0)	for (i=0;i<numCodesInUse;i+=1)		if (isAxisInUse(i))			numRowsWithOnePresent +=1		endif	endfor	return numRowsWithOnePresentendfunction isAxisInUse(axisNum)		//returns 1 if overlay string for axis contains at least 1 one AND at least one trace in the corresponding column is selected, or 0 if otherwise	Variable axisNum	WAVE/T overlayListWave, waveListListWave	WAVE waveListSelListByNums				String overlayString = overlayListWave[axisNum][1]	if (!stringmatch(overlayString,"*1*"))		return 0	endif		return 1endfunction isAxisInputCorrect()			//returns 1 if all axis settings in the overlay list box are present and between 0 and 1 as they should be, 0 otherwise	WAVE/T overlayListWave			Variable i, potentialAxisStart, potentialAxisEnd, numPotentialAxes = DimSize(overlayListWave,0)	Make/O/D/N=(numPotentialAxes,2) numericalAxisVals	numericalAxisVals[][] = str2num(overlayListWave[p][q+2])	if (wavemax(numericalAxisVals) > 1)		return 0	elseif (wavemin(numericalAxisVals) < 0)		return 0	elseif (numtype(sum(numericalAxisVals)) == 2)		return 0	else		return 1	endifend//removes all traces from main graphfunction clearMainGraph()	SVAR currentGraphName	String traceNameTemp	String graphContains = TraceNameList(currentGraphName,";",1) 	Variable numGraphs = ItemsInList(graphContains,";")		Variable i	for(i=0;i<numGraphs;i+=1)		traceNameTemp = StringFromList(i,graphContains)		RemoveFromGraph/Z/W=$currentGraphName $traceNameTemp	endforend//removes all traces whose names match matchStr from top graphfunction clearMainGraphMatchingTraces(matchStr)	String matchStr		SVAR currentGraphName	String traceNameTemp	String graphContains = TraceNameList(currentGraphName,";",1) 	Variable numGraphs = ItemsInList(graphContains,";")	Variable i	for(i=0;i<numGraphs;i+=1)		traceNameTemp = StringFromList(i,graphContains)		if (stringmatch(traceNameTemp, matchStr))			RemoveFromGraph/Z/W=$currentGraphName $traceNameTemp		endif	endforendfunction updateSelListByNumsGeneral(selWaveRef, selWaveByNumsRef)	String selWaveRef, selWaveByNumsRef				Duplicate/O $selWaveRef, byNumsSelWaveTemp	Variable numSelected = sum(byNumsSelWaveTemp)	Make/O/N=(numSelected) byNumsSelWaveByNumsTemp		Variable i,j=0			for (i=0;i<DimSize(byNumsSelWaveTemp,0);i+=1	)		//using dim units, 0 rather than num pnts might be essential for 2D sel waves		if (byNumsSelWaveTemp[i] > 0)	//this seems OK for 2D selwaves but not sure that it cant get sketchy			byNumsSelWaveByNumsTemp[j] = i			j+=1		//	if (j == numSelected)		//		break			//hopefully stops looking at cells at this point		//	endif		endif	endfor		Duplicate/O byNumsSelWaveByNumsTemp, $selWaveByNumsRef		KillWaves/Z byNumsSelWaveTemp, byNumsSelWaveByNumsTempend	function selectInclusiveSubsetGeneral(selWaveRef, selWaveByNumsRef)	String selWaveRef, selWaveByNumsRef		//assumes the by nums wave is up to date! Assumes selWaveByNums uses rows		Duplicate/O $selWaveRef, selWaveInclSubsetTemp	Duplicate/O $selWaveByNumsRef, selWaveByNumsInclSubsetTemp		Variable firstSelectionIndex = selWaveByNumsInclSubsetTemp[0]	Variable lastSelectionIndex = selWaveByNumsInclSubsetTemp[numpnts(selWaveByNumsInclSubsetTemp)-1]	selWaveInclSubsetTemp =0	selWaveInclSubsetTemp[firstSelectionIndex,lastSelectionIndex][0] = 1			//it appears critical important to specify second dimension as 0	Print "Number of selected waves: " + num2str(lastSelectionIndex-firstSelectionIndex+1) + "   BY SUM: " + num2str(sum(selWaveInclSubsetTemp))		Duplicate/O selWaveInclSubsetTemp, $selWaveRef	KillWaves/Z selWaveInclSubsetTemp, SelWaveByNumsInclSubsetTempend///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////NEW ANALYSIS FUNCTIONS/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////calculates statistics of a voltage command step, for use in calculating cell parameters etc. currently only works for the first step function analysis_cellParams_S_vCmd(vCmdRef,  vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step)	String vCmdRef; Variable &vCmd_t0, &vCmd_t1, &vCmd_baseline, &vCmd_step	Variable isNegativeStep = 1	Variable edgePadding = 0.0005		//used for edgeStats command, distance around step to use as basline. changed from 0.01 on 151229. changed again from 0.005 to 0.0005 on 160104	Variable edgeBaseAveraging = 15		//allows some presorting for steps within a certain range	Variable minStepSize = 0.001		//in V		minStepSize = isNegativeStep ? -minStepSize : minStepSize		//negative if negative going, positive if positive going				Variable baselineStart = 0.001			//in seconds	Variable baselineEnd = .009		//changed from 0.01 on 151229		Variable vCmd_t0Threshold = .75	//proportion of vCmd step at which we will say step begins. Probably not a good idea to set to 1	Variable vCmd_t1Threshold = .98	//proportion of vCmd step at which we will say step ends		debug_checkRTErrState(msg="IN VCMD THING 000000000000000000")		Duplicate_FD(vCmdRef, dupSaveRefOrRefs ="vCmd"); WAVE vCmd		//generated by duplicate_FD//	Duplicate/O $vCmdRef, vCmd	debug_checkRTErrState(msg="IN VCMD THING 1111111111111111")		Variable baseline = mean(vCmd, DimOffset(vCmd, 0) + baselineStart, DimOffset(vCmd, 0) + baselineEnd)		//dim offset allows for waves whose x timing doesnt start at 0		debug_checkRTErrState(msg="IN VCMD THING 222222222222")	Make/O/N=1 levels	FindLevels/Q/D=levels vCmd, baseline + minStepSize	Variable stepStart = levels[0]	Variable stepEnd = levels[1]		debug_checkRTErrState(msg="IN VCMD THING aaaaaaaaaaaaaaaaaaaaaaa")	//find step start at set threshold, track baseline and step values as well	EdgeStats/Q/A=(edgeBaseAveraging)/F=(1-vCmd_t0Threshold)/R=(stepStart-edgePadding, stepStart + edgePadding) vCmd	vCmd_t0 = V_EdgeLoc3	vCmd_baseline = V_EdgeLvl0	vCmd_step = V_EdgeLvl4		//find step end at set threshold	EdgeStats/Q/A=(edgeBaseAveraging)/F=(1-vCmd_t0Threshold)/R=(stepEnd-edgePadding, stepEnd + edgePadding) vCmd	vCmd_t1 = V_EdgeLoc1		debug_checkRTErrState(msg="IN VCMD THING")	KillWaves/Z vCmdend //analysis_cellparams_s_vcmd()function analysis_cpSimpleCmd_getInfo(cmdRef, stepExpected, isCC, baselineEndX,  isNegativeStep, outRef)	String cmdRef, outRef		//outRef is name where the ref wave will be stored containing cmd_t0, cmd_t1, cmd_baseline, cmd_step	Variable  stepExpected, isCC, baselineEndX,  isNegativeStep		Variable cmd_t0, cmd_t1, cmd_baseline, cmd_step		analysis_cellParamsSimple_cmd(cmdRef, stepExpected, isCC, baselineEndX,  isNegativeStep,  cmd_t0, cmd_t1, cmd_baseline, cmd_step, 0)	Make/O/D/N=4 $outRef/WAVE=out	out[0] = cmd_t0;out[1] =  cmd_t1;out[2] =  cmd_baseline;out[3] =  cmd_step		Print "cmd_t0",cmd_t0, "cmd_t1",cmd_t1,"cmd_baseline", cmd_baselineend//calls  analysis_getMultiStepInfo for step information, then averages region from one step to anotherfunction wave_avgRepSeries(cmdRef, respRef, isNegativeStep, searchStartX, minStepSize, outRef)	String cmdRef, respRef, outRef	Variable isNegativeStep, searchStartX,minStepSize	//out[0][i] = cmd_t0;out[1][i] =  cmd_t1;out[2][i] =  cmd_baseline;out[3][i] =  cmd_step;out[4][i] = cmd_final		String stepTimingRef = "temp_avgRepSeries"		analysis_getMultiStepInfo(cmdRef, isNegativeStep, searchStartX, minStepSize, stepTimingRef)		WAVE stepTiming = $stepTimingRef		Variable i, t0,t1, interStepInterval, numSteps = DimSize(stepTiming,1)	for (i=0;i<numSteps;i+=1)		t0 = stepTiming[0][i];// t1 = stepTiming[1][i]		if (i==0)			interStepInterval = numSteps > 1 ? stepTiming[0][i+1] - t0 : inf			Duplicate/O/R=(t0,t0 + interStepInterval) $respRef, $outRef/WAVE=out		else			Duplicate/O/R=(t0,t0 + interStepInterval)  $respRef, temp_reg_avgRepSeries			out += temp_reg_avgRepSeries		endif	endfor		out/= numSteps	SetScale/P x, 0, DimDelta($respRef,0), outend//finds steps in a wave and stores step information sequentially in a 2D wave (one row per step, one column per step parameter)function analysis_getMultiStepInfo(ref, isNegativeStep, searchStartX, minStepSize, outRef)	String ref, outRef	Variable isNegativeStep, searchStartX,minStepSize		Variable minSamplesBetweenSteps = 2	Variable minXBetweenSteps = minSamplesBetweenSteps * DimDelta($ref,0)		Variable i,stepFound = 1	//allows entry into for loop	Variable cmd_t0, cmd_t1, cmd_baseline, cmd_step, cmd_final	//will be instantiated by analysis_cellParamsSimple_cmd	Variable currSearchStartX = searchStartX	for (i=0; ;i+=1)		//run infinitely, breaks due to code within loop when no step found 		stepFound = analysis_cellParamsSimple_cmd(ref, 1, 0, currSearchStartX,  isNegativeStep,  cmd_t0, cmd_t1, cmd_baseline, cmd_step, 0, cmd_final=cmd_final,storeAndOrForceMinStepSize=minStepSize)		currSearchStartX = cmd_t1 + minXBetweenSteps				if (!stepFound)			break		endif				if (i==0)			Make/O/D/N=(5,1) $outRef/WAVE=out		else			Redimension/N=(-1,DimSize(out,1) + 1) out		endif		out[0][i] = cmd_t0;out[1][i] =  cmd_t1;out[2][i] =  cmd_baseline;out[3][i] =  cmd_step;out[4][i] = cmd_final		Print "i:",i, "cmd_t0",cmd_t0, "cmd_t1",cmd_t1,"cmd_baseline", cmd_baseline	endforend//calculates statistics of a voltage command step, for use in calculating cell parameters etc//based on analysis_cellparams_s_vcmd, but more general and memory efficient (no wave duplicates)//last 4 input parameters are passed back with found values//baselineEndX may just be any point before the step begins//returns 0 if no step found, 1 if foundfunction analysis_cellParamsSimple_cmd(cmdRef, stepExpected, isCC, baselineEndX,  isNegativeStep,  cmd_t0, cmd_t1, cmd_baseline, cmd_step, preCheckForStep, [cmd_final, storeAndOrForceMinStepSize])	String cmdRef; Variable isCC, baselineEndX, isNegativeStep, &cmd_t0, &cmd_t1, &cmd_baseline, &cmd_step	//isCC determines minStepSize 	Variable preCheckForStep			//pass 1 to check that an exursion from baseline large enough to surpass threshold will happen (involves a duplication so slows down procedure)	Variable stepExpected			//pass 1 for normal behavior, pass 0 to just calculate baseline (because no step is expected)	Variable &cmd_final				//pass to store the level that the step returns to	Variable &storeAndOrForceMinStepSize		//pass NaN to have this variable set to the min step size that is used by default for CC or VC (see minStepSize). pass a real value. should be POSITIVE to set minStepSize, sign changed depending on isNegativeStep		Variable baselineMeasurementDur = 0.04		//number of seconds BEFORE baselineEndX over which baseline is measured	Variable baselineStartX = baselineEndX - baselineMeasurementDur	Variable edgePadding = 0.0005		//used for edgeStats command, distance around step to use as basline. changed from 0.01 on 151229. changed again from 0.005 to 0.0005 on 160104	Variable edgeBaseAveraging = 15		//set threshold for even looking for a step to analyze	Variable minStepSizeBuffer = isCC ? .8*10^-12 : 0.0008		//in A or V//	Variable minStepSizeBuffer = isCC ? .1*10^-12 : 0.0001		//in A or V		Variable preSteMean = mean($cmdRef, baselineStartX, baselineEndX)		Variable preStepMinDelta = wavemin($cmdRef, baselineStartX, baselineEndX) - preSteMean	Variable preStepMaxDelta = wavemax($cmdRef, baselineStartX, baselineEndX) - preSteMean	Variable minStepSize = abs(preStepMinDelta) > abs(preStepMaxDelta) ? abs(preStepMinDelta) : abs(preStepMaxDelta)	minStepSize += minStepSizeBuffer	//handle parameterized version	if (!ParamIsDefault(storeAndOrForceMinStepSize))		if (numtype(storeAndOrForceMinStepSize))			//non-real input, set to used (default) step size			storeAndOrForceMinStepSize = minStepSize		else				//real input, use this for the step size			minStepSize = storeAndOrForceMinStepSize		endif	endif		minStepSize = isNegativeStep ? -minStepSize : minStepSize		//negative if negative going, positive if positive going			Variable cmd_t0Threshold = .75	//proportion of vCmd step at which we will say step begins. Probably not a good idea to set to 1	Variable cmd_t1Threshold = .98	//proportion of vCmd step at which we will say step ends		WAVE cmd = $cmdRef	Variable baseline = mean(cmd, baselineStartX, baselineEndX)		if (!stepExpected)		cmd_baseline = baseline		return 0	endif		//initial (simple) check that step might actually exist	if (preCheckForStep)		if (isNegativeStep)			if (wavemin(cmd) - baseline > minStepSize)		//is largest change from baseline LESS negative than (negative-going) threshold?				cmd_baseline = baseline				return 0			endif		else			if (wavemax(cmd) - baseline < minStepSize)		//converse for a positive going threshold				cmd_baseline = baseline				return 0			endif		endif	endif			Make/O/N=2 levels	FindLevels/Q/D=levels/R=(baselineEndX,) cmd, baseline + minStepSize		if (V_flag == 2)		//no crossing found		return 0	endif		Variable stepStart = levels[0]	Variable hasStepEnd, stepEnd		if (dimsize(levels,0) > 1)		//two crossings found, in which case we want to store some info about the end of the step		 stepEnd = levels[1]		 hasStepEnd = 1	else		stepEnd = nan		hasStepEnd = 0	endif		//get info on the start of the step	//find step start at set threshold, track baseline and step values as well	EdgeStats/Q/A=(edgeBaseAveraging)/F=(1-cmd_t0Threshold)/R=(stepStart-edgePadding, stepStart + edgePadding) cmd	cmd_t0 = V_EdgeLoc3	cmd_baseline = V_EdgeLvl0	cmd_step = V_EdgeLvl4		if (V_flag == 2)		return 0	endif		if (hasStepEnd)		//find step end at set threshold		EdgeStats/Q/A=(edgeBaseAveraging)/F=(1-cmd_t0Threshold)/R=(stepEnd-edgePadding, stepEnd + edgePadding) cmd		cmd_t1 = V_EdgeLoc1		if (!ParamIsDefault(cmd_final))			cmd_final = V_EdgeLvl4		endif				return 2	else		cmd_t1 = nan		if (!ParamIsDefault(cmd_final))			cmd_final = nan		endif							return 1	endifend//analysis_cellParamsSimple_cmd()//fit an individual sweep to an exponential//generates three summary waves://genParams: overall information on response (input resistance etc.)//fitParams:  fit statistics and cell parameters derived from those statistics//coef wave: rows are coefwaves generated from fits, each row for an increasing fit //in addition an optional text wave is generated://listOfFitWaves that stores references to fits and fit components for each model (where one model is an exponential fit with some number of exponential components)function/S analysis_cellParams_S(currentRef, vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step, [genParamsSaveRef, fitParamsSaveRef,  coefWaveSaveRef, waveToSubtractRef, originalCurrentWaveSaveRef, finalCurrentWaveSaveRef, fitWaveSaveRef, fitComponentsAppendStr, fitResidualsSaveRef, fitWavesListWaveRef, allFullFitsDisplayN, allComponentsDisplayN])	String currentRef			//reference to the wave to be analyzed	Variable vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step		//information on the voltage command that was given t0 is step start, t1 is step end, baseline is v_hold before step, step is Vcmd during step	//optional parameters: tells the function what aspects of analysis to save and where to save them. Do not pass displayFits = 1 unless saving fit waves in fitWaveSaveRef (as well as fit components append string 	String genParamsSaveRef					//a reference to which general parameters wave will be saved	String fitParamsSaveRef					//a reference to which fit parameters wave will be saved	String coefWaveSaveRef					//a reference to which coef waves will be saved	String waveToSubtractRef					//a reference to a wave to subtract from currentRef wave (e.g. pipette capacitance before break in). Subtraction only performed if this is passed	String originalCurrentWaveSaveRef			//if original current wave is to be saved, a ref to which it will be saved	String finalCurrentWaveSaveRef			//if final (subtracted) current wave is to be saved, a ref to which it will be saved	String fitWaveSaveRef						//if model waves (sum of fit components) are to be saved, this is the ref in which they will be saved, with [modelNum] following, where for a single exponential fit model num = 0	String fitComponentsAppendStr			//if model wave fit components are to be saved, this will be appended to fitWaveSaveRef[model num], followed by component number from 0, as a reference to save the component in	String fitResidualsSaveRef					//if model wave residuals are to be saved, this will be the ref in which they are saved, with [model num] following, where for a single exponential fit model num = 0	String fitWavesListWaveRef				//a reference to which can be saved a text wave storing refereneces and other information about each fit wave that has been generated	String allFullFitsDisplayN					//a window name on which to display all full models. Only displayed if full models are saved	String allComponentsDisplayN				//a window name that will be the base name for a window for each model, in which each full model (if saved) and each component will be displayed. Only used if full models AND components are saved	Variable saveFinalCurrentWave = 0		Duplicate/O $currentRef, currentResp			String finalCurrentWaveSaveRefUsed = "currentResp"		//tracks which ref will be used, the temp name (if no original wave ref is passed) or the original wave save name, if passed (allows later display). Replaced by subtracted ref if subtraction performed	if (!ParamIsDefault(originalCurrentWaveSaveRef))			if (!equalwaves($currentRef, $originalCurrentWaveSaveRef,-1))			Duplicate/O $currentRef, $originalCurrentWaveSaveRef			//may be where we are getting into trouble with cannot overwrite self!!!!!!!!!!!!!!!!!!!!!!		endif		finalCurrentWaveSaveRefUsed = originalCurrentWaveSaveRef	endif				Variable moreFreeParamsJustifiedThresh= 0.05		//p value from f statistic below which we will say this model is justified	Variable lastPassingModel = 0						//tracks the last model that passed		//choose windows for baseline and steady state measurements	Variable winPadding = 0.001		//in S, amount of time between baseline window ending and step start/end	Variable ssWinSize = 0.004	Variable baseWinStartX = vCmd_t0 - ssWinSize - winPadding	Variable baseWinEndX = vCmd_t0 - winPadding	Variable ssWinStartX = vCmd_t1 - ssWinSize  - winPadding	Variable ssWinEndX = vCmd_t1 - winPadding		//other things to set to start with	Variable fitWinSize = 0.00125	Variable maxNumExps = 5			//maximum number of exponential components to test for	Variable y0InitialGuess = 0	Variable amplitudeInitialGuess = -400 * 10 ^-12	Variable tauInitialGuess = 0.0002			//calculate (steady state) input resistance	Variable deltaVoltage = vCmd_step - vCmd_baseline	Variable baseCurrent = mean(currentResp, baseWinStartX,baseWinEndX)	Variable ssCurrent = mean(currentResp, ssWinStartX,ssWinEndX)	Variable deltaSSCurrent = ssCurrent - baseCurrent	Variable ssRin = deltaVoltage / deltaSSCurrent			String noteSubStr = ""			//for storing as a note with outputs, identifies the wave that was subtracted	Variable subtracted = 0		//stores whether a subtraction has been performed	if (!ParamIsDefault(waveToSubtractRef))		if (WaveExists($waveToSubtractRef))			Duplicate/O $waveToSubtractRef, toSubTemp			currentResp -= toSubTemp			if (!ParamIsDefault(finalCurrentWaveSaveRef)) 		//only save if passed				Duplicate/O currentResp, $finalCurrentWaveSaveRef			endif			KillWaves/Z toSubTemp			subtracted = 1			noteSubStr = waveToSubtractRef			finalCurrentWaveSaveRefUsed = waveToSubtractRef		else			//if wave ref is passed but that reference is invalid, then warn user (and continue without subtraction)			Print "Wave to subtract (" + waveToSubtractRef + ") not found. No wave subtracted!"		endif	endif		//find peak of the capacity transient. Want to start fit at this peak, even if it's after t0, because we don't want to fit to values that are lower than and precede the peak	WaveStats/Q/R=(vCmd_t0, ssWinStartX) currentResp	Variable peakLoc, peakVal	if (deltaVoltage < 0)	//then step is negative, so peak is a minimum		peakLoc = V_minloc		//Might have to NVAR in V_minloc and V_maxloc, but not today...		peakVal = V_min - baseCurrent			//at step, all current flowing through access resistance, giving capactive transient. Subtract baseline to get delta for this capacitive current	else		peakLoc = V_maxloc		peakVal = V_max - baseCurrent	endif			Variable/G x0 = peakLoc				//important for the fitting function to have this global variable set. Though there is a way to pass to a fit function, but I haven't implemented it	Make/O/D/N=1 coefWave				//stores each coefWave (in rows), redimensioned as needed 	Make/O/D/N=(maxNumExps, 1) coefWaveSave		//stores all the coefWaves, one row for each model, each column a different fit coef (e.g. 0 = y0, 1 = A1, 2=tau1, 3=A2, 4 = tau2, etc.) columns redimensioned as needed	coefWave = y0InitialGuess				//first y0 intial guess set		Variable numFitParams = 20	Make/O/T/N=(maxNumExps) fitsTemp							//text wave that stores information (references to fits etc.) for each model. one row per model	Make/O/D/N=(maxNumExps, numFitParams) fitParamsTemp		//stores ss_Residuals etc. for each fit. one row per model		Note fitsTemp, "REF: " + currentRef + ";SUB:" + noteSubStr + ";"	Note fitParamsTemp, "REF: " + currentRef + ";SUB:" + noteSubStr + ";"		String coefFitWaveNStart = currentRef + "_F"			//default append if fitWaveSaveRef not passed. Final save wave is just this (or what's passed) for the whole model for the whole model, and indidual components have this + usedFitComponentAppendStr + [component #]	Variable saveFinalFit = 0								//default is not to save fit waves, though they will be temporarily stored in coefFitWaveNStart 	if (!ParamIsDefault(fitWaveSaveRef))		coefFitWaveNStart = fitWaveSaveRef		saveFinalFit = 1	endif		String residualsFitWaveNStart = currentRef + "_R"	Variable saveResiduals = 0	if (!ParamIsDefault(fitResidualsSaveRef))		residualsFitWaveNStart = fitResidualsSaveRef		saveResiduals = 1	endif		String usedFitComponentAppendStr = "C"			//default append string to mark components. added to coefFitWaveNStart with number of component after C	Variable saveComponents = 0	if (!ParamIsDefault(fitComponentsAppendStr))		usedFitComponentAppendStr = fitComponentsAppendStr		saveComponents = 1	endif		String currFitWavesN, currFitComponentWaveSaveName, currResidualsSaveN, currComponentDisplayN		Variable i, curr_ss_Res, curr_ss_Reg, curr_ss_Tot, curr_r2, curr_x2, curr_numSamples	//former is iterate through each fit, latter will values calculated by calcFitWave	Variable f_numer, f_denom	Make/O/D/N=1 componentParams									//1+i rows where i = numExps. 0th row holds params for sum of all component, 1st, 2nd, etc. for each component in turn	NVAR numResNeg, numerNumerNeg	//iterate through and fit to as many exponentials as one wants	for (i=0;i<maxNumExps;i+=1)		Redimension/N=(DimSize(coefWave,0) + 2) coefWave		Redimension/N=(-1, DimSize(coefWave,0) + 2) coefWaveSave		coefWave[1+2*i] = amplitudeInitialGuess		coefWave[1+2*i + 1] = tauInitialGuess		FuncFit/NTHR=0/W=2/N=1/Q=1 myExp, coefWave, currentResp[x2pnt(currentResp, peakLoc), x2pnt(currentResp, peakLoc + fitWinSize)]				//for saving full models, fit components, and residuals! must be passed even if not saving so that statistics can be gotten		currFitWavesN = coefFitWaveNStart + num2str(i)									//sets full model save name as coefFitWaveNStart + model #		(0 = monoexponential, 1 = biexponential, and so on)		currFitComponentWaveSaveName = currFitWavesN + usedFitComponentAppendStr		//sets component save name as coefFitWaveNStart + model +  usedFitComponentAppendStr. makeFitWaves will append 0,1,2,etc. for component number		currResidualsSaveN =  residualsFitWaveNStart + num2str(i)							//sets full model residuals save name as residualsFitWaveNStart + model #		Note/K coefWave, "FITWIN_X: " + num2str(peakLoc) + "," + num2str(peakLoc + fitWinSize) + ";" + "DATAWAVE: " + finalCurrentWaveSaveRefUsed + ";" + "FIT_x0: " + num2str(x0) + ";"		//stupid but functioning way of passing this info on		Note coefWaveSave, "FITWIN_X: " + num2str(peakLoc) + "," + num2str(peakLoc + fitWinSize) + ";" + "DATAWAVE: " + finalCurrentWaveSaveRefUsed + ";" + "FIT_x0: " + num2str(x0) + ";" + "|" + ";"		// "|" allows iterating through with StringFromList(i, list, "|")				//makeFitWaves returns a string list (semicolon delim.): coefWaveRef, origWaveRef, finalFitRef, residualsRef, fitComponent1Ref, fitComponent2Ref,... a reference to each newly created wave		fitsTemp[i] = makeFitWaves(coefWave, i, baseCurrent, deltaVoltage, x0,componentParams, curr_numSamples, curr_ss_Res, curr_ss_Reg, curr_ss_Tot, curr_r2, curr_x2, coefWaveSaveRef, currFitWavesN, currFitComponentWaveSaveName, currResidualsSaveN, saveFinalFit, saveComponents, saveResiduals)				fitParamsTemp[i][0] = curr_ss_Res						//0 is sum of squares of residuals		fitParamsTemp[i][1] = curr_ss_Reg						//1 is sum of squares of the regression (predicted y - sample mean for each sample)		fitParamsTemp[i][2] = curr_ss_Tot						//2 is total sum of squares calculated directly from data (should be independent of fit)		fitParamsTemp[i][3] = curr_r2							//r2 value 1 - (ss_Res / ss_Tot)		fitParamsTemp[i][4] = curr_x2							//chi-squared value ss_Res/ sum(predicted values) NOT FUNCTIONING / TRUSTWORTHY AT LEAST FOR NEGATIVE VALUES. Could maybe use V_chisq from curve fit if wanted to				fitParamsTemp[i][5] = 	statsChiCDF(curr_x2, DimSize(coefWave,0))							//p value for chi-squared 		fitParamsTemp[i][6] = 	curr_ss_Res + curr_ss_Reg		//total sum of squares calculated from ss_Res + ss_Reg. sHould squal ss_Tot?				fitParamsTemp[i][7] = DimSize(coefWave,0)			//number of free parameters in model		fitParamsTemp[i][8] = curr_numSamples//DimSize($StringFromList(2, fitsTemp[i]), 0)		//number of samples (e.g. length of wave that is fit, in points		fitParamsTemp[i][9] = curr_ss_Res / (fitParamsTemp[i][8] - fitParamsTemp[i][7])		//F test demoninator: Mean of residuals: sum of squares of residuals / d.f. for that (sample N - num free parameters)		if (fitParamsTemp[i][9]  < 0)			numResNeg +=1		endif				if (i > 0)	//then this is a model with more than one exponential and so we will perform and f test to quantify the extent to which it's statistically justified			//relative to 1st fit						fitParamsTemp[i][10] = (fitParamsTemp[0][0] - fitParamsTemp[i][0]) / (fitParamsTemp[i][7] - fitParamsTemp[0][7])			//f test numerator: (ss_Res_reduced - ss_Res_full) / (df_full - df_reduced). demoniator calculated in 5			fitParamsTemp[i][11] = fitParamsTemp[i][10] / fitParamsTemp[i][9]				//f score			if (fitParamsTemp[i][10] < 0)				numerNumerNeg +=1				fitParamsTemp[i][12] = 1			else				fitParamsTemp[i][12] = 1 - StatsFCDF(fitParamsTemp[i][11], fitParamsTemp[i][7] - fitParamsTemp[0][7], fitParamsTemp[i][8] - fitParamsTemp[i][7]) 		//p value: f score, difference in free params, d.f. for sum of squares of residuals?			endif			//relative to last fit			fitParamsTemp[i][13] = (fitParamsTemp[i-1][0] - fitParamsTemp[i][0]) / (fitParamsTemp[i][7] - fitParamsTemp[i-1][7])			//f test numerator: (ss_Res_reduced - ss_Res_full) / (df_full - df_reduced). demoniator calculated in 5			fitParamsTemp[i][14] = fitParamsTemp[i][13] / fitParamsTemp[i][9]				//f score			fitParamsTemp[i][15] = 1 - StatsFCDF(fitParamsTemp[i][14], fitParamsTemp[i][7] - fitParamsTemp[i-1][7], fitParamsTemp[i][8] - fitParamsTemp[i][7]) 		//p value: f score, difference in free params, d.f. for sum of squares of residuals?					if (fitParamsTemp[i][15] < moreFreeParamsJustifiedThresh)				lastPassingModel = i			endif				endif		//display fits					//Store model and component parameters from componentParams. This has the form row 0 is overall model, 1, 2, 3... are components. columns: 0 = Imax, 1 = Ra, 2 = Rm, 3 = Cm		Variable currComponent, numComponentsInclFull = i + 2		Variable startColumn = numFitParams		Variable numParamsPerCompartment = DimSize(componentParams, 1)				Redimension/N=(-1, startColumn + numComponentsInclFull * numParamsPerCompartment) fitParamsTemp		//make room for 4 more parameters per component		Variable currParamCol		for (currComponent  = 0 ; currComponent < numComponentsInclFull; currComponent +=1)			for (currParamCol = 0; currParamCol < numParamsPerCompartment; currParamCol += 1)				fitParamsTemp[i][startColumn + currComponent*numParamsPerCompartment + currParamCol ] = componentParams[currComponent][currParamCol]	//0 = Imax, 1 = Ra, 2 = Rm, 3 = Cm (for weighted avg tau for Rm), 4 = SA from Cm, 5 = radius from SA if sphere			endfor		endfor				Note fitParamsTemp "FIRST_VARIABLE_PARAM_COL: " + num2str(numFitParams)		fitParamsTemp[i][16] = numComponentsInclFull - 1			//num components in this model		fitParamsTemp[i][17] = numParamsPerCompartment			//num parameters saved. Index to parameter in given fit: fitParamsTemp[numExpsOfFit][firstVariableParamCol + [if full: 0, if component:1] + (isComponent? = 1) * (whichComponent)*num...?																		fitParamsTemp[i][17] = getDimSegmentStats(1, 3, "componentParams", "V_sum", startP=1, endP=inf) 		//total Cm for the components of this fit: sum down Cm column across components but not total		fitParamsTemp[i][18] = getDimSegmentStats(1, 4, "componentParams", "V_sum", startP=1, endP=inf) 		//total SA for the components of this fit: sum down SA column		fitParamsTemp[i][19] = getDimSegmentStats(1, 5, "componentParams", "V_sum", startP=1, endP=inf) 		//total radius for the components of this fit: sum down radius column (for completeness)					//store coefWave in coefWaveSave		coefWaveSave[i][0, DimSize(coefWave,0)-1] = coefWave[q]		//transfers all rows of coefWave into one row of coefSaveWave, that row = expNum			endfor	//finished iterating through exponential fits		//dispay fits	if (!ParamIsDefault(allFullFitsDisplayN))		String subtractedDisplayInput = ""		if (subtracted)			if (!ParamIsDefault(originalCurrentWaveSaveRef))				subtractedDisplayInput = originalCurrentWaveSaveRef			else				subtractedDisplayInput = currentRef			endif		endif				for (i=0;i<maxNumExps;i+=1)			if (!ParamIsDefault(allComponentsDisplayN))				currComponentDisplayN = allComponentsDisplayN + "_" + num2str(i)				plotExpFits (fitsTemp[i], subtractedDisplayInput, allFullFitsDisplayN, currComponentDisplayN=currComponentDisplayN)			else				plotExpFits (fitsTemp[i], subtractedDisplayInput, allFullFitsDisplayN)			endif		endfor	endif		if (!ParamIsDefault(coefWaveSaveRef))		Duplicate/O coefWaveSave, $coefWaveSaveRef	endif		if (!ParamIsDefault(fitWavesListWaveRef))		Duplicate/O fitsTemp, $fitWavesListWaveRef	endif		//store parameters of interest:	Variable numGenParams = 25		Make/O/D/N=(numGenParams) genParamsTemp		//input resistance related parameters:	genParamsTemp[0] = NaN										//placeholder for time elapsed since break in sweep	genParamsTemp[1] = text_getInfoFromWaveName_V(currentRef, 1)			//file num	genParamsTemp[2] = text_getInfoFromWaveName_V(currentRef, 2)			//sweep num	genParamsTemp[3] = vCmd_baseline								genParamsTemp[4] = vCmd_step 	genParamsTemp[5] = deltaVoltage	genParamsTemp[6] = baseCurrent	genParamsTemp[7] = ssCurrent	genParamsTemp[8] = deltaSSCurrent	genParamsTemp[9] = ssRin	genParamsTemp[10] = lastPassingModel	genParamsTemp[11] = fitParamsTemp[lastPassingModel][startColumn + 0 + 1]			//Ra of best fitting full model	genParamsTemp[12] = fd_note_getSRate(currentRef)						//stores sample rate	genParamsTemp[13] = fitPAramsTemp[0][0]	genParamsTemp[14] = fitPAramsTemp[0][1]	genParamsTemp[15] = fitPAramsTemp[0][2]	genParamsTemp[16] = fitPAramsTemp[0][3]	genParamsTemp[17] = fitPAramsTemp[0][4]	genParamsTemp[18] = fitParamsTemp[0][11]			//f test model 0	genParamsTemp[19] = fitParamsTemp[0][12]			//p value 0	genParamsTemp[20] = fitParamsTemp[0][7]	 		//num free params model 0	genParamsTemp[21] = fitParamsTemp[0][8]	  		//numpnts model 0 (same across all)	genParamsTemp[22] = fitParamsTemp[1][11]			//f test model 1	genParamsTemp[23] = fitParamsTemp[1][12]			//p value model 1	genParamsTemp[19] = fitParamsTemp[2][11]			//f test model 2	genParamsTemp[20] = fitParamsTemp[2][12]	genParamsTemp[21] = fitParamsTemp[3][11]			//f test model 3	genParamsTemp[22] = fitParamsTemp[3][12]	genParamsTemp[23] = fitParamsTemp[4][11]			//f test model 4	genParamsTemp[24] = fitParamsTemp[4][12]		if (!ParamIsDefault(genParamsSaveRef))				Duplicate/O genParamsTemp, $genParamsSaveRef	endif		if (!ParamIsDefault(fitParamsSaveRef))		Duplicate/O fitParamsTemp, $fitParamsSaveRef	endif			KillWaves/Z currentTemp //, fitParamsTemp, componentParams, coefWaveSave, coefWave, genParamsTemp, end		//analysis_cellParams_Sfunction analysis_cellParams_S3(currentRef, vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step, genAndFitParamsSaveRef, compParamsSaveRef,  coefWaveSaveRef, waveToSubRef, redisplayRef, enforcedCapPeakTimeX, brkInSweepRef)	String currentRef			//reference to the wave to be analyzed	Variable vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step		//information on the voltage command that was given t0 is step start, t1 is step end, baseline is v_hold before step, step is Vcmd during step	String genAndFitParamsSaveRef					//a reference to which general parameters wave will be saved	String compParamsSaveRef					//a reference to which fit parameters wave will be saved	String coefWaveSaveRef					//a reference to which coef waves will be saved	Variable enforcedCapPeakTimeX			//NOT USED IF NEGATIVE (Default)	String brkInSweepRef						//for recording time since break in sweep. Leave blank if unknown and everything will work but time since brk in sweep will be left blank	//optional parameters: tells the function what aspects of analysis to save and where to save them. Do not pass displayFits = 1 unless saving fit waves in fitWaveSaveRef (as well as fit components append string 	String waveToSubRef						//a reference to a wave to subtract from currentRef wave (e.g. pipette capacitance before break in). Subtraction only performed if this is passed	String redisplayRef						//reference to redisplay wave which has wave refs in which raw data can be stored for redisplay		//load headers	analysis_getCoefWaveHeader(); analysis_getCompParamsHeader(5); analysis_getGenParamsHeader(0)	debug_checkRTErrState(msg="AA")					Print "currentRef = "  + currentRef + ". wavetoSubRef = " + waveToSubRef + ". redisplayRef = " + redisplayRef					Variable moreFreeParamsJustifiedThresh= 0.05		//p value from f statistic below which we will say this model is justified	Variable lastPassingModel = 0						//tracks the last model that passed		//other things to set to start with	Variable stepLength = vCmd_t1 - vCmd_t0		//calcualte step duration to assure that fit window falls within step only  (see fit win size limit below for the use of this)	Variable timeAllowedForResponseToPeak = 1e-4		//estimate time to peak (see fit win size limit below for the use of this)	Variable fitWinSize = .01//.002 //				ORIGINAL USED: 0.00125. Appending _2 for 2 ms fits. Used 10 ms for 20 ms window.	Variable fitWinTruncated 	if (fitWinSize < stepLength)		fitWinTruncated = 0	else		fitWinSize = stepLength - timeAllowedForResponseToPeak //fit win size cannot be longer than step length - estimated time to peak		fitWinTruncated = 1	endif	Variable maxNumExps = 5			//maximum number of exponential components to test for	Variable y0InitialGuess		// = 0		NOW SET AFTER FINDING BASELINE, AS OF DEC 10th 2015	Variable amplitudeInitialGuess		// = -400 * 10 ^-12 NOW SET AFTER FINDING PEAK, AS OF DEC 10th 2015	Variable tauInitialGuess = 2e-4		Variable lastSS		Variable ampPadding = 0.500*10^-12			//amount by which any exponential fit component peak may be greater than the actual found peak	Variable foldDiffTauSampleInterval = 0				//how much slower tau must be than sampling, e.g. 2 = tau must be twice as slow as the sample interval. seems to strangly affect some waves whose result when this is zero is within the bounds	String ampConstraintStr		//amp must be negative (see below, changed to positive for positive-going steps	Make/O/T tauConstraints = {"K2 > " + num2str(foldDiffTauSampleInterval*DimDelta($currentRef,0))} 	//tau must be positive (left) and slower than twice the sampling interval (right)	Make/O/T/N=2 ampConstraints	if ( (vCmd_step - vCmd_baseline) > 0)		//positive-going step		ampConstraints[0] =  "K1 > 0"	//constain amplitude to be positive	else		ampConstraints[0] =  "K1 < 0" //constrain to be negative for negative going steps	endif	Variable numTauConstraints = DimSize(tauConstraints,0)	Variable numAmpConstraints =  DimSize(ampConstraints,0)	Variable numConstraints = numTauConstraints + numAmpConstraints			//choose windows for baseline and steady state measurements	Variable winPadding = 0.0005		//in S, amount of time between baseline window ending and step start/end. changed from 1 ms to 0.5 ms on 151230	Variable ssWinSize = 0.001		//changed from 4 ms to 1 ms on 151230	Variable baseWinStartX = vCmd_t0 - ssWinSize - winPadding	Variable baseWinEndX = vCmd_t0 - winPadding	Variable ssWinStartX, ssWinEndX	ssWinStartX = vCmd_t0 + fitWinSize - ssWinSize	ssWinEndX = vCmd_t0 + fitWinSize			Duplicate_FD(currentRef, dupSaveRefOrRefs ="currentResp"); WAVE currentResp	//	Duplicate/O $currentRef, currentResp	//current ref is used for display if doDisplay = 1. If subtraction is being performed (see next), then subbedWaveRef is also used for display (if doDisplay = 1)		debug_checkRTErrState(msg="AAAAAAAAAasdsadwadawdwadwaAAAAAA")	//calculate (steady state) input resistance	Variable deltaVoltage = vCmd_step - vCmd_baseline	Variable baseCurrent = mean(currentResp, baseWinStartX,baseWinEndX)	Variable ssCurrent = mean(currentResp, ssWinStartX,ssWinEndX)	Variable deltaSSCurrent = ssCurrent - baseCurrent	Variable ssRin = deltaVoltage / deltaSSCurrent		y0InitialGuess = ssCurrent	Print "StepLen= " + num2str(stepLength) + ". fitWinSize= " + num2str(fitWinSize) + "deltaVoltage=" + num2str(deltaVoltage) + ". ssWinStartX= " + num2str(ssWinStartX) + ". ssWinEndX= " + num2str(ssWinEndX) + ". baseCurent=" + num2str(baseCurrent) + ". ssCurrent=" + num2str(ssCurrent) + ". deltaCurrent=" + num2str(deltaSSCurrent) + ". Rin=" + num2str(ssRin) +". y0 guess = " + num2str(ssCurrent)		debug_checkRTErrState(msg="AAAAAAAAAAAAAAA")		if (strlen(waveToSubRef) > 0)		//do sub		Print "sub on " + currentRef		Duplicate_FD(waveToSubRef, dupSaveRefOrRefs ="waveToSubTemp"); WAVE waveToSubTemp		//	Duplicate/O $waveToSubRef, waveToSubTemp		currentResp -= wavetoSubTemp		KillWaves/Z waveToSubTemp	else		Print "NO sub on " + currentRef	endif		//find peak of the capacity transient. Want to start fit at this peak, even if it's after t0, because we don't want to fit to values that are lower than and precede the peak	WaveStats/Q/R=(vCmd_t0, ssWinStartX) currentResp	Variable peakLoc, peakVal	if (deltaVoltage < 0)	//then step is negative, so peak is a minimum		peakLoc = V_minloc		//Might have to NVAR in V_minloc and V_maxloc, but not today...		peakVal = V_min - baseCurrent			//at step, all current flowing through access resistance, giving capactive transient. Subtract baseline to get delta for this capacitive current				ampConstraints[1] = "K1 > "		//number limit appended below if statement			else		peakLoc = V_maxloc		peakVal = V_max - baseCurrent				ampConstraints[1] = "K1 < " //number limit appended below if statement	endif			if (enforcedCapPeakTimeX >= 0)		peakLoc = enforcedCapPeakTimeX	endif		amplitudeInitialGuess = peakVal - y0InitialGuess	ampConstraints[1] += num2str(amplitudeInitialGuess + ((deltaVoltage < 0)? -1:1)*ampPadding)	Print "amp guess = " + num2str(amplitudeInitialGuess) + ". t0 = " +num2str(vcmd_t0) + ". peakLoc = " + num2str(peakLoc) + ". peakVal = " + num2str(peakVal)		Variable fitStartX = peakLoc	Variable fitEndX = peakLoc + fitWinSize	Variable fitStartP = x2pnt(currentResp, fitStartX)	Variable fitEndP = x2pnt(currentResp, fitEndX)		debug_checkRTErrState(msg="BBBB")		Variable/G x0 = peakLoc				//important for the fitting function to have this global variable set. Though there is a way to pass to a fit function, but I haven't implemented it	Make/O/D/N=1 coefWave				//stores each coefWave (in rows), redimensioned as needed 	coefWave[0] = y0InitialGuess				//first y0 intial guess set		Variable numFitParams = 20	Make/O/T/N=(maxNumExps) fitsTemp							//text wave that stores information (references to fits etc.) for each model. one row per model	Make/O/D/N=(maxNumExps, numFitParams) fitParamsTemp		//stores ss_Residuals etc. for each fit. numFitParams rows per model. iterate with (currModelNum * numFitParams) + currParamNum	Make/O/D/N=(maxNumExps) fitErrorTrackerTemp		Note fitsTemp, "REF: " + currentRef + ";SUB:" + waveToSubRef + ";"	Note fitParamsTemp, "REF: " + currentRef + ";SUB:" + waveToSubRef + ";"			Variable i, curr_ss_Res, curr_ss_Reg, curr_ss_Tot, curr_r2, curr_x2, curr_numSamples, numComponentParams	//former is iterate through each fit, latter will values calculated by calcFitWave	Variable f_numer, f_denom		//saving fits	String currModelSaveRef,currFitComponentSaveStart		//spacing between model fit params: 	Variable spacer = inf		Variable raBestFitModel	variable V_FitError, fitTries, numAlterations = 8,  numDefaultTries = 10, triesLimit = numAlterations + numDefaultTries		debug_checkRTErrState(msg="CCCC")		//iterate through and fit to as many exponentials as one wants	for (i=0;i<maxNumExps;i+=1)		if (i==0)			Concatenate /NP/O/T  {ampConstraints, tauConstraints}, fitConstraintsWave		// /O makes sure fitconstraints is killed not added to		else			Duplicate/O/T ampConstraints, ampConstraintsTemp; ampConstraintsTemp = ReplaceString("K1", ampConstraintsTemp[p], "K" + num2str(1+2*i))			Duplicate/O/T tauConstraints, tauConstraintsTemp; tauConstraintsTemp = ReplaceString("K2", tauConstraintsTemp[p], "K" + num2str(1+2*i + 1))			Concatenate /NP/T  {ampConstraintsTemp, tauConstraintsTemp}, fitConstraintsWave		endif		Redimension/N=(DimSize(coefWave,0) + 2) coefWave		coefWave[1+2*i] = amplitudeInitialGuess		coefWave[1+2*i + 1] = tauInitialGuess//		fitConstraintsWave[numConstraints*i, numConstraints*i + numAmpConstraints] = num2str(p-numConstraints*i  	)			//ReplaceString("K1", ampConstraints[p-numConstraints*i]	, "K"+num2str(1 + 2*i))	//apply amplitude constaint to amplitude coef for new exp component. 0th in wave is ("K")"1", 2nd is "3", 4th is "5" and so on...//		fitConstraintsWave[numConstraints*i+numAmpConstraints+1, numConstraints*i + numConstraints] = num2str(p-(numConstraints*i+numAmpConstraints) 	)		//ReplaceString("K2", tauConstraints[p-(numConstraints*i+numAmpConstraints)], "K"+num2str(1 + 2*i + 1))				if (i==0)			CurveFit/NTHR=0/W=2/N=1/Q=1 exp_XOffset, kwCWave=coefWave, currentResp[fitStartP, fitendP]// /C=fitConstraintsWave		elseif(i==1)			CurveFit/NTHR=0/W=2/N=1/Q=1 dblExp_XOffset, kwCWave=coefWave, currentResp[fitStartP, fitendP]// /C=fitConstraintsWave		else			FuncFit/NTHR=0/W=2/N=1/Q=1 myExp, coefWave, currentResp[fitStartP, fitendP]///C=fitConstraintsWave		endif	//	FuncFit/NTHR=0/W=2/N=1/Q=1 myExp, coefWave, currentResp[fitStartP, fitendP]		fitErrorTrackerTemp[i] = V_FitError						analysis_sortExpCoefWave(coefWave)		//place components in order of fastest to slowest taus				Print "coefwave = " + num2str(coefwave[0]) + "; " + num2str(coefwave[1]) + "; " +  num2str(coefwave[2])		Note coefWave, "FITWIN_X: " + num2str(fitStartX) + "," + num2str(fitEndX) + ";" + "DATAWAVE: " + currentRef + ";" + "FIT_x0: " + num2str(x0) + ";" +"|"					//save coef wave results by adding them to coefWaveSave		if (i==0)			Duplicate/O coefWave, coefWaveSave		else			Duplicate/O coefWaveSave, coefWaveSaveOld			concatenate/NP=0/O {coefWaveSaveOld, coefWave}, coefWaveSave			Note coefWaveSave, note(coefWave)		endif					makeFitWaves3(currentResp, currentRef, waveToSubRef, coefWave, i, baseCurrent, deltaVoltage, x0, fitStartX, fitEndX, "compParamsTemp_parent", numComponentParams, curr_numSamples, curr_ss_Res, curr_ss_Reg, curr_ss_Tot, curr_r2, curr_x2, redisplayRef)				//save componentParams by concatenating them		if (i==0)			Duplicate/O $"compParamsTemp_parent", compParamsSave		else			Duplicate/O compParamsSave, compParamsSaveOld			concatenate/NP=0/O {compParamsSaveOld, $"compParamsTemp_parent"}, compParamsSave		endif	//analyze coef wave: make fits and compare to raw data, compute f statistic, save anything needed for future display				fitParamsTemp[i][0] = curr_ss_Res						//0 is sum of squares of residuals		fitParamsTemp[i][1] = curr_ss_Reg						//1 is sum of squares of the regression (predicted y - sample mean for each sample)		fitParamsTemp[i][2] = curr_ss_Tot						//2 is total sum of squares calculated directly from data (should be independent of fit)		fitParamsTemp[i][3] = curr_r2							//r2 value 1 - (ss_Res / ss_Tot)		fitParamsTemp[i][4] = curr_x2							//chi-squared value ss_Res/ sum(predicted values) NOT FUNCTIONING / TRUSTWORTHY AT LEAST FOR NEGATIVE VALUES. Could maybe use V_chisq from curve fit if wanted to				fitParamsTemp[i][5] = 	0								//statsChiCDF(curr_x2, DimSize(coefWave,0))							//p value for chi-squared . ZERO AS PLACEHOLDER FOR NOW		fitParamsTemp[i][6] = 	curr_ss_Res + curr_ss_Reg		//total sum of squares calculated from ss_Res + ss_Reg. sHould squal ss_Tot?				fitParamsTemp[i][7] = DimSize(coefWave,0)			//number of free parameters in model		fitParamsTemp[i][8] = curr_numSamples//DimSize($StringFromList(2, fitsTemp[i]), 0)		//number of samples (e.g. length of wave that is fit, in points		fitParamsTemp[i][9] = curr_ss_Res / (fitParamsTemp[i][8] - fitParamsTemp[i][7])		//F test demoninator: Mean of residuals: sum of squares of residuals / d.f. for that (sample N - num free parameters)				if (i > 0)	//then this is a model with more than one exponential and so we will perform and f test to quantify the extent to which it's statistically justified			//relative to 1st fit						fitParamsTemp[i][10] = (fitParamsTemp[0][0] - fitParamsTemp[i][0]) / (fitParamsTemp[i][7] - fitParamsTemp[0][7])			//f test numerator: (ss_Res_reduced - ss_Res_full) / (df_full - df_reduced). demoniator calculated in 5			fitParamsTemp[i][11] = fitParamsTemp[i][10] / fitParamsTemp[i][9]				//f score			fitParamsTemp[i][12] = 1 - StatsFCDF(fitParamsTemp[i][11], fitParamsTemp[i][7] - fitParamsTemp[0][7], fitParamsTemp[i][8] - fitParamsTemp[i][7]) 		//p value: f score, difference in free params, d.f. for sum of squares of residuals?			//relative to last fit			fitParamsTemp[i][13] = (fitParamsTemp[i-1][0] - fitParamsTemp[i][0]) / (fitParamsTemp[i][7] - fitParamsTemp[i-1][7])			//f test numerator: (ss_Res_reduced - ss_Res_full) / (df_full - df_reduced). demoniator calculated in 5			fitParamsTemp[i][14] = fitParamsTemp[i][13] / fitParamsTemp[i][9]				//f score			fitParamsTemp[i][15] = 1 - StatsFCDF(fitParamsTemp[i][14], fitParamsTemp[i][7] - fitParamsTemp[i-1][7], fitParamsTemp[i][8] - fitParamsTemp[i][7]) 		//p value: f score, difference in free params, d.f. for sum of squares of residuals?					if (fitParamsTemp[i][15] < moreFreeParamsJustifiedThresh)				Duplicate/O $"compParamsTemp_parent", tempCompParams				lastPassingModel = i				raBestFitModel = tempCompParams[1]			endif		endif			//Note fitParamsTemp "FIRST_VARIABLE_PARAM_COL: " + num2str(numFitParams)		//complete fit params		fitParamsTemp[i][16] = i+1			//num components in this model		fitParamsTemp[i][17] = numComponentParams			//num parameters saved. Index to parameter in given fit													fitParamsTemp[i][18] = numFitParams				fitParamsTemp[i][19] = spacer			endfor	//finished iterating through exponential fits		Duplicate/O coefWaveSave, $coefWaveSaveRef	debug_checkRTErrState(msg="just before trying to get wave time diff")		//calculate time since brk in using brkInSweepRef	Print "trying to get time wave difference. brkInSweepRef = " + brkinSweepRef + ". currentRef = " + currentRef + ". waveToSubRef = " + waveToSubRef	Variable secsSinceBrkIn = text_getWaveTimeDifference(brkInSweepRef, currentRef, 5)		Variable minsSinceBrkIn = text_getWaveTimeDifference(brkInSweepRef, currentRef, 4)		//calculate capacity transient capacitance value via integration 	String capTransParamsWRef = "analysis_calcCP_S3_capParams"	Variable tau0, amp0	if (lastPassingModel != 0)		//then two compartment model was an improvement over single (still might be better described by higher order models), feed this into cap transient calc		tau0 = getParamFromHeader_1D("m1_c0_tau", "coefWaveHeader", "coefWaveSave")		amp0 = getParamFromHeader_1D("m1_c0_A", "coefWaveHeader", "coefWaveSave")		Variable tau1 = getParamFromHeader_1D("m1_c1_tau", "coefWaveHeader", "coefWaveSave")		Variable amp1 = getParamFromHeader_1D("m1_c1_A", "coefWaveHeader", "coefWaveSave")				analysis_capTransIntegration(currentRef, capTransParamsWRef,  vCmd_t0, vCmd_baseline, vCmd_step, fitWinSize, x0, tau0, amp0, tau1=tau1, amp1=amp1)	else		tau0 = getParamFromHeader_1D("m0_c0_tau", "coefWaveHeader", "coefWaveSave")		amp0 = getParamFromHeader_1D("m0_c0_A", "coefWaveHeader", "coefWaveSave")		analysis_capTransIntegration(currentRef, capTransParamsWRef,  vCmd_t0, vCmd_baseline, vCmd_step, fitWinSize, x0, tau0, amp0)	endif		//store parameters of interest:	Variable numGenParams = 34		Make/O/D/N=(numGenParams) genParamsTemp		//input resistance related parameters:	genParamsTemp[0] = numGenParams							//allows to quickly find end and begin looking at fitParams	genParamsTemp[1] = spacer										//placeholders	genParamsTemp[2] = spacer	genParamsTemp[3] = spacer	genParamsTemp[4] = vCmd_baseline								genParamsTemp[5] = vCmd_step 	genParamsTemp[6] = deltaVoltage	genParamsTemp[7] = baseCurrent	genParamsTemp[8] = ssCurrent	genParamsTemp[9] = deltaSSCurrent	genParamsTemp[10] = ssRin	genParamsTemp[11] = lastPassingModel	genParamsTemp[12] = raBestFitModel		//Ra of best fitting full model	genParamsTemp[13] = fd_note_getSRate(currentRef)						//stores sample rate	genParamsTemp[14] = vCmd_t0									//	Variable vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step		//information on the voltage command that was given t0 is step start, t1 is step end, baseline is v_hold before step, step is Vcmd during step	genParamsTemp[15] = vCmd_t1	genParamsTemp[16] = vCmd_baseline	genParamsTemp[17] = vCmd_step	genParamsTemp[18] = x0	genParamsTemp[19] = fitParamsTemp[0][11]			//f test model 0	genParamsTemp[20] = fitParamsTemp[0][12]			//p value 0	genParamsTemp[21] = fitParamsTemp[0][7]	 		//num free params model 0	genParamsTemp[22] = fitParamsTemp[0][8]	  		//numpnts model 0 (same across all)	genParamsTemp[23] = fitParamsTemp[1][14]			//f test model 1 (Vs 0)	genParamsTemp[24] = fitParamsTemp[1][15]			//p value model 1	genParamsTemp[25] = fitParamsTemp[2][14]			//f test model 2 (vs 1)	genParamsTemp[26] = fitParamsTemp[2][15]	genParamsTemp[27] = fitParamsTemp[3][14]			//f test model 3	genParamsTemp[28] = fitParamsTemp[3][15]	genParamsTemp[29] = fitParamsTemp[4][14]			//f test model 4	genParamsTemp[30] = fitParamsTemp[4][15]	genParamsTemp[31] = secsSinceBrkIn	genParamsTemp[32] = minsSinceBrkIn	genParamsTemp[33] = spacer		//convert fit params into 1D single column to append to genParams and store	convert2DTo1D("fitParamsTemp", "fitParamsOut", 1)		//concatenate rows		Concatenate/NP=0/O {genParamsTemp, $"fitParamsOut", $capTransParamsWRef}, finalParamsOut		// $capTransParamsWRef added 1/25/15	Variable finalParamsEndRow = DimSize(finalParamsOut, 0)	Redimension/N=(finalParamsEndRow + DimSize(fitErrorTrackerTemp,0)) finalParamsOut	finalParamsOut[finalParamsEndRow,] =  fitErrorTrackerTemp[p-finalParamsEndRow]		//error tracker: whether fit converged etc. for each attempted model (implemented from row 9 on of cell params cells)		Duplicate/O finalParamsOut, $genAndFitParamsSaveRef	Duplicate/O compParamsSave, $compParamsSaveRef			KillWaves/Z currentTemp //, fitParamsTemp, componentParams, coefWaveSave, coefWave, genParamsTemp, end		//analysis_cellParams_S3()//returns 1 if step found and analysis was performed, 0 if step wasnt found (in which case analysis is aborted). Step threshold requirements are set in analysis_cellParamsSimple_cmd()function analysis_fastCellParams(isCC,firstFileNum,hasNoStep,cmdRef,respRef,baselineEndX,isNegativeStep,breakInTraceRef,breakInTimeStr,paramsSaveRef,fitSaveRef,cmdStepInfoRef,[fd_fileNum,fd_sweepNum,forceAllNaNOutput])	Variable isCC			//0 for voltage clamp, 1 for current clamp	String cmdRef, respRef; Variable baselineEndX, isNegativeStep	String breakInTraceRef		//optionally pass a breakInTrace to average	String breakInTimeStr		//break in timing str: usually found in wave note for break in, but just in case its not there always have to explicitly pass this	String paramsSaveRef	String fitSaveRef		//stores a 3 column wave: first column is response, second is mono fit, third is dbl fit	Variable fd_fileNum,fd_sweepNum		//only pass if want this info stored, otherwise left blank in params wave (for consistent param wave length)	Variable hasNoStep						//let's either CC or VC routines no not to look for a step--records only baseline, sweep time, and the like	Variable firstFileNum						//used for sweep timing	String cmdStepInfoRef					//pass if no vCmd, should contain cmd_t1, cmd_baseline, cmd_step in that order (see cellParamsSimple_cmd for explanation of these parameters)	Variable forceAllNaNOutput			//pass to get a result that is all NaNs		Variable stepFound; Variable cmd_t0 = NaN, cmd_t1 = NaN, cmd_baseline = NaN, cmd_step = NaN	fd_fileNum = ParamIsDefault(fd_fileNum) ? NaN : fd_fileNum; fd_sweepNum = ParamIsDefault(fd_sweepNum) ? NaN : fd_sweepNum		if (!ParamIsDefault(forceAllNaNOutput) && forceAllNaNOutput)		analysis_fastCellParamsNaNs(paramsSaveRef,fd_fileNum=fd_fileNum,fd_sweepNum=fd_sweepNum)		return 0	endif			//find start and end of cmd step, cmd baseline and step levels		if (hasNoStep)		stepFound = 0		analysis_cellParamsSimple_cmd(cmdRef, 0, isCC, baselineEndX,  isNegativeStep,  cmd_t0, cmd_t1, cmd_baseline, cmd_step,1)		cmd_t0 = baselineEndX			//this gives analysis_fastCellParamsT functions a place to measure baseline at (a bit of an arbitrary spot unfortunately, especially when running in parellel to analysis on steps )	else			//attempt to find step, set stepFound true if a step is found, false otherwise		if (strlen(cmdStepInfoRef) > 0)		//command info passed			WAVE cmdStepInfoWv = $cmdStepInfoRef			cmd_t0=cmdStepInfoWv[0]; cmd_t1=cmdStepInfoWv[1]; cmd_baseline=cmdStepInfoWv[2]; cmd_step=cmdStepInfoWv[3]			stepFound = 1		else			stepFound = analysis_cellParamsSimple_cmd(cmdRef, 1, isCC, baselineEndX,  isNegativeStep,  cmd_t0, cmd_t1, cmd_baseline, cmd_step,1)		endif	endif			if (isCC)		//CC analysis (much les parameterization, no fitting)		analysis_fastCellParamsT_cc(respRef, firstFileNum, stepFound, cmd_t0, cmd_t1, cmd_baseline, cmd_step, isNegativeStep, breakInTraceRef, breakInTimeStr, paramsSaveRef, fd_fileNum=fd_fileNum, fd_sweepNum=fd_sweepNum)	else		//vc (standard) analysis		analysis_fastCellParamsT(respRef, firstFileNum, stepFound, cmd_t0, cmd_t1, cmd_baseline, cmd_step, isNegativeStep,breakInTraceRef, breakInTimeStr, paramsSaveRef,fitSaveRef,fd_fileNum=fd_fileNum, fd_sweepNum=fd_sweepNum)	endif		return stepFoundendfunction analysis_fastCellParamsT_cc(respRef, firstFileNum, hasStep, cmd_t0, cmd_t1, cmd_baseline, cmd_step, isNegativeStep, breakInTraceRef, breakInTimeStr, paramsOutRef, [fd_fileNum, fd_sweepNum])	String respRef; Variable cmd_t0, cmd_t1, cmd_baseline, cmd_step, isNegativeStep	String breakInTraceRef		//(optional) pass "" if none	String paramsOutRef		//must be pre-allocated, data will be overwritten. 	String breakInTimeStr		//pass so that relative sweep timing is known	Variable fd_fileNum,fd_sweepNum		//only pass if want this info stored, otherwise left blank in params wave (for consistent length)	Variable hasStep		//pass zero to bypass majority of processing (and setting of output parameters). cmd_baseline can still be passed but all other cmd values are expected NaN	Variable firstFileNum		Variable unitsSelection = 5 		//gives back in seconds	Variable baselineLenX = 0.01	Variable baselineBuffer = 0.0002	Variable baselineEndX = cmd_t0 - baselineBuffer	Variable baselineStartX = baselineEndX - baselineLenX	Variable ssWinLenX = baselineLenX	Variable ssWinDelay = 0.015	Variable ssWinStartX = cmd_t0 + ssWinDelay	Variable ssWinEndX = ssWinStartX + ssWinLenX						//other things to set to start with				//in comments are equivalents for voltage clamp version	debug_checkRTErrState(msg="aaaa xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx")	Variable ic_baseVoltage = mean($respRef, baselineStartX,baselineEndX)		//baseCurrent	debug_checkRTErrState(msg="xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx")	Variable timeSinceBrkIn = text_getTimeSinceTimeStr(breakInTimeStr, respRef, unitsSelection)		if (hasStep)			Variable stepLength = cmd_t1 - cmd_t0		//calcualte step duration to assure that fit window falls within step only  (see fit win size limit below for the use of this)		Variable ic_deltaCurrent = cmd_step - cmd_baseline	//Variable deltaCurrent = vCmd_step - vCmd_baseline		Variable ic_ssVoltage =  mean($respRef, ssWinStartX,ssWinEndX)	//	Variable ssCurrent = mean(currentResp, ssWinStartX,ssWinEndX)		Variable ic_deltaSSVoltage = ic_ssVoltage - ic_baseVoltage			 //Variable deltaSSCurrent = ssCurrent - baseCurrent		Variable ssRin =	ic_deltaSSVoltage / ic_deltaCurrent	// deltaVoltage / deltaSSCurrent			endif			if (strlen(paramsOutRef) > 0)		Variable numParams = 76, numStatsParams = 31			//use Print DimSize($stats_getFTestHeader(),0) to check numStatsParams		MAke/O/D/N=(numParams+numStatsParams) $paramsOutRef		//stores output parameters		WAVE/D paramsOut = $ParamsOutRef		paramsOut = NaN		//default value as NaN, which takes care of stats positions and all unused VC-only positions		paramsOut[0] = !hasStep ? NaN : ssRin//		paramsOut[1] = NaN//vCmd_baseline//		paramsOut[2] = NaN//vCmd_step//		paramsOut[3] = NaN//deltaVoltage//		paramsOut[4] = NaN//baseCurrent//		paramsOut[5] = NaN//ssCurrent//		paramsOut[6] = NaN//deltaSSCurrent//		paramsOut[7] = NaN//accessR_noModel //		paramsOut[8] = NaN//memR_noModel //		paramsOut[9] = NaN//peakVal//		paramsOut[10] = NaN//peakLoc//		paramsOut[11] = NaN//ssCurrent_mono//		paramsOut[12] = NaN//tau_mono//		paramsOut[13] = NaN//amp_mono//		paramsOut[14] = NaN//iPeak_mono//		paramsOut[15] = NaN//qTot_mono//		paramsOut[16] = NaN//accessR_mono//		paramsOut[17] = NaN//x0 //		paramsOut[18] = NaN//memR_mono//		paramsOut[19] = NaN//mMCapTot_mono//		paramsOut[20] = NaN//mQCapTot_mono//		paramsOut[21] = NaN//ssCurrent_dbl//		paramsOut[22] = NaN//tau1_dbl//		paramsOut[23] = NaN//amp1_dbl//		paramsOut[24] = NaN//tau2_dbl//		paramsOut[25] = NaN//amp2_dbl//		paramsOut[26] = NaN//iPeak_dbl//		paramsOut[27] = NaN//q1_dbl//		paramsOut[28] = NaN//q2_dbl//		paramsOut[29] = NaN//qTot_dbl//		paramsOut[30] = NaN//accessR_dbl//		paramsOut[31] = NaN//memR_dbl//		paramsOut[32] = NaN//mMCap1_dbl//		paramsOut[33] = NaN//mMCap2_dbl//		paramsOut[34] = NaN//mMCapTot_dbl//		paramsOut[35] = NaN//mQcap1_dbl//		paramsOut[36] = NaN//mQcap2_dbl//		paramsOut[37] = NaN//mQcapTot_dbl//		paramsOut[38] = NaN//vCmd_t0//		paramsOut[39] = NaN//vCmd_t1//		paramsOut[40] = NaN//vCmd_baseline//		paramsOut[41] = NaN//vCmd_step		//in common betwen ic/vc		paramsOut[42] = baselineLenX		paramsOut[43] = baselineStartX		paramsOut[44] = baselineEndX		paramsOut[45]  = !hasStep ? NaN : ssWinLenX		paramsOut[46]  = !hasStep ? NaN : ssWinStartX		paramsOut[47]  = !hasStep ? NaN : ssWinEndX		//not in common//		paramsOut[48] = NaN//fitWinSize//		paramsOut[49] = NaN//fitStartX//		paramsOut[50] = NaN//fitEndX//		paramsOut[51] = NaN//fitStartP//		paramsOut[52] = NaN//fitEndP		//in common		paramsOut[53] = timeSinceBrkIn		paramsOut[54] = unitsSelection 				Variable fileNum = text_getInfoFromWaveName_V(respRef, 1)	//1=filenum		Variable sweepNum = text_getInfoFromWaveName_V(respRef, 2)	//2=sweepNum		Variable chanNum = text_getInfoFromWaveName_V(respRef, 3)	//3=chanNum		paramsOut[55] = fileNum		paramsOut[56] = sweepNum		paramsOut[57] = chanNum		paramsOut[58] = fd_fileNum		paramsOut[59] = fd_sweepNum		paramsOut[60] = num_combinedFileAndSweep(fileNum, sweepNum)		//fileNum.sweepNum*1000		paramsOut[61] = num_combinedFileAndSweep(fd_fileNum, fd_sweepNum)						paramsOut[62] = text_fd_getRelTimeSinceFile(respRef,firstFileNum,5)		//timeSinceRecStart (time relative to start time of first file)		paramsOut[63] = 0			//IS_VC		//IC-specific		paramsOut[64] = cmd_t0		paramsOut[65] = !hasStep ? NaN : cmd_t1		paramsOut[66] = cmd_baseline		paramsOut[67] = !hasStep ? NaN : cmd_step				paramsOut[68] = !hasStep ? NaN : ic_deltaCurrent		paramsOut[69] = ic_baseVoltage		paramsOut[70] = !hasStep ? NaN : ic_ssVoltage		paramsOut[71] = !hasStep ? NaN : ic_deltaSSVoltage				paramsOut[72] = !hasStep ? NaN : isNegativeStep		//cc and vc//		paramsOut[73] = NaN					//vc parameter, analysis not performed because peak below threhsold. already set to NaN after making output wave		paramsOut[74] = (DimSize($respRef,0)-1) * DimDelta($respRef,0)		//wave len		paramsOut[75] = 1/DimDelta($respRef,0)							//sample rate	endif		end//function analysis_fastCellParams_cmdIn(respRef, cmdRef, firstFileNum, hasStep, vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step, isNegativeStep, breakInTraceRef, breakInTimeStr, paramsOutRef, fitSaveRef,  [fd_fileNum, fd_sweepNum])//	String respRef; 		//response to get cell params from//	String breakInTraceRef		//(optional) pass "" if none//	String fitSaveRef			//(obligatory) name of wave to store response ref in, necessary especially for subtracting pipette cap//	String paramsOutRef		//must be pre-allocated, data will be overwritten. //	String breakInTimeStr		//pass so that relative sweep timing is known//	Variable fd_fileNum,fd_sweepNum		//only pass if want this info stored, otherwise left blank in params wave (for consistent length)//	Variable hasStep		//pass zero to bypass majority of processing (and setting of output parameters). Only things like baseline are calculated. vCmd_baseline can still be passed and vCmd_t0 MUST be passed (can be set to expected step start time in analogy to other traces with steps)//	Variable firstFileNum		//number of first file of recording, so as to store time since recording start//	//	if (ParamIsDefault(fd_fileNum))//		fd_fileNum  = NaN//	endif//	if (ParamIsDefault(fd_sweepNum))//		fd_sweepNum  = NaN//	endif////	Variable vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step, isNegativeStep		//cmd info (use analysis_fastCellParamsTC to input as array//	WAVE cmd = $cmdRef//	cmd //	//	function analysis_fastCellParamsT(respRef, firstFileNum, hasStep, vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step, isNegativeStep, breakInTraceRef, breakInTimeStr, paramsOutRef, fitSaveRef,  [fd_fileNum=fd_fileNum, fd_sweepNum=fd_sweepNum])////endfunction analysis_getSealSweep(respMatchStr, cmdMatchStr)	String respMatchStr, cmdMatchStr		String respRef = wave_Avgfromwin(respMatchStr, "",0,nan,nan)	String cmdRef = wave_Avgfromwin(cmdMatchStr, "",0,nan,nan)		analysis_setSealSweepInfo($respRef, $cmdRef, "")		//auto name of cmdInfoRef in analysis_setSealSweepInfoend//find timing of pre-break in function analysis_setSealSweepInfo(respWv, stimWv, cmdInfoRef)	WAVE respWv, stimWv	String cmdInfoRef 	//place to store cmdInfo		if (strlen(cmdInfoRef) < 1)		cmdInfoRef = NameOFWave(stimWv) + "_CI"	endif		Variable cmd_t0, cmd_t1, cmd_baseline, cmd_step, cmd_final	analysis_cellParamsSimple_cmd(NameOfWave(stimWv), 1, 0, .01,  1,  cmd_t0, cmd_t1, cmd_baseline, cmd_step, 0)	Variable numParams = 6;Make/O/D/N=(numParams) $cmdInfoRef/WAVE=cmdInfoWv	cmdInfoWv = {cmd_t0, cmd_t1, cmd_baseline, cmd_step, cmd_final}		Print "cmd_t0, cmd_t1, cmd_baseline, cmd_step, cmd_final", cmd_t0, cmd_t1, cmd_baseline, cmd_step, cmd_final		String noteStr	sprintf noteStr, "analysis_setSealSweepInfo:cmd_t0:%.60e|cmd_t1:%.60e|cmd_baseline:%.60e|cmd_step:%.25e|cmd_final:%.25e|;",cmd_t0, cmd_t1, cmd_baseline, cmd_step, cmd_final	noteStr += "cmdInfoRef:"+cmdInfoRef+";"		note cmdInfoWv, "cmdRef:"+nameofwave(stimWv)+";respRef:"+nameofwave(respWv)+";"			note/nocr respWv, noteStr + "analysis_setSealSweepInfo_respRef:"+nameofwave(respWv) + ";"	note/nocr stimWv, noteStr + "analysis_setSealSweepInfo_stimRef:"+nameofwave(stimWv) + ";"	endfunction/S analysis_getCmdInfoRef(stimOrRespRef)	String stimOrRespRef		return StringByKey("cmdInfoRef",note($stimOrRespRef))endfunction/S analysis_getSealSweepInfo(infoStr, sealWv)	String infoStr; Wave sealWv		STring str = stringbykey("analysis_setSealSweepInfo",note(sealWv))		return StringByKey(infoStr, str , ":", "|")end//header for params output is via analysis_getNewHeader()function analysis_fastCellParamsNaNs(paramsOutRef,  [fd_fileNum, fd_sweepNum])	String paramsOutRef		//must be pre-allocated, data will be overwritten. 	Variable fd_fileNum,fd_sweepNum		//only pass if want this info stored, otherwise left blank in params wave (for consistent length)	if (ParamIsDefault(fd_fileNum))		fd_fileNum  = NaN	endif	if (ParamIsDefault(fd_sweepNum))		fd_sweepNum  = NaN	endif		if (strlen(paramsOutRef) > 0)		Variable numParams = 76; Variable numStatsParams = 31		if ( !WaveExists($paramsOutRef) || (DimSize($paramsOutRef,0) != numParams) )			MAke/O/D/N=(numParams) $paramsOutRef/WAVE=paramsOut		//stores output parameters		else			WAVE/D paramsOut = $paramsOutRef		endif		paramsOut[0,57] = NaN		paramsOut[58] = fd_fileNum		paramsOut[59] = fd_sweepNum		paramsOut[60,75] = NaN					Redimension/N=(numParams + numStatsParams) paramsOut; paramsOut[numParams,] = NaN		//fill in fit stats area with NaN	endif	killwaves/Z analysis_expFit_mono,analysis_expFit_dbl,analysis_fitStatsTempend	//analysis_fastCellParamsT()//header for params output is via analysis_getNewHeader()function analysis_fastCellParamsT(respRef, firstFileNum, hasStep, vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step, isNegativeStep, breakInTraceRef, breakInTimeStr, paramsOutRef, fitSaveRef,  [fd_fileNum, fd_sweepNum])	String respRef; 		//response to get cell params from	Variable vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step, isNegativeStep		//cmd info (use analysis_fastCellParamsTC to input as array	String breakInTraceRef		//(optional) pass "" if none	String fitSaveRef			//(obligatory) name of wave to store response ref in, necessary especially for subtracting pipette cap	String paramsOutRef		//must be pre-allocated, data will be overwritten. 	String breakInTimeStr		//pass so that relative sweep timing is known	Variable fd_fileNum,fd_sweepNum		//only pass if want this info stored, otherwise left blank in params wave (for consistent length)	Variable hasStep		//pass zero to bypass majority of processing (and setting of output parameters). Only things like baseline are calculated. vCmd_baseline can still be passed and vCmd_t0 MUST be passed (can be set to expected step start time in analogy to other traces with steps)	Variable firstFileNum		//number of first file of recording, so as to store time since recording start		if (ParamIsDefault(fd_fileNum))		fd_fileNum  = NaN	endif	if (ParamIsDefault(fd_sweepNum))		fd_sweepNum  = NaN	endif			if ( (strlen(breakInTraceRef) > 0) && hasStep && (dimsize($breakInTraceRef,0)==dimsize($respRef,0)) && (dimdelta($breakInTraceRef,0)==dimdelta($respRef,0)) )		//do sub		Duplicate/O $respRef, currentResp		WAVE waveToSub = $breakInTraceRef				//analysis_subtractSealWv(waveToSub,currentResp, {vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step,0})		currentResp -= waveToSub	else		WAVE currentResp = $respRef	endif			Duplicate/O currentResp, subsavetemp		Variable minExcursionForAnalysis = 5 * 10^-12 //in amps		//much of this section in common with current clamp routine	Variable unitsSelection = 5 		//gives back in seconds	Variable baselineLenX = 0.04	Variable baselineBuffer = 0.0002	Variable baselineEndX = vCmd_t0 - baselineBuffer	Variable baselineStartX = baselineEndX - baselineLenX	Variable ssWinLenX = baselineLenX	Variable stepLength = vCmd_t1 - vCmd_t0		//calcualte step duration to assure that fit window falls within step only  (see fit win size limit below for the use of this)	Variable ssWinDelay = 	0.105		//!numtype(vcmd_t1) && (vcmd_t1 > vcmd_t0) ? stepLength - ssWinLenX : 0.05			//defaul to 0.05	if (ssWinDelay >= stepLength)		ssWinDelay = stepLength - ssWinLenX 	endif	Variable ssWinStartX = vCmd_t0 + ssWinDelay	Variable ssWinEndX = ssWinStartX + ssWinLenX	//	Print "(respRef)",respRef,"stepLength",stepLength,"ssWinDelay",ssWinDelay,"ssWinStartX",ssWinStartX,"	ssWinEndX",ssWinEndX		Variable fitWinSize = .01	Variable deltaVoltage = vCmd_step - vCmd_baseline	Variable baseCurrent = mean(currentResp, baselineStartX,baselineEndX)		Variable skipFits = 1		//default is to skip unless it's after break in time	Variable timeSinceBrkIn = NaN	if (hasStep)			Variable ssCurrent = mean(currentResp, ssWinStartX,ssWinEndX)		Variable deltaSSCurrent = ssCurrent - baseCurrent		Variable ssRin = deltaVoltage / deltaSSCurrent				if (strlen(breakInTimeStr) > 0)		 	timeSinceBrkIn = text_getTimeSinceTimeStr(breakInTimeStr, respRef, unitsSelection)		endif		//NO LONGER in common with current clamp version from here until mentioned again below		skipFits = timeSinceBrkIn <= 0			//exponential curve fitting often fails before break in, so this allows it to be skipped. Could produce undesirable results if break in timing is incorrect							//find peak of the capacity transient. Want to start fit at this peak, even if it's after t0, because we don't want to fit to values that are lower than and precede the peak		WaveStats/Q/R=(vCmd_t0, ssWinStartX) currentResp		Variable peakLoc, peakVal		if (isNegativeStep)	//so look for minimum			peakLoc = V_minloc		//Might have to NVAR in V_minloc and V_maxloc, but not today...			peakVal = V_min - baseCurrent			//at step, all current flowing through access resistance, giving capactive transient. Subtract baseline to get delta for this capacitive current		else			peakLoc = V_maxloc			peakVal = V_max - baseCurrent		endif					Variable peakBelowMin =  abs(peakVal) < minExcursionForAnalysis			skipFits = skipFits || peakBelowMin 				Variable accessR_noModel = deltaVoltage/peakVal			//only a rough estimate, especially if the peak is incorrectly found (e.g. before going whole cell)		Variable memR_noModel = ( deltaVoltage - (accessR_noModel*ssCurrent) ) / ssCurrent					if (!skipFits)			Variable fitStartX = peakLoc			Variable fitEndX = peakLoc + fitWinSize			Variable fitStartP = x2pnt(currentResp, fitStartX)			Variable fitEndP = x2pnt(currentResp, fitEndX)						Make/O/D/N=(3) coefWave_mono; Make/O/D/N=1 W_fitconstants	//named place where curvefit stores x0 constant			Curvefit/W=2/N=1/Q=1 exp_XOffset, kwCWave=coefWave_mono, currentResp[fitStartP, fitendP]			Variable x0 = W_fitConstants[0]			Duplicate/O/R=[fitStartP, fitendP] currentResp, analysis_expFit_mono			analysis_expFit_mono = coefWave_mono[0] + coefWave_mono[1]*exp(-(x-x0)/coefWave_mono[2])			Variable ssRes_mono = analysis_getSSResiduals(analysis_expFit_mono, currentResp)						Variable ssCurrent_mono = coefWave_mono[0]			Variable tau_mono = coefWave_mono[2]			Variable amp_mono = coefWave_mono[1]					Variable iPeak_mono = analysis_expFit_mono[0]			Variable qTot_mono =	tau_mono * amp_mono			//	fixed error that had this as 1/tau_mono * amp_mono			Variable accessR_mono = deltaVoltage/iPeak_mono			Variable memR_mono = ( deltaVoltage - (accessR_mono*ssCurrent_mono) ) / ssCurrent_mono			Variable mMCapTot_mono = tau_mono* ( (1/accessR_mono) + (1/memR_mono) )			Variable mQCapTot_mono = qTot_mono / deltaVoltage						Make/O/D/N=(5) coefWave_dbl			VAriable v_FitError = 0, v_fitQuitReason = 0			Curvefit/W=2/N=1/Q=1 dblexp_XOffset, kwCWave=coefWave_dbl, currentResp[fitStartP, fitendP]			if (V_fitError)				Print "analysis_fastCellParamsT(): Fit Error. v_FitError=",v_FitError,"v_fitQuitReason",v_fitQuitReason			endif			analysis_sortExpCoefWave(coefWave_dbl)			//maintains constant order			Duplicate/O/R=[fitStartP, fitendP] currentResp, analysis_expFit_dbl			analysis_expFit_dbl = coefWave_dbl[0] + coefWave_dbl[1]*exp(-(x-x0)/coefWave_dbl[2]) + coefWave_dbl[3]*exp(-(x-x0)/coefWave_dbl[4])						Variable ssCurrent_dbl = coefWave_dbl[0]			Variable tau1_dbl = coefWave_dbl[2]			Variable amp1_dbl = coefWave_dbl[1]			Variable tau2_dbl = coefWave_dbl[4]			Variable amp2_dbl = coefWave_dbl[3]						Variable iPeak_dbl = analysis_expFit_dbl[0] 						Variable q1_dbl = tau1_dbl * amp1_dbl			Variable q2_dbl = tau2_dbl * amp2_dbl			Variable qTot_dbl = q1_dbl + q2_dbl			Variable accessR_dbl = deltaVoltage/iPeak_dbl 			Variable memR_dbl = ( deltaVoltage - (accessR_mono*ssCurrent_dbl) ) / ssCurrent_dbl			Variable mMCap1_dbl = tau1_dbl* ( (1/accessR_dbl) + (1/memR_dbl) )			Variable mMCap2_dbl = tau2_dbl* ( (1/accessR_dbl) + (1/memR_dbl) )				Variable mMCapTot_dbl  = mMCap1_dbl + mMCap2_dbl			Variable mQcap1_dbl = q1_dbl / deltaVoltage			Variable mQcap2_dbl = q2_dbl / deltaVoltage			Variable mQcapTot_dbl = qTot_dbl / deltaVoltage						Duplicate/O/R=[fitStartP, fitEndP] currentResp, $fitSaveRef/WAVE=outFits			Redimension/N=(-1,3) outFits			outFits[][1] = analysis_expFit_mono[p]			outFits[][2] = analysis_expFit_dbl[p]						//stats on fits			stats_ftest(currentResp, analysis_expFit_mono, analysis_expFit_dbl, 3, 5, "analysis_fitStatsTemp")//concatenated to output					endif //if (!skipFitS)			endif //if (hasStep)		if (strlen(paramsOutRef) > 0)		Variable numParams = 76; Variable numStatsParams = 31		if ( !WaveExists($paramsOutRef) || (DimSize($paramsOutRef,0) != numParams) )			MAke/O/D/N=(numParams) $paramsOutRef/WAVE=paramsOut		//stores output parameters		else			WAVE/D paramsOut = $paramsOutRef		endif		paramsOut[0] = !hasStep ? NaN : ssRin		paramsOut[1] = vCmd_baseline		paramsOut[2] = !hasStep ? NaN : vCmd_step		paramsOut[3] = !hasStep ? NaN : deltaVoltage		paramsOut[4] = baseCurrent		paramsOut[5] = !hasStep ? NaN : ssCurrent		paramsOut[6] = !hasStep ? NaN : deltaSSCurrent		paramsOut[7] = !hasStep ? NaN : accessR_noModel 		paramsOut[8] = !hasStep ? NaN : memR_noModel 		paramsOut[9] = !hasStep ? NaN : peakVal		paramsOut[10] = !hasStep ? NaN : peakLoc		//these will be zero if hasStep is zero, but skipFits is always zero if hasStep is zero, so the outcome is the same without checking hasStep		paramsOut[11] = skipFits ? NaN : ssCurrent_mono		paramsOut[12] = skipFits ? NaN : tau_mono		paramsOut[13] = skipFits ? NaN : amp_mono		paramsOut[14] = skipFits ? NaN : iPeak_mono		paramsOut[15] = skipFits ? NaN : qTot_mono		paramsOut[16] = skipFits ? NaN : accessR_mono		paramsOut[17] = skipFits ? NaN : x0 		paramsOut[18] = skipFits ? NaN : memR_mono		paramsOut[19] = skipFits ? NaN : mMCapTot_mono		paramsOut[20] = skipFits ? NaN : mQCapTot_mono		paramsOut[21] = skipFits ? NaN : ssCurrent_dbl		paramsOut[22] = skipFits ? NaN : tau1_dbl		paramsOut[23] = skipFits ? NaN : amp1_dbl		paramsOut[24] = skipFits ? NaN : tau2_dbl		paramsOut[25] = skipFits ? NaN : amp2_dbl		paramsOut[26] = skipFits ? NaN : iPeak_dbl		paramsOut[27] = skipFits ? NaN : q1_dbl		paramsOut[28] = skipFits ? NaN : q2_dbl		paramsOut[29] = skipFits ? NaN : qTot_dbl		paramsOut[30] = skipFits ? NaN : accessR_dbl		paramsOut[31] = skipFits ? NaN : memR_dbl		paramsOut[32] = skipFits ? NaN : mMCap1_dbl		paramsOut[33] = skipFits ? NaN : mMCap2_dbl		paramsOut[34] = skipFits ? NaN : mMCapTot_dbl		paramsOut[35] = skipFits ? NaN : mQcap1_dbl		paramsOut[36] = skipFits ? NaN : mQcap2_dbl		paramsOut[37] = skipFits ? NaN : mQcapTot_dbl		paramsOut[38] = vCmd_t0					//should be set even if no step is passed		paramsOut[39] = !hasStep ? NaN : vCmd_t1		paramsOut[40] = vCmd_baseline					paramsOut[41] = !hasStep ? NaN : vCmd_step		paramsOut[42] = baselineLenX		paramsOut[43] = baselineStartX		paramsOut[44] = baselineEndX		paramsOut[45] = !hasStep ? NaN : ssWinLenX		paramsOut[46] = !hasStep ? NaN : ssWinStartX		paramsOut[47] = !hasStep ? NaN : ssWinEndX		paramsOut[48] = skipFits ? NaN : fitWinSize		paramsOut[49] = skipFits ? NaN : fitStartX		paramsOut[50] = skipFits ? NaN : fitEndX		paramsOut[51] = skipFits ? NaN : fitStartP		paramsOut[52] = skipFits ? NaN : fitEndP		paramsOut[53] = timeSinceBrkIn		paramsOut[54] = unitsSelection 				Variable fileNum = text_getInfoFromWaveName_V(respRef, 1)	//1=filenum		Variable sweepNum = text_getInfoFromWaveName_V(respRef, 2)	//2=sweepNum		Variable chanNum = text_getInfoFromWaveName_V(respRef, 3)	//3=chanNum		paramsOut[55] = fileNum		paramsOut[56] = sweepNum		paramsOut[57] = chanNum		paramsOut[58] = fd_fileNum		paramsOut[59] = fd_sweepNum		paramsOut[60] = num_combinedFileAndSweep(fileNum, sweepNum)		//fileNum.sweepNum*1000		paramsOut[61] = num_combinedFileAndSweep(fd_fileNum, fd_sweepNum)				paramsOut[62] = text_fd_getRelTimeSinceFile(respRef,firstFileNum,5)		paramsOut[63] = 1			//IS_VC		//IC-specific		paramsOut[64] = NaN		paramsOut[65] = NaN		paramsOut[66] = NaN		paramsOut[67] = NaN		paramsOut[68] = NaN		paramsOut[69] = NaN		paramsOut[70] = NaN		paramsOut[71] = NaN				paramsOut[72] = !hasStep ? NaN : isNegativeStep		//shared parameter		paramsOut[73] = !hasStep ? NaN : peakBelowMin		//vc only parameter				paramsOut[74] = (DimSize($respRef,0)-1) * DimDelta($respRef,0)		//wave len		paramsOut[75] = 1/DimDelta($respRef,0)							//sample rate				if (skipFits)		//fill in fit stats area with NaN			Redimension/N=(numParams + numStatsParams) paramsOut; paramsOut[numParams,] = NaN		else				//concatenate stats params, created by stats_ftest			Concatenate/NP=0 {$"analysis_fitStatsTemp"}, paramsOut		endif	endif		killwaves/Z analysis_expFit_mono,analysis_expFit_dbl,analysis_fitStatsTempend	//analysis_fastCellParamsT()function analysis_subtractSealWv(subtractThisWv, fromThisWv, withThisCmdInfoWv)	WAVE/D subtractThisWv, fromThisWv, withThisCmdInfoWv		Print "withThisCmdInfoWv", withThisCmdInfoWv[0],withThisCmdInfoWv[1],withThisCmdInfoWv[2],withThisCmdInfoWv[3]	//cmdInfoWave order: cmd_t0, cmd_t1, cmd_baseline, cmd_step, cmd_final; final not correctly working		Variable diff_baselineLimit = 0.012		//no larger than 12 mV difference in baseline holding	Variable stepRatioLimit = 1.6				//no more/less than 60% difference in step sizes		WAVE/D toSubCmdInfoWv = $analysis_getCmdInfoRef(nameofwave(subtractThisWv))		Variable cmd_t0_pos=0, cmd_t1_pos=1, cmd_baseline_pos=2, cmd_step_pos=3, cmd_final_pos=4		Double offset_t0 = withThisCmdInfoWv[cmd_t0_pos] - toSubCmdInfoWv[cmd_t0_pos]		//+ brkIn step after sealStep, - brkInStep before SealStep, 0 steps at same time//	Double offset_t1 = withThisCmdInfoWv[cmd_t1_pos] - toSubCmdInfoWv[cmd_t1_pos]		//calculate delta step for each wave, use ratio to scale step	Double seal_stepDelta = toSubCmdInfoWv[cmd_step_pos] - toSubCmdInfoWv[cmd_baseline_pos]	double brkIn_stepDelta = withThisCmdInfoWv[cmd_step_pos] - withThisCmdInfoWv[cmd_baseline_pos]	Double brkIn_stepRatio = brkIn_stepDelta / seal_stepDelta		//how much larger was brkIn step cmd than seal step cmd?		if ( (brkIn_stepRatio > stepRatioLimit) || (brkIn_stepRatio < (1/stepRatioLimit)) )		return 0		//no subtraction	endif		Double diff_baseline = withThisCmdInfoWv[cmd_baseline_pos] - subtractThisWv[cmd_baseline_pos]		if (diff_baselineLimit > abs(diff_baseline))		return 0		//no subtraction	endif		Double diff_step = withThisCmdInfoWv[cmd_step_pos] - subtractThisWv[cmd_step_pos]			//how long is each step? only subtract the smaller of the two	Double seal_stepLen = toSubCmdInfoWv[cmd_t1_pos] - toSubCmdInfoWv[cmd_t0_pos]	Double brkIn_stepLen = withThisCmdInfoWv[cmd_t1_pos] - withThisCmdInfoWv[cmd_t0_pos]	Double maxPostStepSubLen = min(seal_stepLen,brkIn_stepLen)				//how much wave is there preceding step? --only subtract with the smaller of the two	Double seal_preStepSubLen = toSubCmdInfoWv[cmd_t0_pos] - DimOFfset(subtractThisWv,0) - dimdelta(subtractThisWv,0)	Double brkIn_preStepSubLen = withThisCmdInfoWv[cmd_t0_pos] - DimOFfset(fromThisWv,0)  - dimdelta(subtractThisWv,0)	Double maxPreStepSubLen = min(seal_preStepSubLen,brkIn_preStepSubLen)		Double subLen = maxPreStepSubLen + maxPostStepSubLen			//set start and end position for each wave	Double seal_subStartX = toSubCmdInfoWv[cmd_t0_pos] - maxPreStepSubLen	Double seal_subEndX = toSubCmdInfoWv[cmd_t0_pos] + maxPostStepSubLen		Double brkIn_subStartX = withThisCmdInfoWv[cmd_t0_pos] - maxPreStepSubLen	Double brkIn_subEndX = withThisCmdInfoWv[cmd_t0_pos] + maxPostStepSubLen	Double brkIn_t0 = subtractThisWv[cmd_t0_pos]			Print "seal_stepLen",seal_preStepSubLen,"brkIn_stepLen",brkIn_preStepSubLen,"maxPostStepSubLen"	Print "seal_preStepSubLen",seal_preStepSubLen,"brkIn_preStepSubLen",brkIn_preStepSubLen,"maxPreStepSubLen"	Print "brkIn_subStartX",seal_preStepSubLen,"brkIn_subEndX",brkIn_preStepSubLen,"brkIn_t0" 		//do actual subtraction	fromThisWv[x2pnt(fromThisWv,brkIn_subStartX),x2pnt(fromThisWv,brkIn_subEndX)] = fromThisWv(x) - subtractThisWv(x-offset_t0)	//	brkIn_subStartX,brkIn_subEndX) = fromThisWv(x) - subtractThisWv(x-offset_t0)		killwaves/z cmdDiffsWv_tempend function/S analysis_getNewHeader()	String ref = "analysis_newHeader"		Variable numParams = 76	Make/O/T/N=(numParams) $ref/WAVE=paramsOut	paramsOut[0] = "ssRin"	paramsOut[1] = "vCmd_baseline"	paramsOut[2] = "vCmd_step"	paramsOut[3] = "deltaVoltage"	paramsOut[4] = "baseCurrent"	paramsOut[5] = "ssCurrent"	paramsOut[6] = "deltaSSCurrent"	paramsOut[7] = "accessR_noModel"	paramsOut[8] = "memR_noModel"	paramsOut[9] = "peakVal"	paramsOut[10] = "peakLoc"	paramsOut[11] = "ssCurrent_mono"	paramsOut[12] = "tau_mono"	paramsOut[13] = "amp_mono"	paramsOut[14] = "iPeak_mono"	paramsOut[15] = "qTot_mono"	paramsOut[16] = "accessR_mono"	paramsOut[17] = "x0"	paramsOut[18] = "memR_mono"	paramsOut[19] = "mMCapTot_mono"	paramsOut[20] = "mQCapTot_mono"	paramsOut[21] = "ssCurrent_dbl"	paramsOut[22] = "tau1_dbl"	paramsOut[23] = "amp1_dbl"	paramsOut[24] = "tau2_dbl"	paramsOut[25] = "amp2_dbl"	paramsOut[26] = "iPeak_dbl"	paramsOut[27] = "q1_dbl"	paramsOut[28] = "q2_dbl"	paramsOut[29] = "qTot_dbl"	paramsOut[30] = "accessR_dbl"	paramsOut[31] = "memR_dbl"	paramsOut[32] = "mMCap1_dbl"	paramsOut[33] = "mMCap2_dbl"	paramsOut[34] = "mMCapTot_dbl"	paramsOut[35] = "mQcap1_dbl"	paramsOut[36] = "mQcap2_dbl"	paramsOut[37] = "mQcapTot_dbl"	paramsOut[38] = "vCmd_t0"	paramsOut[39] = "vCmd_t1"	paramsOut[40] = "vCmd_baseline"	paramsOut[41] = "vCmd_step"	paramsOut[42] = "baselineLenX"	paramsOut[43] = "baselineStartX"	paramsOut[44] = "baselineEndX"	paramsOut[45] = "ssWinLenX"	paramsOut[46] = "ssWinStartX"	paramsOut[47] = "ssWinEndX"	paramsOut[48] = "fitWinSize"	paramsOut[49] = "fitStartX"	paramsOut[50] = "fitEndX"	paramsOut[51] = "fitStartP"	paramsOut[52] = "fitEndP"			paramsOut[53] = "timeSinceBrkIn"	paramsOut[54] =  "timeUnitsStr"	paramsOut[55] = "fileNum"	paramsOut[56] = "sweepNum"	paramsOut[57] = "chanNum"	paramsOut[58] = "fd_fileNum"	paramsOut[59] = "fd_sweepNum"	paramsOut[60] = "file.sweep"	paramsOut[61] = "fd_file.sweep"	paramsOut[62] = "timeSinceRecStart"	paramsOut[63] = "IS_VC"	//IC-specific	paramsOut[64] = "ic_cmd_t0"	paramsOut[65] = "ic_cmd_t1"	paramsOut[66] = "ic_cmd_baseline"	paramsOut[67] = "ic_cmd_step	"	paramsOut[68] = "ic_deltaCurrent"	paramsOut[69] = "ic_baseVoltage"	paramsOut[70] = "ic_ssVoltage"	paramsOut[71] = "ic_deltaSSVoltage"		paramsOut[72] = "isNegativeStep"		//cc and vc	paramsOut[73] = "peakBelowMin"					//vc parameter, analysis not performed because peak below threhsold		paramsOut[74] = "Len_s" 	paramsOut[75] = "sRate"		concatenate/NP=0/T {$stats_getFTestHeader()}, paramsOut	return refend//analysis_getNewHeader()//for data generated with analysis_fastCellParamsT()function analysis_dispCellParams(gName, leftAxisName, paramsRef, respRef, monoFitRef, dblFitRef)	String gName, leftAxisName, paramsRef, respRef, monoFitRef, dblFitRef	Variable numDispPoints = 6	Variable ssWinStartX = getParamFromHeader_1D("ssWinStartX", "analysis_newHeader", paramsRef)	Variable ssWinEndX = getParamFromHeader_1D("ssWinEndX", "analysis_newHeader", paramsRef)	Variable baselineStartX = getParamFromHeader_1D("baselineStartX", "analysis_newHeader", paramsRef)	Variable baselineEndX = getParamFromHeader_1D("baselineEndX", "analysis_newHeader", paramsRef)	Variable fitStartX = getParamFromHeader_1D("fitStartX", "analysis_newHeader", paramsRef)	Variable fitEndX = getParamFromHeader_1D("fitEndX", "analysis_newHeader", paramsRef)	Variable peakLoc = getParamFromHeader_1D("peakLoc", "analysis_newHeader", paramsRef)	Variable peakVal = getParamFromHeader_1D("peakVal", "analysis_newHeader", paramsRef)			PRint "ssWinStartX....",ssWinStartX, ssWinEndX, baselineStartX, baselineEndX, fitStartX, fitEndX		Make/O/N=(numDispPoints,2) analysis_cellParamsSimpleDisp	Make/O/N=(numDispPoints,3) analysis_cellParamsDisp_colors	Make/O/N=(numDispPoints) analysis_cellParamsDisp_shapes; 	analysis_cellParamsDisp_shapes = 10	analysis_cellParamsSimpleDisp[0][0] = ssWinStartX	analysis_cellParamsSimpleDisp[1][0] = ssWinEndX	analysis_cellParamsDisp_colors[0,1][] = 50000	analysis_cellParamsSimpleDisp[2][0] = baselineStartX	analysis_cellParamsSimpleDisp[3][0] = baselineEndX	analysis_cellParamsDisp_colors[2,3][] = 50000	analysis_cellParamsSimpleDisp[4][0] = peakLoc; analysis_cellParamsSimpleDisp[4][1] = peakVal	analysis_cellParamsDisp_shapes[4] = 19			//circle for peak	analysis_cellParamsSimpleDisp[5][0] = fitEndX	analysis_cellParamsDisp_colors[4,5][0] = 50000 ;analysis_cellParamsDisp_colors[4,5][1,2] = 0		//red	if (!disp_isWaveOnGraph(gName, "analysis_cellParamsSimpleDisp"))		appendtoGraph/W=$gName/L=$leftAxisName analysis_cellParamsSimpleDisp[][1] vs analysis_cellParamsSimpleDisp[][0]	endif		//monoFitTest","dblFitTest", "paramsTest	if (!disp_isWaveOnGraph(gName, respRef))		appendtoGraph/W=$gName/L=$leftAxisName $respRef	endif	if (!disp_isWaveOnGraph(gName, monoFitRef))		appendtoGraph/W=$gName/L=$leftAxisName $monoFitRef	endif	if (!disp_isWaveOnGraph(gName, dblFitRef))		appendtoGraph/W=$gName/L=$leftAxisName $dblFitRef	endif		ModifyGraph mode(analysis_cellParamsSimpleDisp)=3;DelayUpdate	ModifyGraph marker(analysis_cellParamsSimpleDisp)=10, mrkThick(analysis_cellParamsSimpleDisp)=2	ModifyGraph zColor(analysis_cellParamsSimpleDisp)={analysis_cellParamsDisp_colors,*,*,directRGB,0}end//analysis_dispCellParams()//meant for use on windows with abf waves with standard bruxton naming: assumes waves end in AD0, AD1, AD2function/S fa_autoFromWin(hashStr)	String hashStr		//1;0;1;1; ... determines which AD#s to avg, e.g. this hash would avg "*AD0", "*AD2", "*AD3"		Variable i; string saveStr, outStr="", matchStr	for (i=0;i<itemsInLisT(hashStr);i+=1)		if (stringmatch(stringfromlist(i,hashStr),"1"))			matchStr = "*AD" + num2str(i)			saveStr = wave_avgFromWin(matchStr, "",0,nan,nan)			outStr += saveStr + ";"		//autogenerates output naming		endif	endfor		return outStrend//expects that refs are generated in the automatic format of wave_avgfromlist() / wave_avgfromwin()function ic_cp_main(somaPedBothOrBothRev,firstFDFileNum,vrespRef_S,cmdRef_S,sealRef_S,icRef_PfS,vrespRef_P,cmdRef_P,sealRef_P,icRef_SfP,streamTags,forceNameBase,earlyVersion)	Variable somaPedBothOrBothRev	//(0-5:) 0	-soma(hs1) only, 1-soma(hs2) only, 2-ped(hs1) only, 3-ped(hs2) only, 4-both(soma:hs1,ped:hs2), 5-both(soma:hs2,ped:hs1)	String streamTags , forceNameBase	variable firstFDFileNum		//file num of first file for this cell in file directory.. helps with bookkeeping	String vrespRef_S,cmdRef_S,sealRef_S,vrespRef_P,cmdRef_P,sealRef_P	String icRef_PfS, icRef_SfP	//current clamp responses at each site (PfS is ped with v clamp from soma), should be simultaneous with responses at main site	Variable earlyVersion				//0 for no, 1 or more for version #. e + version # == earlyVersion appended to file name so that main analysis not deleted		String avgRefs = vrespRef_S+";"+cmdRef_S+";"+sealRef_S+";"+icRef_PfS+";"+vrespRef_P+";"+cmdRef_P+";"+sealRef_P+";"+icRef_SfP+";"	da_fd_remakeAvgWaves(avgRefs,1,1)	String streamedAnalysisStr = "", streamedRefsStr = ""	Variable doDisplay = 1,deleteSavedStreamRefs=0		//save calling function str	--wont return stream tags	streamedAnalysisStr+="calling_func:ic_cp_main("+num2str(somaPedBothOrBothRev)+","+num2str(firstFDFileNum)+","	streamedAnalysisStr+=qu(vrespRef_S)+","+qu(cmdRef_S)+","+qu(sealRef_S)+","+qu(icRef_PfS)+","+qu(vrespRef_P)+","+qu(cmdRef_P)+","+qu(sealRef_P)+","+qu(icRef_SfP)+","	streamedAnalysisStr+="stag,"+qu(forceNameBase)+","+num2str(earlyVersion) + ");"		//save input waves	streamedRefsStr += vrespRef_S+";"+cmdRef_S+";"+sealRef_S+";"+icRef_PfS+";"+vrespRef_P+";"+cmdRef_P+";"+sealRef_P+";"+icRef_SfP+";"	streamedAnalysisStr += "vrespRef_S:"+vrespRef_S+";cmdRef_S:"+cmdRef_S+";sealRef_S:"+sealRef_S+";icRef_PfS:"+icRef_PfS+";vrespRef_P:"+vrespRef_P+";cmdRef_P:"+cmdRef_P+";sealRef_P:"+sealRef_P+";icRef_SfP:"+icRef_SfP+";"	Print "streamedRefsStr",streamedRefsStr		String cp_analysisSaveRefs, cp_streamedAnalysisStr	scp_main(somaPedBothOrBothRev,firstFDFileNum,vrespRef_S,cmdRef_S,sealRef_S,vrespRef_P,cmdRef_P,sealRef_P,streamTags,forceNameBase,0,out_streamedAnalysisSaveRefs=cp_analysisSaveRefs,out_streamedAnalysisStr=cp_streamedAnalysisStr)	String nameBase = StringByKey("nameBase",cp_streamedAnalysisStr)		if (earlyVersion)		namebase += "E"+num2str(earlyVersion)		streamedAnalysisStr += "earlyVersion:"+ num2str(earlyVersion)+";"	endif		String ic_params_ref_S = "", ic_params_ref_P = "", ic_fit_ref_S="", ic_fit_ref_P=""		Variable icResp_stimAtSoma = strlen(icRef_PfS) > 0	Variable vCmd_t0,vCmd_t1,vCmd_baseline,vCmd_step, current_delta	if (icResp_stimAtSoma)		String vStepParamsRef_fS=StringByKey("paramSaveName_S",cp_streamedAnalysisStr)		//vstep info from ped v step		Print "ic_cp_main(): vStepParamsRef_fS",vStepParamsRef_fS		WAVE vStepParams_fS = $vStepParamsRef_fS		vCmd_t0 = vStepParams_fS[%vCmd_t0]		vCmd_t1 = vStepParams_fS[%vCmd_t1]		vCmd_baseline = vStepParams_fS[%vCmd_baseline]		vCmd_step = vStepParams_fS[%vCmd_step]		current_delta = vStepParams_fS[%deltaSSCurrent]		//delta current at stimualted site for an approximation of input res at other site				ic_params_ref_S = nameBase + "_ic_cp_fS"		ic_fit_ref_S = nameBase + "_ic_cp_fit_fS"		Print "ic_cp_main(): ic_params_ref_S",ic_params_ref_S		analysis_cellParams_ic(icRef_PfS,vCmd_t0,vCmd_t1,vCmd_baseline,vCmd_step,current_delta,NaN,NaN,ic_params_ref_S,ic_fit_ref_S)				streamedAnalysisStr += "ic_params_ref_S:"+ic_params_ref_S+";ic_fit_ref_S:"+ic_fit_ref_S+";"		streamedRefsStr += ic_params_ref_S+";"+ic_fit_ref_S+";"	endif			Variable isResp_stimAtPed = strlen(icRef_SfP) > 0	if (isResp_stimAtPed)		String vStepParamsRef_fP=StringByKey("paramSaveName_P",cp_streamedAnalysisStr)		//vstep info from ped v step		Print "ic_cp_main(): vStepParamsRef_fP",vStepParamsRef_fP		WAVE vStepParams_fP = $vStepParamsRef_fP		vCmd_t0 = vStepParams_fP[%vCmd_t0]		vCmd_t1 = vStepParams_fP[%vCmd_t1]		vCmd_baseline = vStepParams_fP[%vCmd_baseline]		vCmd_step = vStepParams_fP[%vCmd_step]		current_delta = vStepParams_fP[%deltaSSCurrent]		//delta current at stimualted site for an approximation of input res at other site				ic_params_ref_P = nameBase + "_ic_cp_fP"		ic_fit_ref_P = nameBase + "_ic_cp_fit_fP"		Print "ic_cp_main(): ic_params_ref_P",ic_params_ref_P		analysis_cellParams_ic(icRef_SfP,vCmd_t0,vCmd_t1,vCmd_baseline,vCmd_step,current_delta,NaN,NaN,ic_params_ref_P,ic_fit_ref_P)				streamedAnalysisStr += "ic_params_ref_P:"+ic_params_ref_P+";ic_fit_ref_P:"+ic_fit_ref_P+";"		streamedRefsStr += ic_params_ref_P+";"+ic_fit_ref_P+";"		endif			streamedAnalysisStr += "cp_streamed_info:starts_afer_this;"+	text_appendToKeyStrs("cp_",0,cp_streamedAnalysisStr)				//ReplaceString(";",cp_streamedAnalysisStr,"|") + ";"	streamedRefsStr += cp_analysisSaveRefs		streamedAnalysisStr += "streamTags:" + replacestring(";",streamTags,"|") + ";"			Print "streamedAnalysisStr",streamedAnalysisStr	Print "streamedRefsStr", streamedRefsStr		fio_stream_saveToStream("ic_cp",nameBase,streamedAnalysisStr,streamTags,"",0,streamedRefsStr,deleteSavedStreamRefs)end //ic_cp_mainfunction ic_cp_main_update_all()		variable i	for (i=0;i<dimsize($"ic_cp_refs_main0",0);i+=1)		ic_cp_main_update(i)	endforendfunction ic_cp_main_update(ic_cp_row)	Variable ic_cp_row		WAVE/T infWv = $"ic_cp_refs_main0"	String info = infWv[ic_cp_row]	String lastSaveName = GetDimLabel(infWv, 0, ic_cp_row )			String loadList = ""	Variable somaPedBothOrBothRev = str2num(stringbykey("cp_somaPedBothOrBothRev",info));	Variable firstFDFileNum = str2num(stringbykey("cp_firstFDFileNum",info))	String vrespRef_S = stringbykey("vrespRef_S",info);loadList+=vrespRef_S+";"	String cmdRef_S = stringbykey("cmdRef_S",info);loadList+=cmdRef_S+";"	String sealRef_S = stringbykey("sealRef_S",info);loadList+=sealRef_S+";"	String icRef_PfS = stringbykey("icRef_PfS",info);loadList+=icRef_PfS+";"	String vrespRef_P = stringbykey("vrespRef_P",info);loadList+=vrespRef_P+";"	String cmdRef_P = stringbykey("cmdRef_P",info);loadList+=cmdRef_P+";"	String sealRef_P = stringbykey("sealRef_P",info);loadList+=sealRef_P+";"	String icRef_SfP = stringbykey("icRef_SfP",info);loadList+=icRef_SfP+";"	String forceNameBase = stringbykey("cp_forceNameBase",info)		fio_stream_loadIBF("ic_cp_refs_main0",loadList,skipPreExisting=1)		String missingKeyStrList="",missingWvList=""	Variable missingKeyStrCount = 0,missingWvCount = 0;	if (numtype(somaPedBothOrBothRev))		missingKeyStrList+="somaPedBothOrBothRev;";missingKeyStrCount += 1	endif		if (numtype(firstFDFileNum))		missingKeyStrList+="firstFDFileNum;";missingKeyStrCount += 1	endif		if (!strlen(vrespRef_S))		missingKeyStrList+="vrespRef_S;";missingKeyStrCount += 1	else		if (!waveExists($vrespRef_S))			missingWvList+="vrespRef_S;"			missingWvCount += 1		endif	endif	if (!strlen(cmdRef_S))		missingKeyStrList+="cmdRef_S;";missingKeyStrCount += 1		else		if (!waveExists($cmdRef_S))			missingWvList+="cmdRef_S;"			missingWvCount += 1		endif	endif	if (!strlen(sealRef_S))		missingKeyStrList+="sealRef_S;";missingKeyStrCount += 1		else		if (!waveExists($sealRef_S))			missingWvList+="sealRef_S;"			missingWvCount += 1		endif	endif	if (!strlen(icRef_PfS))		missingKeyStrList+="icRef_PfS;";missingKeyStrCount += 1		else		if (!waveExists($icRef_PfS))			missingWvList+="icRef_PfS;"			missingWvCount += 1		endif	endif	if (!strlen(vrespRef_P))		missingKeyStrList+="vrespRef_P;";missingKeyStrCount += 1		else		if (!waveExists($vrespRef_P))			missingWvList+="vrespRef_P;"			missingWvCount += 1		endif	endif	if (!strlen(cmdRef_P))		missingKeyStrList+="cmdRef_P;";missingKeyStrCount += 1		else		if (!waveExists($cmdRef_P))			missingWvList+="cmdRef_P;"			missingWvCount += 1		endif	endif	if (!strlen(sealRef_P))		missingKeyStrList+="sealRef_P;";missingKeyStrCount += 1		else		if (!waveExists($sealRef_P))			missingWvList+="sealRef_P;"			missingWvCount += 1		endif	endif	if (!strlen(icRef_SfP))		missingKeyStrList+="icRef_SfP;";missingKeyStrCount += 1		else		if (!waveExists($icRef_SfP))			missingWvList+="icRef_SfP;"			missingWvCount += 1		endif	endif	if (!strlen(forceNameBase))		missingKeyStrList+="forceNameBase;";missingKeyStrCount += 1	endif		Variable earlyVersion,earlyVersionNumStart = strsearch(lastSaveName,"E",2,0)		//passing 0 causes necessity for case match	if (earlyVersionNumStart < 0)		//no early version indicator found		earlyVersion = nan	else		earlyVersion = str2num(lastSaveName[earlyVersionNumStart+1])		Print "ic_cp_main_update(): row",ic_cp_row,"earlyVersion found #=",earlyVersion	endif		String streamTags = "",key	String possibleStreamTags = "soma;ped;"	variable i	for (i=0;i<itemsinlist(possibleStreamTags);i+=1)		key = stringfromlist(i,possibleStreamTags)		streamTags += key + ":" + stringbykey(key,info) + ";"	endfor		//info str	if ( (missingKeyStrCount > 1) || (missingKeyStrCount && !stringmatch(missingKeyStrList,"forceNameBase;") ) )		String repeatStr = stringbykey("calling_func",info)		Print "ic_cp_main_update(): row",ic_cp_row,"missingKeyStrCount",missingKeyStrCount,"missingKeyStrList",missingKeyStrList		Print "repeatStr",repeatStr	endif		if (missingWvCount > 0)		Print "ic_cp_main_update(): row",ic_cp_row,"missingWvCount",missingWvCount,"missingWvList",missingWvList	endif		ic_cp_main(somaPedBothOrBothRev,firstFDFileNum,vrespRef_S,cmdRef_S,sealRef_S,icRef_PfS,vrespRef_P,cmdRef_P,sealRef_P,icRef_SfP,streamTags,forceNameBase,earlyVersion)endfunction cp_fixStreamTags_all(infoRef)	String infoRef		Variable i	for (i=0;i<dimsize($infoRef,0);i+=1)		cp_fixStreamTags(infoRef,i)	endforendfunction cp_fixStreamTags(infoRef,row)	String infoRef;Variable row		WAVE/T inWv = $infoRef		String info = inWv[row]		info = replacestring("hs1:soma,",info,"soma:hs1,")	info = replacestring("hs1:ped,",info,"ped:hs1,")	info = replacestring("hs2:soma,",info,"soma:hs2,")	info = replacestring("hs2:ped,",info,"ped:hs2,")end//appends to key strings in a list. assumes standard key and list sep strings, but one can adjust thisfunction/S text_appendToKeyStrs(keyAppendStr,appendAfterNotBefore,listStr)	String keyAppendStr,listStr	Variable appendAfterNotBefore		String keySepStr = ":"	String listSepStr = ";"		if (!stringmatch(listStr,"*" + listSepStr))		listStr += listSepStr	endif		String preAppendStr, postAppendStr	if (appendAfterNotBefore)		preAppendStr = ""		postAppendStr = keyAppendStr	else		preAppendStr = keyAppendStr		postAppendStr = ""		endif			variable i	string key,keyAndItem,item,keyReplacement,out=""	for (i=0;i<itemsinlist(listStr,listSepStr);i+=1)		keyAndItem = stringfromlist(i,listStr,listSepStr)		key = stringfromlist(0,keyAndItem,keySepStr)		item =  stringfromlist(1,keyAndItem,keySepStr)		keyReplacement = preAppendStr + key + postAppendStr		out += keyReplacement + keySepStr + item + listSepStr	endfor		return outend//should work equally function/S text_appendToStrsInList(list,appendStr,appendBeforeNotAFter,listSepStr)	STring list,appendStr,listSepStr;variable appendBeforeNotAFter		String preAppendStr,postAppendStr	if (appendBeforeNotAFter)		preAppendStr = appendStr		postAppendStr = ""	else		preAppendStr = ""		postAppendStr = appendStr	endif		variable i;string out = ""	for (i=0;i<itemsinlist(list,listSepStr);i+=1)		out += preAppendStr + stringfromlist(i,list,listSepStr) + postAPpendStr + listSepStr	endfor		return out	endfunction/S qu(str)	String str		return "\""+str+"\""end//streamed cell param function with no streaming... use if not wanting to save wavesfunction/S analysis_cellParams_NS(somaPedBothOrBothRev,firstFDFileNum,respRef_S,cmdRef_S,sealRef_S,respRef_P,cmdRef_P,sealRef_P,nameBaseAppendStr,streamTags,forceNameBase,isDualClamp)	Variable somaPedBothOrBothRev,firstFDFileNum	String respRef_S,cmdRef_S,sealRef_S,respRef_P,cmdRef_P,sealRef_P,nameBaseAppendStr	String streamTags,forceNameBase	Variable isDualClamp		Variable doDisplay = 1		String analysisSaveRefs = "", analysisStr=""	scp_main(somaPedBothOrBothRev,firstFDFileNum,respRef_S,cmdRef_S,sealRef_S,respRef_P,cmdRef_P,sealRef_P,streamTags,forceNameBase,isDualClamp,out_streamedAnalysisSaveRefs=analysisSaveRefs,nameBaseAppendStr=nameBaseAppendStr,out_streamedAnalysisStr=analysisStr)		String paramSaveName_S=StringByKey("paramSaveName_S",analysisStr)	String paramSaveName_P=StringByKey("paramSaveName_P",analysisStr)	String fitSaveName_S = StringByKey("fitSaveName_S",analysisStr)	String fitSaveName_P = StringByKey("fitSaveName_P",analysisStr)	Print "analysis_cellParams_NS(): paramSaveName_S",paramSaveName_S,"fitSaveName_S",fitSaveName_S,"paramSaveName_P",paramSaveName_P,"fitSaveName_P",fitSaveName_P	return analysisStrend//related useful functions//analysis: ic_cp_main: for simultaneous streams, analysis_cellParams_NS: for calling this function easily without streaming//display: analysis_capTrans_dispFitStats, analysis_expFit_again_dispFits//expects that refs are generated in the automatic format of wave_avgfromlist() / wave_avgfromwin()function scp_main(somaPedBothOrBothRev,firstFDFileNum,respRef_S,cmdRef_S,sealRef_S,respRef_P,cmdRef_P,sealRef_P,streamTags,forceNameBase,isDualClamp,[nameBaseAppendStr,out_streamedAnalysisSaveRefs,out_streamedAnalysisStr])	Variable somaPedBothOrBothRev	//(0-5:) 0	-soma(hs1) only, 1-soma(hs2) only, 2-ped(hs1) only, 3-ped(hs2) only, 4-both(soma:hs1,ped:hs2), 5-both(soma:hs2,ped:hs1) 	variable firstFDFileNum		//file num of first file for this cell in file directory.. helps with bookkeeping	String respRef_S,cmdRef_S,sealRef_S,respRef_P,cmdRef_P,sealRef_P	String &out_streamedAnalysisSaveRefs,&out_streamedAnalysisStr		//pass to return these lists INSTEAD OF save to stream	String nameBaseAppendStr		//optionally pass to annote nameBase	String streamTags,forceNameBase	Variable isDualClamp		//appends appropriate stream string and to base name adds "D" so as not to overwrite non-simultaneous clamp info		Variable saveToStream = 0		Variable deleteSavedStreamRefs = 0, doDisplay = 1		//defaults 0, 1	Variable baselineEndX = 0.015		//good default	Variable isNegativeStep = 1		String nameBase, defaultNameBase	String/G paramSaveName_S="",paramSaveName_P="",fitSaveName_S="",fitSaveName_P=""	//instantiated to avoid errors in with replacestring/replacenumber by key	Variable fd_fileNum_S=-inf, fd_sweepNum_S=-inf, fd_fileNum_P=-inf, fd_sweepNum_P=-inf		//useful for bookkeeping in analysis_cap	String usedNameBaseAppendStr	if (PAramIsDefault(nameBaseAppendStr))		usedNameBaseAppendStr = ""	else		usedNameBaseAppendStr = nameBaseAppendStr	endif		if (isDualClamp)		usedNameBaseAppendStr += "D"	endif		Variable respAtSoma = strlen(respRef_S) > 0, respAtTerminal = strlen(respRef_P) > 0		//////////////		//added as convenient way to store actual capacity transient mean:	String/G subSaveRef_S="",subSaveref_P=""	if (respAtSoma)		subSaveRef_S=respRef_S + "_SS"		//for seal sub		WAVE resp=$respRef_S		Duplicate/O resp, $subSaveRef_S/wave=sub		if (strlen(sealRef_S))			WAVE seal=$sealRef_S			sub-=seal		endif			endif	if (respAtTerminal)		subSaveRef_P=respRef_P + "_SS"		//for seal sub		WAVE resp=$respRef_P		Duplicate/O resp, $subSaveRef_P/wave=sub		if (strlen(sealRef_P))			WAVE seal=$sealRef_P			sub-=seal		endif			endif			Print "subSaveRef_S",subSaveRef_S,"subSaveref_P",subSaveref_P////////////		//analyze somatic responses	if (respAtSoma)		defaultNameBase =text_getInfoFromWaveName_S(respRef_S, 0)	+ usedNameBaseAppendStr		if (strlen(forceNameBase))			nameBase = forceNameBase + usedNameBaseAppendStr		else		//default			nameBase = defaultNameBase		endif		paramSaveName_S = nameBase + "scp_S"		//scp -- streamed cell params or may simple is better, to diferentiate from automated mased one		fitSaveName_S = nameBase + "scpf_S"		fd_fileNum_S = NumberByKey("AVG_FIRST_SWEEP_FD_FILENUM", note($respRef_S))			fd_sweepNum_S = NumberByKey("AVG_FIRST_SWEEP_FD_SWEEPNUM", note($respRef_S))				Print "scp_main(): paramSaveName_S",paramSaveName_S,"fitSaveName_S",fitSaveName_S		analysis_cap(firstFDFileNum, cmdRef_S, respRef_S, baselineEndX, isNegativeStep, sealRef_S, paramSaveName_S, fitSaveName_S, "",fd_fileNum=fd_fileNum_S,fd_sweepNum=fd_sweepNum_S)	endif		//analyze terminal responses	if (respAtTerminal)		if (!respAtSoma)		//get nameBase from ped			defaultNameBase = text_getInfoFromWaveName_S(respRef_P, 0)		+ usedNameBaseAppendStr			if (strlen(forceNameBase))				nameBase = forceNameBase	+ usedNameBaseAppendStr			else				nameBase = defaultNameBase			endif		endif		paramSaveName_P = nameBase + "scp_P"		fitSaveName_P = nameBase + "scpf_P"		fd_fileNum_P = NumberByKey("AVG_FIRST_SWEEP_FD_FILENUM", note($respRef_P))		//useful for bookkeeping		fd_sweepNum_P = NumberByKey("AVG_FIRST_SWEEP_FD_SWEEPNUM", note($respRef_P))					Print "scp_main(): paramSaveName_P",paramSaveName_P,"fitSaveName_P",fitSaveName_P		analysis_cap(firstFDFileNum, cmdRef_P, respRef_P, baselineEndX, isNegativeStep, sealRef_P, paramSaveName_P, fitSaveName_P, "",fd_fileNum=fd_fileNum_S,fd_sweepNum=fd_sweepNum_P)	endif	String streamedAnalysisStr = ""	streamedAnalysisStr = ReplaceNumberByKey("oneSiteOrDual", streamedAnalysisStr, isDualClamp)	streamedAnalysisStr = ReplaceNumberByKey("somaPedBothOrBothRev", streamedAnalysisStr, somaPedBothOrBothRev)	streamedAnalysisStr = ReplaceNumberByKey("respAtSoma", streamedAnalysisStr, respAtSoma)	streamedAnalysisStr = ReplaceNumberByKey("respAtTerminal", streamedAnalysisStr, respAtTerminal)	streamedAnalysisStr = ReplaceStringByKey("defaultNameBase", streamedAnalysisStr, defaultNameBase)	streamedAnalysisStr = ReplaceStringByKey("forceNameBase", streamedAnalysisStr, forceNameBase)	streamedAnalysisStr = ReplaceStringByKey("nameBase", streamedAnalysisStr, nameBase)	streamedAnalysisStr = ReplaceStringByKey("usedNameBaseAppendStr", streamedAnalysisStr, usedNameBaseAppendStr)	streamedAnalysisStr = ReplaceStringByKey("paramSaveName_S", streamedAnalysisStr, paramSaveName_S)	streamedAnalysisStr = ReplaceStringByKey("fitSaveName_S", streamedAnalysisStr, fitSaveName_S)	streamedAnalysisStr = ReplaceStringByKey("paramSaveName_P", streamedAnalysisStr, paramSaveName_P)	streamedAnalysisStr = ReplaceStringByKey("fitSaveName_P", streamedAnalysisStr, fitSaveName_P)		streamedAnalysisStr = ReplaceNumberByKey("firstFDFileNum", streamedAnalysisStr, firstFDFileNum)	streamedAnalysisStr = ReplaceNumberByKey("isNegativeStep", streamedAnalysisStr, isNegativeStep)	streamedAnalysisStr = ReplaceNumberByKey("baselineEndX", streamedAnalysisStr, baselineEndX)	streamedAnalysisStr = ReplaceStringByKey("respRef_S", streamedAnalysisStr, respRef_S)	streamedAnalysisStr = ReplaceStringByKey("cmdRef_S", streamedAnalysisStr, cmdRef_S)	streamedAnalysisStr = ReplaceStringByKey("sealRef_S", streamedAnalysisStr, sealRef_S)	streamedAnalysisStr = ReplaceStringByKey("respRef_P", streamedAnalysisStr, respRef_P)	streamedAnalysisStr = ReplaceStringByKey("cmdRef_P", streamedAnalysisStr, cmdRef_P)	streamedAnalysisStr = ReplaceStringByKey("sealRef_P", streamedAnalysisStr, sealRef_P)		String streamedAnalysisSaveRefs = ""	streamedAnalysisSaveRefs = AddListItem(respRef_S, streamedAnalysisSaveRefs)	streamedAnalysisSaveRefs = AddListItem(cmdRef_S, streamedAnalysisSaveRefs)	streamedAnalysisSaveRefs = AddListItem(sealRef_S, streamedAnalysisSaveRefs)	streamedAnalysisSaveRefs = AddListItem(respRef_P, streamedAnalysisSaveRefs)	streamedAnalysisSaveRefs = AddListItem(cmdRef_P, streamedAnalysisSaveRefs)	streamedAnalysisSaveRefs = AddListItem(sealRef_P, streamedAnalysisSaveRefs)	streamedAnalysisSaveRefs = AddListItem(paramSaveName_S, streamedAnalysisSaveRefs)	streamedAnalysisSaveRefs = AddListItem(fitSaveName_S, streamedAnalysisSaveRefs)	streamedAnalysisSaveRefs = AddListItem(paramSaveName_P, streamedAnalysisSaveRefs)	streamedAnalysisSaveRefs = AddListItem(fitSaveName_P, streamedAnalysisSaveRefs)		streamedAnalysisSaveRefs = RemovefromList(";",streamedAnalysisSaveRefs)		//remove any null strings e.g. if only single site or no brk in ref		if (saveToStream)		if (ParamIsDefault(out_streamedAnalysisSaveRefs))			fio_stream_saveToStream("scp",nameBase,streamedAnalysisStr,streamTags,"",0,streamedAnalysisSaveRefs,deleteSavedStreamRefs)		else			out_streamedAnalysisSaveRefs = streamedAnalysisSaveRefs			if (!paramIsDefault(out_streamedAnalysisStr))				out_streamedAnalysisStr = streamedAnalysisStr			endif		endif	endif	if (doDisplay)		if (!respAtTerminal)		//assume soma only			analysis_expFit_again_dispFits($paramSaveName_S, 0.073458,0.078)			analysis_capTrans_dispFitStats(paramSaveName_S, "")			return 0		endif				if (!respAtSoma)		//assume terminal only			analysis_expFit_again_dispFits($paramSaveName_P, 0.073458,0.078)			analysis_capTrans_dispFitStats("", paramSaveName_P)			return 0					endif				//assume resp at both		analysis_expFit_again_dispFits($paramSaveName_S, 0.073458,0.078)		analysis_expFit_again_dispFits($paramSaveName_P, 0.073458,0.078)		analysis_capTrans_dispFitStats(paramSaveName_S, paramSaveName_P)	endif	end //scp_main()//related useful functions//analysis: ic_cp_main: for simultaneous streams, analysis_cellParams_NS: for calling this function easily without streaming//display: analysis_capTrans_dispFitStats, analysis_expFit_again_dispFits//as for scp_main but meant to focus on one site before after after other site break infunction scp_bad_main(somaPedBothOrBothRev,firstFDFileNum,preAndPostAtPed,respRef_pre,respRef_post,cmdRef,sealRef,doDisplay,streamTags,forceNameBase,[in_cmdRef_pre,in_sealRef_pre,in_cmdRef_post,in_sealRef_post,addNameBaseAppendStr,out_streamedAnalysisSaveRefs,out_streamedAnalysisStr])	Variable somaPedBothOrBothRev	//(0-5:) 0	-soma(hs1) only, 1-soma(hs2) only, 2-ped(hs1) only, 3-ped(hs2) only, 4-both(soma:hs1,ped:hs2), 5-both(soma:hs2,ped:hs1) 	variable firstFDFileNum		//file num of first file for this cell in file directory.. helps with bookkeeping	Variable preAndPostAtPed		//are the before and after second site waves at soma or ped?	String respRef_pre,respRef_post,cmdRef,sealRef	String &out_streamedAnalysisSaveRefs,&out_streamedAnalysisStr		//pass to return these lists INSTEAD OF save to stream	String addNameBaseAppendStr		//optionally pass to annote nameBase	Variable doDIsplay			//pass to display: may interfere with deletion or deletion may interfere with it	String streamTags,forceNameBase	String in_cmdRef_pre,in_sealRef_pre,in_cmdRef_post,in_sealRef_post	//optionally pass to seperately set cmdRef and sealRefs. particularly helpful if subtracting post ahead of time e.g. with analysis_subCmd()	Variable baselineEndX = 0.015		//good default	Variable isNegativeStep = 1		Variable deleteSavedStreamRefs = 0	//set true to delete those refs that have been saved to analysis stream (onto file)		String nameBase, nameBaseAppendStr = "", defaultNameBase	String paramSaveName_pre="",paramSaveName_post="",fitSaveName_pre="",fitSaveName_post=""	Variable fd_fileNum_pre=-inf, fd_sweepNum_pre=-inf, fd_fileNum_post=-inf, fd_sweepNum_post=-inf		//useful for bookkeeping in analysis_cap	if (!PAramIsDefault(addNameBaseAppendStr))		nameBaseAppendStr = addNameBaseAppendStr	endif	//analyze pre response	defaultNameBase = text_getInfoFromWaveName_S(respRef_pre, 0)	+ nameBaseAppendStr	if (strlen(forceNameBase))		nameBase = forceNameBase + nameBaseAppendStr	else		nameBase = defaultNameBase	endif			paramSaveName_pre = nameBase + "scp_pre"		//scp -- streamed cell params	fitSaveName_pre = nameBase + "scpf_pre"	fd_fileNum_pre = NumberByKey("AVG_FIRST_SWEEP_FD_FILENUM", note($respRef_pre))		fd_sweepNum_pre = NumberByKey("AVG_FIRST_SWEEP_FD_SWEEPNUM", note($respRef_pre))	String cmdRef_pre,sealRef_pre	if (!ParamIsDefault(in_cmdRef_pre))		cmdRef_pre = in_cmdRef_pre	else		cmdRef_pre = cmdRef	endif	if (!ParamIsDefault(in_sealRef_pre))		sealRef_pre = in_sealRef_pre	else		sealRef_pre = sealREf	endif			analysis_cap(firstFDFileNum, cmdRef, respRef_pre, baselineEndX, isNegativeStep, sealRef_pre, paramSaveName_pre, fitSaveName_pre, "",fd_fileNum=fd_fileNum_pre,fd_sweepNum=fd_sweepNum_pre)		//analyze post response	paramSaveName_post = nameBase + "scp_post"	fitSaveName_post = nameBase + "scpf_post"	fd_fileNum_post = NumberByKey("AVG_FIRST_SWEEP_FD_FILENUM", note($respRef_post))		//useful for bookkeeping	fd_sweepNum_post = NumberByKey("AVG_FIRST_SWEEP_FD_SWEEPNUM", note($respRef_post))		String cmdRef_post,sealRef_post	if (!ParamIsDefault(in_cmdRef_post))		cmdRef_post = in_cmdRef_post	else		cmdRef_post = cmdRef	endif	if (!ParamIsDefault(in_sealRef_post))		sealRef_post = in_sealRef_post	else		sealRef_post = sealREf	endif		analysis_cap(firstFDFileNum, cmdRef_post, respRef_post, baselineEndX, isNegativeStep, sealRef_post, paramSaveName_post, fitSaveName_post, "",fd_fileNum=fd_fileNum_post,fd_sweepNum=fd_sweepNum_post)		//calculate differences	String diffParamsName = nameBase + "scp_bad"		//scp before after difference	String fDiffParamsName = nameBase + "scp_fbad"		//fold before after diff	WAVE/D params_pre = $paramSaveName_pre, params_post = $paramSaveName_post	Duplicate/O params_pre, $diffParamsName/wave=params_diffs, $fDiffParamsName/wave=params_fold	params_diffs = params_post - params_pre	params_fold = params_post / params_pre		Print "scp_bad_main(): paramSaveName_pre",paramSaveName_pre,"fitSaveName_pre",fitSaveName_pre,"paramSaveName_post",paramSaveName_post,"fitSaveName_post",fitSaveName_post,"diffParamsName",diffParamsName,"fDiffParamsName",fDiffParamsName	String streamedAnalysisStr = ""		streamedAnalysisStr = ReplaceNumberByKey("somaPedBothOrBothRev", streamedAnalysisStr, somaPedBothOrBothRev)	streamedAnalysisStr = ReplaceNumberByKey("preAndPostAtPed", streamedAnalysisStr, preAndPostAtPed)	streamedAnalysisStr = ReplaceStringByKey("nameBase", streamedAnalysisStr, nameBase)	streamedAnalysisStr = ReplaceStringByKey("nameBaseAppendStr", streamedAnalysisStr, nameBaseAppendStr)	streamedAnalysisStr = ReplaceStringByKey("defaultNameBase", streamedAnalysisStr, defaultNameBase)	streamedAnalysisStr = ReplaceStringByKey("paramSaveName_pre", streamedAnalysisStr, paramSaveName_pre)	streamedAnalysisStr = ReplaceStringByKey("fitSaveName_pre", streamedAnalysisStr, fitSaveName_pre)	streamedAnalysisStr = ReplaceStringByKey("paramSaveName_post", streamedAnalysisStr, paramSaveName_post)	streamedAnalysisStr = ReplaceStringByKey("fitSaveName_post", streamedAnalysisStr, fitSaveName_post)		streamedAnalysisStr = ReplaceStringByKey("diffParamsName", streamedAnalysisStr, diffParamsName)	streamedAnalysisStr = ReplaceStringByKey("fDiffParamsName", streamedAnalysisStr, fDiffParamsName)			streamedAnalysisStr = ReplaceNumberByKey("firstFDFileNum", streamedAnalysisStr, firstFDFileNum)	streamedAnalysisStr = ReplaceNumberByKey("isNegativeStep", streamedAnalysisStr, isNegativeStep)	streamedAnalysisStr = ReplaceNumberByKey("baselineEndX", streamedAnalysisStr, baselineEndX)	streamedAnalysisStr = ReplaceStringByKey("respRef_pre", streamedAnalysisStr, respRef_pre)	streamedAnalysisStr = ReplaceStringByKey("cmdRef", streamedAnalysisStr, cmdRef)	streamedAnalysisStr = ReplaceStringByKey("sealRef", streamedAnalysisStr, sealRef)	streamedAnalysisStr = ReplaceStringByKey("respRef_post", streamedAnalysisStr, respRef_post)	streamedAnalysisStr = ReplaceStringByKey("cmdRef_pre", streamedAnalysisStr, cmdRef_pre)	streamedAnalysisStr = ReplaceStringByKey("sealRef_pre", streamedAnalysisStr, sealRef_pre)	streamedAnalysisStr = ReplaceStringByKey("cmdRef_post", streamedAnalysisStr, cmdRef_post)	streamedAnalysisStr = ReplaceStringByKey("sealRef_post", streamedAnalysisStr, sealRef_post)	streamedAnalysisStr = ReplaceStringByKey("streamTags", streamedAnalysisStr, Replacestring(";",streamTags,"|"))		String streamedAnalysisSaveRefs = ""	streamedAnalysisSaveRefs = AddListItem(respRef_pre, streamedAnalysisSaveRefs)	streamedAnalysisSaveRefs = AddListItem(cmdRef, streamedAnalysisSaveRefs)	streamedAnalysisSaveRefs = AddListItem(sealRef, streamedAnalysisSaveRefs)	streamedAnalysisSaveRefs = AddListItem(respRef_post, streamedAnalysisSaveRefs)	streamedAnalysisSaveRefs = AddListItem(paramSaveName_pre, streamedAnalysisSaveRefs)	streamedAnalysisSaveRefs = AddListItem(fitSaveName_pre, streamedAnalysisSaveRefs)	streamedAnalysisSaveRefs = AddListItem(paramSaveName_post, streamedAnalysisSaveRefs)	streamedAnalysisSaveRefs = AddListItem(fitSaveName_post, streamedAnalysisSaveRefs)	streamedAnalysisSaveRefs = AddListItem(diffParamsName, streamedAnalysisSaveRefs)	streamedAnalysisSaveRefs = AddListItem(fDiffParamsName, streamedAnalysisSaveRefs)		streamedAnalysisSaveRefs = RemovefromList(";",streamedAnalysisSaveRefs)		//remove any null strings e.g. if only single site or no brk in ref		if (ParamIsDefault(out_streamedAnalysisSaveRefs))		fio_stream_saveToStream("scp_bad",nameBase,streamedAnalysisStr,streamTags,"",0,streamedAnalysisSaveRefs,deleteSavedStreamRefs)	else		out_streamedAnalysisSaveRefs = streamedAnalysisSaveRefs		if (!paramIsDefault(out_streamedAnalysisStr))			out_streamedAnalysisStr = streamedAnalysisStr		endif	endif		if (doDisplay)		analysis_expFit_again_dispFits($paramSaveName_pre, 0.073458,0.078)		analysis_expFit_again_dispFits($paramSaveName_post, 0.073458,0.078)		analysis_capTrans_dispFitStats(paramSaveName_pre, paramSaveName_post)		edit/k=1 $paramSaveName_pre.ld,$paramSaveName_post,$diffParamsName,$fDiffParamsName		display/k=1 $fitSaveName_post[][0]		//will be in read		appendtograph/C=(0,0,0) $fitSaveName_pre[][0]		//will be in black	endif	endfunction analysis_cellParams_ic(icRef,vCmd_t0,vCmd_t1,vCmd_baseline,vCmd_step,secondSite_current_delta,secondSite_voltage_baseline,secondSite_votage_step,paramsOutRef,fitOutRef)	String icRef		//response ref	Double vCmd_t0,vCmd_t1,vCmd_baseline,vCmd_step		//step command info	Double secondSite_current_delta,secondSite_voltage_baseline, secondSite_votage_step		//optional: pass NaN, otherwise some parameters are calculated based on these	String paramsOutRef,fitOutRef		string noteStr = "ic_cp_icRef:"+icRef+";"		WAVE icWv = $icRef		Variable maxNumExps = 4			//max num exps for fit	Variable baselineWinSizeX = 0.03	Variable baselineWinDelayX = 5*DimDelta(icWv,0)	//small delay in case anything unexpected really fast	Variable baselineStartX = vCmd_t0 - baselineWinSizeX - baselineWinDelayX	//small delay in case anything unexpected really fast	Variable baselineEndX = vCmd_t0 - baselineWinDelayX	Variable ssWinDelayX = 0.075		//start and end time for linear fit (lFit) at absolute time from t0	Variable lFitStartDelayX_fixed = 0.0001		Variable lFitLenX_fixed = 0.00025		//proportion of rise and fall for linear fit at times relative to rising and speed	Variable lFitStartDelayX_prop = 0.05		//start linear fit at x where rising is (e.g. for = 0.05) 5% of the way to final	Variable lFitLenX_prop = 0.3		//end linear fit at x where rising is (e.g. for = 0.3) 30% of the way to final									Variable ssWinSizeX = baselineWinSizeX	Variable ssWinStartX = vCmd_t0 + ssWinDelayX	Variable ssWinEndX = vCmd_t0 + ssWinDelayX + ssWinSizeX		Double baseline_mean = mean(icWv,baselineStartX, baselineEndX)	Double step_mean = mean(icWv,ssWinStartX, ssWinEndX)	Double delta_mean = step_mean - baseline_mean	Variable isNegativeResponse = delta_mean < 0	Double baseline_var = variance(icWv,baselineStartX, baselineEndX)	Double step_var = variance(icWv,ssWinStartX, ssWinEndX)	Double delta_var = step_var - baseline_var	Double delta_cmd = vCmd_step - vCmd_baseline	Variable negativeGoingCmd = delta_cmd < 0 	Double respBaselineCmdBaselineDiff = baseline_mean - vCmd_baseline	Double respStepCmdStepDiff = step_mean - vCmd_step	Double respDeltaMinusCmdDelta = delta_mean - delta_cmd			//difference in cmd and resp delta	Double respDeltaOverCmdDelta = delta_mean / delta_cmd			//fold difference in cmd and resp deltas	Double cmdDeltaOverRespDelta = 1 / respDeltaOverCmdDelta		Double Rin_apparent=NaN	Double site2site_volt_baseline_diff=NaN,site2site_volt_step_diff=NaN,secondSite_voltage_delta=NaN,site2site_voltDelta_diff=NaN,site2site_voltDelta_ratio=NaN	if ( numtype(secondSite_current_delta) != 2 )			//num is not NaN --note, for better or worse, +/-inf ok		Rin_apparent = delta_mean / secondSite_current_delta	endif//secondSite_voltage_baseline, secondSite_votage_step	if ( numtype(secondSite_voltage_baseline)  != 2  )		site2site_volt_baseline_diff = baseline_mean - secondSite_voltage_baseline	endif	if ( numtype(secondSite_votage_step) != 2  )		site2site_volt_step_diff = step_mean - secondSite_votage_step 	endif	if ( (numtype(secondSite_voltage_baseline) != 2) && (numtype(secondSite_votage_step) != 2) )		secondSite_voltage_delta = secondSite_votage_step - secondSite_voltage_baseline		site2site_voltDelta_diff = delta_mean - secondSite_voltage_delta		site2site_voltDelta_ratio = delta_mean / secondSite_voltage_delta	endif			//fit a line to the rising phase and extrapolate back to baseline crossing		//for fixed time after t0	Double lFitStartX_fixed = vCmd_t0 + lFitStartDelayX_fixed				//thresholdTimes_peakToBase_Rise[lineStartProp]	Double lFitEndX_fixed = lFitStartX_fixed + lFitLenX_fixed			// thresholdTimes_peakToBase_Rise[lineEndProp]		analysis_fitRisingPhaseLine(icWv,lFitStartX_fixed,lFitEndX_fixed,baseline_mean,vCmd_t0,"cp_ic_line_fixed_temp",0, "cp_ic_line_fixed_ftemp", 1)			//for time at t0 relative to ~speed of rising   --based on lFitStartDelayX_prop, lFitLenX_prop	Double lFitStartX_prop_level = baseline_mean + delta_mean * lFitStartDelayX_prop	Double lFitEndX_prop_level = baseline_mean + delta_mean * lFitLenX_prop	FindLevel/Q/R=(vCmd_t0,ssWinStartX) icWv, lFitStartX_prop_level	Double lFitStartX_prop = V_LevelX		FindLevel/Q/R=(vCmd_t0,ssWinStartX) icWv, lFitEndX_prop_level	Double lFitEndX_prop = V_LevelX		analysis_fitRisingPhaseLine(icWv,lFitStartX_prop,lFitEndX_prop,baseline_mean,vCmd_t0,"cp_ic_line_prop_temp",0, "cp_ic_line_prop_ftemp", 1)		//find 30% 50% 66% whatever thresholds	Double threshold_05 = baseline_mean + delta_mean * 0.05	Double threshold_10 = baseline_mean + delta_mean * 0.1	Double threshold_30 = baseline_mean + delta_mean * 0.3	Double threshold_50 = baseline_mean + delta_mean * 0.5	Double threshold_75 = baseline_mean + delta_mean * 0.75	Double threshold_90 = baseline_mean + delta_mean * 0.9	Double threshold_e1 = baseline_mean + delta_mean * (1/exp(1))		//~37%	Double threshold_e2 = baseline_mean + delta_mean * (1-(1/exp(1)))//~63%		FindLevel/Q/R=(vCmd_t0,ssWinStartX) icWv, threshold_05	Double threshold_05_X = V_LevelX; Double threshold_05_xRelT0 = threshold_05_X - vCmd_t0	FindLevel/Q/R=(vCmd_t0,ssWinStartX) icWv, threshold_10	Double threshold_10_X = V_LevelX; Double threshold_10_xRelT0 = threshold_10_X - vCmd_t0		FindLevel/Q/R=(vCmd_t0,ssWinStartX) icWv, threshold_30	Double threshold_30_X = V_LevelX; Double threshold_30_xRelT0 = threshold_30_X - vCmd_t0		FindLevel/Q/R=(vCmd_t0,ssWinStartX) icWv, threshold_50	Double threshold_50_X = V_LevelX; Double threshold_50_xRelT0 = threshold_50_X - vCmd_t0		FindLevel/Q/R=(vCmd_t0,ssWinStartX) icWv, threshold_75	Double threshold_75_X = V_LevelX; Double threshold_75_xRelT0 = threshold_75_X - vCmd_t0	FindLevel/Q/R=(vCmd_t0,ssWinStartX) icWv, threshold_90	Double threshold_90_X = V_LevelX; Double threshold_90_xRelT0 = threshold_90_X - vCmd_t0		FindLevel/Q/R=(vCmd_t0,ssWinStartX) icWv, threshold_e1	Double threshold_e1_X = V_LevelX; Double threshold_e1_xRelT0 = threshold_e1_X - vCmd_t0	FindLevel/Q/R=(vCmd_t0,ssWinStartX) icWv, threshold_e2	Double threshold_e2_X = V_LevelX; Double threshold_e2_xRelT0 = threshold_e2_X - vCmd_t0		//find best fits to exponentials	Variable expFit_startXProp = 0.05		//convenient to make equal to a threshold calculated above	Double expFit_startXVal = threshold_05	Double expFit_startX = threshold_05_X	Double expFit_endX = ssWinEndX		Variable expFit_startProp = threshold_05			analysis_expFit_again(icWv, expFit_startX, expFit_endX, maxNumExps, "cp_ic_exp_params_temp", NaN, NaN, fitOutRef)	noteStr += "ic_cp_fitOutRef:"+fitOutRef+";"		Variable numParams = 60	Make/O/D/N=(numParams) $"ic_cp_params_Temp"/wave=out	dl_assignAndLbl(out, 0, maxNumExps, "maxNumExps")	dl_assignAndLbl(out, 1, baselineWinSizeX, "baselineWinSizeX")	dl_assignAndLbl(out, 2, baselineWinDelayX, "baselineWinDelayX")	dl_assignAndLbl(out, 3, baselineStartX, "baselineStartX")	dl_assignAndLbl(out, 4, baselineEndX, "baselineEndX")	dl_assignAndLbl(out, 5, ssWinDelayX, "ssWinDelayX")	dl_assignAndLbl(out, 6, lFitStartDelayX_fixed, "lFitStartDelayX_fixed")	dl_assignAndLbl(out, 7, lFitLenX_fixed, "lFitLenX_fixed")	dl_assignAndLbl(out, 8, lFitStartDelayX_prop, "lFitStartDelayX_prop")	dl_assignAndLbl(out, 9, lFitLenX_prop, "lFitLenX_prop")	dl_assignAndLbl(out, 10, ssWinSizeX, "ssWinSizeX")	dl_assignAndLbl(out, 11, ssWinStartX, "ssWinStartX")	dl_assignAndLbl(out, 12, ssWinEndX, "ssWinEndX")	dl_assignAndLbl(out, 13, baseline_mean, "baseline_mean")	dl_assignAndLbl(out, 14, step_mean, "step_mean")	dl_assignAndLbl(out, 15, delta_mean, "delta_mean")	dl_assignAndLbl(out, 16, isNegativeResponse, "isNegativeResponse")	dl_assignAndLbl(out, 17, baseline_var, "baseline_var")	dl_assignAndLbl(out, 18, step_var, "step_var")	dl_assignAndLbl(out, 19, delta_var, "delta_var")	dl_assignAndLbl(out, 20, delta_cmd, "delta_cmd")					dl_assignAndLbl(out, 21, negativeGoingCmd, "negativeGoingCmd")		dl_assignAndLbl(out, 22, respBaselineCmdBaselineDiff, "respBaselineCmdBaselineDiff")	dl_assignAndLbl(out, 23, respStepCmdStepDiff, "respStepCmdStepDiff")			dl_assignAndLbl(out, 24, respDeltaMinusCmdDelta, "respDeltaMinusCmdDelta")		dl_assignAndLbl(out, 25, respDeltaOverCmdDelta, "respDeltaOverCmdDelta")		dl_assignAndLbl(out, 26, cmdDeltaOverRespDelta, "cmdDeltaOverRespDelta")		dl_assignAndLbl(out, 27, Rin_apparent, "Rin_apparent")		dl_assignAndLbl(out, 28, site2site_volt_baseline_diff, "site2site_volt_baseline_diff")		dl_assignAndLbl(out, 29, site2site_volt_step_diff, "site2site_volt_step_diff")		dl_assignAndLbl(out, 30, secondSite_voltage_delta, "secondSite_voltage_delta")		dl_assignAndLbl(out, 31, site2site_voltDelta_diff, "site2site_voltDelta_diff")		dl_assignAndLbl(out, 32, site2site_voltDelta_ratio, "site2site_voltDelta_ratio")		dl_assignAndLbl(out, 33, lFitStartX_fixed, "lFitStartX_fixed")		dl_assignAndLbl(out, 34, lFitEndX_fixed, "lFitEndX_fixed")			dl_assignAndLbl(out, 35, lFitStartX_prop_level, "lFitStartX_prop_level")		dl_assignAndLbl(out, 36, lFitEndX_prop_level, "lFitEndX_prop_level")		dl_assignAndLbl(out, 37, lFitStartX_prop, "lFitStartX_prop")		dl_assignAndLbl(out, 38, lFitEndX_prop, "lFitEndX_prop")		dl_assignAndLbl(out, 39, threshold_05, "threshold_05")		dl_assignAndLbl(out, 40, threshold_10, "threshold_10")		dl_assignAndLbl(out, 41, threshold_30, "threshold_30")		dl_assignAndLbl(out, 42, threshold_50, "threshold_50")		dl_assignAndLbl(out, 43, threshold_75, "threshold_75")		dl_assignAndLbl(out, 44, threshold_90, "threshold_90")		dl_assignAndLbl(out, 45, threshold_e1, "threshold_e1")	dl_assignAndLbl(out, 46, threshold_e2, "threshold_e2")	dl_assignAndLbl(out, 47, threshold_05, "threshold_05_X")		dl_assignAndLbl(out, 48, threshold_10, "threshold_10_X")		dl_assignAndLbl(out, 49, threshold_30, "threshold_30_X")		dl_assignAndLbl(out, 50, threshold_50, "threshold_50_X")		dl_assignAndLbl(out, 51, threshold_75, "threshold_75_X")		dl_assignAndLbl(out, 52, threshold_90, "threshold_90_X")		dl_assignAndLbl(out, 53, threshold_e1, "threshold_e1_X")	dl_assignAndLbl(out, 54, threshold_e2, "threshold_e2_X")	dl_assignAndLbl(out, 55, expFit_startXProp, "expFit_startXProp")	dl_assignAndLbl(out, 56, expFit_startXVal, "expFit_startXVal")	dl_assignAndLbl(out, 57, expFit_startX, "expFit_startX")	dl_assignAndLbl(out, 58, expFit_endX, "expFit_endX")	dl_assignAndLbl(out, 59, expFit_startProp, "expFit_startProp")			//bring in wavse (not necessary; only worthwhile so that an error is thrown if one unexpectedly does not exist)	WAVE ic_cp_params_Temp;	WAVE cp_ic_line_fixed_temp;	WAVE cp_ic_line_prop_temp;	WAVE cp_ic_exp_params_temp;		string catList="ic_cp_params_Temp;cp_ic_line_fixed_temp;cp_ic_line_prop_temp;cp_ic_exp_params_temp;"		dl_cat(0,catList,"main_;fixedL_;propL_;exp_;",1,paramsOutRef)	note/nocr $paramsOutRef, noteStr	end	//analysis_cellParams_ic()function analysis_fitRisingPhaseLine(respWv,lineStartX,lineEndX,baselineVal,t0, out_paramsRef, returnInputParams, out_fitRef, dispFitOverlay)	WAVE/D respWv	Double lineStartX,lineEndX	//position to fit line to	Double baselineVal				//value of baseline for extrapolation back to time of baseline crossing	Double t0			//time of baseline ending--for relative timing of baseline crossing	String out_paramsRef			//pass to return params	Variable returnInputParams		//pass to include input parameters (e.g. t0) in out_paramsRef (appended to end, dim label preceded by "in_")	String out_fitRef			//pass to generate and store fit -- required for dispFitOverlay	Variable dispFitOverlay		//pass to display fit with overlay -- requires a usable reference for out_fitRef		Variable makeFitToBaselineCross = 1	//0 - fit between lineStartX, lineEndX; 1 - fit between lineStartX/lineEndX (whichever appropriate) and fitfunc(x) = baselineVal 		Make/O/D/N=2 lineCoefsWv	CurveFit/Q/N=1 line, kwCWave=lineCoefsWv, respWv(lineStartX,lineEndX)	Variable lineSlope = lineCoefsWv[1]	Variable lineZeroCrossX = lineCoefsWv[0]	Variable lineBaselineCrossX = (baselineVal - lineZeroCrossX) / lineSlope	Variable lineStartX_rel_t0 = lineStartX - t0	Variable lineEndX_rel_t0 = lineEndX - t0	Variable lineZeroCrossX_rel_t0 = lineZeroCrossX-t0	Variable lineBaselineCrossX_rel_t0 = lineBaselineCrossX - t0		Variable lineEndVal = fit_line(lineCoefsWv,lineEndX)	Variable lineStartVal = fit_line(lineCoefsWv,lineStartX)		if (strlen(out_paramsRef))		Variable numOutputParams = 11, numInputParams = 4		Variable numParams = numOutputParams + ( returnInputParams ? numInputParams : 0 )		Make/O/D/N=(numParams) $out_paramsRef/wave=out				dl_assignAndLbl(out,0,lineCoefsWv[0],"line_coef_0")		dl_assignAndLbl(out,1,lineCoefsWv[1],"line_coef_1")		dl_assignAndLbl(out,2,lineZeroCrossX,"line_ZeroCrossX")		//equal to line_coef_0 but I hate checking which is which		dl_assignAndLbl(out,3,lineSlope,"line_Slope")		//equal to lineSlope		dl_assignAndLbl(out,4,lineBaselineCrossX,"line_BaselineCrossX")		dl_assignAndLbl(out,5,lineStartVal,"line_StartVal")		dl_assignAndLbl(out,6,lineEndVal,"line_EndVal")		dl_assignAndLbl(out,7,lineStartX_rel_t0,"line_StartX_rel_t0")		dl_assignAndLbl(out,8,lineEndX_rel_t0,"line_EndX_rel_t0")		dl_assignAndLbl(out,9,lineZeroCrossX_rel_t0,"line_ZeroCrossX_rel_t0")		dl_assignAndLbl(out,10,lineBaselineCrossX_rel_t0,"line_BaselineCrossX_rel_t0")				if (returnInputParams)			dl_assignAndLbl(out,11,lineStartX,"line_StartX")//"in_line_StartX")			dl_assignAndLbl(out,12,lineEndX,"line_EndX")//"in_line_EndX")			dl_assignAndLbl(out,13,baselineVal,"line_BaselineVal")//"in_line_BaselineVal")			dl_assignAndLbl(out,14,t0,"line_t0")//"in_line_t0")		endif	endif		if (strlen(out_fitRef))		Variable fitStartX, fitEndX		if (!makeFitToBaselineCross)			fitStartX = lineStartX; fitEndX = lineEndX		else			if (lineBaselineCrossX < lineStartX)				fitStartX = lineBaselineCrossX; fitEndX = lineEndX			elseif (lineBaselineCrossX > lineEndX)				fitStartX = lineStartX; fitEndX = lineBaselineCrossX			else				fitStartX = lineStartX; fitEndX = lineEndX	//just draw whole fit bc baseline crossing is in middle of line			endif		endif		duplicate/O/R=(fitStartX,fitEndX) respWv, $out_fitRef/wave=outFitWv		outFitWv = fit_line(lineCoefsWv,x)	endif		note/nocr out, "analysis_fitRisingPhaseLine_INWAVE:"+nameofwave(respWv)+";analysis_fitRisingPhaseLine_returnInputParams:"+num2str(returnInputParams)+";"		if (dispFitOverlay && WaveExists(outFitWv))		//must pass a reference that out_fitRef can (and has been) saved into		Display/k=1		appendtograph/C=(0,0,0) respWv		appendtograph outFitWv		setaxis bottom, fitStartX, fitEndX		Setaxis/A=2 left		note/nocr out, "analysis_fitRisingPhaseLine_DISPWIN:"+S_name+";"		Print "analysis_fitRisingPhaseLine(): response [ref=",nameofwave(respWv),"] and fit [ref=",out_fitRef,"]displayed in winName=",S_name	endifendfunction fit_line(w,x)	WAVE w	Double x		return w[0] + w[1]*xendfunction analysis_cap_list(firstFileNum,cmdRef_list,respRef_list,baselineEndX,isNegativeStep,sealRef,paramsSaveRef,avg_paramsSaveRef,fitSaveRef,avg_fitSaveRef,cmdStepInfoRef,avgRespMeth_paramsRef,avgRespMeth_fitSaveRef)	String cmdRef_list, respRef_list	//paired list of cmdRefs and respRefs; to avoid command ref list, pass cmdStepInfoRef... or alter this function to keep using the first cmdRef in the list	Variable baselineEndX, isNegativeStep	String sealRef		//optionally pass a sealRespRef to subtract	String paramsSaveRef	//wave into which parameterized results should be stored (e.g., input resistance)	String avg_paramsSaveRef	//wave to store average of each parameter mean value (col 0), stdev (col1),  SEM (col2), CV (col 3), and N (col 4)	String fitSaveRef		//stores a 3 column wave: first column is response, second is mono fit, third is dbl fit	String avg_fitSaveRef	//same as for avg_paramsSaveRef; except that there are layers--layer 0 is the raw response, 1 is monoexp fit, 2 is dbl exp, and so on	Variable firstFileNum						//used for sweep timing	String cmdStepInfoRef					//pass if no vCmd, should contain cmd_t1, cmd_baseline, cmd_step in that order (see cellParamsSimple_cmd for explanation of these parameters)	String avgRespMeth_paramsRef,avgRespMeth_fitSaveRef		//pass "" to not do this		//calculate mean of actual response	if (strlen(avgRespMeth_paramsRef) || strlen(avgRespMeth_fitSaveRef))		//then calculate 		String resp_avgRef = wave_avgFromStrList(respRef_list,";", "",0,nan,nan)		String cmd_avgRef = wave_avgFromStrList(cmdRef_list,";", "",0,nan,nan)		analysis_cap(firstFileNum,cmd_avgRef,resp_avgRef,baselineEndX,isNegativeStep,sealRef,avgRespMeth_paramsRef,avgRespMeth_fitSaveRef,cmdStepInfoRef)	endif	String cmdRef,respRef	String fitSaveRef_temp,paramsSaveRef_temp	variable i,num = itemsinlist(respRef_list),j,numRawDataAndFits,numFitPnts	for (i=0;i<num;i+=1)		cmdRef=stringfromlist(i,cmdRef_list)		respRef=stringfromlist(i,respRef_list)		paramsSaveRef_temp = paramsSaveRef + "_" + num2str(i)	//temporarily hold fit output		fitSaveRef_temp = fitSaveRef + "_" + num2str(i)	//temporarily hold params output		analysis_cap(firstFileNum,cmdRef,respRef,baselineEndX,isNegativeStep,sealRef,paramsSaveRef_temp,fitSaveRef_temp,cmdStepInfoRef)		WAVE paramsSaveWv_temp = $paramsSaveRef_temp;WAVE fitSaveWv_temp = $fitSaveRef_temp		//change fitSaveWv_temp from a N_timePnts x M_rawDataAndFits wave of rows x columns		//into a N_timePnts x 1 column X M_rawDataAndFits wave of rows x 1 columns x layers wave		if (i==0)			//copy over params wave to output after instantiating output wave			//WAVE paramsSaveWv_temp = $paramsSaveRef_temp			Duplicate/O paramsSaveWv_temp, $paramsSaveRef/wave=paramsSaveWv			Redimension/N=(-1,1) paramsSaveWv						//copy over fit wave to output, after instanting fit output wave			numFitPnts=dimsize(fitSaveWv_temp,0)			numRawDataAndFits=dimsize(fitSaveWv_temp,1)			duplicate/O fitSaveWv_temp, $fitSaveRef/wave=fitSaveWv		//currently N rows by M=(numFits+1) columns			Redimension/N=(-1,-1,1) fitSaveWv; SetDimLabel 2,i,$respRef,fitSaveWv		else			//copy over params wave to output			matrixop/O paramsSaveWv = catcols(paramsSaveWv,paramsSaveWv_temp)//concatenate the new params wave with all previous					Redimension/N=(-1,-1,1) fitSaveWv_temp			concatenate/DL/NP=2 {fitSaveWv_temp}, fitSaveWv			SetDimLabel 2,i,$respRef,fitSaveWv		endif				//label params from output		SetDimLabel 1,i,$respRef,paramsSaveWv	endfor			variable numParams = dimsize(paramsSaveWv,0), numStats = 11,z		//numStats should be updated to add e.g. skew or kurtosis etc. as a new column	Make/O/D/N=(numParams,numStats) $avg_paramsSaveRef/wave=avg_paramsSaveWv	dl_labelsFromWvToWv(paramsSaveWv,0,0,numParams,avg_paramsSaveWv,0,0)	for (i=0;i<numParams;i+=1)		Imagestats/G={i,i,0,num-1} paramsSaveWv		z=0;avg_paramsSaveWv[i][z] = V_avg		z+=1;avg_paramsSaveWv[i][z] = V_sdev		z+=1;avg_paramsSaveWv[i][z] = V_npnts				//this number does not included nans, infs		z+=1;avg_paramsSaveWv[i][z] = V_sdev / sqrt(V_npnts)		//SEM		z+=1;avg_paramsSaveWv[i][z] = V_sdev / V_npnts				//CV		z+=1;avg_paramsSaveWv[i][z] = V_min		z+=1;avg_paramsSaveWv[i][z] = V_minColLoc		z+=1;avg_paramsSaveWv[i][z] = V_max		z+=1;avg_paramsSaveWv[i][z] = V_maxColLoc		z+=1;avg_paramsSaveWv[i][z] = V_adev		z+=1;avg_paramsSaveWv[i][z] = V_rms				if (i==0)		//label columns			z=0;SetDimLabel 1,z,V_avg,avg_paramsSaveWv			z+=1;SetDimLabel 1,z,V_sdev,avg_paramsSaveWv			z+=1;SetDimLabel 1,z,V_npnts,avg_paramsSaveWv			z+=1;SetDimLabel 1,z,SEM,avg_paramsSaveWv			z+=1;SetDimLabel 1,z,CV,avg_paramsSaveWv			z+=1;SetDimLabel 1,z,V_min,avg_paramsSaveWv			z+=1;SetDimLabel 1,z,V_minColLoc,avg_paramsSaveWv			z+=1;SetDimLabel 1,z,V_max,avg_paramsSaveWv			z+=1;SetDimLabel 1,z,V_maxColLoc,avg_paramsSaveWv			z+=1;SetDimLabel 1,z,V_adev,avg_paramsSaveWv			z+=1;SetDimLabel 1,z,V_rms,avg_paramsSaveWv				endif	endfor		//in fitSaveWv, rows are time pnts, columns are different fits, and layers are different reps	//store in each column the average (in layer 0) for a given raw data/fit; store in each layer a different statistic 	Make/O/D/N=(numFitPnts,numRawDataAndFits,numStats) $avg_fitSaveRef/wave=avg_fitSaveWv	SetScale/P x, DimOffset(fitSaveWv, 0), dimdelta(fitSaveWv,0),waveunits(fitSaveWv,0), avg_fitSaveWv	Make/O/U/B/N=(numFitPnts,numRawDataAndFits,num) cap_roi_temp	dl_labelsFromWvToWv(fitSaveWv,1,0,numRawDataAndFits,avg_fitSaveWv,1,0)	for (i=0;i<numFitPnts;i+=1)	//all rows of time points in fit window		for (j=0;j<numRawDataAndFits;j+=1)	//all columns of raw data or fit types			cap_roi_temp=1		//exclude all			cap_roi_temp[i][j][] = 0	//include the current rows at the current columns for all layers (all reps) --this seems like it could be faster than a one-liner that queries to see if a point is in desired bounds			Imagestats/R=cap_roi_temp fitSaveWv			z=0;avg_fitSaveWv[i][j][z] = V_avg			z+=1;avg_fitSaveWv[i][j][z] = V_sdev			z+=1;avg_fitSaveWv[i][j][z] = V_npnts				//this number does not included nans, infs			z+=1;avg_fitSaveWv[i][j][z] = V_sdev / sqrt(V_npnts)		//SEM			z+=1;avg_fitSaveWv[i][j][z] = V_sdev / V_npnts				//CV			z+=1;avg_fitSaveWv[i][j][z] = V_min			z+=1;avg_fitSaveWv[i][j][z] = V_minColLoc			z+=1;avg_fitSaveWv[i][j][z] = V_max			z+=1;avg_fitSaveWv[i][j][z] = V_maxColLoc			z+=1;avg_fitSaveWv[i][j][z] = V_adev			z+=1;avg_fitSaveWv[i][j][z] = V_rms						if (i==0)		//label columns				z=0;SetDimLabel 2,z,V_avg,avg_fitSaveWv				z+=1;SetDimLabel 2,z,V_sdev,avg_fitSaveWv				z+=1;SetDimLabel 2,z,V_npnts,avg_fitSaveWv				z+=1;SetDimLabel 2,z,SEM,avg_fitSaveWv				z+=1;SetDimLabel 2,z,CV,avg_fitSaveWv				z+=1;SetDimLabel 2,z,V_min,avg_fitSaveWv				z+=1;SetDimLabel 2,z,V_minColLoc,avg_fitSaveWv				z+=1;SetDimLabel 2,z,V_max,avg_fitSaveWv				z+=1;SetDimLabel 2,z,V_maxColLoc,avg_fitSaveWv				z+=1;SetDimLabel 2,z,V_adev,avg_fitSaveWv				z+=1;SetDimLabel 2,z,V_rms,avg_fitSaveWv					endif		endfor	endfor			end//best function for complex fits to cap transientsfunction analysis_cap(firstFileNum,cmdRef,respRef,baselineEndX,isNegativeStep,sealRef,paramsSaveRef,fitSaveRef,cmdStepInfoRef,[fd_fileNum,fd_sweepNum])	String cmdRef, respRef; Variable baselineEndX, isNegativeStep	String sealRef		//optionally pass a sealRespRef to subtract	String paramsSaveRef	//wave into which parameterized results should be stored (e.g., input resistance)	String fitSaveRef		//stores a 3 column wave: first column is response, second is mono fit, third is dbl fit	Variable fd_fileNum,fd_sweepNum		//only pass if want this info stored, otherwise left blank in params wave (for consistent param wave length)	Variable firstFileNum						//used for sweep timing	String cmdStepInfoRef					//pass if no vCmd, should contain cmd_t1, cmd_baseline, cmd_step in that order (see cellParamsSimple_cmd for explanation of these parameters)	Variable stepFound; Variable cmd_t0 = NaN, cmd_t1 = NaN, cmd_baseline = NaN, cmd_step = NaN	//find start and end of cmd step, cmd baseline and step levels			//attempt to find step, set stepFound true if a step is found, false otherwise	if (strlen(cmdStepInfoRef) > 0)		//command info passed		WAVE cmdStepInfoWv = $cmdStepInfoRef		cmd_t0=cmdStepInfoWv[0]; cmd_t1=cmdStepInfoWv[1]; cmd_baseline=cmdStepInfoWv[2]; cmd_step=cmdStepInfoWv[3]		stepFound = 1	else		stepFound = analysis_cellParamsSimple_cmd(cmdRef, 1, 0, baselineEndX,  isNegativeStep,  cmd_t0, cmd_t1, cmd_baseline, cmd_step,1)	endif		fd_fileNum = ParamIsDefault(fd_fileNum) ? NaN : fd_fileNum; fd_sweepNum = ParamIsDefault(fd_sweepNum) ? NaN : fd_sweepNum		String breakInTimeStr = ""	if (strlen(sealRef) > 0)		breakInTimeStr = fd_note_getWaveTimeStr(sealRef, 1, lastSweepTimingFromAvg=1)	endif	analysis_cap_sub(respRef, firstFileNum, stepFound, cmd_t0, cmd_t1, cmd_baseline, cmd_step, isNegativeStep,sealRef, breakInTimeStr, paramsSaveRef,fitSaveRef,fd_fileNum=fd_fileNum, fd_sweepNum=fd_sweepNum)		return stepFoundend//header for params output is via analysis_getNewHeader()function analysis_cap_sub(respRef,firstFileNum,hasStep,vCmd_t0,vCmd_t1,vCmd_baseline,vCmd_step,isNegativeStep,sealRespRef,breakInTimeStr,paramsOutRef,fitSaveRef,[fd_fileNum,fd_sweepNum,forceMinExcursion,forceBaseCurrent,forceSSCurrent])	String respRef; 		//response to get cell params from	Variable vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step, isNegativeStep		//cmd info (use analysis_fastCellParamsTC to input as array	String sealRespRef		//(optional) pass "" if none	String fitSaveRef			//optionally pass non-zero length to save fits	String paramsOutRef		//must be pre-allocated, data will be overwritten. 	String breakInTimeStr		//pass so that relative sweep timing is known	Variable fd_fileNum,fd_sweepNum		//only pass if want this info stored, otherwise left blank in params wave (for consistent length)	Variable hasStep		//pass zero to bypass majority of processing (and setting of output parameters). Only things like baseline are calculated. vCmd_baseline can still be passed and vCmd_t0 MUST be passed (can be set to expected step start time in analogy to other traces with steps)	Variable firstFileNum		//number of first file of recording, so as to store time since recording start	Double forceMinExcursion		//min excursion for analysis -- avoid default by passing a value (absolute value)	Double forceBaseCurrent,forceSSCurrent		//for use with normalized waves		Double integration_estTimeToSS = 0.006	//estimated time to reach steady state for numerical integration of cap transient -- don't want to have Ih cut into this		Make/O/D/N=1 $paramsOutRef			Print "analysis_cap_sub(): paramsOutRef",paramsOutRef	dl_addVal(vCmd_t0, "vCmd_t0", paramsOutRef,0)	dl_addVal(vCmd_t1, "vCmd_t1", paramsOutRef,0)	dl_addVal(vCmd_baseline, "vCmd_baseline", paramsOutRef,0)	dl_addVal(vCmd_step, "vCmd_step", paramsOutRef,0)	dl_addVal(isNegativeStep, "isNegativeStep", paramsOutRef,0)	dl_addVal(firstFileNum, "firstFileNum", paramsOutRef,0)		if (ParamIsDefault(fd_fileNum))		fd_fileNum  = NaN	endif	if (ParamIsDefault(fd_sweepNum))		fd_sweepNum  = NaN	endif		dl_addVal(!ParamIsDefault(fd_fileNum) ? fd_fileNum : NaN, "fd_fileNum", paramsOutRef,0)	dl_addVal(!ParamIsDefault(fd_sweepNum) ? fd_sweepNum : NaN, "fd_sweepNum", paramsOutRef,0)		Variable currentRespNeedsKill	if ( (strlen(sealRespRef) > 0) && hasStep)		//do sub		Duplicate/O $respRef, currentResp; currentRespNeedsKill = 1		WAVE waveToSub = $sealRespRef			//	analysis_subtractSealWv(waveToSub,currentResp, {vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step,0})		currentResp -= waveToSub	else		WAVE currentResp = $respRef; currentRespNeedsKill = 0	endif			Duplicate/O currentResp, subsavetemp		Double minExcursionForAnalysis,minExcursionForAnalysisDefault=5 * 10^-12	//usually in amps	Variable minExcursionForced	if ( ParamIsDefault(forceMinExcursion) || (numtype(forceMinExcursion) == 2) )		minExcursionForAnalysis = minExcursionForAnalysisDefault		minExcursionForced = 0	else		minExcursionForAnalysis = forceMinExcursion		minExcursionForced = 1	endif		dl_addVal(minExcursionForAnalysis, "minExcursionForAnalysis", paramsOutRef,0)	dl_addVal(minExcursionForced, "minExcursionForced", paramsOutRef,0)		//settings for measuring baseline and step	Variable timing_unitsSelection = 5  ;dl_addVal(timing_unitsSelection, "timing_unitsSelection", paramsOutRef,0)		//gives back in seconds	Variable baselineLenX = 0.01 ;dl_addVal(baselineLenX, "baselineLenX", paramsOutRef,0)	Variable baselineBuffer = 0.0002 ;dl_addVal(baselineBuffer, "baselineBuffer", paramsOutRef,0)	Variable baselineEndX = vCmd_t0 - baselineBuffer ;dl_addVal(baselineEndX, "baselineEndX", paramsOutRef,0)	Variable baselineStartX = baselineEndX - baselineLenX ;dl_addVal(baselineStartX, "baselineStartX", paramsOutRef,0)	Variable ssWinLenX = baselineLenX ;dl_addVal(ssWinLenX, "ssWinLenX", paramsOutRef,0)	Variable ssWinDelay = 0.05 ;dl_addVal(ssWinDelay, "ssWinDelay", paramsOutRef,0)//0.015	Variable ssWinStartX = vCmd_t0 + ssWinDelay ;dl_addVal(ssWinStartX, "ssWinStartX", paramsOutRef,0)	Variable ssWinEndX = ssWinStartX + ssWinLenX	 ;dl_addVal(ssWinEndX, "ssWinEndX", paramsOutRef,0)					Variable stepLength = vCmd_t1 - vCmd_t0	 ;dl_addVal(stepLength, "stepLength", paramsOutRef,0)			//calcualte step duration to assure that fit window falls within step only  (see fit win size limit below for the use of this)	Variable fitWinSize = .01	 ;dl_addVal(fitWinSize, "fitWinSize", paramsOutRef,0)		Variable deltaVoltage = vCmd_step - vCmd_baseline	 ;dl_addVal(deltaVoltage, "deltaVoltage", paramsOutRef,0)			//baseline measurement	Variable baseCurrent,baseCurrentForced	if (ParamIsDefault(forceBaseCurrent) || (numtype(forceBaseCurrent) == 2))		baseCurrent= mean(currentResp, baselineStartX,baselineEndX)		baseCurrentForced = 0	else		baseCurrent=forceBaseCurrent		baseCurrentForced=1	endif	dl_addVal(baseCurrent, "baseCurrent", paramsOutRef,0)	dl_addVal(baseCurrentForced, "baseCurrentForced", paramsOutRef,0)			Variable skipFits = 1		 	//default is to skip unless it's after break in time	Variable timeSinceBrkIn = NaN	 ;		//filled in if there's a step to analyze		Double assumedSpecificCap = NaN	if (hasStep)		//ss current measurement		Variable ssCurrent,ssCurrentForced		if (ParamIsDefault(forceSSCurrent) || (numtype(forceSSCurrent) == 2))			ssCurrent= mean(currentResp, ssWinStartX,ssWinEndX)			ssCurrentForced = 0		else			ssCurrent=forceSSCurrent			ssCurrentForced=1		endif		dl_addVal(ssCurrent, "ssCurrent", paramsOutRef,0)		dl_addVal(ssCurrentForced, "ssCurrentForced", paramsOutRef,0)									Variable deltaSSCurrent = ssCurrent - baseCurrent	 ;dl_addVal(deltaSSCurrent, "deltaSSCurrent", paramsOutRef,0)			Variable ssRin = deltaVoltage / deltaSSCurrent	 ;dl_addVal(ssRin, "ssRin", paramsOutRef,0)					if (strlen(breakInTimeStr) > 0)		 	timeSinceBrkIn = text_getTimeSinceTimeStr(breakInTimeStr, respRef, timing_unitsSelection)		endif				dl_addVal(timeSinceBrkIn, "timeSinceBrkIn", paramsOutRef,0)	//ad this now that it's decided		//NO LONGER in common with current clamp version from here until mentioned again below		skipFits = !numtype(timeSinceBrkIn) && (timeSinceBrkIn <= 0) 			//exponential curve fitting often fails before break in, so this allows it to be skipped. Could produce undesirable results if break in timing is incorrect				//find peak of the capacity transient. Want to start fit at this peak, even if it's after t0, because we don't want to fit to values that are lower than and precede the peak		WaveStats/Q/R=(vCmd_t0, ssWinStartX) currentResp		Variable peakLoc, peakVal		if (isNegativeStep)	//so look for minimum			peakLoc = V_minloc		//Might have to NVAR in V_minloc and V_maxloc, but not today...			peakVal = V_min - baseCurrent			//at step, all current flowing through access resistance, giving capactive transient. Subtract baseline to get delta for this capacitive current		else			peakLoc = V_maxloc			peakVal = V_max - baseCurrent		endif			Print "peakLoc",peakLoc,"peakVal",peakVal		dl_addVal(peakLoc, "peakLoc", paramsOutRef,0)		 ;dl_addVal(peakVal, "peakVal", paramsOutRef,0)			 			Variable peakBelowMin =  abs(peakVal) < minExcursionForAnalysis	 ;dl_addVal(peakBelowMin, "peakBelowMin", paramsOutRef,0)		skipFits = skipFits || peakBelowMin  ;dl_addVal(skipFits, "skipFits", paramsOutRef,0)				//access res and membrane res based on cap transient peak		Variable accessR_noModel = deltaVoltage/peakVal	 ;dl_addVal(accessR_noModel, "accessR_noModel", paramsOutRef,0)		//only a rough estimate, especially if the peak is incorrectly found (e.g. before going whole cell)		Variable memR_noModel = ( deltaVoltage - (accessR_noModel*ssCurrent) ) / ssCurrent ;dl_addVal(memR_noModel, "memR_noModel", paramsOutRef,0)						if (!skipFits)			//prepare for peak fit			Variable fitStartX = peakLoc ;dl_addVal(fitStartX, "fitStartX", paramsOutRef,0)			Variable fitEndX = peakLoc + fitWinSize ;dl_addVal(fitEndX, "fitEndX", paramsOutRef,0)			Variable maxNumExps = 5						analysis_expFit_again(currentResp, fitStartX, fitEndX, maxNumExps, "expFitAgain_temp",deltaVoltage,baseCurrent,fitSaveRef)		endif //if (!skipFitS)				//integrate for one metric of charge transfer during capacity transient and, though this, an estimate of capacitance 		WAVE/D expFitAgain_temp		//from analysis_expFit_again		if (WaveExists($"expfitAgain_temp"))			WAVE/D expFitAgain_temp			assumedSpecificCap = expFitAgain_temp[%assumedSpecificCap]		endif		analysis_capTransIntegration_lh(currentResp,"cp_again_int_params_temp",vCmd_t0,vCmd_baseline,vCmd_step,integration_estTimeToSS,assumedSpecificCap,"int_")				Make/O/N=1 paramsTemp_blah		concatenate/NP=0/DL/O {$paramsOutRef,$"cp_again_int_params_temp",$"expFitAgain_temp"}, paramsTemp_blah		//have to do out of place or else dim labels dont transfer		Duplicate/O paramsTemp_blah, $paramsOutRef		killwaves/z expFitAgain_temp, paramsTemp_blah			endif //if (hasStep)		if (currentRespNeedsKill)		killwaves/z currentRespf	endif		//respRef, firstFileNum, hasStep, vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step, isNegativeStep, sealRespRef, breakInTimeStr, paramsOutRef, fitSaveRef,  [fd_fileNum, fd_sweepNum])	String noteStr = "respRef:"+respRef+";sealRespRef:"+sealRespRef+";breakInTimeStr:"+breakInTimeStr+";fitSaveRef:"+fitSaveRef+";"	if (!ParamIsDefault(fd_fileNum))		noteStr += "fd_fileNum:"+num2str(fd_fileNum)+";"	endif	if (!ParamIsDefault(fd_sweepNum))		noteStr += "fd_SweepNum:"+num2str(fd_sweepNum)+";"	endif		note/nocr $paramsOutRef, noteStr	end	//analysis_cap_sub()//modify to be able to skip cell paramsfunction analysis_expFit_again(wv,fitStartX,fitEndX,maxNumExps,outParamsRef,baselineCurrent,stepDeltaVoltage,fitSaveRef)	WAVE/D wv; Double fitStartX, fitEndX; Variable maxNumExps		//tests mono exponential up to number of exponentials = maxNumExps	String outParamsRef	//place to store parameters. length varies (only) with maxNumExps -- not whether fit was successful etc.	Double stepDeltaVoltage,baselineCurrent		//pass for parameters relating to access etc.	String fitSaveRef				//pass to store fits, otherwise killed -- stores as new columns, 0th is original wave, 1st is monoexponential, 2nd double etc.		Double assumedSpecificCap = 0.01 			//pF / um^2 conversion to F / m ^ 2: 1 F / 10^12 pF * 10^6 um / m * 10^6 um / m = x pF/um^2 = F/ m ^ 2		Variable calcCellParams = numtype(stepDeltaVoltage) != 2			//pass NaN to skip cell params calcs		Variable storeFits = strlen(fitSaveRef) > 0		Variable fitStartP = x2pnt(wv, fitStartX)	Variable fitEndP = x2pnt(wv, fitEndX)			Variable useFitConstraints = 1			//choose whether to apply constraints like all exponentials must go same direction as overall response (e.g. no positive fit components to a negative-going response)	//	Make/O/N=1/D $outParamsRef; disp_killWinsWithWave(outParamsRef,1,1)	print "analysis_expFit_again(): outParamsRef", outParamsRef	Make/O/N=1/D $outParamsRef		//store initial conditions	dl_addVal(maxNumExps, "exp_maxNumExps", outParamsRef,0)	dl_addVal(useFitConstraints, "useFitConstraints", outParamsRef,0)	dl_addVal(fitStartX, "exp_fitStartX", outParamsRef,0)	dl_addVal(fitEndX, "exp_fitEndX", outParamsRef,0)	dl_addVal(fitStartP, "exp_fitStartP", outParamsRef,0)	dl_addVal(fitEndP, "exp_fitEndP", outParamsRef,0)	dl_addVal(assumedSpecificCap, "assumedSpecificCap", outParamsRef,0)		Variable fitTol = 0.00001		//forces iterations to continue as long as possible	Variable fitMaxIters = 200	//default would be 40		Variable i, numExps, numCoefs, previousNumCoefs	Make/O/D/N=1 expFit_temp, lastExpFit_temp											//placeholders, filled in later with current fit	Double x0_mono, x0_dbl, x0_forced_multi											//initial condition for each fit	Variable/G x0																			//x0 actually used; must be global for custom fit function myExp	Double iSS_tot,iPeak_tot,Ra_tot,Rmem_tot											//parameters for all fits	Variable j,tau_cIndex,amp_cIndex														//iterators for fit components	Double Ra_c,Rmem_c,q_c,cap_v0_c,cap_v1_c,cap_v2_c								//parametes for fit components	Double Ra_csum,Rmem_csum,q_csum,cap_v0_csum,cap_v1_csum,cap_v2_csum			//parameters for sums of fit components (equal to their counterparts for monoexponential)	Double tau_fromRC_v0_c,tau_fromRC_v1_c,tau_fromRC_v2_c	Double sa_v0_c, sph_dia_v0_c, sa_v0_csum, sph_dia_v0_csum	Double sa_v1_c, sph_dia_v1_c, sa_v1_csum, sph_dia_v1_csum	Double sa_v2_c, sph_dia_v2_c, sa_v2_csum, sph_dia_v2_csum	Double tau_fromRC_v0_csum,tau_fromRC_v1_csum,tau_fromRC_v2_csum		String dimLabel_fitStartStr = "expFIT_", dimLabel_compStartStr = "C_"	String dimLabel_currFitStr, dimLabel_currCompStr									//handles dimension labels (aka header)	variable V_FitError, V_FitQuitReason, V_fitTol, v_fitMaxIters, V_FitNumIters															//fit variables -- some of these are outputs of fit func, some are inputs displayhelptopic "Special Variables for Curve Fitting" or maybe just "Curve Fitting"	String S_Info		//info on each fit	String out_notStr = ""		//note to be appended to outParams, contains fit info	Variable fitSaveColIndex	//iterator for saving fits into different columns of fitSaveRef	Variable newTauIndex, newAmpIndex	Variable RF	//RF will track whether fit failed and then is used to decide whether to store parameters as NaN	Double deltaCurrentSS,effective_ssRin	Variable lastImprCont=0, lastImprDisc=0, discBeforeImpr=0,simplerModelBetter_now,simBeenBetter=0,complexModelBetter_now		//some stats for f test		for (i=0;i<maxNumExps;i+=1)		numExps = i+1				dimLabel_currFitStr = dimLabel_fitStartStr + num2str(i) + "_"		//set fit label				V_FitError = 0; V_FitQuitReason=0; V_FitNumIters=0; V_fitTol = fitTol; v_fitMaxIters = fitMaxIters		//reset fit variables		S_Info = ""				if (numExps == 1)		//use built in mono exponential fit (auto-generates starting conditions)			Make/O/D/N=(1 + 2*numExps) cWave; Make/O/D/N=1 W_fitConstants		//stores initial guesses and calculated coefs; latter stores x0						Curvefit/W=2/N=1/Q=1 exp_XOffset, kwCWave=cWave, wv[fitStartP, fitendP]/C=analysis_expFit_getConstaints(wv,dimsize(cWave,0),fitStartP,fitEndP)			x0_mono = W_fitConstants[0]		//store fit constant			x0 = x0_mono		elseif (numExps == 2)	//use built in double exponential fit (auto-generates starting conditions)			Make/O/D/N=(1 + 2*numExps) cWave; Make/O/D/N=1 W_fitConstants		//stores initial guesses and calculated coefs; latter stores x0			Curvefit/W=2/N=1/Q=1 dblexp_XOffset, kwCWave=cWave, wv[fitStartP, fitendP]/C=analysis_expFit_getConstaints(wv,dimsize(cWave,0),fitStartP,fitEndP)			x0_dbl = W_fitConstants[0]		//store fit constant			x0 = x0_dbl		else	//numExps > 2, use custom multi-exponential fit		(must generate starting conditions)			if (numExps == 3)		//first iteration to reach here, instantiate some placeholder waves				Make/O/D/N=(numExps-1) newAmps,newTaus				Double amp_sum,proportion,amp_new							Double tau_oldMin,tau_oldMax,tau_oldRange,tau_newMin,tau_newMax,tau_newRange,tau_new				Variable oldNumParams			else				Redimension/N=(numExps-1) newAmps,newTaus			endif						//copy over fit results from last fit			Duplicate/O cWave, cWave_last		//this is already sorted fastest to slowest tau			oldNumParams = dimsize(cWave,0)			newAmpIndex = oldNumParams			newTauIndex = oldNumParams+1			Redimension/N=(oldNumParams+2) cWave						//NEW FIT PARAMETER INITIAL GUESS GENERATING METHOD:			//pick an amplitude for the new component, pretty arbitrary			newAmps = cWave_last[1+2*p]			newTaus = cWave_last[2+2*p]			proportion = 1/numExps		//if amplitude was evenly distributed across all components, what proportion of the total would one component have?			amp_sum = sum(newAmps)			amp_new = amp_sum/numExps	//give new guess the proportion of the amplitude it would have if all parts were equal						newAmps *= (numExps-1)/numExps					//scale down the remaining amplitudes to make room for that one			cWave[1,newAmpIndex-1;2] = newAmps[(p-1)/2]	//transfer rescaled amplitudes to new coef wave (initial guesses)			cWave[newAmpIndex] = amp_new							//pick a tau for the new component, also arbitrary			tau_oldMin = newTaus[0]			tau_oldMax = newTaus[dimsize(newTaus,0)-1]			tau_oldRange = tau_oldMax-tau_oldMin			tau_newMin = tau_oldMin/2			tau_newMax = tau_oldMax*2			tau_newRange = tau_newMax-tau_newMin			tau_new = tau_newMin + tau_newRange * 0.5		//put new tau squarely in the middle			newTaus = tau_newMin + tau_newRange * ( (newTaus[p]-tau_oldMin) / tau_oldRange )		//redistribute old taus across new range in proportion to their original value			cWave[2,newTauIndex-1;2] = newTaus[(p-2)/2]			cWave[newTauIndex] = tau_new							Print "analysis_expFit_again() on wave",nameofwave(wv),"numExps",numExps,"cwave_last",cwave_last,"cwave new",cwave						//OLD METHOD:			//cWave[newTauIndex] = cWave[newTauIndex-2]/4		//arbitrarily guessing new tau is 4x faster			//cWave[newAmpIndex] = cWave[newAmpIndex-2]/4		//arbitrarily guessing new amp is 4x smaller						x0_forced_multi = x0_dbl		//use x0 from dbl (mono should work fine too--or even startX, but this seems safer?)			x0 = x0_forced_multi						//multi-exponential curve fit			FuncFit/NTHR=0/W=2/N=1/Q=1 myExp, cWave, wv[fitStartP, fitendP]/C=analysis_expFit_getConstaints(wv,dimsize(cWave,0),fitStartP,fitEndP)		endif				//V_FitQuitReason: usually ok to use results (ihf:"1 if the iteration limit was reached, 2 if the user stopped the fit, or 3 if the limit of passes without decreasing chi-square was reached.")		//V_FitError: unacceptable if > 0		RF = V_FitError > 0		if (RF)			Print "analysis_expFit_again(): fit rejection. numExps=",numExps,"V_fitQuitReason",V_fitQuitReason,"V_FitError",V_FitError, "cWave:"// saved as",(nameofwave(wv) + "fitFail_"+num2str(i))," and follows:"			Print/d cWave		//	Duplicate/O cWave, $(nameofwave(wv) + "fitFail_"+num2str(i))		endif				//rearrange coefs so that exponentials are ordered from fastest (smallest tau) to slowest -- does nothing to monoexponential		analysis_sortExpCoefWave(cWave)		numCoefs = DimSize(cWave,0)				//build predicted response for this exponential		Duplicate/O/R=[fitStartP, fitendP] wv, expFit_temp				expFit_temp = myExp(cWave,x)		//fill in predicted values				if (calcCellParams)			//some overall parameters (same for all possible numExps)			iSS_tot = cWave[0]		//current (i) at steady state (SS)			iPeak_tot = expFit_temp[0]		//current at peak			Ra_tot = stepDeltaVoltage / iPeak_tot										//only valid for single compartment (monoexponetial) cell			Rmem_tot = ( stepDeltaVoltage - (Ra_tot*iSS_tot) ) / iSS_tot		//only valid for single compartment (monoexponetial) cell						deltaCurrentSS = iSS_tot-baselineCurrent			effective_ssRin = stepDeltaVoltage/deltaCurrentSS			//note: charge transfer requires a tau, and tau_total = tau only for monoexponential. so use monoexponential q, calculated in for loop						//mark beginning of parameters for this fit in outParamsRef			dl_addVal(-inf, dimLabel_currFitStr +"PARAMS_START", outParamsRef,0)			//spacer									//analysis on each exponential component			Ra_csum=0;Rmem_csum=0;q_csum=0;cap_v0_csum=0;cap_v1_csum=0;cap_v2_csum=0	//sum component paremters into these				for (j=0;j<numExps;j+=1)						tau_cIndex = 2 + 2*j		//order is y0 + amp0 + tau0 + amp1 + tau1 ...				amp_cIndex = 1 + 2*j										Ra_c = stepDeltaVoltage / cWave[amp_cIndex]							//potentially meaningless value				Rmem_c = ( stepDeltaVoltage - (Ra_c*iSS_tot) ) / iSS_tot			//potentially meaningless value				q_c = cWave[tau_cIndex] * cWave[amp_cIndex]							//charge (q) for component (c)				cap_v0_c = q_c / stepDeltaVoltage										//simple version of compartment capacitance (Geiger and Jonas 2000) -- amplitude * tau / DV = (~)q_apparent / DV				cap_v1_c = cWave[tau_cIndex] * ( (1/Ra_c) + (1/Rmem_c) )			//complex and likely even more senseless version -- correcting by apparent resistances to compartment				cap_v2_c = cWave[tau_cIndex] * ( (1/Ra_tot) + (1/Rmem_tot) )		//another complex version -- correcting by apparent resistances to all compartments									sa_v0_c = cap_v0_c / assumedSpecificCap								//F / F / m^2 == units of m^2				sa_v1_c = cap_v1_c / assumedSpecificCap				sa_v2_c = cap_v2_c / assumedSpecificCap								sph_dia_v0_c = 2*sqrt(sa_v0_c/4/pi)										//surface area to sphere diameter ( from SA = 4*pi(d/2)^2 )				sph_dia_v1_c = 2*sqrt(sa_v1_c/4/pi)				sph_dia_v2_c = 2*sqrt(sa_v2_c/4/pi)								Ra_csum += Ra_c				Rmem_csum += Rmem_c				q_csum += q_c								cap_v0_csum += cap_v0_c				cap_v1_csum += cap_v1_c				cap_v2_csum += cap_v2_c								sa_v0_csum += sa_v0_c				sa_v1_csum += sa_v1_c				sa_v2_csum += sa_v2_c								sph_dia_v0_csum += sph_dia_v0_c				sph_dia_v1_csum += sph_dia_v1_c				sph_dia_v2_csum += sph_dia_v2_c								tau_fromRC_v0_C = cap_v0_c/effective_ssRin				tau_fromRC_v1_c = cap_v0_c/effective_ssRin				tau_fromRC_v2_c = cap_v0_c/effective_ssRin								tau_fromRC_v0_csum += tau_fromRC_v0_c				tau_fromRC_v1_csum += tau_fromRC_v1_c				tau_fromRC_v2_csum += tau_fromRC_v2_c								//store component parameters -- note, these are stored BEFORE (for simplicity) any overall parameters for a given model				dimLabel_currCompStr = dimLabel_currFitStr + dimLabel_compStartStr + num2str(j) + "_"				dl_addVal(RF ? NaN : Ra_c, dimLabel_currCompStr + "Ra_c", outParamsRef,0)				dl_addVal(RF ? NaN : Rmem_c, dimLabel_currCompStr + "Rmem_c", outParamsRef,0)				dl_addVal(RF ? NaN : q_c, dimLabel_currCompStr + "q_c", outParamsRef,0)				dl_addVal(RF ? NaN : cap_v0_c, dimLabel_currCompStr + "cap_v0_c", outParamsRef,0)				dl_addVal(RF ? NaN : cap_v1_c, dimLabel_currCompStr + "cap_v1_c", outParamsRef,0)				dl_addVal(RF ? NaN : cap_v2_c, dimLabel_currCompStr + "cap_v2_c", outParamsRef,0)				dl_addVal(RF ? NaN : sa_v0_c, dimLabel_currCompStr + "sa_v0_c", outParamsRef,0)				dl_addVal(RF ? NaN : sa_v1_c, dimLabel_currCompStr + "sa_v1_c", outParamsRef,0)				dl_addVal(RF ? NaN : sa_v2_c, dimLabel_currCompStr + "sa_v2_c", outParamsRef,0)				dl_addVal(RF ? NaN : sph_dia_v0_c, dimLabel_currCompStr + "sph_dia_v0_c", outParamsRef,0)				dl_addVal(RF ? NaN : sph_dia_v1_c, dimLabel_currCompStr + "sph_dia_v1_c", outParamsRef,0)				dl_addVal(RF ? NaN : sph_dia_v2_c, dimLabel_currCompStr + "sph_dia_v2_c", outParamsRef,0)					dl_addVal(RF ? NaN : tau_fromRC_v0_c, dimLabel_currCompStr + "tau_fromRC_v0_c", outParamsRef,0)				dl_addVal(RF ? NaN : tau_fromRC_v1_c, dimLabel_currCompStr + "tau_fromRC_v1_c", outParamsRef,0)				dl_addVal(RF ? NaN : tau_fromRC_v2_c, dimLabel_currCompStr + "tau_fromRC_v2_c", outParamsRef,0)							endfor						//store overall parameters, STARTING with totals from componenents				//totals from components			dl_addVal(RF ? NaN : numExps, dimLabel_currFitStr + "numExps", outParamsRef,0)			dl_addVal(RF ? NaN : Ra_csum, dimLabel_currFitStr + "Ra_csum", outParamsRef,0)			dl_addVal(RF ? NaN : Rmem_csum, dimLabel_currFitStr +"Rmem_csum", outParamsRef,0)			dl_addVal(RF ? NaN : q_csum, dimLabel_currFitStr +"q_csum", outParamsRef,0)			dl_addVal(RF ? NaN : cap_v0_csum, dimLabel_currFitStr +"cap_v0_csum", outParamsRef,0)			dl_addVal(RF ? NaN : cap_v1_csum, dimLabel_currFitStr +"cap_v1_csum", outParamsRef,0)			dl_addVal(RF ? NaN : cap_v2_csum, dimLabel_currFitStr +"cap_v2_csum", outParamsRef,0)			dl_addVal(RF ? NaN : sa_v0_csum, dimLabel_currFitStr +"sa_v0_csum", outParamsRef,0)			dl_addVal(RF ? NaN : sa_v1_csum, dimLabel_currFitStr +"sa_v1_csum", outParamsRef,0)			dl_addVal(RF ? NaN : sa_v2_csum, dimLabel_currFitStr +"sa_v2_csum", outParamsRef,0)			dl_addVal(RF ? NaN : sph_dia_v0_csum, dimLabel_currFitStr +"sph_dia_v0_csum", outParamsRef,0)			dl_addVal(RF ? NaN : sph_dia_v1_csum, dimLabel_currFitStr +"sph_dia_v1_csum", outParamsRef,0)			dl_addVal(RF ? NaN : sph_dia_v2_csum, dimLabel_currFitStr +"sph_dia_v2_csum", outParamsRef,0)			dl_addVal(RF ? NaN : tau_fromRC_v0_csum, dimLabel_currFitStr +"tau_fromRC_v0_csum", outParamsRef,0)			dl_addVal(RF ? NaN : tau_fromRC_v1_csum, dimLabel_currFitStr +"tau_fromRC_v1_csum", outParamsRef,0)			dl_addVal(RF ? NaN : tau_fromRC_v2_csum, dimLabel_currFitStr +"tau_fromRC_v2_csum", outParamsRef,0)				//fit info stats V_FitError = 0; V_FitQuitReason=0; V_FitNumIters=0; V_fitTol = fitTol; v_fitMaxIters = fitMaxIters			dl_addVal(V_FitError, dimLabel_currFitStr +"V_FitError", outParamsRef,0)			dl_addVal(V_FitQuitReason, dimLabel_currFitStr +"V_FitQuitReason", outParamsRef,0)			dl_addVal(V_FitNumIters, dimLabel_currFitStr +"V_FitNumIters", outParamsRef,0)			dl_addVal(V_fitTol, dimLabel_currFitStr +"V_fitTol", outParamsRef,0)			dl_addVal(v_fitMaxIters, dimLabel_currFitStr +"v_fitMaxIters", outParamsRef,0)					//other info specific to this fit --starts with x0 -- fit coefs come last			dl_addVal(RF ? NaN : iPeak_tot, dimLabel_currFitStr +"iPeak_tot", outParamsRef,0)			dl_addVal(RF ? NaN : Ra_tot, dimLabel_currFitStr +"Ra_tot", outParamsRef,0)			dl_addVal(RF ? NaN : Rmem_tot, dimLabel_currFitStr +"Rmem_tot", outParamsRef,0)			dl_addVal(RF ? NaN : iSS_tot, dimLabel_currFitStr +"iSS_tot", outParamsRef,0)		//note: iSS_tot and cWave[0] should be equal, so this should help mark beginning of cWave data				endif	//end region skipped by cell params				dl_addVal(RF, dimLabel_currFitStr +"REJECT_FIT", outParamsRef,0)		dl_addVal(x0, dimLabel_currFitStr +"x0", outParamsRef,0)		dl_addVal(-inf, dimLabel_currFitStr +"CWAVE_START", outParamsRef,0)			//spacer .. note that x0 comes just before it				//label and add fit remaining components		for (j=0;j<DimSize(cWave,0);j+=1)			dl_addVal(RF ? NaN : cWave[j], dimLabel_currFitStr +"cWave_" + num2str(j), outParamsRef,0)		//only add cWave parameters for fits that worked		endfor				dl_addVal(-inf, dimLabel_currFitStr +"CWAVE_END", outParamsRef,0)			//spacer				//if i>0: handle f test		if (i>0)								dl_addVal(-inf, dimLabel_currFitStr +"FTEST_START", outParamsRef,0)			//spacer			stats_ftest_LH(wv, lastExpFit_temp, expFit_temp, previousNumCoefs, numCoefs, "stats_ftest_again_temp")			dl_appendToLbls($"stats_ftest_again_temp",0,dimLabel_currFitStr,1,-inf,inf)			if (RF || (i==1))				WAVE stats_ftest_again_temp				if (RF)					stats_ftest_again_temp = NaN			//only store f test results on fits that worked				endif			endif								concatenate/NP=0/DL/O {$outParamsRef,$"stats_ftest_again_temp"}, expFit_again_params_temp		//dim labels only copy over if copying out of place			Duplicate/O expFit_again_params_temp, $outParamsRef			dl_addVal(-inf, dimLabel_currFitStr +"FTEST_END", outParamsRef,0)			//spacer						complexModelBetter_now = stats_ftest_again_temp[%$("expFIT_"+num2str(i)+"_f_useCpx")]			simplerModelBetter_now = !complexModelBetter_now			simBeenBetter = simBeenBetter ? 1 : simplerModelBetter_now		//if already true, keep it true, otherwise set based on whether its better this round			//ADDED SOME ADDITIONAL INFO TO ASSESS F TEST (6/1/17)			if (i==1)		//first time checking f test result .. basically no need to check simBeenBetter				lastImprCont = 1				lastImprDisc = 1 // (equals 0 for simple model, 1 for complex)			else				if (simBeenBetter)			//cannot have a continuous improvement, don't update lastImprCont					if (complexModelBetter_now)						lastImprDisc = i					endif				else		//so far, the more complex model has always been better					if (complexModelBetter_now)		//improvement now, so set lastImprovedModel to this one						lastImprCont = i						lastImprDisc = i										endif								endif			endif				endif						discBeforeImpr = lastImprCont != lastImprDisc				//ADDED SOME ADDITIONAL INFO TO ASSESS F TEST (6/1/17)		dl_addVal(i==0? nan : simBeenBetter, dimLabel_currFitStr +"simBeenBetter", outParamsRef,0)		dl_addVal(i==0? nan : lastImprCont, dimLabel_currFitStr +"lastImprCont", outParamsRef,0)		dl_addVal(i==0? nan : lastImprDisc, dimLabel_currFitStr +"lastImprDisc", outParamsRef,0)		dl_addVal(i==0? nan : discBeforeImpr, dimLabel_currFitStr +"discBeforeImpr", outParamsRef,0)				dl_addVal(inf, dimLabel_currFitStr +"PARAMS_END", outParamsRef,0)			//spacer						//store fit if requested		if (storeFits)			if (i==0)				Duplicate/O/R=[fitStartP, fitendP] wv, $fitSaveRef/WAVE=fitSaveWv				Redimension/N=(-1,1) fitSaveWv		//make a one column 2 wave so that resizing below is consistent				setdimlabel 1,0,rawDataInFitWin,fitSaveWv			else				WAVE fitSaveWv = $fitSaveRef			endif			fitSaveColIndex = DimSize(fitSaveWv,1)	//1 for i==0			Redimension/N=(-1,fitSaveColIndex+1) fitSaveWv			fitSaveWv[][fitSaveColIndex] = RF ? NaN : expFit_temp[p]		//only store fits that worked			SetDimLabel 1,fitSaveColIndex,$("fit_"+num2str(i)),fitSaveWv		endif				//store fit info		S_info = ReplaceString(";",S_info,"|")		//make "|" instead of semi-colon delim;	keySepStr = "=" according to help file, so that's alright		out_notStr += dimLabel_currFitStr + "S_INFO_FROMFIT:"+S_info+";"						//save info for next round (f-test comparison between models)		Duplicate/O expFit_temp, lastExpFit_temp		previousNumCoefs = numCoefs	endfor		//ADDED SOME ADDITIONAL INFO TO ASSESS F TEST (6/1/17) -- store final assessment of f-test result for quick summary (i==0 still a possibility if only checked monoexponential)	dl_addVal(i==0? nan : simBeenBetter, "expFit_"+"simBeenBetter", outParamsRef,0)	dl_addVal(i==0? nan : lastImprCont, "expFit_"+"lastImprCont", outParamsRef,0)	dl_addVal(i==0? nan : lastImprDisc, "expFit_"+"lastImprDisc", outParamsRef,0)	dl_addVal(i==0? nan : discBeforeImpr, "expFit_"+"discBeforeImpr", outParamsRef,0)		out_notStr += "FIT_SAVE_REF:"+ fitSaveRef +";"	killwaves/z expFit_temp,expFit_again_params_temp,cWave,$NameOfwave(analysis_expFit_getConstaints(wv,dimsize(cWave,0),fitStartP,fitEndP))endfunction/WAVE analysis_expFit_getConstaints(wvToFit,numCoefs,fitStartP,fitEndP,[xWvRef])	WAVE wvToFit	Variable numCoefs	Variable fitStartP,fitEndP		//fit start and end, pass NaN to ignore.. note these are in point values NOT x values	String xWvRef				//optionally pass an xWv for non-uniform dt		Variable hasxwv=!paramisdefault(xWvRef) && strlen(xWvRef)>0		if (numtype(fitStartP))		//NaN or +/- inf		fitStartP = 0	endif	if (numtype(fitEndP))		fitEndP = dimsize(wvToFit,0)-1	endif		Variable foldDiffTauSampleInterval = 0.2		//least multiple of sampling interval that tau must be	Variable tauMin	if (hasxwv)		wave xwv = $xWvRef		tauMin = foldDiffTauSampleInterval*wave_getMinAdjacentDiff(xwv,fitStartP,fitEndP)	else		tauMin = foldDiffTauSampleInterval*DimDelta(wvToFit,0)	endif	Make/O/T/free tauConstraints = {"K2 > " + num2str(tauMin)} 	//tau must be slower than twice the sampling interval (right)	Make/O/T/N=1/free ampConstraints		Variable positiveGoing	if (hasxwv)		positiveGoing = wvToFit[fitStartP] > wvToFit[fitEndP]		//is first point in waveToFit > last? 	else		positiveGoing = wvToFit[fitStartP] > wvToFit[fitEndP]		//is first point in waveToFit > last? 	endif	if (positiveGoing)		//positive-going step		ampConstraints[0] =  "K1 > 0"	//constain amplitude to be positive	else		ampConstraints[0] =  "K1 < 0" //constrain to be negative for negative going steps	endif		Variable i,numExps = floor((numCoefs - 1)/2)	for (i=0;i<numExps;i+=1)		//update constraints wave		if (i==0)			Concatenate /NP/O/T  {ampConstraints, tauConstraints}, fitConstraintsWave		// /O makes sure fitconstraints is killed not added to in first instance		else			//set constraints for 			Duplicate/O/T/free ampConstraints, ampConstraintsTemp; ampConstraintsTemp = ReplaceString("K1", ampConstraintsTemp[p], "K" + num2str(1+2*i))			Duplicate/O/T/free tauConstraints, tauConstraintsTemp; tauConstraintsTemp = ReplaceString("K2", tauConstraintsTemp[p], "K" + num2str(1+2*i + 1))			Concatenate /NP/T  {ampConstraintsTemp, tauConstraintsTemp}, fitConstraintsWave		endif	endfor			return fitConstraintsWaveend//generates contraints waves for exps//currently requests to limit amplitudes as positive and taus as twice the sampling interval//allows a Y zero constraint THAT MAY NOT BE WORKING CORRECTLY AT THE MOMENT SO I WOULDNT USE WITHOUT FURTHER TESTINGfunction analysis_expFit_getConstraintsMats(wvToFit,numCoefs,fitStartP,fitEndP,maxAmp,maxTau,constrainY0,cMatOutRef,dVecOutRef,[xWvRef])	WAVE wvToFit	Variable numCoefs	Variable fitStartP,fitEndP		//fit start and end, pass NaN to ignore.. note these are in point values NOT x values	String cMatOutRef,dVecOutRef	Double maxAmp			//pass to limit amplitudes	Double maxTau			//pass to limit tau max	Variable constrainY0	//pass 1 to costrain y zero in same diretion as peak	String xWvRef		Variable hasxwv=!paramisdefault(xWvRef) && strlen(xWvRef)>0		if (numtype(fitStartP))		//NaN or +/- inf		fitStartP = 0	endif	if (numtype(fitEndP))		fitEndP = dimsize(wvToFit,0)-1	endif		Variable positiveGoing	if (hasxwv)		wave xwv = $xWvRef		positiveGoing = wvToFit[fitStartP] > wvToFit[fitEndP]		//is first point in waveToFit > last? 	else		positiveGoing = wvToFit[fitStartP] > wvToFit[fitEndP]		//is first point in waveToFit > last? 	endif		Variable hasMaxAmp = numtype(maxAmp) == 0	Variable hasMaxTau = numtype(maxTau) == 0		//want greater than but rules have to be started as <= so multiply both coef and limit by -1	Variable ampMult = positiveGoing ? -1 : 1		//pos going		Variable foldDiffTauSampleInterval = 2		//least multiple of sampling interval that tau must be	Variable minTau	if (hasxwv)		minTau = foldDiffTauSampleInterval*wave_getMinAdjacentDiff(xwv,fitStartP,fitEndP)	else		minTau = foldDiffTauSampleInterval*DimDelta(wvToFit,0)	endif		Variable i,numExps = floor((numCoefs - 1)/2)	Variable numAmpRules1 = numExps		//not counting maxAmpRule	Variable numAmpRules2 = hasmaxAmp ?  numExps : 0	Variable numTauRules1 = numExps	Variable numTauRules2 = hasMaxTau ?  numExps : 0	Variable numRules=numAmpRules1 + numTauRules1 + numAmpRules2	+ numTauRules2 +(constrainY0 != 0)	//add one extra rule if hasmaxAmp and add 1 or y zero rule	make/o/d/n=(numRules,numCoefs) $cMatOutRef/wave=cMat	cMat=0	make/o/d/n=(numRules) $dVecOutRef/wave=dVec	dVec=nan		//set amp rules	for (i=0;i<numAmpRules1;i+=1)		cMat[i][1+2*i]=ampMult	//dVec is already zero at these indices		dVec[i]=-1e-18			//must be less than and not equal tozero	endfor			//set tau rules	for (i=0;i<numTauRules1;i+=1)		cMat[i+numAmpRules1][1+2*i+1]=-1	//dVec is already zero at these indices		dVec[i+numAmpRules1]=-minTau			//must be less than and not equal tozero	endfor				//add max amp sum if necessary	if (hasmaxAmp)		ampMult = positiveGoing ? 1 : -1		for (i=0;i<numAmpRules2;i+=1)			cMat[i+numAmpRules1+numTauRules1][1+2*i]=ampMult	//dVec is already zero at these indices			dVec[i+numAmpRules1+numTauRules1]=maxAmp * ampMult		//must be less than and not equal tozero		endfor		endif		if (hasMaxTau)		for (i=0;i<numTauRules2;i+=1)			cMat[i+numAmpRules1+numTauRules1+numAmpRules2][1+2*i+1]=1	//dVec is already zero at these indices			dVec[i+numAmpRules1+numTauRules1+numAmpRules2]=maxTau			//must be less than and not equal tozero		endfor			endif		//add y0 constraint if needed	if (constrainY0)		Variable y0RuleRow = numAmpRules1+numTauRules1+numAmpRules2+numTauRules2		cMat[y0RuleRow][0] = positiveGoing ? -1 : 1			//positive going, we don't wat negative numbers so constrain -1*y0<0. neg going constrain y0 < 0		dVec[y0RuleRow] = -1e-18	endifendfunction/S analysis_expFit_again_getCoefs(paramWv,x0_valsRef_out)	Wave/D paramWv	String x0_valsRef_out	//place to store x0_out, one for each model		String outRefStart = NameOfWave(paramWv) + "_cw_"	String fitparam_startStr = "expFIT_"		Variable numFits = paramWv[%exp_maxNumExps]	Make/O/D/N=(numfits) $x0_valsRef_out/wave=x0wv		Variable i,j, numExps, numCoefs; String outRef,outList="", coefStrStart, coefStr	for (i=0;i<numFits;i+=1)		numExps = i+1		numCoefs = 1 + 2*numExps		outRef = outRefStart + num2str(i)		Make/o/d/n=(numCoefs) $outRef/wave=out; outList += outRef + ";"		coefStrStart = fitparam_startStr + num2str(i) + "_cWave_"		for (j=0;j<numCoefs;j+=1)			coefStr = coefStrStart + num2str(j)			out[j] = paramWv[%$coefStr]		endfor				x0wv[i] = paramWv[%$(fitparam_startStr + num2str(i) + "_x0")]	endfor		return outListendfunction/S analysis_expFit_again_dispFits(paramWv, startX, endX)	WAVE/D paramWv	Variable startX, endX	//good values are 0.073458,0.078		String fitWvRef = Stringbykey("fitSaveRef",note(paramWv))	WAVE/D fitWv = $fitWvRef		if (numtype(startX))		startX = dimoffset(fitWv,0)	endif	if (numtype(endX))		endX = indexToScale(fitWv,DimSize(fitWv,0),0)	endif			String fitCoefWvList = analysis_expFit_again_getCoefs(paramWv,"x0wv") 	Print "fitCoefWvList",fitCoefWvList	WAVE/D x0wv	Variable/G x0	Variable numFits = ItemsInList(fitCoefWvList)	, numExps	Variable i,j,numComponents; string coefRef, componentsRef, componentsList=""	Make/O/D/N=(3)/free exptempaaa	for (i=0;i<numFits;i+=1)		numExps = i+1		Print "numExps",numExps		numComponents = numExps		coefRef = stringfromlist(i,fitCoefWvList)		WAVE/D coefWv = $coefRef		x0 = x0wv[i]				//plot actual data and overall fit		display/k=1/N=$coefRef		appendTograph/C=(0,0,0) fitWv[][0]		//actual data		appendtograph/W=$S_name fitWv[][i+1]					//full fit				for (j=0;j<numComponents;j+=1)			//calculate component			componentsRef = coefRef + "c_" + num2str(j)			Print "componentsRef",componentsRef			componentsList += componentsRef + ";"			Duplicate/O/R=[][0] fitWv, $componentsRef/wave=componentWv 			REDIMENSION/n=(-1) componentWv			exptempaaa[0] = 	coefWv[0]		//j == 0 ? coefWv[0] : 0		//note: only adds up to final wave if you only add the y offset once, but adding it each helps with comparing time courses			exptempaaa[1] = coefWv[1+2*j]			exptempaaa[2] = coefWv[2+2*j]			componentWv = myExp(exptempaaa,x)			Print "coefWv[0]",coefWv[0],"coefWv[1+2*j]",coefWv[1+2*j],"coefWv[2+2*j]",coefWv[2+2*j]						//append fit component to graph			appendtograph/W=$S_name/C=(23000,23000,23000,23000) componentWv			setaxis/W=$S_name bottom, startX, endX		endfor	endfor		killwaves/z overallParamsListWv,x0wv	return componentsListendfunction analysis_capTrans_dispFitStats(paramRef_S, paramRef_P)	String paramRef_S, paramRef_P		String pickedParams_S,pickedParams_P	if (strlen(paramRef_S))		pickedParams_S = analysis_capTrans_dispFit_sub($paramRef_S,0)	endif	if (strlen(paramRef_P))		pickedParams_P = analysis_capTrans_dispFit_sub($paramRef_P,1)	endif				String catParamsRef_S, catParamsRef_P	if (strlen(paramRef_S) || strlen(paramRef_P))		MAke/O colors = {{0,50000},{0,0},{0,0}}		String saveRef,saveRef_R		if (!strlen(paramRef_S))			Duplicate/O $pickedParams_P, paramsTempTempTemp			paramsTempTempTemp = NaN			catParamsRef_S = "paramsTempTempTemp"			catParamsRef_P = pickedParams_P			saveRef = paramRef_P + "_duCP"		elseif (!strlen(paramRef_P))			Duplicate/O $pickedParams_S, paramsTempTempTemp			paramsTempTempTemp = NaN			catParamsRef_P = "paramsTempTempTemp"			catParamsRef_S = pickedParams_S				saveRef = paramRef_S + "_duCP"			else		//both present			catParamsRef_S = pickedParams_S			catParamsRef_P = pickedParams_P			saveRef = paramRef_S + "_duCP"			endif		saveRef_R = saveRef + "_r"		//for DUal Cell Params		Make/O/N=(DimSize($catParamsRef_S,0),2) $saveRef_R/wave=rowlbls		rowlbls[][0] = p		//soma rows		rowlbls[][1] = rowlbls[p][0] + 0.001		concatenate/o/kill/np=1/dl {$catParamsRef_S,$catParamsRef_P}, $saveRef		wave dualSiteParamsWv = $saveRef		Print "dual site save ref", saveRef		Variable i; string lbl, axlbl_b,axlbl_l		Variable axStart, axEnd, numAxes = dimsize(dualSiteParamsWv,0)		Variable axSpacing = 0.05		Variable totalAxSpacing = axSpacing * (numAxes-1)		Variable totalAxRoom = 1 - totalAxSpacing		Variable roomPerAx = totalAxRoom / numAxes		display/k=1		for (i=0;i<numAxes;i+=1)		//DimSize(cellParamsWv,0);i+=1)			lbl = GetDimLabel(dualSiteParamsWv, 0, i)			axlbl_b = "B_" + lbl			axlbl_l = "L_" + lbl						appendtograph/w=$S_name/B=$axlbl_b/L=$axlbl_l dualSiteParamsWv[i][]/TN=$lbl vs rowlbls[i][]			modifygraph/W=$S_name zColor={colors,*,*,directRGB}			label/W=$S_name $axlbl_b, lbl; label/W=$S_name $axlbl_l, "\\Z10"+ lbl + " (\\f01\\U\\f00)"			axStart = i*axSpacing + i*roomPerAx			axEnd = axStart + roomPerAx			modifygraph/W=$s_name axisenab($axlbl_b) = {axStart, axEnd},freepos($axLbl_L) = {0,$axLbL_B},lblpos($axlbl_l) = 50			setaxis/W=$s_name $axlbl_b, -1000,1000 			modifygraph/W=$s_name tick($axlbl_b)=3,noLabel($axlbl_b)=2,freePos($axlbl_b)=200,axRGB($axlbl_b)=(65535,65535,65535)			setaxis/W=$s_name/A/N=2 $axLbl_L		//round to nice units		endfor		modifygraph/W=$s_name mode=3,marker=8,fsize=8	endifendfunction/S analysis_capTrans_dispFit_sub(paramWv,fromPed)	WAVE/D paramWv	Variable fromPed				//pass for color coding: soma==black, ped==red. only used for cellParams, not most fit-related stats			String fitparam_startStr = "expFIT_"	String compParams_startStr = "_C_"	String coefParams_startStr = "_cWave_"	//	if (!strlen(cellStatsWinN))//		cellStatsWinN = cellStatsWinN + "_cpwin"//	endif//	//	cellStatsWinN = disp_winIDHandling(cellStatsWinN, doNewGraph,1)//	Print "---cellStatsWinN",cellStatsWinN//		Make/O/T cellParamsList = {"baseCurrent","ssCurrent","ssRin","expFIT_0_C_0_Ra_c","expFIT_0_C_0_Rmem_c","memR_noModel","accessR_nomodel","expFIT_1_cap_v0_csum","int_C","int_sa","int_sph_dia"}	String cellParamsRef = nameofwave(paramWv) + "_cpars" 	//0th row for index	MAke/O/D/N=(DimSize(cellParamsList,0)) $cellParamsRef/wave=cellParamsWv	Variable i; string lbl, axlbl_b,axlbl_l	Variable axStart, axEnd	Variable axSpacing = 0.05	Variable totalAxSpacing	Variable totalAxRoom	Variable roomPerAx		for (i=0;i<DimSize(cellParamsWv,0);i+=1)		lbl = cellParamsList[i]		cellParamsWv[i] = paramWv[%$lbl]		SetDimLabel 0,i,$lbl,cellParamsWv	endfor		//handles more fit details	Variable numFits = 	paramWv[%exp_maxNumExps]		//overall params setup	String allFitParamsRef = NameOfwave(paramWv) + "_fitstats"	String allFitParamsRef_rows = allFitParamsRef + "_r"		Make/O/T overallParamsListWv = {"ss_res_foldChange","f_stat","f_pval"}	Variable numoverallParams = dimsize(overallParamsListWv,0)	Make/O/D/N=(numFits,numoverallParams) $allFitParamsRef/wave=fit_stats	Make/O/T/N=(numfits) $allFitParamsRef_rows/wave=rows		//component params set up	make/o/t compParamsListWv = {"cap_v0_c","sa_v0_c","sph_dia_v0_c"}			//tau and amp automatically included below	Variable numCompParams = DimSize(compParamsListWv,0) + 2		//2 extra for tau and amp	String compParamsRef = NameOfwave(paramWv) + "_fitCStats"		//handles values on plots	String compParamsRef_rows = compParamsRef + "_r"					//handes x position on plots	String compParamsRef_colors = compParamsRef + "_clr"			//handles colors on plots .. different color for each component #	Variable numCompParamsRows = numFits*(numFits+1)/2	//for a series 1 + 2 + 3 + ... + n, the sum will be n*(n+1)/2	Make/O/D/N=(numCompParamsRows, numCompParams) $compParamsRef/wave=fit_compStats	Make/O/N=(numCompParamsRows) $compParamsRef_rows/wave=fit_compStatsRows	Print "compParamsRef_colors",compParamsRef_colors		//c0-black(0,0,0), c1-red(65535,0,0), c2-green(0,65535,0), c3-blue(0,0,65535), c4-magenta (65535,16385,55749)	Variable opac = 0.6	Make/O/N=(numCompParamsRows,4) $compParamsRef_colors/wave=fit_compStatsColors	Make/O/N=(1,4) black; black=0; black[0][3] = opac * 65535	Make/O/N=(1,4) red;red=0;red[0][0] = 65535; red[0][3] = opac * 65535	Make/o/N=(1,4) green;green=0;green[0][1] = 65535; green[0][3] = opac * 65535	make/o/N=(1,4) blue;blue[0][2] = 65535; blue[0][3] = opac * 65535	make/o/N=(1,4) magenta;magenta[0][0]=65535;magenta[0][1]=16385;magenta[0][2]=16385;; magenta[0][3] = opac * 65535		Variable j,r,numComponents;string param,fitParamStr; double val		//fill in comp params rows and color rows so that the same component can be tracked across params	r = 0	for (i=0;i<numFits;i+=1)		for (j=0;j<i+1;j+=1)			fit_compStatsRows[r] = i				switch (j)				case 1:		//second component					fit_compStatsColors[r][] = red[0][q]					break				case 2:		//second component					fit_compStatsColors[r][] = green[0][q]					break				case 3:		//second component					fit_compStatsColors[r][] = blue[0][q]					break				case 4:		//second component					fit_compStatsColors[r][] = magenta[0][q]					break									default:	//first component or higher than dealt with in switch					fit_compStatsColors[r][] = black[0][q]			endswitch			r += 1			endfor	endfor	for (i=0;i<DimSize(fit_compStats,0);i+=1)		SetDimLabel 0,i,$"model_"+num2str(fit_compStatsRows[i]),fit_compStats	endfor		//overall params	for (i=0;i<numoverallParams;i+=1)		param = overallParamsListWv[i]		SetDimLabel 1,i,$param,fit_stats				for (j=0;j<numFits;j+=1)			//set row labels			if (i==0)				setdimlabel 0,j,$("model_"+num2str(j)),fit_stats				rows[j] = "model_"+num2str(j)			endif					fitParamStr = fitparam_startStr + num2str(j) + "_" + param			r = FindDimLabel(paramWv, 0, fitParamStr)			if (r < 0)				val = NaN			else				val = paramWv[r]			endif			fit_stats[j][i] = val				endfor	endfor		String winN = disp_columns($allFitParamsRef,"",1,5,"",NaN,NaN,nan,nan)	ModifyGraph/W=$winN mode=4,marker=8,rgb=(0,0,0,32768),fsize=8,lblpos=40		//component params -- many variables repurposed and used differently 	//this part just set up	String compParamStr; variable k, index_shift	for (i=0;i<numCompParams;i+=1)		if (i < DimSize(compParamsListWv,0))			param = compParamsListWv[i]			lbl = param; SetDimLabel 1,i,$lbl,fit_compStats			r = 0			for (j=0;j<numFits;j+=1)				fitParamStr = fitparam_startStr + num2str(j) + compParams_startStr				for (k=0;k<j+1;k+=1)					compParamStr = fitParamStr + num2str(k) + "_" + param					val = paramWv[%$compParamStr]					fit_compStats[r][i] = val					r += 1				endfor			endfor		else			if (i == DimSize(compParamsListWv,0))					lbl = "amp"				index_shift = 1			else				lbl = "tau"				index_shift = 2			endif				SetDimLabel 1,i,$lbl,fit_compStats			r = 0			for (j=0;j<numFits;j+=1)								fitParamStr = fitparam_startStr + num2str(j) + coefParams_startStr				for (k=0;k<j+1;k+=1)					compParamStr = fitParamStr + num2str(index_shift+2*k) 	//maps to proper index in coef wave					val = paramWv[%$compParamStr]					fit_compStats[r][i] = val					r += 1				endfor						endfor				endif		endfor		//plot  graphs as on command line and then size and label them appropriately	//String cellParamsRef = cellStatsWinN, cellParamsRef_R = cellStatsWinN + "_r"//	Print "cellParamsRef",cellParamsRef,"cellParamsRef_R",cellParamsRef_R,	Print "cellParamsRef",cellParamsRef,"allFitParamsRef",allFitParamsRef,"allFitParamsRef_rows",allFitParamsRef_rows,"compParamsRef",compParamsRef,"compParamsRef_rows",compParamsRef_rows		//			currAxStart = i*defaultAxSpacing + i*sizePerAx	//			currAxEnd = currAxStart + sizePerAx	//plot components	display/k=1/N=$compParamsref	variable numAxes = DimSize(fit_compStats,1)		//=num cols = num comp params	axSpacing = 0.15	totalAxSpacing = axSpacing * (numAxes-1)	totalAxRoom = 1 - totalAxSpacing	roomPerAx = totalAxRoom / numAxes	for (i=0;i<DimSize(fit_compStats,1);i+=1)		axstart = i*roomPerAx + i*axSpacing		axEnd = axstart + roomPerAx		lbl = GetDimLabel(fit_compStats, 1, i)		axLbl_B = "B_" + lbl		axLbL_L = "L_" + lbl		appendtograph/W=$S_name/B=$axLbl_B/L=$axLbl_L fit_compStats[][i]/TN=$lbl vs fit_compStatsRows		modifygraph/W=$S_name axisEnab($axLbl_B) = {axStart,axEnd},lblpos($axLbl_B)=50,freepos($axLbl_B)=0,fsize=8		modifygraph/W=$S_name freepos($axLbl_L) = {0,$axLbL_B},lblpos($axlbl_l) = 30		label/W=$S_name $axLbl_B, lbl	; label/W=$S_name $axLbl_L, "\\Z10"+ lbl + " (\\f01\\U\\f00)"		setaxis/W=$S_name/A/N=2 $axLBL_L;doupdate;		getaxis/Q/W=$S_name $axLBL_L		setaxis/W=$S_name $axLBL_L, v_min < 0 ? V_min : 0, v_max > 0 ? V_max : 0	endfor	ModifyGraph/W=$S_name mode=3,marker=8,rgb=(0,0,0,32768), highTrip=1000,lowTrip=0.01,notation=0	ModifyGraph zColor={fit_compStatsColors,*,*,directRGB,0}	killwaves/z cellParamsList,overallParamsListWv		return cellParamsRefend//note: all values must have a non-zero length valueStr! --or rewrite more carefully to handle the if statement in if (valueRow < 0)function dl_addVal(value, valueStr, paramRef, dim,[dontAssign])	Double value		//value to add	String valueStr	//description of value for indexing (any existing value at this index is overwritten)	String paramRef //reference to save value and valueStr to (latter as dim label for row that value is assigned to)	Variable dim	Variable dontAssign		//optionally pass dontAssign=1 to skip assignment. Safest bet for adding to higher dims		Variable reportReplacement = 0		//when set, prints to command line if a replacement occurs		if (strlen(valueStr) < 1)		Print "dl_addVal(): warning! length to value string. call stack follows so calling line can be ID'd"	endif	Variable valueRow,ns	if (!WaveExists($paramRef))		Make/O/D/N=1 $paramRef/WAVE=paramWv		valueRow = 0	else		WAVE/D paramWv = $paramRef		valueRow = FindDimLabel(paramWv,dim, valueStr)		if (valueRow < 0)		//label not found			if ( (DimSize(paramWv,dim)==1) && (strlen( GetDimLabel(paramWv,dim,0) ) < 1 ) )		//if only one row and no label in this row, likely just starting off				valueRow = 0			else				valueRow = DimSize(paramWv,dim)			endif			ns=valueRow+1		//new size			Redimension/N=(dim==0 ? ns : -1,dim==1 ? ns : -1,dim==2 ? ns : -1,dim==3 ? ns : -1) paramWv		else		//do nothing except check whether to report this replacement			if (reportReplacement)				Print "dl_addVal() Replacement occured! paramRef =",paramRef,"valueStr",valueStr,"value",value			endif				endif	endif	if (ParamIsDefault(dontAssign) || !dontAssign)		dl_assignAndLbl(paramWv, valueRow, value, valueStr)	endif	return DimSize(paramWv,0)endfunction num_combinedFileAndSweep(fileNum, sweepNum)	Variable fileNum, sweepNum		Variable div = 1000			//sweep nums in the normal abf/data access system go up to 999, so dividing by 1000 gives sweep nums 1 = 0.0001, 2 = 0.0002, 20 = 0.002, etc.	return fileNum + sweepNum/divendfunction analysis_getSSResiduals(fitWv, dataWv)	WAVE fitWv, dataWv		Variable i, ssRes = 0	for (i=0;i<DimSize(fitWv,0);i+=1)		ssRes += ( fitWv[i] - dataWv[i] )^2	endfor		return sqrt(ssRes)end//sorts exponential fit coefs so that fastest exponential are first, retaining their associated amplitude//y0 (coefWave[p=0]) unaffectedthreadsafe function analysis_sortExpCoefWave(expCoefWave)	WAVE/D expCoefWave		Variable numExps =  floor( ( DimSize(expCoefWave,0) - 1)  / 2 )		if (numExps == 1)		return 0	endif		Make/O/D/N=(numExps)/free taus_sortKey, amps	Variable y0 = expCoefWave[0]	taus_sortKey = expCoefWave [2+(2*p)]		//take out all taus from coef wave	amps =  expCoefWave [1+(2*p)]			//take out all amps		Sort taus_sortKey, taus_sortKey, amps		//sort taus_sortKey and amps in smallest to largest based on taus in indices in taus_sortkey		expCoefWave[0] = y0	expCoefWave[2,;2] = taus_sortKey[(p-2)/2]		//even numbers from index 2 on are the taus	expCoefWave[1,;2] = amps[(p-1)/2]		//odd numbers from index 1 on are the amps			return 1end//label the rows in a multiexponential coeficient wavefunction analysis_labelExpCoefWave(expCoefWave)	WAVE/D expCoefWave		String y0Lbl="y0"	String ampLbl="amp"	String tauLbl="tau"		Variable i,numExps =  floor( ( DimSize(expCoefWave,0) - 1)  / 2 )	setdimlabel 0,0,$y0Lbl,expCoefWave	for (i=0;i<numExps;i+=1)		setdimlabel 0,2*i+1,$(ampLbl+num2str(i)),expCoefWave		setdimlabel 0,2*i+2,$(tauLbl+num2str(i)),expCoefWave	endfor	end//stand-alone capacity integration: requires current and cmd reffunction analysis_capTransIntegration_SA(currentRef, cmdRef paramsOutRef, timeToSS_X)	String currentRef, cmdRef, paramsOutRef	Variable timeToSS_X		Double vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step	analysis_cellParams_S_vCmd(cmdRef,  vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step)			analysis_capTransIntegration_S2(currentRef, paramsOutRef,  vCmd_t0, vCmd_baseline, vCmd_step, timeToSS_X)endfunction analysis_capTransIntegration_S2(currentRef, paramsOutRef,  vCmd_t0, vCmd_baseline, vCmd_step, timeToSS_X)	String currentRef, paramsOutRef		Variable  vCmd_t0, vCmd_baseline, vCmd_step			//information about step evoking transient: analysis_cellParams_vCmd can be used to generate	Variable timeToSS_X											//time to steady state: be careful to avoid onset of anything like Ih	Variable ssAvgWinSize = 0.001	Variable intStartX = vCmd_t0	Variable intEndX = intStartX + timeToSS_X	Variable baseMeanStartX = intStartX - ssAvgWinSize	Variable baseMeanEndX = intStartX	Variable ssMeanStartX = vCmd_t0 + timeToSS_X	Variable ssMeanEndX = ssMeanStartX + ssAvgWinSize		Variable isNegativeGoing = vCmd_step < vCmd_baseline		Duplicate/O/R=(intStartX,intEndX) $currentRef, currentWaveTemp	//baseline subtract the steady state (ionic) component of the current. exponential now falls to zero	Variable ssVal = mean($currentRef, ssMeanStartX, ssMeanEndX)	currentWaveTemp -= ssVal 	Variable deltaVcmd = vCmd_step - vCmd_baseline	Variable deltaSSVal = ssVal - mean($currentRef, baseMeanStartX, baseMeanEndX)	//actual size of change of steady state current	//threshold so that only portion of wave going in proper direction is considered (e.g. for negative steps, negative-going).	//this is only necessary because there aresome values below the steady state at the very beginning of the step, before the the capacity transient	if (isNegativeGoing)				currentWaveTemp[] = currentWaveTemp[p] > 0 ? 0 :  currentWaveTemp[p]		//threshold at zero	else		currentWaveTemp[] = currentWaveTemp[p] < 0 ? 0 :  currentWaveTemp[p]		//threshold at zero	endif	//perform integration								Integrate/T currentWaveTemp/D=$"capTrans_intResult"			WAVE/D capTrans_intResult	Double  Q_int = capTrans_intResult[DimSize(capTrans_intResult,0)-1]		double C_int = Q_int / deltaVcmd			Make/O/D/N=2 $paramsOutRef/WAVE=out	out[0] = Q_int	out[1] = C_intend//currently most up to date capacity transient integrationfunction analysis_capTransIntegration_lh(wv,paramsOutRef,vCmd_t0,vCmd_baseline,vCmd_step,timeToSS_X,assumedSpecificCap, lblPreAppendStr)	WAVE/D wv	String paramsOutRef	Variable vCmd_t0, vCmd_baseline, vCmd_step			//information about step evoking transient: analysis_cellParams_vCmd can be used to generate	Variable timeToSS_X											//time to steady state: be careful to avoid onset of anything like Ih	Double assumedSpecificCap								//usually 0.01 pF/um^2 (== 0.01 F/m^2)	String lblPreAppendStr									//pass to add something before label. often "int_" is helpful	if (numtype(assumedSpecificCap))		assumedSpecificCap = 0.01	endif	Variable ssAvgWinSize = 0.001	Variable intStartX = vCmd_t0	Variable intEndX = intStartX + timeToSS_X	Variable baseMeanStartX = intStartX - ssAvgWinSize	Variable baseMeanEndX = intStartX	Variable ssMeanStartX = vCmd_t0 + timeToSS_X	Variable ssMeanEndX = ssMeanStartX + ssAvgWinSize	Variable isNegativeGoing = vCmd_step < vCmd_baseline		Duplicate/O/R=(intStartX,intEndX) wv, capTransIntLH_temp		//baseline subtract the steady state (ionic) component of the current. exponential now falls to zero	Double baselineVal = mean(capTransIntLH_temp, ssMeanStartX, ssMeanEndX)	Double ssVal = mean(capTransIntLH_temp, ssMeanStartX, ssMeanEndX)	capTransIntLH_temp -= ssVal 	Double deltaVcmd = vCmd_step - vCmd_baseline	Double deltaSSVal = ssVal - baselineVal	//actual size of change of steady state current		//perform integration								Integrate/T capTransIntLH_temp/D=capTransIntLH_result_temp		Double Q_int = capTransIntLH_result_temp[DimSize(capTransIntLH_result_temp,0)-1]		double C_int = Q_int / deltaVcmd		Double sa_int = C_int / assumedSpecificCap	Double sph_dia_int = 2*sqrt(sa_int/4/pi)			Variable numParams = 8	Make/O/D/N=(numParams) $paramsOutRef/WAVE=out	dl_assignAndLbl(out, 0, Q_int, lblPreAppendStr + "Q")	dl_assignAndLbl(out, 1, C_int, lblPreAppendStr + "C")	dl_assignAndLbl(out, 2, sa_int, lblPreAppendStr + "sa")	dl_assignAndLbl(out, 3, sph_dia_int, lblPreAppendStr + "sph_dia")	dl_assignAndLbl(out, 4, timeToSS_X, lblPreAppendStr + "timeToSS_X")	dl_assignAndLbl(out, 5, baselineVal, lblPreAppendStr + "baselineLevel")	dl_assignAndLbl(out, 6, ssVal, lblPreAppendStr + "ssLevel")	dl_assignAndLbl(out, 7, deltaSSVal, lblPreAppendStr + "ssBaselineDeltaLevel")			killwaves/z capTransIntLH_temp, capTransIntLH_result_tempendfunction analysis_capTransIntegration(currentRef, paramsOutRef,  vCmd_t0, vCmd_baseline, vCmd_step, timeToSS_X, exp_x0, tau0 ,amp0, [tau1, amp1])	String currentRef, paramsOutRef		Variable  vCmd_t0, vCmd_baseline, vCmd_step			//information about step evoking transient: analysis_cellParams_vCmd can be used to generate	Variable timeToSS_X											//time to steady state: be careful to avoid onset of anything like Ih. 0.006 (6 ms) seems very safe		Variable tau0, exp_x0, amp0//dominant time constant of exponential. Used for estimating time course of membrane potential (and therefore passive membrane current) change. can be found with analysis_calcCellPArams_S3, for example	Variable tau1, amp1		//if double exponential is a significant improvement (e.g. using f test or by eye), pass tau1, for second tau, and amp0 and amp1 (amplitude of first and second exponentials)		Variable ssAvgWinSize = 0.001	Variable intStartX = vCmd_t0	Variable intEndX = intStartX + timeToSS_X	Variable baseMeanStartX = intStartX - ssAvgWinSize	Variable baseMeanEndX = intStartX	Variable ssMeanStartX = vCmd_t0 + timeToSS_X	Variable ssMeanEndX = ssMeanStartX + ssAvgWinSize		Variable isNegativeGoing = vCmd_step < vCmd_baseline		Duplicate/O/R=(intStartX,intEndX) $currentRef, currentWaveTemp	//baseline subtract the steady state (ionic) component of the current	Variable ssVal = mean($currentRef, ssMeanStartX, ssMeanEndX)	currentWaveTemp -= ssVal 	Variable deltaVcmd = vCmd_step - vCmd_baseline	Variable deltaSSVal = ssVal - mean($currentRef, baseMeanStartX, baseMeanEndX)	//actual size of change of steady state current	//threshold so that only portion of wave going in proper direction is considered (e.g. for negative steps, negative-going).	//this is only necessary because there aresome values below the steady state at the very beginning of the step, before the the capacity transient	if (isNegativeGoing)				currentWaveTemp[] = currentWaveTemp[p] > 0 ? 0 :  currentWaveTemp[p]		//threshold at zero	else		currentWaveTemp[] = currentWaveTemp[p] < 0 ? 0 :  currentWaveTemp[p]		//threshold at zero	endif									Integrate/T currentWaveTemp/D=$"capTrans_intResult"	//	disp_overlays("", 0, "currentWaveTemp;capTrans_intResult","L_0;L_1", "r;r;", axisPairs="0,.48;.52,1")		//This is still an underestimate of the capacitive current because the membrane only changes potential after the capacitance is charged, so ionic is delayed by the time course of the cap current	//but these are convoluted with one another so need to estimate one (here we'll do ionic) to get the other	Duplicate/O/R=(exp_x0,) currentWaveTemp, estIonicCurrentTemp	estIonicCurrentTemp = 0	Variable secondTauPassed = (!ParamIsDefault(tau1) && !ParamIsDefault(amp1))	Variable expectedIntegral	if (secondTauPassed)		Variable t0_t1_ratio = amp0/amp1		estIonicCurrentTemp = ( (t0_t1_ratio/(1+ t0_t1_ratio) )*exp(-(x-exp_x0)/tau0) ) + ( (1/(1+ t0_t1_ratio) )*exp(-(x-exp_x0)/tau1) ) 			expectedIntegral = tau0*(t0_t1_ratio/(1+ t0_t1_ratio) ) + tau1*  (1/(1+ t0_t1_ratio)) 	else		 estIonicCurrentTemp = exp(-(x-exp_x0)/tau0)		 tau1 = NaN			//for output purposes: signifies that these were not passed		 t0_t1_ratio = NaN		//for output purposes		 expectedIntegral = tau0	endif		estIonicCurrentTemp *= deltaSSVal	expectedIntegral*= deltaSSVal		Integrate/T estIonicCurrentTemp/D=$"preionicTrans_intResult"	WAVE/D capTrans_intResult, preionicTrans_intResult	Variable Q_int = capTrans_intResult[DimSize(capTrans_intResult,0)-1]	Variable Q_int_estIonic = preionicTrans_intResult[DimSize(preionicTrans_intResult,0)-1]	Variable Q_int_total = Q_int + Q_int_estIonic		Print "testing integration. expected integral = " + num2str(expectedIntegral) + ". empirical integral = " + num2str(Q_int_estIonic)		Variable C_int = Q_int / deltaVcmd	Variable C_int_estIonic = Q_int_estIonic / deltaVcmd	Variable C_int_total = Q_int_total / deltaVcmd		Print "cap transient integration. Q_int = " + num2str(Q_int) + "Q_int_estIonic=" + num2str(Q_int_estIonic) + ". C_int=" + num2str(C_int) + ". C_int_estIonic=" + num2str(C_int_estIonic)	//	Display/K=1 estIonicCurrentTemp	killwaves/Z estIonicCurrentTemp, capTrans_intResult, preionicTrans_intResult, currentWaveTemp		//compare C from fit for C from integration	Variable C_fit_c0 = NaN, C_fit_c1 = NaN, C_fit_total = NaN	C_fit_c0 = tau0 * amp0 / deltaVcmd	Variable fastComponent=NaN, fastTau=NaN, fastAmp=NaN, fastCap=NaN, slowTau=NaN, slowAmp=NaN, slowCap=NaN	if (secondTauPassed)		C_fit_c1 = tau1 * amp1 / deltaVCmd		if (tau0 < tau1)		//first is slow			fastComponent = 0			fastTau = tau0			fastAmp = amp0			fastCap = C_fit_c0			slowTau = tau1			slowAmp = amp1			slowCap = C_fit_c1			else			fastComponent = 1			fastTau = tau1			fastAmp = amp1			fastCap = C_fit_c1			slowTau = tau0			slowAmp = amp0			slowCap = C_fit_c0			endif			else		C_fit_c1 = 0	endif		C_fit_total = C_fit_c0 + C_fit_c1		Variable numCapParams = 28	Make/O/D/N=(numCapParams) $paramsOutRef	WAVE cap_params_temp = $paramsOutRef	cap_params_temp[0] = intStartX	cap_params_temp[1] = intEndX	cap_params_temp[2] = timeToSS_X	cap_params_temp[3] = baseMeanStartX	cap_params_temp[4] = baseMeanEndX	cap_params_temp[5] = ssMeanStartX	cap_params_temp[6] = ssMeanEndX	cap_params_temp[7] = ssAvgWinSize	cap_params_temp[8] = tau0	cap_params_temp[9] = exp_x0	cap_params_temp[10] = tau1	cap_params_temp[11] = t0_t1_ratio	cap_params_temp[12] = Q_int	cap_params_temp[13] = Q_int_estIonic	cap_params_temp[14] = Q_int_total	cap_params_temp[15] = C_int	cap_params_temp[16] = C_int_estIonic	cap_params_temp[17] = C_int_total	cap_params_temp[18] = C_fit_c0	cap_params_temp[19] = C_fit_c1	cap_params_temp[20] = C_fit_total	cap_params_temp[21] = fastComponent	cap_params_temp[22] = fastTau	cap_params_temp[23] = fastAmp	cap_params_temp[24] = fastCap	cap_params_temp[25] = slowTau	cap_params_temp[26] = slowAmp	cap_params_temp[27] = slowCapend	//end analysis_capTransIntegration()function/S analysis_getCapTransIntHeader()	Variable numCapParams = 28	Make/O/T/N=(numCapParams) capParamsHeader	capParamsHeader[0] = "intStartX"	capParamsHeader[1] = "intEndX"	capParamsHeader[2] = "timeToSS_X"	capParamsHeader[3] = "baseMeanStartX"	capParamsHeader[4] = "baseMeanEndX"	capParamsHeader[5] = "ssMeanStartX"	capParamsHeader[6] = "ssMeanEndX"	capParamsHeader[7] = "ssAvgWinSize"	capParamsHeader[8] = "tau0"	capParamsHeader[9] = "exp_x0"	capParamsHeader[10] = "tau1"	capParamsHeader[11] = "t0_t1_ratio"	capParamsHeader[12] = "Q_int"	capParamsHeader[13] = "Q_int_estIonic"	capParamsHeader[14] = "Q_int_total"	capParamsHeader[15] = "C_int"	capParamsHeader[16] = "C_int_estIonic"	capParamsHeader[17] = "C_int_total"	capParamsHeader[18] = "C_fit_c0"	capParamsHeader[19] = "C_fit_c1"	capParamsHeader[20] = "C_fit_total"	capParamsHeader[21] = "fastComponent"	capParamsHeader[22] = "fastTau"	capParamsHeader[23] = "fastAmp"	capParamsHeader[24] = "fastCap"	capParamsHeader[25] = "slowTau"	capParamsHeader[26] = "slowAmp"	capParamsHeader[27] = "slowCap"		return "capParamsHeader"endfunction getExpFit(outWaveRef, coefWaveRef, waveThatWasFitRef, fitStartX, fitEndX, componentNum)		String outWaveRef, coefWaveRef, waveThatWasFitRef	Variable  fitStartX, fitEndX, componentNum		if (strlen(outWaveRef) < 1)		outWaveRef = waveThatWasFitRef + "_expFit"	endif			Duplicate/O/D/R=(fitStartX, fitEndX) $waveThatWasFitRef, $outWaveRef	WAVE/D tempFit = $outWaveRef	WAVE/D coefTemp = $coefWaveRef		tempFit = coefTemp[0]			//y0		NVAR x0		Variable currExpNum, currIndex, currAmp, currTau, numExps = floor( (DimSize(coefTemp,0)-1)/2 )		Variable plotComponent = ( (componentNum >= 0) && (componentNum < numExps) )		//only plot component instead of whole thing if valid component num input		if (plotComponent)		currIndex = 1 + 2 * componentNum			currAmp =  coefTemp[currIndex]			//ith component amp		currTau =  coefTemp[currIndex+1]			//ith component tau		tempFit += currAmp* exp(-(x-x0) / currTau)			else		for (currExpNum=0;currExpNum<numExps;currExpNum+=1)			currIndex = 1 + 2 * currExpNum				currAmp =  coefTemp[currIndex]			//ith component amp			currTau =  coefTemp[currIndex+1]			//ith component tau			tempFit += currAmp* exp(-(x-x0) / currTau)		endfor	endifendfunction makeFitWaves3(data, currentRef, toSubWaveRef, fitCoefsWave, fitNum, baselineC, deltaV, x0, fitStartX, fitEndX, componentParamsOutRef,numParams_out, numSamples_out, ss_Res_out, ss_Reg_out, ss_Total_out, r2_out, x2_out, redisplayRef)	WAVE data					//reference to original wave that was fit and wave after subtraction (latter if only actually performed)	String currentRef, toSubWaveRef	WAVE fitCoefsWave															//coef wave from which fit waves are to be made	Variable fitNum															//number to be saved for use in future redisplay, to allow one to get proper coefs from that final coef wave ref	Variable fitStartX, fitEndX, baselineC, deltaV, x0												//needed for making fits and for analysis	String componentParamsOutRef											//a reference to which parameters about fits are to be stored	Variable &numParams_out,  &numSamples_out, &ss_Res_out, &ss_Reg_out, &ss_Total_out, &r2_out, &x2_out		//various outputs	String redisplayRef			Variable subbedWaveRefIndex = 6	Variable modelSaveRefIndex = 7		Variable saveForDisplay = strlen(redisplayRef) > 0			Variable assumedSpecificCap = 0.01 			//pF / um^2 conversion to F / m: 1 F / 10^12 pF * 10^6 um / m * 10^6 um / m = x pF/um^2 = F/ m ^ 2	Variable currExp	Variable numExps = floor((DimSize(fitCoefsWave, 0) - 1) / 2)	Duplicate/O/R=(fitStartX, fitEndX) data, finalFit, currFitComponent, originalData		//dont have to worry about missing data wave bc data has to be re-loaded if absent by function calling this function	finalFit = 0			Variable y0 = fitCoefsWave[0]	Variable currAmp, currTau		//fitCoefsWave should have form of y0, c0_amp, c0_tau, c1_amp, c1_tau,....		Variable Imax = 0		//sum this across components to get total for model	Variable meanTau	//calculate the average tau weighted by the amplitude of the component		//display related: find start of component save names, save subbed wave, which if occured is passed as data and to sub wave ref has strlen > 0	if (saveForDisplay)		Duplicate/O/T $redisplayRef, redisplayTemp		Variable componentsSaveStartIndex = ItemsInList(redisplayTemp[0]) - 1		String redisplayList = redisplayTemp[fitNum]		if (strlen(toSubWaveRef) > 0)			Duplicate/O data, $StringFromList(subbedWaveRefIndex, redisplayList)		endif	endif		for (currExp=0;currExp < numExps; currExp+=1)		currAmp = fitCoefsWave[currExp*2 + 1]		Imax += currAmp		currTau = fitCoefsWave[currExp*2 + 2]		meanTau += currTau * currAmp		currFitComponent = y0 + currAmp * exp(-(x-x0) / currTau)		finalFit += currFitComponent		//redisplay related: save components		if (saveForDisplay)			Duplicate/O currFitComponent, $StringFromList(componentsSaveStartIndex+currExp, redisplayList)		endif		if (currExp > 0)			finalFit -= y0		//must not keep adding this except once!		endif	endfor		meanTau /= Imax		if (saveForDisplay)		Duplicate/O finalFit, $StringFromList(modelSaveRefIndex, redisplayList)	endif		//fit model / components to Lindau and Neher method to find access resistance (strictly only valid for data well fit by a single compartment model!)	//first do so for overall fit. Access and rm are straightfoward, but cm is not for multi-compartmentals. We will just take the average of time constants weighted by the amplitude of each exponential for an approximation. There's no basis for this			//storage location will be componentParams_out. 1 + i rows where i is number of exponential components. 0th row stores info for overall fit, then rest are components 1, 2 etc.		//columns: 0 = Imax, 1 = Ra, 2 = Rm, 3 = Cm\	Variable numComponentParams = 11		//including spacer	numParams_out = numComponentParams	Make/O/N=(1+numExps, numComponentParams) componentParams_temp				//handle overall fit (row 0)		componentParams_temp[0][0] = Imax			//Imax for total model	componentParams_temp[0][1] = deltaV / Imax		//Ra = deltaV / Imax	componentParams_temp[0][2] = ( deltaV - (componentParams_temp[0][1] * y0) ) / y0					//Rm =  ( deltaV - (Ra * Iss) ) / Iss			Input resistance corrected for losses to access. Iss = y0	componentParams_temp[0][3] = meanTau * ( (1 / componentParams_temp[0][1]) + (1 / componentParams_temp[0][2]) )		//Cm = tau * ( (1/Ra) + (1/Rm) )			THIS IS ONLY AN ESTIMATE WHEN USING MORE THAN ONE COMPARTMENT	componentParams_temp[0][4] = componentParams_temp[0][3] / assumedSpecificCap									//estimate of SA from Cm	componentParams_temp[0][5] = sqrt(componentParams_temp[0][4])/(4*pi)												//radius estimate under assumption of SA above for a perfect sphere		Variable voltageChangeAcrossAccess = componentParams_temp[0][1] * y0	Print "expNum = " + num2str(currExp) + ". Imax = " + num2str(Imax) + ". deltaV = " + num2str(deltaV) + ". y0 = " +num2str(y0) + ". Ra = " + num2str(componentParams_temp[0][1]) +  ". Rm = " + num2str(componentParams_temp[0][2]) + ". vDropAccess = " + num2str(voltageChangeAcrossAccess)	if (abs(voltageChangeAcrossAccess) > abs(deltaV))		Print "WARNING: in makeFitWaves3 for wave = " + NameOfWave(data) + ". v drop across access is greater than v command. Rm will be negative, access likely extremely poor"	endif			//handle all fit components	Variable currRow	for (currExp=0;currExp < numExps; currExp+=1)		currRow = 1 + currExp		componentParams_temp[currRow][0] = fitCoefsWave[currExp*2 + 1]			//Imax for component = component amplitude		componentParams_temp[currRow][1] = deltaV / componentParams_temp[currRow][0]		//Ra for component = deltaV / component amplitude		componentParams_temp[currRow][2] = ( deltaV - (componentParams_temp[currRow][1] * y0) ) / y0		//Rm for component = (deltaV - (Ra,c * Iss) ) / Iss		componentParams_temp[currRow][3] =  fitCoefsWave[currExp*2 + 2] * ( (1 / componentParams_temp[currRow][1]) + (1 / componentParams_temp[currRow][2]) )		//Cm for component = tau,c * ( (1/Ra,c) + (1/Rm,c) )		componentParams_temp[currRow][4] = componentParams_temp[currRow][3] / assumedSpecificCap									//estimate of SA from Cm		componentParams_temp[currRow][5] = sqrt(componentParams_temp[currRow][4]/(4*pi))												//radius estimate under assumption of SA above for a perfect sphere		endfor		Variable cmSum = getDimSegmentStats(1, 3, "componentParams_temp", "V_sum", startP=1, endP=numExps+1) 	Variable saSum =  getDimSegmentStats(1, 4, "componentParams_temp", "V_sum", startP=1, endP=numExps+1) 	Variable radiusSum = getDimSegmentStats(1, 5, "componentParams_temp", "V_sum", startP=1, endP=numExps+1) 		componentParams_temp[][6] = componentParams_temp[p][0] /  componentParams_temp[0][0]			//proportion of Imax contributed by this component	componentParams_temp[][7] = componentParams_temp[p][3] / cmSum			//cm normalized to total cm	componentParams_temp[][8] = componentParams_temp[p][4] / saSum			//sa normalized to total sa	componentParams_temp[][9] = componentParams_temp[p][5] / radiusSum			//radius normalized to total radius (for completeness)		convert2DTo1D("componentParams_temp", "componentParams_out", 1)		//concatenate ROWS 		WAVE componentParams_out			//made by convert2DTo1D	//append num components and spacer	Redimension/N=(DimSize(componentParams_out,0) + 2) componentParams_out	componentParams_out[DimSize(componentParams_out,0) - 2] = numExps	componentParams_out[DimSize(componentParams_out,0) - 1] = inf		//save this for output	Duplicate/O componentParams_out, $componentParamsOutRef			//calculate residuals and sum of squares of that for final fit and regression sum of squares	Duplicate/O finalFit, residuals, finalFitTemp	residuals = originalData - finalFit		numSamples_out = DimSize(finalFit, 0)		residuals *= residuals	ss_Res_out =  sum(residuals)		Variable sampleMean = mean(originalData, fitStartX, fitEndX)	finalFit -= sampleMean		//regression residuals	finalFit *= finalFit				//squared regression residuals	ss_Reg_out = sum(finalFit)	//sum of squares of regression residuals		//total sum of squares in original data	Duplicate/O originalData, dataTemp		originalData -= sampleMean		//total difference from mean	originalData *= originalData		//squared total difference from mean	ss_Total_out = sum(originalData, fitStartX, fitEndX)		//sum of squares for total difference from mean		r2_out = 1 - (ss_Res_out / ss_total_out)		//calculate chi-sq value: sum( (data[i] - predicted[i])^2 / predicted[i] ) --numerator is just ss_Res_out, but we'll start the with the squared residuals from above	residuals /= finalFitTemp			//divide squared residuals by each prediction	x2_out = sum(residuals)			KillWaves/Z dataTemp, residuals, finalFit, finalFitTemp, originalData, currFitComponent end		//makeFitWaves3function/S analysis_getCoefWaveHeader()	Make/O/T/N=35 coefWaveHeader	Variable index = 0	Variable numModels=5, numNonY0ParamsInModel, model_i, i	String currStartStr	for (model_i=0; model_i < numModels;model_i+=1)		numNonY0ParamsInModel=(2*(model_i+1))		currStartStr = "m" + num2str(model_i) + "_"		coefWaveHeader[index] = currStartStr + "y0"		index+=1		for (i = 0; i< numNonY0ParamsInModel; i+=1)			if (mod(i,2) == 0)		//amplitude				coefWaveHeader[index] = currStartStr + "c" + num2str(floor(i/2)) + "_A"			else					//tau				coefWaveHeader[index] = currStartStr + "c" + num2str(floor(i/2)) + "_tau"			endif			index+=1				endfor	endfor	Print "index",index		return "coefWaveHeader"endfunction/S getCoefsAsText(modelNum, coefHeaderRef, coefWaveRef)	Variable modelNum	String coefHeaderRef, coefWaveRef		Variable i	String startStr = "m" + num2str(modelNum) + "_", findStr	String out = ""	Variable numCoefs = 1 + ((modelNum+1) * 2)	for (i=0;i<numCoefs;i+=1)		if (i==0)			findStr = startStr + "y0"		else			findStr = startStr + "c" + num2str(floor((i-1)/2)) + "_"			if (mod(i,2) == 0)				findStr += "tau"			else				findStr += "A"			endif		endif		out += findStr + ":"+num2str(getParamFromHeader_1D(findStr, coefHeaderRef, coefWaveRef)) + ";"	endfor	return outendfunction/S analysis_getCompParamsHeader(numExps)	Variable numExps		Variable numCompParams=12	Make/O/T/N=230 compParamsHeader	Variable maxNumReps = numExps + 2	Variable compNum, totalComps = numExps + 1	String startStr	Variable currNumReps	Variable index = 0	Variable haveNotPassedFirst = 1	for (currNumReps = 2; currNumReps < maxNumReps; currNumReps +=1)		String modelStr = num2str(currNumReps-2) + "_"		for (compNum=0; compNum < currNumReps; compNum+=1)			if (compNum == 0)				startStr = "mT_"			else				startStr = "m" + num2str(compNum-1) + "_"			endif			compParamsHeader[index + 0] = modelStr + startStr + "Imax"			compParamsHeader[index + 1] = modelStr +startStr +	"Ra"			compParamsHeader[index + 2] = modelStr +startStr + "Rm"			compParamsHeader[index + 3] = modelStr +startStr + "Cm"			compParamsHeader[index + 4] = modelStr +startStr +	"SA"			compParamsHeader[index + 5] = modelStr +startStr +"rad"			compParamsHeader[index + 6] = modelStr +startStr +"propImax"			compParamsHeader[index + 7] = modelStr +startStr +	"propCm"			compParamsHeader[index + 8] = modelStr +startStr +"propSA"			compParamsHeader[index + 9] = modelStr +startStr +"propRad"			compParamsHeader[index + 10] = modelStr +startStr +"Blank"			index+= 11		endfor		compParamsHeader[index] = modelStr +"numComps" + num2str(currNumReps-1)		index+=1		compParamsHeader[index] = modelStr +"END" + num2str(currNumReps-1)		index+=1	endfor		Print "index", index	return "compParamsHeader"end //getComponentParamsHeader()//fit an individual sweep to an exponential//generates three summary waves://genParams: overall information on response (input resistance etc.)//fitParams:  fit statistics and cell parameters derived from those statistics//coef wave: rows are coefwaves generated from fits, each row for an increasing fit //in addition an optional text wave is generated://listOfFitWaves that stores references to fits and fit components for each model (where one model is an exponential fit with some number of exponential components)function/S analysis_cellParams_S2(currentRef, vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step, genAndFitParamsSaveRef, compParamsSaveRef,  coefWaveSaveRef, [waveToSubRef, subbedWaveSaveRef, modelSaveRef, cmpntntsAppendStr, modelResSaveRef, modelsListWaveSaveRef, modelsDispN, cmpntntsDispN])	String currentRef			//reference to the wave to be analyzed	Variable vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step		//information on the voltage command that was given t0 is step start, t1 is step end, baseline is v_hold before step, step is Vcmd during step	String genAndFitParamsSaveRef					//a reference to which general parameters wave will be saved	String compParamsSaveRef					//a reference to which fit parameters wave will be saved	String coefWaveSaveRef					//a reference to which coef waves will be saved	//optional parameters: tells the function what aspects of analysis to save and where to save them. Do not pass displayFits = 1 unless saving fit waves in fitWaveSaveRef (as well as fit components append string 	String waveToSubRef						//a reference to a wave to subtract from currentRef wave (e.g. pipette capacitance before break in). Subtraction only performed if this is passed	String subbedWaveSaveRef				//if final (subtracted) current wave is to be saved, a ref to which it will be saved (REQUIRED FOR DISPLAY IF DOING SUBTRACTION)	String modelSaveRef						//if model waves (sum of fit components) are to be saved, this is the ref in which they will be saved, with [modelNum] following, where for a single exponential fit model num = 0	String cmpntntsAppendStr			//if model wave fit components are to be saved, this will be appended to fitWaveSaveRef[model num], followed by component number from 0, as a reference to save the component in	String modelResSaveRef					//if model wave residuals are to be saved, this will be the ref in which they are saved, with [model num] following, where for a single exponential fit model num = 0	String modelsListWaveSaveRef				//a reference to which can be saved a text wave storing refereneces and other information about each fit wave that has been generated	String modelsDispN					//a window name on which to display all full models. Only displayed if full models are saved	String cmpntntsDispN				//a window name that will be the base name for a window for each model, in which each full model (if saved) and each component will be displayed. Only used if full models AND components are saved	Variable saveFinalCurrentWave = 0		Variable doDisplay = 0		if (!ParamIsDefault(modelSaveRef) && !ParamIsDefault(cmpntntsAppendStr) && !ParamIsDefault(modelsListWaveSaveRef) && !ParamIsDefault(modelsDispN) && !ParamIsDefault(cmpntntsDispN))		//these are obligate for automatic display		doDisplay = 1	endif		if (!ParamIsDefault(waveToSubRef) && ParamIsDefault(subbedWaveSaveRef)	)	//if the former is present, the latter has to be present for display		doDisplay = 0	endif					Variable moreFreeParamsJustifiedThresh= 0.05		//p value from f statistic below which we will say this model is justified	Variable lastPassingModel = 0						//tracks the last model that passed		//choose windows for baseline and steady state measurements	Variable winPadding = 0.001		//in S, amount of time between baseline window ending and step start/end	Variable ssWinSize = 0.004	Variable baseWinStartX = vCmd_t0 - ssWinSize - winPadding	Variable baseWinEndX = vCmd_t0 - winPadding	Variable ssWinStartX = vCmd_t1 - ssWinSize  - winPadding	Variable ssWinEndX = vCmd_t1 - winPadding		//other things to set to start with	Variable fitWinSize = 0.00125	Variable maxNumExps = 5			//maximum number of exponential components to test for	Variable y0InitialGuess = 0	Variable amplitudeInitialGuess = -400 * 10 ^-12	Variable tauInitialGuess = 0.0002		Variable lastSS		Duplicate/O $currentRef, currentResp	//current ref is used for display if doDisplay = 1. If subtraction is being performed (see next), then subbedWaveRef is also used for display (if doDisplay = 1)			//calculate (steady state) input resistance	Variable deltaVoltage = vCmd_step - vCmd_baseline	Variable baseCurrent = mean(currentResp, baseWinStartX,baseWinEndX)	Variable ssCurrent = mean(currentResp, ssWinStartX,ssWinEndX)	Variable deltaSSCurrent = ssCurrent - baseCurrent	Variable ssRin = deltaVoltage / deltaSSCurrent		String waveForSubRef = ""	if (!ParamIsDefault(waveToSubRef))		Duplicate/O $waveToSubRef, waveToSubTemp		currentResp -= wavetoSubTemp		if (!ParamIsDefault(subbedWaveSaveRef))			Duplicate/O currentResp, $subbedWaveSaveRef		else		endif		waveForSubRef = waveToSubRef	endif		//find peak of the capacity transient. Want to start fit at this peak, even if it's after t0, because we don't want to fit to values that are lower than and precede the peak	WaveStats/Q/R=(vCmd_t0, ssWinStartX) currentResp	Variable peakLoc, peakVal	if (deltaVoltage < 0)	//then step is negative, so peak is a minimum		peakLoc = V_minloc		//Might have to NVAR in V_minloc and V_maxloc, but not today...		peakVal = V_min - baseCurrent			//at step, all current flowing through access resistance, giving capactive transient. Subtract baseline to get delta for this capacitive current	else		peakLoc = V_maxloc		peakVal = V_max - baseCurrent	endif			Variable fitStartX = peakLoc	Variable fitEndX = peakLoc + fitWinSize	Variable fitStartP = x2pnt(currentResp, fitStartX)	Variable fitEndP = x2pnt(currentResp, fitEndX)		Variable/G x0 = peakLoc				//important for the fitting function to have this global variable set. Though there is a way to pass to a fit function, but I haven't implemented it	Make/O/D/N=1 coefWave				//stores each coefWave (in rows), redimensioned as needed //	Make/O/D/N=(1 + (maxNumExps*2)) coefWaveSave		//stores all the coefWaves, one row for each model, each column a different fit coef (e.g. 0 = y0, 1 = A1, 2=tau1, 3=A2, 4 = tau2, etc.) columns redimensioned as needed	coefWave = y0InitialGuess				//first y0 intial guess set		Variable numFitParams = 20	Make/O/T/N=(maxNumExps) fitsTemp							//text wave that stores information (references to fits etc.) for each model. one row per model	Make/O/D/N=(maxNumExps, numFitParams) fitParamsTemp		//stores ss_Residuals etc. for each fit. numFitParams rows per model. iterate with (currModelNum * numFitParams) + currParamNum		Note fitsTemp, "REF: " + currentRef + ";SUB:" + waveForSubRef + ";"	Note fitParamsTemp, "REF: " + currentRef + ";SUB:" + waveForSubRef + ";"			Variable i, curr_ss_Res, curr_ss_Reg, curr_ss_Tot, curr_r2, curr_x2, curr_numSamples, numComponentParams	//former is iterate through each fit, latter will values calculated by calcFitWave	Variable f_numer, f_denom		//saving fits	String currModelSaveRef,currFitComponentSaveStart		//spacing between model fit params: 	Variable spacer = inf		Variable raBestFitModel	variable V_FitError, fitTries, numAlterations = 8,  numDefaultTries = 10, triesLimit = numAlterations + numDefaultTries		//iterate through and fit to as many exponentials as one wants	for (i=0;i<maxNumExps;i+=1)		Redimension/N=(DimSize(coefWave,0) + 2) coefWave		V_FitError = 0		fitTries = 0		do			switch (mod(fitTries, numAlterations)-numDefaultTries)				case 0:					coefWave[1+2*i] = amplitudeInitialGuess/4					coefWave[1+2*i + 1] = tauInitialGuess						break				case 1:					coefWave[1+2*i] = amplitudeInitialGuess/8					coefWave[1+2*i + 1] = tauInitialGuess					break				case 2:					coefWave[1+2*i] = amplitudeInitialGuess*4					coefWave[1+2*i + 1] = tauInitialGuess					break									case 3:					coefWave[1+2*i] = amplitudeInitialGuess*8					coefWave[1+2*i + 1] = tauInitialGuess						break							case 4:					coefWave[1+2*i] = amplitudeInitialGuess					coefWave[1+2*i + 1] = tauInitialGuess/4					break				case 5:					coefWave[1+2*i] = amplitudeInitialGuess					coefWave[1+2*i + 1] = tauInitialGuess/8					break				case 6:					coefWave[1+2*i] = amplitudeInitialGuess					coefWave[1+2*i + 1] = tauInitialGuess*4					break				case 7:					coefWave[1+2*i] = amplitudeInitialGuess					coefWave[1+2*i + 1] = tauInitialGuess*8					break				default:					if (fitTries == 0)						coefWave[1+2*i] = amplitudeInitialGuess						coefWave[1+2*i + 1] = tauInitialGuess					endif					break			endswitch				FuncFit/NTHR=0/W=2/N=1/Q=1 myExp, coefWave, currentResp[fitStartP, fitendP]			fitTries+=1		while ((V_FitError > 0) && (fitTries < triesLimit))						Note/K coefWave, "FITWIN_X: " + num2str(fitStartX) + "," + num2str(fitEndX) + ";" + "DATAWAVE: " + currentRef + ";" + "FIT_x0: " + num2str(x0) + ";"		//stupid but functioning way of passing this info on				//save coef wave results by adding them to coefWaveSave		if (i==0)			Duplicate/O coefWave, coefWaveSave		else			Duplicate/O coefWaveSave, coefWaveSaveOld			concatenate/NP=0/O {coefWaveSaveOld, coefWave}, coefWaveSave			Note coefWaveSave, "FITWIN_X: " + num2str(fitStartX) + "," + num2str(fitEndX) + ";" + "DATAWAVE: " + currentRef + ";" + "FIT_x0: " + num2str(x0) + ";" + "|" + ";"		// "|" allows iterating through with StringFromList(i, list, "|")		endif					if (doDisplay)			currModelSaveRef = modelSaveRef + num2str(i)			currFitComponentSaveStart = currModelSaveRef + cmpntntsAppendStr			if (!ParamIsDefault(subbedWaveSaveRef))				fitsTemp[i] = makeFitWaves2(currentResp, currentRef,  coefWave,  coefWaveSaveRef, i, baseCurrent, deltaVoltage, x0, fitStartX, fitEndX, "compParamsTemp_parent", numComponentParams, curr_numSamples, curr_ss_Res, curr_ss_Reg, curr_ss_Tot, curr_r2, curr_x2,finalWaveSaveRef=subbedWaveSaveRef, finalFitStorageWaveRef=currModelSaveRef,fitComponentStorageWaveStart=currFitComponentSaveStart)			else				fitsTemp[i] = makeFitWaves2(currentResp, currentRef,  coefWave,  coefWaveSaveRef, i, baseCurrent, deltaVoltage, x0, fitStartX, fitEndX, "compParamsTemp_parent", numComponentParams, curr_numSamples, curr_ss_Res, curr_ss_Reg, curr_ss_Tot, curr_r2, curr_x2,finalFitStorageWaveRef=currModelSaveRef,fitComponentStorageWaveStart=currFitComponentSaveStart)			endif		else			if (!ParamIsDefault(subbedWaveSaveRef))						fitsTemp[i] = makeFitWaves2(currentResp, currentRef, coefWave, coefWaveSaveRef, i, baseCurrent, deltaVoltage, x0, fitStartX, fitEndX, "compParamsTemp_parent", numComponentParams,  curr_numSamples, curr_ss_Res, curr_ss_Reg, curr_ss_Tot, curr_r2, curr_x2, finalFitStorageWaveRef=currModelSaveRef)			else				fitsTemp[i] = makeFitWaves2(currentResp, currentRef, coefWave, coefWaveSaveRef, i, baseCurrent, deltaVoltage, x0, fitStartX, fitEndX, "compParamsTemp_parent", numComponentParams,  curr_numSamples, curr_ss_Res, curr_ss_Reg, curr_ss_Tot, curr_r2, curr_x2)			endif		endif				//save componentParams by concatenating them		if (i==0)			Duplicate/O $"compParamsTemp_parent", compParamsSave		else			Duplicate/O compParamsSave, compParamsSaveOld			concatenate/NP=0/O {compParamsSaveOld, $"compParamsTemp_parent"}, compParamsSave		endif	//analyze coef wave: make fits and compare to raw data, compute f statistic, save anything needed for future display				fitParamsTemp[i][0] = curr_ss_Res						//0 is sum of squares of residuals		fitParamsTemp[i][1] = curr_ss_Reg						//1 is sum of squares of the regression (predicted y - sample mean for each sample)		fitParamsTemp[i][2] = curr_ss_Tot						//2 is total sum of squares calculated directly from data (should be independent of fit)		fitParamsTemp[i][3] = curr_r2							//r2 value 1 - (ss_Res / ss_Tot)		fitParamsTemp[i][4] = curr_x2							//chi-squared value ss_Res/ sum(predicted values) NOT FUNCTIONING / TRUSTWORTHY AT LEAST FOR NEGATIVE VALUES. Could maybe use V_chisq from curve fit if wanted to				fitParamsTemp[i][5] = 	0//statsChiCDF(curr_x2, DimSize(coefWave,0))							//p value for chi-squared . ZERO AS PLACEHOLDER FOR NOW		fitParamsTemp[i][6] = 	curr_ss_Res + curr_ss_Reg		//total sum of squares calculated from ss_Res + ss_Reg. sHould squal ss_Tot?				fitParamsTemp[i][7] = DimSize(coefWave,0)			//number of free parameters in model		fitParamsTemp[i][8] = curr_numSamples//DimSize($StringFromList(2, fitsTemp[i]), 0)		//number of samples (e.g. length of wave that is fit, in points		fitParamsTemp[i][9] = curr_ss_Res / (fitParamsTemp[i][8] - fitParamsTemp[i][7])		//F test demoninator: Mean of residuals: sum of squares of residuals / d.f. for that (sample N - num free parameters)				if (i > 0)	//then this is a model with more than one exponential and so we will perform and f test to quantify the extent to which it's statistically justified			//relative to 1st fit						fitParamsTemp[i][10] = (fitParamsTemp[0][0] - fitParamsTemp[i][0]) / (fitParamsTemp[i][7] - fitParamsTemp[0][7])			//f test numerator: (ss_Res_reduced - ss_Res_full) / (df_full - df_reduced). demoniator calculated in 5			fitParamsTemp[i][11] = fitParamsTemp[i][10] / fitParamsTemp[i][9]				//f score			fitParamsTemp[i][12] = 1 - StatsFCDF(fitParamsTemp[i][11], fitParamsTemp[i][7] - fitParamsTemp[0][7], fitParamsTemp[i][8] - fitParamsTemp[i][7]) 		//p value: f score, difference in free params, d.f. for sum of squares of residuals?			//relative to last fit			fitParamsTemp[i][13] = (fitParamsTemp[i-1][0] - fitParamsTemp[i][0]) / (fitParamsTemp[i][7] - fitParamsTemp[i-1][7])			//f test numerator: (ss_Res_reduced - ss_Res_full) / (df_full - df_reduced). demoniator calculated in 5			fitParamsTemp[i][14] = fitParamsTemp[i][13] / fitParamsTemp[i][9]				//f score			fitParamsTemp[i][15] = 1 - StatsFCDF(fitParamsTemp[i][14], fitParamsTemp[i][7] - fitParamsTemp[i-1][7], fitParamsTemp[i][8] - fitParamsTemp[i][7]) 		//p value: f score, difference in free params, d.f. for sum of squares of residuals?					if (fitParamsTemp[i][15] < moreFreeParamsJustifiedThresh)				Duplicate/O $"compParamsTemp_parent", tempCompParams				lastPassingModel = i				raBestFitModel = tempCompParams[1]			endif		endif			//Note fitParamsTemp "FIRST_VARIABLE_PARAM_COL: " + num2str(numFitParams)		//complete fit params		fitParamsTemp[i][16] = i+1			//num components in this model		fitParamsTemp[i][17] = numComponentParams			//num parameters saved. Index to parameter in given fit													fitParamsTemp[i][18] = numFitParams				fitParamsTemp[i][19] = spacer			endfor	//finished iterating through exponential fits		//dispay fits	if (!ParamIsDefault(modelsDispN))		for (i=0;i<maxNumExps;i+=1)			if (!ParamIsDefault(cmpntntsDispN))				plotExpFits2 (fitsTemp[i], modelsDispN, currComponentDisplayN=(cmpntntsDispN+num2str(i)))			else				plotExpFits2 (fitsTemp[i], modelsDispN)			endif		endfor	endif		Duplicate/O coefWaveSave, $coefWaveSaveRef			if (!ParamIsDefault(modelsListWaveSaveRef))		Duplicate/O fitsTemp, $modelsListWaveSaveRef	endif		//store parameters of interest:	Variable numGenParams = 32		Make/O/D/N=(numGenParams) genParamsTemp		//input resistance related parameters:	genParamsTemp[0] = numGenParams							//allows to quickly find end and begin looking at fitParams	genParamsTemp[1] = NaN										//placeholder for time elapsed since break in sweep	genParamsTemp[2] = text_getInfoFromWaveName_V(currentRef, 1)			//file num	genParamsTemp[3] = text_getInfoFromWaveName_V(currentRef, 2)			//sweep num	genParamsTemp[4] = vCmd_baseline								genParamsTemp[5] = vCmd_step 	genParamsTemp[6] = deltaVoltage	genParamsTemp[7] = baseCurrent	genParamsTemp[8] = ssCurrent	genParamsTemp[9] = deltaSSCurrent	genParamsTemp[10] = ssRin	genParamsTemp[11] = lastPassingModel	genParamsTemp[12] = raBestFitModel		//Ra of best fitting full model	genParamsTemp[13] = fd_note_getSRate(currentRef)						//stores sample rate	genParamsTemp[14] = fitParamsTemp[i][0]	genParamsTemp[15] = fitParamsTemp[i][1] 	genParamsTemp[16] = fitParamsTemp[i][2]	genParamsTemp[17] = fitParamsTemp[i][3]	genParamsTemp[18] = fitParamsTemp[i][4]	genParamsTemp[19] = fitParamsTemp[0][11]			//f test model 0	genParamsTemp[20] = fitParamsTemp[0][12]			//p value 0	genParamsTemp[21] = fitParamsTemp[0][7]	 		//num free params model 0	genParamsTemp[22] = fitParamsTemp[0][8]	  		//numpnts model 0 (same across all)	genParamsTemp[23] = fitParamsTemp[1][14]			//f test model 1 (Vs 0)	genParamsTemp[24] = fitParamsTemp[1][15]			//p value model 1	genParamsTemp[25] = fitParamsTemp[2][14]			//f test model 2 (vs 1)	genParamsTemp[26] = fitParamsTemp[2][15]	genParamsTemp[27] = fitParamsTemp[3][14]			//f test model 3	genParamsTemp[28] = fitParamsTemp[3][15]	genParamsTemp[29] = fitParamsTemp[4][14]			//f test model 4	genParamsTemp[30] = fitParamsTemp[4][15]	genParamsTemp[31] = spacer		//convert fit params into 1D single column to append to genParams and store	convert2DTo1D("fitParamsTemp", "fitParamsOut", 1)		//concatenate rows		Concatenate/NP=0/O {genParamsTemp, $"fitParamsOut"}, finalParamsOut		Duplicate/O finalParamsOut, $genAndFitParamsSaveRef	Duplicate/O compParamsSave, $compParamsSaveRef			KillWaves/Z currentTemp //, fitParamsTemp, componentParams, coefWaveSave, coefWave, genParamsTemp, end		//analysis_cellParams_S2function/S analysis_getGenParamsHeader(kill, [flip])	Variable kill	Variable flip	String genParamsHeaderN = "genParamsHeader"	String dispWinName = genParamsHeaderN		if (kill==1)		KillWaves/Z $genParamsHeaderN	endif	//	if (!WaveExists($"genParamsHeader"))		Variable numGenParams = 34		Variable numFitParams=20		Variable numExps = 5		Make/O/T/N=(numGenParams+(numFitParams*numExps)) genParamsHeader		genParamsHeader[0] = "numGenParams"		genParamsHeader[1] = "spacer"		genParamsHeader[2] = "spacer"		genParamsHeader[3] = "spacer"		genParamsHeader[4] = "vCmd_baseline"									genParamsHeader[5] = "vCmd_step"		genParamsHeader[6] = "deltaVoltage"		genParamsHeader[7] = "baseCurrent"		genParamsHeader[8] = "ssCurrent"		genParamsHeader[9] = "deltaSSCurrent"		genParamsHeader[10] = "ssRin"		genParamsHeader[11] = "lastPassingModel"		genParamsHeader[12] = "raBestFitModel"		//Ra of best fitting full model		genParamsHeader[13] = "sRate"					//stores sample rate		genParamsHeader[14] = "vCmd_t0"					//changed from ~6 onward!		genParamsHeader[15] = "vCmd_t1"		genParamsHeader[16] = "fvCmd_baseline"		genParamsHeader[17] = "vCmd_step"		genParamsHeader[18] = "x0"		genParamsHeader[19] = "m0_F"			//f test model 0		genParamsHeader[20] = "m0_P"			//p value 0		genParamsHeader[21] = "m0_#FP"	 		//num free params model 0		genParamsHeader[22] = "m0_n"	  		//numpnts model 0 (same across all)			genParamsHeader[23] = "m1_F_-1"				//f test model 1		genParamsHeader[24] = "m1_P_-1"			//p value model 1		genParamsHeader[25] = "m2_F_-1"				//f test model 2		genParamsHeader[26] = "m2_P_-1"		genParamsHeader[27] = "m3_F_-1"				//f test model 3		genParamsHeader[28] = "m3_P_-1"		genParamsHeader[29] = "m4_F_-1"				//f test model 4		genParamsHeader[30] = "m4_P_-1"		genParamsHeader[31] = "secsSinceBrkIn"		genParamsHeader[32] = "minsSinceBrkIn"		genParamsHeader[33] = "End_G/StartFitParams"		Variable startFitParamsCol = numGenParams		Make/O/T/N=(numFitParams) fitParamsHeaderTemp		fitParamsHeaderTemp[0] = "ss_Res"		fitParamsHeaderTemp[1] = "ss_Reg"		fitParamsHeaderTemp[2] = "ss_Tot"		fitParamsHeaderTemp[3] = "r2"		fitParamsHeaderTemp[4] = "x2"		fitParamsHeaderTemp[5] = "chi()"		fitParamsHeaderTemp[6] = "Res+Reg"		fitParamsHeaderTemp[7] = "#FP"		fitParamsHeaderTemp[8] = "n"		fitParamsHeaderTemp[9] = "F_denom"		fitParamsHeaderTemp[10] = "F_numer"		fitParamsHeaderTemp[11] = "F_0"		fitParamsHeaderTemp[12] = "P_0"		fitParamsHeaderTemp[13] = "F_numer-1"		fitParamsHeaderTemp[14] = "F_-1"		fitParamsHeaderTemp[15] = "P_-1"		fitParamsHeaderTemp[16] = "numExps"		fitParamsHeaderTemp[17] = "numCompParams"		fitParamsHeaderTemp[18] = "numFitParams"		fitParamsHeaderTemp[19] = "END"				Variable i, numModel, currStartIndex, currEndIndex		for (numModel=0;numModel<numExps;numModel+=1)			currStartIndex=startFitParamsCol + (numFitParams*numModel)			for (i=0;i<numFitParams;i+=1)				genParamsHeader[currStartIndex+i] = "m" + num2str(numModel) +"_" + fitParamsHeaderTemp[i]			endfor		endfor				KillWaves/Z fitParamsHeaderTemp				Concatenate/NP /O /T {genParamsHeader,  $analysis_getCapTransIntHeader()}, genPAramsHeaderFinal				Variable fullLen = DimSize(genPAramsHeaderFinal,0)		Redimension/N=(fullLen+ numExps) genPAramsHeaderFinal		genPAramsHeaderFinal[fullLen,] = "m" + num2str(p-fullLen) + "_VfitError"//	endif	if (!ParamIsDefault(flip))		MatrixTranspose genPAramsHeaderFinal	endif//	Edit/K=1/N=$dispWinName $genParamsHeaderN	Duplicate/O/T genPAramsHeaderFinal, genParamsHeader		return genParamsHeaderNendfunction plotFromHeader(itemStr, headerRef, waveRef_2D)	String itemStr, headerRef, waveRef_2D		Variable useRowIndex = 1	if (DimSize($headerRef, 1) > 0)		//expect 		useRowIndex = 0	endif		FindValue/TEXT=(itemStr) $headerRef	Variable colNum = V_Value	Print "colNum",colNum		Display/K=1 $waveRef_2D[][colNum]	endfunction getParamFromHeader_1D(itemStr, headerRef, waveRef_1D)	String itemStr, headerRef, waveRef_1D		Variable rowNum = findInHeader(itemStr, headerRef)	WAVE tempw_getParam = $waveRef_1D	Variable temp = tempw_getParam[rowNum]		return tempendfunction getParamFromHeader_2D(itemStr, headerRef, waveRef, colNum)	String itemStr, headerRef, waveRef	Variable colNum		//column to use along with found row		Variable rowNum = findInHeader(itemStr, headerRef)	WAVE tempw_getParam = $waveRef		Variable temp = tempw_getParam[rowNum][colNum]		return tempendfunction findInHeader(itemStr, headerRef)	String itemStr, headerRef	if (WaveExists($headerRef) == 0)		Print "in findInHeader, header wave does not exist. wave = " + headerRef + "(search was for item =" + itemStr + ")"	endif		WAVE/T headerTemp = $headerRef		Variable index = -1, i	//better than FindValue built in function which doesnt seem to allow wild cards etc. in an intuitive way	for (i=0;i<DimSize(headerTemp,0);i+=1)		if (stringmatch(headerTemp[i],itemStr))			index = i			break		//break finds first match; remove to return last match instead		endif	endfor		if (index < 0)		Print "in findInHeader(), item not found in header. item = " + itemStr 		Print ". header = " + headerRef	endif		return index	endfunction getFirstEmpty_T(textwave, byRow, indexOfSearchedRowOrCol)	WAVE/T textWave	Variable byRow		//1 to search across rows, default (0) is to search down cols	Variable indexOfSearchedRowOrCol //specify column to search down (if byRow = 0), or row to search across (if byRow = 1)		Variable i	if (!byRow)		//search down a column		for (i=0; i< DimSize(textWave, byRow);i+=1)			if (strlen(textWave[i][indexOfSearchedRowOrCol]) < 1)				return i			endif		endfor	else		//search across rows byRow = 1		for (i=0; i< DimSize(textWave, byRow);i+=1)			if (strlen(textWave[indexOfSearchedRowOrCol][i]) < 1)				return i			endif		endfor	endif		return -1		//-1 for not foundendfunction/S getParamFromHeader_1D_T(itemStr, headerRef, waveRef_1D, [setFailReport])	String itemStr, headerRef, waveRef_1D	Variable &setFailReport		//if passed, will be set 1 if lookup fails (no valid row number found)		Variable rowNum = findInHeader(itemStr, headerRef)			if (rowNum < 0 )		Print "Warning, rownum < 0 " + "in getParamFromHeader_1D_T(), item not found in header. item = " + itemStr + ". header = " + headerRef		if (!ParamIsDefault(setFailReport))			setFailReport = 1			return ""		endif	endif		WAVE/T tempw_getParam = $waveRef_1D	String tempStr = tempw_getParam[rowNum]		if (!ParamIsDefault(setFailReport))		setFailReport = 0	endif	return tempStrendfunction fd_note_getSRate(waveRef)	String waveRef		Variable notePos = 2		Variable out		return str2num(StringByKey(Note($waveRef), "RATE"))		//For old format:	//	String noteStr = StringFromList(notePos, note($waveRef))//	//	sscanf noteStr, " RATE: %e", out			//note that there's a space before RATE!//	//	return outendfunction/S makeFitWaves2(data, currentRef, fitCoefsWave, finalCoefWaveSaveRef, fitNum, baselineC, deltaV, x0, fitStartX, fitEndX, componentParamsOutRef,numParams_out, numSamples_out, ss_Res_out, ss_Reg_out, ss_Total_out, r2_out, x2_out, [finalWaveSaveRef,finalFitStorageWaveRef, fitComponentStorageWaveStart, residualsStorageRef])	WAVE data					//reference to original wave that was fit and wave after subtraction (latter if only actually performed)	String currentRef	WAVE fitCoefsWave															//coef wave from which fit waves are to be made	String finalCoefWaveSaveRef												//reference to where final coef wave is to be stored (for later redisplay)	Variable fitNum															//number to be saved for use in future redisplay, to allow one to get proper coefs from that final coef wave ref	Variable fitStartX, fitEndX, baselineC, deltaV, x0												//needed for making fits and for analysis	String componentParamsOutRef											//a reference to which parameters about fits are to be stored	Variable &numParams_out,  &numSamples_out, &ss_Res_out, &ss_Reg_out, &ss_Total_out, &r2_out, &x2_out		//various outputs		//OPTIONAL PARAMETERS	String finalWaveSaveRef		//finalWaveSaveRef=subbedWaveSaveRef, originalCurrentRef=currentRef	String  finalFitStorageWaveRef, fitComponentStorageWaveStart				//stored parameters. Only saved is saveRawData = 1	String	residualsStorageRef													//optional parameters: pass to save		Variable saveResiduals = 0	if (!ParamIsDefault(residualsStorageRef))		saveResiduals = 1	endif			Variable assumedSpecificCap = 0.01 			//pF / um^2 conversion to F / m: 1 F / 10^12 pF * 10^6 um / m * 10^6 um / m = x pF/um^2 = F/ m ^ 2	Variable currExp	Variable numExps = floor((DimSize(fitCoefsWave, 0) - 1) / 2)		String currFitStorageWaveRef	String fitStorageWaveList = finalCoefWaveSaveRef + ";" + num2str(fitNum) + ";" +currentRef + ";"			//pos 0, 1, 2	String fittedDataRef		//pos 3			if (!ParamIsDefault(finalWaveSaveRef))		//subtraction performed		fitStorageWaveList +=	finalWaveSaveRef +";"	else		fitStorageWaveList += ";"	endif	Duplicate/O/R=(fitStartX, fitEndX) data, finalFit, currFitComponent, originalData	finalFit = 0			Variable y0 = fitCoefsWave[0]	Variable currAmp, currTau		//fitCoefsWave should have form of y0, c0_amp, c0_tau, c1_amp, c1_tau,....		Variable Imax = 0		//sum this across components to get total for model	Variable meanTau	//calculate the average tau weighted by the amplitude of the component		for (currExp=0;currExp < numExps; currExp+=1)		currAmp = fitCoefsWave[currExp*2 + 1]		Imax += currAmp		currTau = fitCoefsWave[currExp*2 + 2]		meanTau += currTau * currAmp		currFitComponent = y0 + currAmp * exp(-(x-x0) / currTau)				if (!ParamIsDefault(finalFitStorageWaveRef) && !ParamIsDefault(fitComponentStorageWaveStart))			currFitStorageWaveRef = fitComponentStorageWaveStart + num2str(currExp)			Duplicate/O currFitComponent, $currFitStorageWaveRef		else			currFitStorageWaveRef = ""		endif				fitStorageWaveList += currFitStorageWaveRef + ";"		finalFit += currFitComponent		if (currExp > 0)			finalFit -= y0		//must not keep adding this except once!		endif	endfor		meanTau /= Imax		//fit model / components to Lindau and Neher method to find access resistance (strictly only valid for data well fit by a single compartment model!)	//first do so for overall fit. Access and rm are straightfoward, but cm is not for multi-compartmentals. We will just take the average of time constants weighted by the amplitude of each exponential for an approximation. There's no basis for this			//storage location will be componentParams_out. 1 + i rows where i is number of exponential components. 0th row stores info for overall fit, then rest are components 1, 2 etc.		//columns: 0 = Imax, 1 = Ra, 2 = Rm, 3 = Cm\	Variable numComponentParams = 11		//including spacer	numParams_out = numComponentParams	Make/O/N=(1+numExps, numComponentParams) componentParams_temp				//handle overall fit (row 0)	componentParams_temp[0][0] = Imax			//Imax for total model	componentParams_temp[0][1] = deltaV / Imax		//Ra = deltaV / Imax	componentParams_temp[0][2] = ( deltaV - (componentParams_temp[0][1] * y0) ) / y0					//Rm =  ( deltaV - (Ra * Iss) ) / Iss			Input resistance corrected for losses to access. Iss = y0	componentParams_temp[0][3] = meanTau * ( (1 / componentParams_temp[0][1]) + (1 / componentParams_temp[0][2]) )		//Cm = tau * ( (1/Ra) + (1/Rm) )			THIS IS ONLY AN ESTIMATE WHEN USING MORE THAN ONE COMPARTMENT	componentParams_temp[0][4] = componentParams_temp[0][3] / assumedSpecificCap									//estimate of SA from Cm	componentParams_temp[0][5] = sqrt(componentParams_temp[0][4])/(4*pi)												//radius estimate under assumption of SA above for a perfect sphere		//handle all fit components	Variable currRow	for (currExp=0;currExp < numExps; currExp+=1)		currRow = 1 + currExp		componentParams_temp[currRow][0] = fitCoefsWave[currExp*2 + 1]			//Imax for component = component amplitude		componentParams_temp[currRow][1] = deltaV / componentParams_temp[currRow][0]		//Ra for component = deltaV / component amplitude		componentParams_temp[currRow][2] = ( deltaV - (componentParams_temp[currRow][1] * y0) ) / y0		//Rm for component = (deltaV - (Ra,c * Iss) ) / Iss		componentParams_temp[currRow][3] =  fitCoefsWave[currExp*2 + 2] * ( (1 / componentParams_temp[currRow][1]) + (1 / componentParams_temp[currRow][2]) )		//Cm for component = tau,c * ( (1/Ra,c) + (1/Rm,c) )		componentParams_temp[currRow][4] = componentParams_temp[currRow][3] / assumedSpecificCap									//estimate of SA from Cm		componentParams_temp[currRow][5] = sqrt(componentParams_temp[currRow][4]/(4*pi))												//radius estimate under assumption of SA above for a perfect sphere		endfor		Variable cmSum = getDimSegmentStats(1, 3, "componentParams_temp", "V_sum", startP=1, endP=numExps+1) 	Variable saSum =  getDimSegmentStats(1, 4, "componentParams_temp", "V_sum", startP=1, endP=numExps+1) 	Variable radiusSum = getDimSegmentStats(1, 5, "componentParams_temp", "V_sum", startP=1, endP=numExps+1) 		componentParams_temp[][6] = componentParams_temp[p][0] /  componentParams_temp[0][0]			//proportion of Imax contributed by this component	componentParams_temp[][7] = componentParams_temp[p][3] / cmSum			//cm normalized to total cm	componentParams_temp[][8] = componentParams_temp[p][4] / saSum			//sa normalized to total sa	componentParams_temp[][9] = componentParams_temp[p][5] / radiusSum			//radius normalized to total radius (for completeness)		convert2DTo1D("componentParams_temp", "componentParams_out", 1)		//concatenate ROWS 		WAVE componentParams_out			//made by convert2DTo1D	//append num components and spacer	Redimension/N=(DimSize(componentParams_out,0) + 2) componentParams_out	componentParams_out[DimSize(componentParams_out,0) - 2] = numExps	componentParams_out[DimSize(componentParams_out,0) - 1] = NaN		//save this for output	Duplicate/O componentParams_out, $componentParamsOutRef		//	String  finalFitStorageWaveRef, fitComponentStorageWaveStart, residualsStorageRef	if (!ParamIsDefault(finalFitStorageWaveRef)) 			Duplicate/O finalFit, $finalFitStorageWaveRef		//pos 4		fitStorageWaveList = addlistitem(finalFitStorageWaveRef, fitStorageWaveList, ";", 4)	else		fitStorageWaveList = addlistitem("", fitStorageWaveList, ";", 4)	endif			//calculate residuals and sum of squares of that for final fit and regression sum of squares	Duplicate/O finalFit, residuals, finalFitTemp	residuals = originalData - finalFit		if (saveResiduals)		Duplicate/O residuals, $residualsStorageRef		Note $residualsStorageRef, "DATA: " + fittedDataRef + "; FIT: " + StringFromList(4, fitStorageWaveList)		fitStorageWaveList = addListItem(residualsStorageRef, fitStorageWaveList, ";", 5)		//pos 5. 6 on is fit components	else		fitStorageWaveList = addListItem("", fitStorageWaveList, ";", 5)		//pos 5. 6 on is fit components	endif		numSamples_out = DimSize(finalFit, 0)		residuals *= residuals	ss_Res_out =  sum(residuals)		Variable sampleMean = mean(originalData, fitStartX, fitEndX)	finalFit -= sampleMean		//regression residuals	finalFit *= finalFit				//squared regression residuals	ss_Reg_out = sum(finalFit)	//sum of squares of regression residuals		//total sum of squares in original data	Duplicate/O originalData, dataTemp		originalData -= sampleMean		//total difference from mean	originalData *= originalData		//squared total difference from mean	ss_Total_out = sum(originalData, fitStartX, fitEndX)		//sum of squares for total difference from mean		r2_out = 1 - (ss_Res_out / ss_total_out)		//calculate chi-sq value: sum( (data[i] - predicted[i])^2 / predicted[i] ) --numerator is just ss_Res_out, but we'll start the with the squared residuals from above	residuals /= finalFitTemp			//divide squared residuals by each prediction	x2_out = sum(residuals)			KillWaves/Z dataTemp, residuals, finalFit, finalFitTemp, originalData, currFitComponent 		return fitStorageWaveListend		//makeFitWaves2function/S makeFitWaves(fitCoefsWave, fitNum, baselineC, deltaV, x0, componentParams_out, numSamples_out, ss_Res_out, ss_Reg_out, ss_Total_out, r2_out, x2_out, finalCoefWaveSaveRef, finalFitStorageWaveRef, fitComponentStorageWaveStart, residualsStorageRef, saveFinalFit, saveFitComponents, saveResiduals)	WAVE fitCoefsWave	Variable fitNum	Variable baselineC, deltaV, x0	WAVE componentParams_out	Variable &numSamples_out, &ss_Res_out, &ss_Reg_out, &ss_Total_out, &r2_out, &x2_out		String finalCoefWaveSaveRef	String finalFitStorageWaveRef, fitComponentStorageWaveStart, residualsStorageRef		Variable saveFinalFit, saveFitComponents, saveResiduals				Variable assumedSpecificCap = 0.01 			//pF / um^2 conversion to F / m: 1 F / 10^12 pF * 10^6 um / m * 10^6 um / m = x pF/um^2 = F/ m ^ 2		Variable  fitStartX, fitEndX		//stores fit window starts and ends	String dataRef							//reference to original wave that was fit			//get fit start and end as well as data ref from coef wave notes	sscanf StringFromList(0,note(fitCoefsWave)), "FITWIN_X: %f, %f;", fitStartX, fitEndX	if (V_flag != 2)		Print "could not find window start and end for fit in makeFitWaves(...)" 		return ""	endif		sscanf StringFromList(1,note(fitCoefsWave)), "DATAWAVE: %s", dataRef	if (V_flag != 1)		Print "could not find data ref in makeFitWaves(...)" 		return ""	endif				Duplicate/O/R=(fitStartX, fitEndX) $dataRef, finalFit, currFitComponent, originalData	finalFit = 0	Variable currExp	Variable numExps = floor((DimSize(fitCoefsWave, 0) - 1) / 2)		String currFitStorageWaveRef	String fitStorageWaveList = finalCoefWaveSaveRef + ";" + num2str(fitNum) + ";" + dataRef + ";"			Variable y0 = fitCoefsWave[0]	Variable currAmp, currTau		//fitCoefsWave should have form of y0, c0_amp, c0_tau, c1_amp, c1_tau,....		Variable Imax = 0		//sum this across components to get total for model	Variable meanTau	//calculate the average tau weighted by the amplitude of the component		for (currExp=0;currExp < numExps; currExp+=1)		currFitStorageWaveRef = fitComponentStorageWaveStart + num2str(currExp)		currAmp = fitCoefsWave[currExp*2 + 1]		Imax += currAmp		currTau = fitCoefsWave[currExp*2 + 2]		meanTau += currTau * currAmp		currFitComponent = y0 + currAmp * exp(-(x-x0) / currTau)				Duplicate/O currFitComponent, $currFitStorageWaveRef				fitStorageWaveList += currFitStorageWaveRef + ";"		finalFit += currFitComponent		if (currExp > 0)			finalFit -= y0		//must not keep adding this except once!		endif	endfor		meanTau /= Imax		//fit model / components to Lindau and Neher method to find access resistance (strictly only valid for data well fit by a single compartment model!)	//first do so for overall fit. Access and rm are straightfoward, but cm is not for multi-compartmentals. We will just take the average of time constants weighted by the amplitude of each exponential for an approximation. There's no basis for this			//storage location will be componentParams_out. 1 + i rows where i is number of exponential components. 0th row stores info for overall fit, then rest are components 1, 2 etc.		//columns: 0 = Imax, 1 = Ra, 2 = Rm, 3 = Cm	Redimension/N=(1+numExps, 10) componentParams_out				//handle overall fit (row 0)	componentParams_out[0][0] = Imax			//Imax for total model	componentParams_out[0][1] = deltaV / Imax		//Ra = deltaV / Imax	componentParams_out[0][2] = ( deltaV - (componentParams_out[0][1] * y0) ) / y0					//Rm =  ( deltaV - (Ra * Iss) ) / Iss			Input resistance corrected for losses to access. Iss = y0	componentParams_out[0][3] = meanTau * ( (1 / componentParams_out[0][1]) + (1 / componentParams_out[0][2]) )		//Cm = tau * ( (1/Ra) + (1/Rm) )			THIS IS ONLY AN ESTIMATE WHEN USING MORE THAN ONE COMPARTMENT	componentParams_out[0][4] = componentParams_out[0][3] / assumedSpecificCap									//estimate of SA from Cm	componentParams_out[0][5] = sqrt(componentParams_out[0][4])/(4*pi)												//radius estimate under assumption of SA above for a perfect sphere		//handle all fit components	Variable currRow	for (currExp=0;currExp < numExps; currExp+=1)		currRow = 1 + currExp		componentParams_out[currRow][0] = fitCoefsWave[currExp*2 + 1]			//Imax for component = component amplitude		componentParams_out[currRow][1] = deltaV / componentParams_out[currRow][0]		//Ra for component = deltaV / component amplitude		componentParams_out[currRow][2] = ( deltaV - (componentParams_out[currRow][1] * y0) ) / y0		//Rm for component = (deltaV - (Ra,c * Iss) ) / Iss		componentParams_out[currRow][3] =  fitCoefsWave[currExp*2 + 2] * ( (1 / componentParams_out[currRow][1]) + (1 / componentParams_out[currRow][2]) )		//Cm for component = tau,c * ( (1/Ra,c) + (1/Rm,c) )		componentParams_out[currRow][4] = componentParams_out[currRow][3] / assumedSpecificCap									//estimate of SA from Cm		componentParams_out[currRow][5] = sqrt(componentParams_out[currRow][4]/(4*pi))												//radius estimate under assumption of SA above for a perfect sphere		endfor		Variable cmSum = getDimSegmentStats(1, 3, "componentParams", "V_sum", startP=1, endP=numExps+1) 	Variable saSum =  getDimSegmentStats(1, 4, "componentParams", "V_sum", startP=1, endP=numExps+1) 	Variable radiusSum = getDimSegmentStats(1, 5, "componentParams", "V_sum", startP=1, endP=numExps+1) 		componentParams_out[][6] = componentParams_out[p][0] /  componentParams_out[0][0]			//proportion of Imax contributed by this component	componentParams_out[][7] = componentParams_out[p][3] / cmSum			//cm normalized to total cm	componentParams_out[][8] = componentParams_out[p][4] / saSum			//sa normalized to total sa	componentParams_out[][9] = componentParams_out[p][5] / radiusSum			//radius normalized to total radius (for completeness)		Duplicate/O finalFit, $finalFitStorageWaveRef	fitStorageWaveList = addlistitem(finalFitStorageWaveRef, fitStorageWaveList, ";", 3)		//calculate residuals and sum of squares of that for final fit and regression sum of squares	Duplicate/O finalFit, residuals, finalFitTemp	residuals = originalData - finalFit	Duplicate/O residuals, $residualsStorageRef	fitStorageWaveList = addListItem(residualsStorageRef, fitStorageWaveList, ";", 4)		numSamples_out = DimSize(finalFit, 0)		residuals *= residuals	ss_Res_out =  sum(residuals)		Variable sampleMean = mean(originalData, fitStartX, fitEndX)	finalFit -= sampleMean		//regression residuals	finalFit *= finalFit				//squared regression residuals	ss_Reg_out = sum(finalFit)	//sum of squares of regression residuals		//total sum of squares in original data	Duplicate/O originalData, dataTemp		originalData -= sampleMean		//total difference from mean	originalData *= originalData		//squared total difference from mean	ss_Total_out = sum(originalData, fitStartX, fitEndX)		//sum of squares for total difference from mean		r2_out = 1 - (ss_Res_out / ss_total_out)		//calculate chi-sq value: sum( (data[i] - predicted[i])^2 / predicted[i] ) --numerator is just ss_Res_out, but we'll start the with the squared residuals from above	residuals /= finalFitTemp			//divide squared residuals by each prediction	x2_out = sum(residuals)		Note $residualsStorageRef, "DATA: " + dataRef + "; FIT: " + finalFitStorageWaveRef			KillWaves/Z dataTemp, residuals, finalFit, finalFitTemp, originalData, currFitComponent 		if (!saveFinalFit)		KillWaves/Z $finalFitStorageWaveRef	endif		if (!saveResiduals)		KillWaves/Z $residualsStorageRef	endif		if (!saveFitComponents)		for (currExp=0;currExp < numExps; currExp+=1)				currFitStorageWaveRef = fitComponentStorageWaveStart + num2str(currExp)					KillWaves/Z $currFitStorageWaveRef			endfor	endif			return fitStorageWaveListend		//makeFitWavesfunction walkFits(rowNum,doPed, refreshTime)	Variable rowNum, doPed, refreshTime		String plotWinN = "brkInFitsWalkThru"		WAVE/T hsList		Variable somaDispListCol = 28	Variable pedDispListCol = somaDispListCol + 11		Variable hsListCol		if (!doPed)		hsListCol = somaDispListCol	else		hsListCol = pedDispListCol	endif		if (winType(plotWinN) > 0)		bringtotop(plotWinN)	else		Display/N=$plotWinN/K=1		plotWinN = S_name	endif		String dispList = hsList[rowNum][hsListCol]	Variable numDisps = ItemsInList(dispList)		Variable i_disp, i_model, numModels	String currDispSubList, currDispRef	for (i_disp = 0; i_disp < numDisps;i_disp+=1)		currDispSubList = StringFromList(i_disp, dispList)		currDispRef = StringFromList(2, currDispSubList, ",")		numModels = DimSize($currDispRef, 0)		for (i_model=0;i_model < numModels; i_model += 1)			vis_clear()						plotExpFits3(	i_model, currDispRef, plotWinN)			doupdate			func_pause(refreshTime)		endfor	endforendfunction/S plotExpFits3(modelNum, redisplayRef, plotWinN, [genParamsRef, coefWaveRef])	Variable modelNum	String redisplayRef		String plotWinN	String genParamsRef, coefWaveRef					Variable fitStartPadding = -0.0002	Variable fitEndPadding = 0		Duplicate/O/T $redisplayRef, redisplayTemp	String redisplayList = redisplayTemp[modelNum]	KillWaves/Z redisplayTemp	Variable indexOfFirstFitComponent = 9	Variable numFitComponents = ItemsInList(redisplayList) - indexOfFirstFitComponent			Print "redisplayList = " + redisplayList					String fittRef = StringFromList(3, redisplayList)			//will check on whether there was subtraction later	String cmdRef = StringfromList(4, redisplayList)	String sealRef = StringfromList(5, redisplayList)	String subbedWaveRef = StringfromList(6, redisplayList)	String modelRef = StringfromList(7, redisplayList)	String originalWaveBeforeSub		//only placeholder for now		Variable fitStartX, fitEndX			//get from start and end of fit waves themselves	fitStartX = DimOffset($modelRef, 0)	fitEndX =  fitStartX + DimSize($modelRef, 0) * DimDelta($modelRef, 0)		Variable currR, currG, currB		//stores color values		//first handle overlay of full models	if (strlen(plotWinN) == 0)		plotWinN = fittRef + "m" + num2str(modelNum) +"WIN"	endif		Display/K=1/N=$plotWinN	plotWinN = S_name		//determine if subtraction was performed, reorganize accordingly	Variable subtraction = 0	if (strlen(subbedWaveRef) > 0)		subtraction = 1		originalWaveBeforeSub = fittRef		fittRef = subbedWaveRef	endif		//do this first because it looks better behind all the others	if (subtraction)		vis_getColorForGraph2("lime", currR, currG, currB)		AppendToGraph/W=$plotWinN/C=(currR, currG, currB) $originalWaveBeforeSub/TN=$(originalWaveBeforeSub+"_US")	endif		vis_getColorForGraph2("black", currR, currG, currB)		//black	AppendToGraph/W=$plotWinN/C=(currR, currG, currB) $fittRef ; ModifyGraph lsize($fittRef) = 2//	AppendToGraph/W=$plotWinN/C=(currR, currG, currB) $fittRef/TN=$(fittRef + "_fit"); ModifyGraph lsize($(fittRef + "_fit")) = 2	vis_getColorForGraph2("lblue", currR, currG, currB)		//Light blue	AppendToGraph/W=$plotWinN/C=(currR, currG, currB) $modelRef; ModifyGraph lsize($modelRef) = 1.5	AppendToGraph/W=$plotWinN/L=L_cmd $cmdRef; modifygraph axisEnab(L_cmd) = {0,.10}, lblpos= 52, freepos = 0, axisEnab(left) = {.12,1}	Setaxis/A=2 L_cmd	SetAxis bottom, fitStartX + fitStartPadding, fitEndX + fitEndPadding		Variable currListPos, currFitComponent; String currRef	Print "numFitComponents",numFitComponents	for (currFitComponent=0;currFitComponent<numFitComponents;currFitComponent+=1)		//iterate through all fit components except the last one. Start at 1 because zeroeth is coef wave		currListPos = indexOfFirstFitComponent + currFitComponent		currRef = StringFromList(currListPos, redisplayList)		vis_getColorForGraph2("orange", currR, currG, currB)				AppendToGraph/W=$plotWinN/C=(currR, currG, currB) $currRef	endfor	SetAxis bottom, fitStartX + fitStartPadding, fitEndX + fitEndPadding	SetAxis/A=2 left		if ( !ParamIsDefault(coefWaveRef) && !ParamIsDefault(genParamsRef) && (strlen(genParamsRef) > 0) && (strlen(coefWaveRef) > 0))		//Duplicate/O $genParamsRefForStats, gtemp		//Duplicate/O $compParamsRefForStats, ctemp		String genHeaderN = "genParamsHeader"		String compHeaderN = "compParamsHeader"		if (WaveExists($genHeaderN) == 0)			Print "instantiate " +genHeaderN + " for stats display in plotExpFit3"		elseif (WaveExists($coefWaveRef) == 0)			Print "instantiate " +coefWaveRef + " for stats display in plotExpFit3"		endif		String findStr = "m" + num2str(modelNum)		String numFP = " FP= " + num2str(getParamFromHeader_1D(findStr+"_#FP", genHeaderN, genParamsRef))		String ssRes = "; + ssRes = " + num2str(getParamFromHeader_1D(findStr+"_ss_Res", genHeaderN, genParamsRef))		String r2 = "r^2 = " +num2str(getParamFromHeader_1D(findStr+"_r2", genHeaderN, genParamsRef)) 		String fnumer = "; Fnumer(-1) = " + num2str(getParamFromHeader_1D(findStr+"_F_numer-1", genHeaderN, genParamsRef))		String fdenom  = "; Fdenom = " + num2str(getParamFromHeader_1D(findStr+"_F_denom", genHeaderN, genParamsRef))		String fstat  = "Fstat(-1) = " + num2str(getParamFromHeader_1D(findStr+"_F_-1", genHeaderN, genParamsRef))		String pVal   = "; Pval_fstat(-1) = " + num2str(getParamFromHeader_1D(findStr+"_P_-1", genHeaderN, genParamsRef))		String numps  = "; N = " + num2str(getParamFromHeader_1D(findStr+"_n", genHeaderN, genParamsRef))		String statsStr1 = fittRef + numFP + ssRes		String statsStr2 =  r2+fnumer + fdenom		String statsStr3 = fstat+pVal + numps;		variable space = 9		variable absX = 130, absY = 70, componentsShift = 0		SetDrawEnv xcoord= abs,ycoord= abs,fsize= 8;DelayUpdate		Drawtext absX , absY+(0*space),statsStr1		SetDrawEnv xcoord= abs,ycoord= abs,fsize= 8;DelayUpdate		Drawtext absX,absY +(1*space), statsStr2		SetDrawEnv xcoord= abs,ycoord= abs,fsize= 8;DelayUpdate		Drawtext absX,absY +(2*space), statsStr3		Print statsStr1 + "; " + statsStr2 + "; " + statsStr3				String componentInfo = getCoefsAsText(modelNum, "coefWaveHeader", coefWaveRef)		componentInfo = ReplaceString("m" + num2str(modelNum) + "_", componentInfo, "")	///get rid of m# to save space		if (modelNum > 1)			String cInfo1 = Stringfromlist(0, componentInfo) + ";" + Stringfromlist(1, componentInfo) + ";" + Stringfromlist(2, componentInfo) + ";" + Stringfromlist(3, componentInfo) + ";" + Stringfromlist(4, componentInfo)			String cInfo2 =""			Variable i			for (i=5;i<ItemsInList(componentInfo);i+=1)				cInfo2 += StringFromList(i, componentInfo)			endfor			SetDrawEnv xcoord= abs,ycoord= abs,fsize= 6;DelayUpdate			DrawText absX +componentsShift, absY +( 3*space),cInfo1			SetDrawEnv xcoord= abs,ycoord= abs,fsize= 6;DelayUpdate			DrawText absX +componentsShift, absY +( 4*space),cInfo2		else			SetDrawEnv xcoord= abs,ycoord= abs,fsize= 6;DelayUpdate			DrawText absX +componentsShift, absY +( 3*space),componentInfo		endif	endif			return plotWinN + ";" + fittRef + ";" + redisplayListend		//plotExpFits3function plotWaveList(listStr, topGraph, winN, delimStr, useColors)	String listStr, winN,delimStr	Variable useColors, topGraph		if (strlen(delimStr) == 0)		delimStr = ";"	endif		if (strlen(winN) == 0)		winN= StrinGfromList(0,listStr) + "etcList"	endif		if (topGraph)		winN = ""		Variable axMin, axMax, flag		GetAxis/Q bottom		axMin = V_min		axMax = V_max		flag = V_flag	else		if (winType(winN) ==0)			Display/K=1/N=$winN		endif	endif	Variable i	if (useColors < 1)		for (i=0;i<ItemsInList(listStr, delimStr);i+=1)			AppendtoGraph/W=$winN $StringFromList(i, listStr,delimStr)		endfor	else		Variable currR, currG, currB		for (i=0;i<ItemsInList(listStr, delimStr);i+=1)			vis_getColor(i +useColors-1,currR, currG, currB)			AppendtoGraph/W=$winN/C=(currR, currG, currB) $StringFromList(i, listStr,delimStr)		endfor	endif		if (topGraph && !flag)		SetAxis/Z bottom axMin, axMax		SetAxis/Z/A=2 left	endifendfunction plotExpFits2(fitsList, fullFitsDisplayN, [currComponentDisplayN])	String fitsList				//(0) coefWaveRef, (1) fitNum in coefwaveRef (row num) (2) origWaveRef, (3) finalFitRef, (4) residualsRef, (5) fitComponent1Ref, (6) fitComponent2Ref,... (7...) which are generated here	String fullFitsDisplayN 	//name of window in which full fit models will be displayed, overlaid. calling function must assure that this window name is good	String currComponentDisplayN	//name of window in which this full fit and its components will be displayed, overlaid. Any window matching this name + "*" will be killed		Variable fitStartPadding = -0.0002	Variable fitEndPadding = 0		Variable numNonFitComponentsInList = 6	Variable numFitComponents = ItemsInList(fitsList) - numNonFitComponentsInList		//because 0 to 4 of this list hold coefWaveRef, origWaveRef, finalFitRef, residualsRef,  and then the rest are components			Variable plotOriginalData = 0, plotUnsubtracted = 0, plotComponents = 0		//only will change these and make plots if waves can be found			String dataRef = StringFromList(3 , fitsList)	if (WaveExists($dataRef))		plotOriginalData = 1	endif		String unsubtractedRef = StringFromList(2, fitsList)	if ((strlen(unsubtractedRef) > 0) && WaveExists($unsubtractedRef))		Print "Plotted unsubtracted!"		plotUnsubtracted = 1	endif				String finalFitRef = StringFromList(4, fitsList)	if (!WaveExists($finalFitRef))		return 0			//only works with something to plot	endif			Variable fitStartX, fitEndX			//get from start and end of fit waves themselves	fitStartX = DimOffset($finalFitRef, 0)	fitEndX =  fitStartX + DimSize($finalFitRef, 0) * DimDelta($finalFitRef, 0)	//check to see if any one of the fit components is available, then later we will check each individually, but we won't even bother with that if we cant find the first one	String currRef = StringFromList(numNonFitComponentsInList, fitsList)	if (!ParamIsDefault(currComponentDisplayN) && WaveExists($currRef))		plotComponents = 1	endif		Variable currR, currG, currB		//stores color values		//first handle overlay of full models	if (WinType(fullFitsDisplayN) != 1)		makeMyFuckingWindow(fullFitsDisplayN)		if (plotOriginalData)			AppendToGraph/W=$fullFitsDisplayN/C=(0,0,0) $dataRef/TN=$(dataRef + "_orig")		endif		if (plotUnsubtracted)			vis_getColor(15, currR, currG, currB)			AppendToGraph/W=$fullFitsDisplayN/C=(currR, currG, currB) $unsubtractedRef		endif				SetAxis bottom, fitStartX + fitStartPadding, fitEndX + fitEndPadding				//if window already existed, we don't need to append original as it should already have been done	endif		Variable currFitComponent 		//iterator		//append finalFit to graph	Variable fitNum = str2num(StringFromList(1, fitsList))	vis_getColor(fitNum, currR, currG, currB)		//sits currR, currG, currB to some color combo. This will give a different color to each final fit that's added	AppendToGraph/W=$fullFitsDisplayN/C=(currR,currG,currB) $finalFitRef	SetAxis/A=2 left		//make graph to display components, if plotComponents	if (plotComponents)		makeMyFuckingWindow(currComponentDisplayN)				//Append data that was fit, if available		if (plotOriginalData)			AppendToGraph/W=$currComponentDisplayN/C=(0,0,0) $dataRef/TN=$(dataRef + "_orig")			ModifyGraph lsize($(dataRef + "_orig")) = 2		endif				//Append final fit that was found		vis_getColor(1, currR, currG, currB)		//sets currR, currG, currB to some color combo		AppendToGraph/W=$currComponentDisplayN/C=(currR,currG,currB) $finalFitRef		//final fit func is last in this list		ModifyGraph lsize($finalFitRef) = 2				Variable currListPos		for (currFitComponent=0;currFitComponent<numFitComponents;currFitComponent+=1)		//iterate through all fit components except the last one. Start at 1 because zeroeth is coef wave			currListPos = numNonFitComponentsInList + currFitComponent			currRef = StringFromList(currListPos, fitsList)			if (WaveExists($currRef))				vis_getColor(currFitComponent+1, currR, currG, currB)		//color #1 is used for final fit before for loop				AppendToGraph/W=$currComponentDisplayN/C=(currR, currG, currB) $currRef			endif		endfor				SetAxis bottom, fitStartX + fitStartPadding, fitEndX + fitEndPadding		SetAxis/A=2 left				if (strlen(unsubtractedRef) > 0)			vis_getColor(15, currR, currG, currB)			AppendToGraph/W=$currComponentDisplayN/C=(currR, currG, currB) $unsubtractedRef/TN=$(dataRef + "_us")				endif	endif	end		//plotExpFits2function table_addTableRC(numRowsOrCols, colsNotRows, numWavesToAdj)	Variable numRowsOrCols, colsNotRows, numWavesToAdj		if (numWavesToAdj < 1)		numWavesToAdj = 1	endif		Variable i=0; String info, waveN, alteredWavesList = ""		info=tableinfo("",-2)	Variable numCols = str2num(stringbykey("COLUMNS",info)) - 1		//remove one to discount the point column		for (i=0;i<numCols;i+=1)		info = tableinfo("",i)		if (strlen(info) < 1)			break		//info is empty string when the column index holds no wave		endif		waveN = StringByKey("COLUMNNAME", info)		waveN=Replacestring(".", waveN, " ")		//replace period with space for sscanf		sscanf waveN, "%s", waveN		//get wave name		if (WhichListItem(waveN, alteredWavesList) > -1)			//wave name in alteredWavesList, so does not need to be altered			continue		endif		alteredWavesList += waveN	+ ";"		//store this wave so we know it's been altered		if (colsNotRows)		//add cols			if (Dimsize($waveN,1) == 0)			//adding one will annoyingly keep as 1 column for a 1D wave, since col nums = 0				numRowsOrCols = 2			endif			Redimension/N=(-1, DimSize($waveN,1) + numRowsOrCols) $waveN		else			Redimension/N=(DimSize($waveN,0) + numRowsOrCols, -1) $waveN		endif	endforendfunction plotExpFits(fitsList, unsubtractedRef, fullFitsDisplayN, [currComponentDisplayN])	String fitsList				//(0) coefWaveRef, (1) fitNum in coefwaveRef (row num) (2) origWaveRef, (3) finalFitRef, (4) residualsRef, (5) fitComponent1Ref, (6) fitComponent2Ref,... (7...) which are generated here	String unsubtractedRef	//reference to wave that was fit before a subtraction was performed (e.g. if subtracted pipette cap)	String fullFitsDisplayN 	//name of window in which full fit models will be displayed, overlaid. calling function must assure that this window name is good	String currComponentDisplayN	//name of window in which this full fit and its components will be displayed, overlaid. Any window matching this name + "*" will be killed		Variable fitStartPadding = -0.0002	Variable fitEndPadding = 0		Variable numNonFitComponentsInList = 5	Variable numFitComponents = ItemsInList(fitsList) - numNonFitComponentsInList		//because 0 to 4 of this list hold coefWaveRef, origWaveRef, finalFitRef, residualsRef,  and then the rest are components			Variable plotOriginalData = 0, plotFinalFit = 0, plotComponents = 0		//only will change these and make plots if waves can be found			String dataRef = StringFromList(2 , fitsList)	if (WaveExists($dataRef))		plotOriginalData = 1	endif		String finalFitRef = StringFromList(3, fitsList)	if (!WaveExists($finalFitRef))		return 0			//only works with something to plot	endif			Variable fitStartX, fitEndX			//get from start and end of fit waves themselves	fitStartX = DimOffset($finalFitRef, 0)	fitEndX =  fitStartX + DimSize($finalFitRef, 0) * DimDelta($finalFitRef, 0)	//check to see if any one of the fit components is available, then later we will check each individually, but we won't even bother with that if we cant find the first one	String currRef = StringFromList(numNonFitComponentsInList, fitsList)	if (!ParamIsDefault(currComponentDisplayN) && WaveExists($currRef))		plotComponents = 1	endif		Variable currR, currG, currB		//stores color values		//first handle overlay of main residuals	if (WinType(fullFitsDisplayN) != 1)		makeMyFuckingWindow(fullFitsDisplayN)		if (plotOriginalData)			AppendToGraph/W=$fullFitsDisplayN/C=(0,0,0) $dataRef/TN=$(dataRef + "_orig")		endif		if (strlen(unsubtractedRef) > 0)			vis_getColor(15, currR, currG, currB)			AppendToGraph/W=$fullFitsDisplayN/C=(currR, currG, currB) $unsubtractedRef		endif				SetAxis bottom, fitStartX + fitStartPadding, fitEndX + fitEndPadding				//if window already existed, we don't need to append original as it should already have been done	endif		Variable currFitComponent 		//iterator		//append finalFit to graph	Variable fitNum = str2num(StringFromList(1, fitsList))	vis_getColor(fitNum, currR, currG, currB)		//sits currR, currG, currB to some color combo. This will give a different color to each final fit that's added	AppendToGraph/W=$fullFitsDisplayN/C=(currR,currG,currB) $finalFitRef	SetAxis/A=2 left		//make graph to display components, if plotComponents	if (plotComponents)		makeMyFuckingWindow(currComponentDisplayN)				//Append data that was fit, if available		if (plotOriginalData)			AppendToGraph/W=$currComponentDisplayN/C=(0,0,0) $dataRef/TN=$(dataRef + "_orig")			ModifyGraph lsize($(dataRef + "_orig")) = 2		endif				//Append final fit that was found		vis_getColor(1, currR, currG, currB)		//sets currR, currG, currB to some color combo		AppendToGraph/W=$currComponentDisplayN/C=(currR,currG,currB) $finalFitRef		//final fit func is last in this list		ModifyGraph lsize($finalFitRef) = 2				Variable currListPos		for (currFitComponent=0;currFitComponent<numFitComponents;currFitComponent+=1)		//iterate through all fit components except the last one. Start at 1 because zeroeth is coef wave			currListPos = numNonFitComponentsInList + currFitComponent			currRef = StringFromList(currListPos, fitsList)			if (WaveExists($currRef))				vis_getColor(currFitComponent+1, currR, currG, currB)		//color #1 is used for final fit before for loop				AppendToGraph/W=$currComponentDisplayN/C=(currR, currG, currB) $currRef			endif		endfor				SetAxis bottom, fitStartX + fitStartPadding, fitEndX + fitEndPadding		SetAxis/A=2 left				if (strlen(unsubtractedRef) > 0)			vis_getColor(15, currR, currG, currB)			AppendToGraph/W=$currComponentDisplayN/C=(currR, currG, currB) $unsubtractedRef/TN=$(dataRef + "_us")				endif					endif	end		//plotExpFits	function run(saveRawDAta)	Variable saveRawData		Variable vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step		analysis_cellParams_S_vCmd("G15041100_0000_45_AD3",vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step)//	Print vCmd_t0//	Print vCmd_t1//	Print vCmd_baseline//	Print vCmd_step		String currentRef = "G15041100_0000_45_AD0"		if (saveRawData)		analysis_cellParams_S(currentRef, vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step, genParamsSaveRef = currentRef + "_G", fitParamsSaveRef  = currentRef + "_F",  coefWaveSaveRef  = currentRef + "_C", fitWaveSaveRef = currentRef + "f", fitComponentsAppendStr = "c", fitWavesListWaveRef = currentRef + "L", allFullFitsDisplayN = "test1", allComponentsDisplayN = "test2")	else		analysis_cellParams_S(currentRef, vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step, genParamsSaveRef = currentRef + "_G", fitParamsSaveRef  = currentRef + "_F",  coefWaveSaveRef  = currentRef + "_C")	endifendfunction run2(saveRawDAta)	Variable saveRawData		Variable vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step		analysis_cellParams_S_vCmd("G15041100_0000_45_AD3",vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step)//	Print vCmd_t0//	Print vCmd_t1//	Print vCmd_baseline//	Print vCmd_step		String currentRef = "G15041100_0000_45_AD0"		if (saveRawData)		analysis_cellParams_S2(currentRef, vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step,  currentRef + "_G", currentRef + "_F",   currentRef + "_C", modelSaveRef =currentRef + "f", cmpntntsAppendStr = "c", modelsListWaveSaveRef= currentRef + "L", modelsDispN="testA", cmpntntsDispN="testB")	else		analysis_cellParams_S2(currentRef, vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step,  currentRef + "_G",currentRef + "_F",   currentRef + "_C")		endifendfunction makeMyFuckingWindow(winNameStr)	String winNameStr	doupdate/W=$winNameStr	KillWindow $winNameStr		Display/K=1/N=$winNameStr	Variable winByNameCreated = stringmatch(winNameStr, S_name)	if (!winByNameCreated)		//then probably some other window already existed or the name fucked up.		RenameWindow S_name, winNameStr	endif	winByNameCreated = stringmatch(winNameStr, S_name)	if (!winByNameCreated)		Print "makeMyFuckingWindow failed!"	endif	doupdateend			//find peak of each capacity transient, then fit starting from this peak. stop looking at end of windowStartX (totally abitrary)	//Also make wave to store cell params	WaveStats/Q/R=(stepStartX, stepWindowStartX) currentTemp	Variable firstPeakLoc, secondPeakLoc, firstCapCurrent, secondCapCurrent	if (deltaVoltage < 0)	//then step is negative, so peak is a minimum		firstPeakLoc = V_minloc		//Might have to NVAR in V_minloc and V_maxloc, but not today...		firstCapCurrent = V_min - baselineCurrent			//at step, all current flowing through access resistance, giving capactive transient. Subtract baseline to get delta for this capacitive current	else		firstPeakLoc = V_maxloc		firstCapCurrent = V_max - baselineCurrent	endif			//{0resistance, 1deltaCurrent, 2deltaVoltage, 3baselineCurrent, 4baselineVoltage, 5stepCurrent, 6stepVoltage}	//calculate some of the cell parameters from the value of the peak of the capacity transient	Variable firstAccRes = deltaVoltage/firstCapCurrent			//ohms law on capactive transient 	Ra = Vdelta,cmd / Icap	Variable firstMemRes = ((deltaVoltage - (firstAccRes * deltaCurrent))/deltaCurrent			//Rm = (Vdelta,cmd - Ra*Isteadystate) / Isteadystate, from Single Channel Recordings		//find the time constant of the capacity transient to finish the analysis. Could augment for multiple time constants 	//For first step, fit capacity peak to a decaying exponential starting at the peak	Make/O/D/N=3 coefWave		//will put in as parameter for curvefit so that fit coefs are stored here	Make/O/D/N=1 W_fitconstants	//named place where curvefit stores x0 constant	CurveFit/W=2/N=1/Q=1 exp_XOffset, kwCWave=coefWave, currentTemp(firstPeakLoc,stepWindowStartX)  //add /D to save the fit wave, /N/Q avoids certain updates being printed	Variable y0 = coefWave[0]	Variable coef = coefWave[1]	Variable tau = coefWave[2]		//gets tau from the fit parameters stored in coefWave. Could also check pipette resistance from this by the equation tau = Rpipette * Cm, but we can also calculate Cm without knowing the pipette resistance (see a few lines below)	Variable x0 = W_fitConstants[0]	//calculate Cm from tau, Ra, Rm	Variable Cm = tau * ((1/firstAccRes) + (1/firstMemRes))	//calculates Cm from access and membrane resistance calculated above (from single channel recordings)		//make single exp fit wave	Duplicate/O/R=(firstPeakLoc,stepWindowStartX) currentTemp, firstPeakFit	firstPeakFit = y0 + coef*exp(-(x-x0)/tau)		//repeat analysis for double exp	Make/O/D/N=5 coefWave	CurveFit/W=2/N=1/Q=1 dblexp_XOffset, kwCWave = coefWave, currentTemp(firstPeakLoc, stepWindowStartX)	Variable y0_dbl = coefWave[0]	Variable coef_dbl_firstExp = coefWave[1]	Variable tau_dbl_firstExp = coefWave[2]	Variable coef_dbl_secondExp = coefwave[3]	Variable tau_dbl_secondExp = coefWave[4]	Variable x0_dbl = W_fitConstants[0]		//calculate Cms for each component and there sum	Variable Cm_dbl_firstExp = tau_dbl_firstExp *  ((1/firstAccRes) + (1/firstMemRes))	Variable Cm_dbl_secondExp = tau_dbl_secondExp *  ((1/firstAccRes) + (1/firstMemRes))	Variable Cm_dbl_total = Cm_dbl_firstExp + Cm_dbl_secondExp	//make dblExp fit Wave	Duplicate/O/R=(firstPeakLoc,stepWindowStartX) currentTemp, dblFit	dblFit = y0_dbl + coef_dbl_firstExp*exp(-(x-x0_dbl)/tau_dbl_firstExp) + coef_dbl_secondExp*exp(-(x-x0_dbl)/tau_dbl_secondExp) 	//update note to have time of trace	String recTimeString = fd_note_getWaveTimeStr(currentRef)	+";"	Display/K=1/N=cellParamsSimple	AppendToGraph/C=(0,0,0) currentTemp	AppendToGraph/C=(0,0,50000) firstPeakFit; ModifyGraph lstyle(firstPeakFit) = 1, lsize(firstPeakFit) = 3	AppendToGraph/C=(0,50000,0) dblFit; ModifyGraph lstyle(dblFit) = 1, lsize(dblFit) = 3		if (performSealSubtraction)		Duplicate/O $currentRef, preSubWave		AppendToGraph preSubWave	endif			Variable prePeakTime = 0.0003	//in seconds, additional time before peak that will be displayed	Variable postPeakTime = 0.002	SetAxis bottom, firstPeakLoc - prePeakTime, firstPeakLoc + postPeakTime	SetAxis/A=2 left//end//fit a plateau that rises to one and then falls back to zero in the same time constant//free parameters are rising and falling x position and the taufunction fit_simpleSigmoids(w,x) : FitFunc	//returns exptest = 1/(1+exp(-(x-x0)/tau))-1/(1+exp(-(x-x1)/tau))	WAVE w	//contains tau	Variable x		return 1/(1+exp(-(x-w[1])/w[0]))-1/(1+exp(-(x-w[2])/w[0]))endfunction fit_getSimpleSigmoids(inRef,tauGuess,x0Guess, x1Guess,outCoefsRef,outFitRef,appendToGraphStr)	String inRef,outFitRef	//ref to fit and fit to save fit to	String outCoefsRef	//ref to save coefs to	String appendToGraphStr		//graph name to plot to or "" for none... input winname(0,1) for top graph	Double tauGuess,x0Guess, x1Guess		//standard values (e.g. from mike's 2009 paper are 12.2*10^-12, 12.9, 1.3 (Mike has fast and slow switched in his figure 2 legend)		Make/O/D/N=3 $outCoefsRef/wave=outCoefsWv	outCoefsWv[0] = tauGuess;setdimlabel 0,0,tauGuess,outCoefsWv	outCoefsWv[1] = x0Guess;setdimlabel 0,0,x0Guess,outCoefsWv	outCoefsWv[2] = x1Guess;setdimlabel 0,0,x1Guess,outCoefsWv		FuncFit/N=1/Q/W=2 fit_simpleSigmoids,outCoefsWv,$inRef	if (strlen(outFitRef))		Duplicate/O $inRef, $outFitRef/wave=outFitWv		outFitWv = fit_simpleSigmoids(outCoefsWv,x)						if (strlen(appendToGraphStr))			appendToGraph/W=$appendToGraphStr outFitWv		endif	endifendfunction fit_dblExpConv(w,x) : FitFunc		//returns a * [exp^-(t-t0)/tau1 - exp^-(t-t0)/tau2)]	Wave w		Variable x			NVAR x0		return	w[0] * ( exp(-(x-x0)/w[1]) - exp(-(x-x0)/w[2]) )endfunction fit_getDblExpConv(inRef,baseSubStartX,baseSubEndX,startX,endX,ampGuess,tau0Guess,tau1Guess,outCoefsRef,outFitRef,appendToGraphStr)	String inRef,outFitRef	//ref to fit and fit to save fit to	String outCoefsRef	//ref to save coefs to	Variable startX,endX		//fit start and end	String appendToGraphStr		//graph name to plot to or "" for none... input winname(0,1) for top graph	Variable baseSubStartX,baseSubEndX	//pass real numbers if there's a baseline to subtract away	Double ampGuess,tau0Guess,tau1Guess		//standard values (e.g. from mike's 2009 paper are 12.2*10^-12, 12.9, 1.3 (Mike has fast and slow switched in his figure 2 legend)		Variable lenP = dimsize($inRef,0)		Variable doBaseSub = numtype(baseSubStartX) == 0		if (numtype(startX))		startX = pnt2x($inRef,0)	endif	if (numtype(endX))		endX = pnt2x($inRef,lenP-1)	endif		Double baselineSubtracted	Duplicate/O $inRef, fit_getDblExpConv_temp	if (doBaseSub)		baselineSubtracted = mean(fit_getDblExpConv_temp,baseSubStartX,baseSubEndX)		fit_getDblExpConv_temp -= baselineSubtracted	else		baselineSubtracted = 0	endif		wavestats/Q fit_getDblExpConv_temp		Variable/G x0 = startX	Variable numCoefs = 3	Make/O/D/N=(numCoefs) $outCoefsRef/wave=outCoefsWv	outCoefsWv[0] = ampGuess	outCoefsWv[1] = tau0Guess	outCoefsWv[2] = tau1Guess	FuncFit/N=1/Q/W=2 fit_dblExpConv,outCoefsWv,fit_getDblExpConv_temp(startX,endX)	if (strlen(outFitRef))		Duplicate/O/R=(startX,endX) $inRef, $outFitRef/wave=outFitWv		outFitWv = fit_dblExpConv(outCoefsWv,x)						if (strlen(appendToGraphStr))			appendToGraph/W=$appendToGraphStr outFitWv			modifygraph offset($outFitRef) = {0,baselineSubtracted}		endif	endif		killwaves/z fit_getDblExpConv_temp		return baselineSubtractedend//built to fit an arbitrary number of exponentials that share a common offset. Inspired in part by the example function FitManyGaussians in the Curve fitting in detail help//call by first generating a coefficient wave (double precision) with 1 + 2N points, where N = number of exponential to fit//then call FuncFit/NTHR =0 myExp [Coef wave name] [wave to fit name]threadsafe Function myExp(w,x) : FitFunc	Wave/D w	Double x			//number of fits is i where numExps = 1 + i*2, there is one w0 parameter and then 2 more fit parameters for each additional exponential fit	Variable coefs=DimSize(w,0)	Variable i,numExps = floor( (coefs - 1) / 2) 			//must have previously saved these values globally	NVAR x0	//xoffset -- not sure this is threadsafe???	//CurveFitDialog/ These comments were created by the Curve Fitting dialog. Altering them will	//CurveFitDialog/ make the function less convenient to work with in the Curve Fitting dialog.	//CurveFitDialog/ Equation:	//CurveFitDialog/ f(x) = y0 + A1*exp(-(x)/Tau)	//CurveFitDialog/ End of Equation	//CurveFitDialog/ Independent Variables 1	//CurveFitDialog/ x	//CurveFitDialog/ Coefficients 3	//CurveFitDialog/ w[0] = y0	//CurveFitDialog/ w[1] = A1	//CurveFitDialog/ w[2] = Tau			//will fit a function of the form y0 + A1*exp(x/tau1) + A2*exp(x/tau2) + ... x is actually -(x-x0) to allow for a non-zero start to the fit	//find and then return the output value based on the current values of the fit coefficients. 	Variable returnVal = w[0]		//start by setting equal to coef 0 (y0)	Variable currCoefIndex	for (i=0;i<numExps;i+=1)		//then add the value of each exponential term		currCoefIndex = 2*i + 1		returnVal += w[currCoefIndex]*exp(-(x-x0)/w[currCoefIndex+1])	endfor	return returnValEnd	//myExp()//(f(V)  Gmax/(1  exp//((V1/2V)/k))) where V is the membrane potential,//Gmax is the maximal conductance, V1/2//is the potential at which half the channels are//activated, and k is the voltage-change that produces//an e-fold change in channel activity.function fit_boltzmann(w,x) : fitfunc	WAVE/D w //K0: Gmax K1: V1/2 K2: k	Double x		return w[0] / (1 + exp( (w[1]-x)/w[2] ) )endfunction/S fitExpsAndPlot(coefWave, finalFitRef, saveComponents, plotType, [toFitRef, x1, x2, plotWinName, ssResVar, x0Var, tol])	WAVE coefWave	String finalFitRef	Variable saveComponents	//0 == no saving (OVERRIDDEN by plotType > 1), 1 = saving	Variable plotType 		//0 = do not plot, 1 = plot only final fit, 2 = plot final fit and components	String toFitRef			//optionally pass reference to wave to be fit, otherwise fits top trace on top graph	String plotWinName		//optional, pass window name to create a new window with name 	Variable x1, x2			//optional, specifies window for fit	Variable &ssResVar, &x0Var 		//optional, specifies refs to variables in which ssRes and x0Var can be saved	Variable tol				//optionally set fit tolerance. largest is 0.1 and smallest is 0.00001, default is 0.001		String waveRef	if (ParamIsDefault(toFitRef))		waveRef = StringFromList(0, TraceNameList("", ";", 1))	else		waveRef = toFitRef	endif		String winN = ""	if (!ParamIsDefault(plotWinName))		Display/K=1/N=plotWinName		winN = S_name		//Igor likes to slightly change names of windows, ostensibly when windows by that name are already present, seems to happen more often though	endif		Variable startX, endX	if (!ParamIsDefault(x1))		startX = x1	else		startX = DimOffset($waveRef, 0)		//default is start time of wave	endif	if (!ParamIsDefault(x2))		endX = x2	else		endX = DimOffset($waveRef, 0) + ( DimSize($waveRef, 0 ) * DimDelta($waveRef,0) )		//default is end time of wave	endif		Variable/G x0 =DimOffset($waveRef, 0)		//global variable that is used by funcfit/myExp. current default is to start from wave 0	if (!ParamIsDefault(x1))		x0 = x1	endif	if (!ParamIsDefault(x0Var))		x0Var = x0	endif		Duplicate/O/R=[x2pnt($waveRef, startX), x2pnt($waveRef,endX)] $waveRef, expFit_resTemp	String outRefs = ""			//outRefs: stored fit, followed by semi-colon delimited list of stored components, if components are stored	if (!ParamIsDefault(tol))		Variable/G V_FitTol = tol	endif		FuncFit/NTHR=0/W=2/N=1/Q=1 myExp, coefWave, $waveRef[x2pnt($waveRef, startX), x2pnt($waveRef,endX)]			Variable numExps = floor( (DimSize(coefWave,0) - 1) / 2) 		Duplicate/O $waveRef, currFitComponent, finalFitTemp	currFitComponent = 0; finalFitTemp = 0	Variable currExp, currAmp, currTau, y0 = coefWave[0]	for (currExp=0;currExp < numExps; currExp+=1)		currAmp = coefWave[currExp*2 + 1]		currTau = coefWave[currExp*2 + 2]		currFitComponent = y0 + currAmp * exp(-(x-x0) / currTau)						finalFitTemp += currFitComponent		if (currExp > 0)			finalFitTemp -= y0		//must not keep adding this except once!		endif						if (saveComponents || (plotType > 1)	)	//save components for display			Duplicate/O currFitComponent, $ (finalFitRef + "c" + num2str(currExp) )			if (currExp==0)				outRefs =  finalFitRef + ";"					endif			outRefs += (finalFitRef + "c" + num2str(currExp) ) + ";"		elseif (currExp==0)			outRefs = finalFitRef		//does not return as a list if components arent saved		endif	endfor	//calculate ssRes	expFit_resTemp -= finalFitTemp		//compute difference between real and predicted	expFit_resTemp*= expFit_resTemp		//square difference	Variable ssRes = sum(expFit_resTemp)				//sum squared difference	if (!ParamIsDefault(ssResVar))		ssResVar = ssRes	endif		Duplicate/O finalFitTemp, $finalFitRef	if (plotType > 0)		bringtotop(winN)		String tracelist = TraceNameList("", ";", 1)		if (WhichListItem(finalFitRef, tracelist) < 0)			AppendtoGraph/C=(0,0,0) $finalFitRef		endif		ModifyGraph lstyle($finalFitRef)=8, lsize($finalFitRef) = 2		if (WhichListItem(waveRef, traceList) < 0)			AppendToGraph $waveRef		endif	endif	if (plotType > 1)		Variable r,g,b; String currRef		for (currExp = 0; currExp < numExps; currExp +=1)			bringtotop(winN)			currRef = StringFromList(currExp+1,outRefs)				vis_getColor(currExp+1, r, g, b)			if (WhichListItem(currRef, tracelist) < 0)				AppendtoGraph/C=(r,g,b) $currRef					ModifyGraph lstyle($currRef)=3			endif		endfor	endif	Print "Waves generated by fitExpsAndPlot: " + outRefs	Print "ssRes = " + num2str(ssRes)		return outRefsend	//fitExpsAndPlot()//goes through pairs with readings from soma and terminal without simultaneous clamp, adds up cap at either site to derive parameters (denoted by col 12 blank, 0 in col 19)//assumes ped ref comes before soma ref for allfunction/S SI_updateBothParams()	WAVE/T cpSummaryIndex		Variable i; String currParamsRef, genParamsRef_S, genParamsRef_P	for (i=0;i<DimSize(cpSummaryIndex,0);i+=1)		if (stringmatch(cpsummaryIndex[i][19], "0"))		//signifies cell where both sites had cap transient recorded non-simultaneously			currParamsRef  = cpSummaryIndex[i][1] + "ccB"		//"both" parameters			cpSummaryIndex[i][13] = currParamsRef			//"both" parameters			if (stringmatch(cpsummaryIndex[i][2], "P"))				genParamsRef_P = cpsummaryIndex[i][3]				genParamsRef_S = cpsummaryIndex[i+1][3]			else	//then soma				genParamsRef_S = cpsummaryIndex[i][3]				genParamsRef_P = cpsummaryIndex[i-1][3]				endif			SI_calcBothParams(currParamsRef, genParamsRef_S, genParamsRef_P)					endif	endfor	return SI_getBothParamsHeader()end//SI_updateBothParams()function SI_calcBothParams(paramsOutRef, somaParamsRef, pedParamsRef)	String paramsOutRef, somaParamsRef, pedParamsRef		Variable C_int_S = getParamFromHeader_1D("C_int", "genParamsHeader", somaParamsRef)			//not with addition for steady state inaccuracy	Variable C_int_P = getParamFromHeader_1D("C_int", "genParamsHeader", pedParamsRef)		Variable C_int_total_S	 = getParamFromHeader_1D("C_int_total", "genParamsHeader", somaParamsRef)				//with addition for steady state inaccuracy	Variable C_int_total_P = getParamFromHeader_1D("C_int_total", "genParamsHeader", pedParamsRef)		Variable C_int_sum = C_int_S + C_int_P	Variable C_int_total_sum = C_int_total_S + C_int_total_P	Variable C_int_prop_S = C_int_S / C_int_sum	Variable C_int_prop_P = C_int_P / C_int_sum	Variable C_int_total_prop_S = C_int_total_S / C_int_total_sum	Variable C_int_total_prop_P = C_int_total_P / C_int_total_sum		Variable numBothParams = 14	Make/O/D/N=(numBothParams) $paramsOutRef	WAVE/D tempBothParams = $paramsOutRef	tempBothParams[0] = C_int_S	tempBothParams[1] = C_int_P	tempBothParams[2] = C_int_total_S	tempBothParams[3] = C_int_total_P	tempBothParams[4] = C_int_sum	tempBothParams[5] = C_int_total_sum	tempBothParams[6] = C_int_prop_S	tempBothParams[7] = C_int_prop_P	tempBothParams[8] = C_int_total_prop_S	tempBothParams[9] = C_int_total_prop_P		tempBothParams[10] = C_int_S - C_int_P	tempBothParams[11] = C_int_total_S - C_int_total_P	tempBothParams[12] = C_int_P - C_int_S	tempBothParams[13] = C_int_total_P - C_int_total_Send	//SI_calcBothParams()function/S SI_getBothParamsHeader()	String bothParamsHeaderN = "bothParamsHeader"	Variable numBothParams = 14	Make/O/T/N=(numBothParams) $bothParamsHeaderN	WAVE/T tempBothParamsHeader = $bothParamsHeaderN	tempBothParamsHeader[0] = "C_int_S"	tempBothParamsHeader[1] = "C_int_P"	tempBothParamsHeader[2] = "C_int_total_S"	tempBothParamsHeader[3] = "C_int_total_P"	tempBothParamsHeader[4] = "C_int_sum"	tempBothParamsHeader[5] = "C_int_total_sum"	tempBothParamsHeader[6] = "C_int_prop_S"	tempBothParamsHeader[7] = "C_int_prop_P"	tempBothParamsHeader[8] = "C_int_total_prop_S"	tempBothParamsHeader[9] = "C_int_total_prop_P"	tempBothParamsHeader[10] = "C_int_S - C_int_P"	tempBothParamsHeader[11] = "C_int_total_S - C_int_total_P"	tempBothParamsHeader[12] = "C_int_P - C_int_S"	tempBothParamsHeader[13] = "C_int_total_P - C_int_total_S"		return bothParamsHeaderNend//SI_getBothParamsHeader()function convert2DTo1D(ref_2D_in, ref_1D_out, catByRows, [outAsOneColNotOneRow])	String ref_2D_in, ref_1D_out; Variable catByRows, outAsOneColNotOneRow		Duplicate/O $ref_2D_in, temp2D		Variable numRows = DimSize(temp2D,0)	Variable numCols = DimSize(temp2D,1)		Variable total = numRows * numCols		Make/O/D/N=(numRows*numCols) out1DTemp	Note out1DTemp, note(temp2D)		if (!catByRows)	//cat by columns		out1DTemp = temp2D[mod(p,numRows)][floor(p/numRows)]	else				//cat by rows		out1DTemp = temp2D[floor(p/numCols)][mod(p,numCols)]	endif			if (!ParamIsDefault(outAsOneColNotOneRow) && outAsOneColNotOneRow)		MatrixTranspose out1DTemp	endif		Duplicate/O out1DTemp, $ref_1D_out	KillWaves/Z temp2Dendfunction/S capValsToRad(inRef, outRef)	String inRef, outRef		Duplicate/O $inRef, tempCap		tempCap = getEquivSphereRFromCap(tempCap[p])		Duplicate/O tempCap, $outRef		KillWaves/Z tempCap		return outRefendfunction getEquivSphereRFromCap(cap)	Variable cap		Variable sa = getSAFromCap(cap)		Variable rad = sqrt(sa/(4*pi))		return radendfunction getSAFromCap(cap)	Variable cap		Variable assumedSpecificCap = 0.01 			//pF / um^2 conversion to F / m: 1 F / 10^12 pF * 10^6 um / m * 10^6 um / m = x pF/um^2 = F/ m ^ 2		return cap/assumedSpecificCapendfunction getCapFromTau(amp, tau, deltaV)			//as by method of Geiger and Jonas. cap = tau/R = tau * (1/R) = tau * (I/V)	Variable amp, tau, deltaV		return amp*tau/deltaV	end//for 5 model coefWave, uses Geiger and Jonas methodfunction/S getCapValues(coefWaveRef, coefWaveHeaderRef, deltaV, outRef)	String coefWaveRef, coefWaveHeaderRef, outRef; Variable deltaV		Make/O/D/N=(1 + 2 + 3 + 4 + 5) outTemp_cap	String findStr_tau, findStr_amp, findStr_p1	Variable i,j, index=0, currAmp, currTau	for (i=0;i<5;i+=1)		findStr_p1 = "m" + num2str(i) + "_"		for (j=0;j<i+1;j+=1)			findStr_amp = findStr_p1 + "c" + num2str(j) + "_A"			findStr_tau = findStr_p1 + "c" + num2str(j) + "_tau"		//	Print findStr_amp			currAmp = getParamFromHeader_1D(findStr_amp, coefWaveHeaderRef, coefWaveRef)		//	Print currAmp			currTau = getParamFromHeader_1D(findStr_tau, coefWaveHeaderRef, coefWaveRef)		//	Print currTau			outTemp_cap[index] = getCapFromTau(currAmp, currTau, deltaV)			index+=1		endfor	endfor		Duplicate/O outTemp_cap, $outRef	KillWaves/Z outTemp_cap	return outRefend//for 5 model coefWave, uses Geiger and Jonas methodfunction/S getCapValsHeader()		Make/O/T/N=(1 + 2 + 3 + 4 + 5) capValsHeader	String findStr_p1	Variable i,j, index=0	for (i=0;i<5;i+=1)		findStr_p1 = "m" + num2str(i) + "_"		for (j=0;j<i+1;j+=1)			capValsHeader[index] = findStr_p1 + "c" + num2str(j) + ""			index+=1		endfor	endfor		return "capValsHeader"endfunction getDeltaV(rowNum)	Variable rowNum		WAVE/T cpSummaryIndex	String dataWaveRef = cpSummaryIndex[rowNum][1]	String genParamsRef = cpSummaryIndex[rowNum][3]	String coefWaveRef = cpSummaryIndex[rowNum][5]	String capStorageRef = cpSummaryIndex[rowNum][7]	String radStorageRef = cpSummaryIndex[rowNum][8]	Print "dataWaveRef",dataWaveRef	Print "genParamsRef",genParamsRef	Variable deltaV = getParamFromHeader_1D("deltaVoltage", "genParamsHeader", genParamsReF)	Print "deltaV",deltaV		//getCapValues(coefWaveRef, "coefWaveHeader", deltaV, capStorageRef)	//capValsToRad(capStorageRef, radStorageRef)	return deltaVendfunction SI_quickCellParams(rowNum)	Variable rowNum		WAVE/T cpSummaryIndex	Variable hsListRowNum = str2num(cpSummaryIndex[rowNum][14])			//DO NOT USE col 13. OUTDATED	quickCellParams(cpSummaryIndex[rowNum][1], hsListRowNum, stringmatch(cpSummaryIndex[rowNum][2],"P"), cpSummaryIndex[rowNum][3], cpSummaryIndex[rowNum][4], cpSummaryIndex[rowNum][5] )	updateSummaryList(rowNum)endfunction SI_quickCellParams_all()	WAVE/T cpSummaryIndex		Variable i	for (i=0;i<DimSize(cpSummaryIndex,0);i+=1)		if (SI_getDispStatusFromStr(i, "all", -1))			Print "Starting CP calc on SI Row = " + num2str(i)		//	SI_quickCellParams(i)			if (SI_getDispStatusFromStr(i, "vresp", -1))				SI_vresp_analysis(i)			endif		endif	endfor	analysis_getGenParamsHeader(0)	SI_getVrespHeader()endfunction SI_plotRow(rowNum, modelNum)	Variable rowNum, modelNum		WAVE/T cpSummaryIndex	String plotStr = plotExpFits3(modelNum, cpSummaryIndex[rowNum][6], "",genParamsRef = cpSummaryIndex[rowNum][3], coefWaveRef=cpSummaryIndex[rowNum][5])		String winN = StringFromList(0,plotStr)	String responseRef = StringFromList(1, plotStr)	//	Print responseRef		Variable vClampFromSoma = stringmatch(cpSummaryIndex[rowNum][2],"*S*")	Print "vClampFromSoma",vClampFromSoma	Variable r,g,b	if (vClampFromSoma)		vis_getColorForGraph2("black", r, g, b)	else		vis_getColorForGraph2("red", r, g, b)	endif	ModifyGraph/W=$winN rgb($responseRef) = (r,g,b)				if (SI_getCCStepStatus(rowNum) > -1)		String ccRespRef = cpSummaryIndex[rowNum][16]		String ccFitResp = cpSummaryIndex[rowNum][17] 		if (vClampFromSoma)			vis_getColorForGraph2("red", r, g, b)		else			vis_getColorForGraph2("black", r, g, b)		endif		appendtograph/C=(r,g,b)/L=L_cc $ccRespRef		vis_getColorForGraph2("blue", r, g, b)		appendtograph/C=(r,g,b)/L=L_cc $ccFitResp		modifygraph  axisEnab(L_cmd)={0,.1}, axisEnab(L_cc) = {.12,.35}, axisEnab(left)={.37,1}, lblpos=52, freepos=0	endif	doupdate;disp_setAxisToA2("L*")endfunction SI_getCCStepStatus(row)	Variable row		WAVE/T cpSummaryIndex	String status = cpSummaryIndex[row][21]	//blank for none, 0 for new row, 1 for original row		if (strlen(status) == 0)		return -1	endif	return str2num(status)endfunction SI_clearRow(rowNum)	Variable rowNum		WAVe/T cpSummaryIndex	cpSummaryIndex[rowNum][] = ""endfunction SI_plotSelections3(plottedWaveName, winN, y_paramTypeStrOrExcelWv, y_keyStr, x_paramTypeStrOrExcelWv, x_keyStr, groupByLen, plotRuleStr, plotSomaOrTerminal, [slowestTauBestModel])	String plottedWaveName	//name of wave name that will be created and plot from	String winN				//name of window on which to plot, pass "" for name generated automatically by plottedWaveName (if blank, name will just be auto generated by igor)	String y_paramTypeStrOrExcelWv	//SI param wave to look up values from or name of excel wave to look up values from. The former is matched to each SI index, the latter is matched to the hsList number in each SI index 									//determines wave passed to be excel wave by "*excel*"	String y_keyStr					//ignored for excel waves passed. For paramTypeStr, determines which param in paramWave is plotted	String x_paramTypeStrOrExcelWv, x_keyStr		//same as y waves//	Variable plotSitesTogether		//soma and terminal use same color on graph//	Variable plotFovAndPeriphTogether	//foveal and peripheral cells use same color	Variable plotSomaOrTerminal		//-1 for both, 0 for soma, 1 for terminal	Variable groupByLen	String plotRuleStr			//pass rule to use (see SI_getDispStatusFromStr())		Variable slowestTauBestModel			//pass to get slowest tau from best model: 0 or default is for y axis, 1 is for x axis		//set colors for traces	Variable r,g,b	Make/O/N=(2,3) somaTerminalColors	vis_getColorForGraph2("black", r, g, b)	somaTerminalColors[0][0] = r; somaTerminalColors[0][1] = g; somaTerminalColors[0][2] = b; 	vis_getColorForGraph2("red", r, g, b)	somaTerminalColors[1][0] = r; somaTerminalColors[1][1] = g; somaTerminalColors[1][2] = b; 		if (strlen(winN) == 0)		winN = plottedWaveName	endif		Variable y_useExcelWv = stringmatch(y_paramTypeStrOrExcelWv, "*excel*")	if (y_useExcelWv)		WAVE y_excelWv = $y_paramTypeStrOrExcelWv	endif		//for comparison to length	String recLensWvRef = "excel_recLens"	WAVE recLensWv = $recLensWvRef		if ( (strlen(x_paramTypeStrOrExcelWv) == 0) && ParamIsDefault(slowestTauBestModel))		//default is to use excelRecLens wave for x		x_paramTypeStrOrExcelWv = recLensWvRef	endif		Variable x_useExcelWv = stringmatch(x_paramTypeStrOrExcelWv, "*excel*")		if (x_useExcelWv)		WAVE x_excelWv = $x_paramTypeStrOrExcelWv	endif	//need to select fitting rows in cpIndex, combine them into a wave, track their cpIndex, length (F vs P), and soma or terminal	//then make a second wave with the corresponding x value for each wave. can just get this by cpIndex		//first determine how many indices are up to snuff	WAVE/T cpSummaryIndex	Variable i, ptsCount = 0	for (i=0;i<DimSize(cpSummaryIndex,0);i+=1)		ptsCount += SI_getDispStatusFromStr(i, plotRuleStr, plotSomaOrTerminal)	endfor		//make wave and populate	Make/O/D/N=(ptsCount,6) $plottedWaveName	WAVE plottedWave = $plottedWaveName		String colorsWvSaveName = plottedWaveName + "_color"	Make/O/N=(ptsCount,3) $colorsWvSaveName	WAVE colorsWave = $colorsWvSaveName			String yLabel = y_paramTypeStrOrExcelWv + "_" +y_keyStr		//cleaned up below	String xLabel = x_paramTypeStrOrExcelWv + "_" +x_keyStr		//cleaned up below	Variable ptsIter = 0, currHsListRow, isAtPed	for (i=0;i<DimSize(cpSummaryIndex,0);i+=1)		if (SI_getDispStatusFromStr(i, plotRuleStr, plotSomaOrTerminal))			currHsListRow = str2num(cpSummaryIndex[i][14])			isAtPed = stringmatch(cpSummaryIndex[i][2],"P")				//0 for somatic 1 for terminal			//fill in y value			if (y_useExcelWv)				plottedWave[ptsIter][0] = y_excelWv[currHsListRow]			else				if (ParamIsDefault(slowestTauBestModel) || (slowestTauBestModel != 1))		//if not passed or if NOT equal to one, do not plot slowest tau from best model for y					plottedWave[ptsIter][0] = SI_getParamByKey2(i, y_paramTypeStrOrExcelWv, y_keyStr)			//must be updated to include icl parameters!				else					plottedWave[ptsIter][0] = SI_getBestFitSlowTau(i,0)					yLabel = "Slowest Tau Best Fit Model"				endif			endif			//fill in x value			if (x_useExcelWv)				plottedWave[ptsIter][1] = x_excelWv[currHsListRow]			else				if (ParamIsDefault(slowestTauBestModel) || (slowestTauBestModel == 1))		//if not passed or if EQUAL to one, do not plot slowest tau from best model for x					plottedWave[ptsIter][1] = SI_getParamByKey2(i, x_paramTypeStrOrExcelWv, x_keyStr)			//must be updated to include icl parameters!				else					plottedWave[ptsIter][1] = SI_getBestFitSlowTau(i,0)					xLabel = "Slowest Tau Best Fit Model"				endif								endif									//store other information			plottedWave[ptsIter][2] = i			plottedWave[ptsIter][3] = isAtPed			plottedWave[ptsIter][4] = recLensWv[currHsListRow]										//length of cell			plottedWave[ptsIter][5] = recLensWv[currHsListRow] > 100 									//cell is peripheral (0) or foveal (1)						//populate colors 			colorsWave[ptsIter][] = somaTerminalColors[isAtPed][q]						ptsIter +=1		endif	endfor				String yTraceName = plottedWaveName	Display/K=1/N=$winN plottedWave[][0]/TN=$yTraceName vs plottedWave[][1] 	winN = S_name	ModifyGraph/W=$winN zColor($yTraceName)={$colorsWvSaveName,*,*,directRGB,0}	GetAxis/Q/W=$winN left; SetAxis left, 0, V_max	GetAxis/Q/W=$winN bottom; SetAxis bottom, 0, V_max	Label/W=$winN  left, text_makeStrPresentable(yLabel)	Label/W=$winN  bottom, text_makeStrPresentable(xLabel)		if (groupByLen > -1)		String groupedTN = plottedWaveName + "_grouped"		AppendToGraph/W=$winN/B=bottom2 plottedwave[][0]/TN=$groupedTN vs plottedWave[][5]		ModifyGraph/W=$winN axisEnab(bottom) = {0,.75}, axisEnab(bottom2)={0.8,1}		ModifyGraph tick(bottom2)=3,noLabel(bottom2)=2		ModifyGraph axisEnab(bottom2)={0.9,1},freePos(bottom2)=0; doupdate		ModifyGraph/W=$winN zColor($groupedTN)={$colorsWvSaveName,*,*,directRGB,0}		//gives these points same color scheme as main graph		doupdate		SetDrawEnv/W=$winN xcoord= bottom2, ycoord= left;DelayUpdate; DrawText/W=$winN 0,0,"P"		SetDrawEnv/W=$winN xcoord= bottom2, ycoord= left;DelayUpdate; DrawText/W=$winN 1,0,"F"	endif		doupdate;	ModifyGraph/W=$winN mode=3,marker=19	doupdate;	SetWindow $winN, hook(cp_cursorClickHook) = cp_cursorClickHook	SetWindow $winN, hook(winHook_killWaves) = winHook_killWaves //	SetWindow $winN, hook(winHook_killWaves) = winHook_killWaves 	endfunction VI_getDispStatus(row, ruleNum, bothSomaPed, allFovealPeriph)	Variable row, ruleNum	Variable bothSomaPed 		//0 for recs at both soma or ped, 1 for soma only, 2 for ped only	Variable allFovealPeriph		//0 for all cells regardless length, 1 for fovea only (defn at moment > 100 microns), 2 for periph only	WAVE/T VI_index, hsList	WAVE excel_recLens		Variable hsListRow = str2num(VI_index[row][1])	Variable isFromPed = str2num(VI_index[row][2])	Variable recClass = str2num(VI_index[row][25])	Variable len = excel_recLens[hsListRow]	Variable isPeripheral = (len < 100) 		//check site req	if ( (bothSomaPed == 1) && isFromPed)		return 0	endif	if ( (bothSomaPed == 2) && !isFromPed)		return 0	endif		//check len requirement	if ( (allFovealPeriph == 1) && isPeripheral)		return 0	endif	if ( (allFovealPeriph == 2) && !isPeripheral)		return 0	endif			//check other rules	switch (ruleNum)		case 0:		//only recClasses of 1			return (recClass == 1)			break	endswitch		return 0	end	//function VI_plotSelections(winN, y_bothSomaTermDiffSDiffPExcel, y_keyStr, x_bothSomaTermDiffSDiffPExcel, x_keyStr, plotRuleNum)//	String winN				//name of window on which to plot, pass "" for name generated automatically by plottedWaveName (if blank, name will just be auto generated by igor)//	Variable  y_bothSomaTermDiffSDiffPExcel	//0 for regular VI param BOTH, 1 for soma, 2 for term, 3 for difference param from soma, 4 for difference param from ped. If 5, pass excel wave name as y_keyStr//	String y_keyStr					//see above//	//	Variable  x_bothSomaTermDiffSDiffPExcel	//as for y//	String x_keyStr					//see above	//	//	Variable plotRuleNum			//pass rule to use (see VI_getDispStatus())//	//	WAVE/T VI_index//	//	String y_axLbl = text_makeStrPresentable(y_keyStr)//	String x_axLbl = text_makeStrPresentable(x_keyStr)//	if (y_bothSomaTermDiffSDiffPExcel)//		y_axLbl += "_DIFF"//	endif//	if (x_bothSomaTermDiffSDiffPExcel)//		x_axLbl += "_DIFF"//	endif	//	String plottedWaveName = text_makeStrPresentable(y_axLbl + "_v_" + x_axLbl)//	//	//set colors for traces//	Variable r,g,b//	Make/O/N=(2,3) somaTerminalColors//	vis_getColorForGraph2("black", r, g, b)//	somaTerminalColors[0][0] = r; somaTerminalColors[0][1] = g; somaTerminalColors[0][2] = b; //	vis_getColorForGraph2("red", r, g, b)//	somaTerminalColors[1][0] = r; somaTerminalColors[1][1] = g; somaTerminalColors[1][2] = b; //	//	if (strlen(winN) == 0)//		winN = plottedWaveName//	endif//	//	//get excel waves if necessary and length waves. recall that these are indexed as in hsList, unlike VI_index//	Variable y_useExcelWv = (y_bothSomaTermDiffSDiffPExcel == 5)//	Variable x_useExcelWv = (x_bothSomaTermDiffSDiffPExcel == 5)//	if (y_useExcelWv)//		WAVE y_excelWv = $y_keyStr//	endif//	if (x_useExcelWv)//		WAVE x_excelWv = $x_keyStr//	endif//	//	//for comparison to length//	String recLensWvRef = "excel_recLens"//	WAVE recLensWv = $recLensWvRef//	//	//first determine how many indices are up to snuff//	WAVE/T cpSummaryIndex//	Variable i, ptsCount = 0//	Variable bothSomaPed		//determine whether to plot from soma or ped or both//	Variable y_doDiffs = 0, x_doDiffs = 0//	if (y_bothSomaTermDiffSDiffPExcel < 3)//		bothSomaPed = y_bothSomaTermDiffSDiffPExcel		//0 for both, 1 for soma, 2 for ped//	elseif (y_bothSomaTermDiffSDiffPExcel == 3)//		bothSomaPed = 1//		y_doDiffs = 1//	elseif (y_bothSomaTermDiffSDiffPExcel == 4)//		bothSomaPed = 2//		y_doDiffs = 1//	else	//excel params, use both sites//		bothSomaPed = 0//	endif//	if (x_bothSomaTermDiffSDiffPExcel < 3)//		bothSomaPed = x_bothSomaTermDiffSDiffPExcel		//0 for both, 1 for soma, 2 for ped//	elseif (x_bothSomaTermDiffSDiffPExcel == 3)//		bothSomaPed = 1//		x_doDiffs = 1//	elseif (x_bothSomaTermDiffSDiffPExcel == 4)//		bothSomaPed = 2//		x_doDiffs = 1//	else	//excel params, use both sites//		bothSomaPed = 0//	endif//	//	for (i=0;i<DimSize(cpSummaryIndex,0);i+=1)	//		ptsCount += VI_getDispStatus(i, plotRuleNum, bothSomaPed, 0)		//0 means default is to plot cells of any length//	endfor//	//	//make wave and populate//	Make/O/D/N=(ptsCount,6) $plottedWaveName//	WAVE plottedWave = $plottedWaveName//	//	String colorsWvSaveName = plottedWaveName + "_color"//	Make/O/N=(ptsCount,3) $colorsWvSaveName//	WAVE colorsWave = $colorsWvSaveName//	//	debug_checkRTErrState(msg="dwajkdajid")//	//	Variable ptsIter = 0, currHsListRow, isAtPed//	for (i=0;i<DimSize(VI_index,0);i+=1)//		if (VI_getDispStatus(i, plotRuleNum, bothSomaPed,0))//			currHsListRow = str2num(VI_index[i][1])//			isAtPed = stringmatch(VI_index[i][2],"P")				//0 for somatic 1 for terminal//			//fill in y value//			if (y_useExcelWv)//				plottedWave[ptsIter][0] = y_excelWv[currHsListRow]//			else//				plottedWave[ptsIter][0] = VI_getParam(i, y_keyStr, y_doDiffs)			//must be updated to include icl parameters!//			endif//			//fill in x value//			if (x_useExcelWv)//				plottedWave[ptsIter][1] = x_excelWv[currHsListRow]//			else//				plottedWave[ptsIter][1] = VI_getParam(i, x_keyStr, x_doDiffs)			//must be updated to include icl parameters!//			endif		//			//			//store other information//			plottedWave[ptsIter][2] = i//			plottedWave[ptsIter][3] = isAtPed//			plottedWave[ptsIter][4] = recLensWv[currHsListRow]										//length of cell//			plottedWave[ptsIter][5] = recLensWv[currHsListRow] > 100 									//cell is peripheral (0) or foveal (1)//			//			//populate colors //			colorsWave[ptsIter][] = somaTerminalColors[isAtPed][q]//			//			ptsIter +=1//		endif//	endfor	//	//	debug_checkRTErrState(msg="aaaaaaaaaaaaa")//	//	String yTraceName = plottedWaveName//	Display/K=1/N=$winN plottedWave[][0]/TN=$yTraceName vs plottedWave[][1] //	winN = S_name//	ModifyGraph/W=$winN zColor($yTraceName)={$colorsWvSaveName,*,*,directRGB,0}//	GetAxis/Q/W=$winN left; SetAxis left, 0, V_max//	GetAxis/Q/W=$winN bottom; SetAxis bottom, 0, V_max//	Label/W=$winN  left, text_makeStrPresentable(yLabel)//	Label/W=$winN  bottom, text_makeStrPresentable(xLabel)//	//	if (groupByLen > -1)//		String groupedTN = plottedWaveName + "_grouped"//		AppendToGraph/W=$winN/B=bottom2 plottedwave[][0]/TN=$groupedTN vs plottedWave[][5]//		ModifyGraph/W=$winN axisEnab(bottom) = {0,.75}, axisEnab(bottom2)={0.8,1}//		ModifyGraph tick(bottom2)=3,noLabel(bottom2)=2//		ModifyGraph axisEnab(bottom2)={0.9,1},freePos(bottom2)=0; doupdate//		ModifyGraph/W=$winN zColor($groupedTN)={$colorsWvSaveName,*,*,directRGB,0}		//gives these points same color scheme as main graph//		doupdate//		SetDrawEnv/W=$winN xcoord= bottom2, ycoord= left;DelayUpdate; DrawText/W=$winN 0,0,"P"//		SetDrawEnv/W=$winN xcoord= bottom2, ycoord= left;DelayUpdate; DrawText/W=$winN 1,0,"F"//	endif//	//	doupdate;//	ModifyGraph/W=$winN mode=3,marker=19//	doupdate;//	SetWindow $winN, hook(cp_cursorClickHook) = cp_cursorClickHook//	SetWindow $winN, hook(winHook_killWaves) = winHook_killWaves ////	SetWindow $winN, hook(winHook_killWaves) = winHook_killWaves //	//end//function VI_getParam(row, paramStr, atSomaAtPedUseDiff)//	Variable row, atSomaAtPedUseDiff//	String paramStr		//paramStr as in analysis_step1SiteHeader//	//	String headerRef = analysis_getStep1siteHeader()//	//	WAVE/T VI_index//	Variable col = VI_index[row][30]		//row to specify used column //	//	if (atSomaAtPedUseDiff < 3)//		VI_col = 17 + atSomaAtPedUseDiff		//17 is soma ref, 18 ped, 19 both//	else	///atSomaAtPedUseDiff > 2, return prestep param: 3 for soma from soma at soma (sfs), 4 pfs, 5 bfs, 6 sfp,  7 pfp, 8 bfp//		VI_col = 11 + atSomaAtPedUseDiff - 3//	endif//	//	String paramRef = VI_index[row][VI_col]//	//	return getParamFromHeader_1D(paramStr, headerRef, paramRef)	//endfunction/S text_makeStrPresentable(str)		//takes in a string and cleans up so that no error would be thrown if one tries to generate a wave etc.	String str		String autoFirstLetter_ifNeeded = "G"		//remove dangerous symbols	str = ReplaceString(" ", str, "")		//space	str = ReplaceString("-", str, "")		//minus	str = ReplaceString("+", str, "")	//plus	str = ReplaceString(";", str, "")		//semi colon	str = ReplaceString(":", str, "")		//colon	str = ReplaceString("/", str, "")		str = ReplaceString("\\", str, "")		str = ReplaceString("[", str, "")		str = ReplaceString("]", str, "")		str = ReplaceString("!", str, "")		str = ReplaceString("@", str, "")		str = ReplaceString("#", str, "")		str = ReplaceString("$", str, "")		str = ReplaceString("%", str, "")		str = ReplaceString("^", str, "")		str = ReplaceString("&", str, "")		str = ReplaceString("*", str, "")		str = ReplaceString("(", str, "")		str = ReplaceString(")", str, "")		str = ReplaceString("=", str, "")		str = ReplaceString("\"", str, "")		str = ReplaceString("'", str, "")		str = ReplaceString("?", str, "")		str = ReplaceString("<", str, "")		str = ReplaceString(">", str, "")		str = ReplaceString(",", str, "")		str = ReplaceString(".", str, "")		Variable currCharVal	sscanf str, "%c", currCharVal	Variable startsWithNum = text_asciiIsNumber(currCharVal)	if (startsWithNum)		str = autoFirstLetter_ifNeeded + str	endif		return str			/// [0,30]			//word limit for wave names is 32 chars! not any more in Igor 8!endfunction SI_getDispStatusFromStr(row, ruleStr, somaOrTerminal)	Variable row	String ruleStr	Variable somaOrTerminal //0 for both, 1 for soma, 2 for terminal		WAVE/T cpSummaryIndex		if (somaOrTerminal > -1)		//check if soma or ped		Variable isPed = stringmatch(cpSummaryIndex[row][2], "P")		//will be 0 for somatic, 1 for ped		if (isPed != somaOrTerminal)									//if input does not match site, return 0, otherwise continue			return 0		endif	endif		strswitch (ruleStr)			case "vresp"	:				return strlen(cpSummaryIndex[row][21]) > 0			break			default:	//includes input like "" or "all"			return 1						endswitch		end//TO CHAGNE DISPLAY RULE: SI_getRowDispStatus()function SI_plotSelections2(somaOutName, pedOutName, xAxOutName, xAxName, winN, keyStrForOutNames, paramTypeStr, keyStr,  plotAgainstWave, doPed , [icParamNum, plotAgainstParamTypeStr, plotAgainstParamKeyStr])		String somaOutName, pedOutName		//out name for y variables	String xAxOutName		//out name for xAx output wave (for plot)	String xAxName 			//name used for v as in vs. xAxName in automatically generated wave names (empty string may usually be passed)	String winN	String keyStrForOutNames 	//some keys have negatves etc in their names and should not be used for wave names. pass this when that is the case	String paramTypeStr		//parameter wave type string: e.g. "ccW", "ccG", "ccP", ...	String keyStr				//key names used in header wave for above type parameter waves. e.g. "m1_c1_tau" would be used with "ccW"	Variable doPed			//0 for soma, 1 for ped,  -1 for both ONE COLOR (non-descriminant, uses somaOutName), 2 for both overlaid soma black ped red	WAVE plotAgainstWave 	//must be numeric and should match by index to excel_ waves		Variable icParamNum			//allows plotting of icParams instead. 0 = y0, 1 = amp, 2 = tau, 3 = x0	String plotAgainstParamTypeStr, plotAgainstParamKeyStr		//optionally pass BOTH of these in order to plot a parameter vs another parameter on the x axis. naming otherwise as for plotting against length etc.			if (strlen(winN) == 0)		winN = "param_"+keyStr + "_vs_x"	endif				Variable doICParam	if (!ParamIsDefault(icParamNum))		doICParam = icParamNum		else		doICParam = -1		//signals function to skip plotting an icParam and plot one of the other param types	endif		if (doPed > -1)	//do one one or both	//check whether to do soma		if (doPed != 1)			if (!ParamIsDefault(plotAgainstParamTypeStr) && !ParamIsDefault(plotAgainstParamKeyStr))				SI_plotSelections_1Site(somaOutName, xAxOutName, xAxName, keyStrForOutNames, paramTypeStr, keyStr,  plotAgainstWave, 0 , icParamNum = doIcParam, plotAgainstParamTypeStr=plotAgainstParamTypeStr, plotAgainstParamKeyStr=plotAgainstParamKeyStr)			else				SI_plotSelections_1Site(somaOutName, xAxOutName, xAxName, keyStrForOutNames, paramTypeStr, keyStr,  plotAgainstWave, 0 , icParamNum = doIcParam)			endif		endif		//check whether to do ped		if (doPed != 0)			if (!ParamIsDefault(plotAgainstParamTypeStr) && !ParamIsDefault(plotAgainstParamKeyStr))				SI_plotSelections_1Site(pedOutName, xAxOutName, xAxName, keyStrForOutNames, paramTypeStr, keyStr,  plotAgainstWave, 1 , icParamNum = doIcParam, plotAgainstParamTypeStr=plotAgainstParamTypeStr, plotAgainstParamKeyStr=plotAgainstParamKeyStr)			else				SI_plotSelections_1Site(pedOutName, xAxOutName, xAxName, keyStrForOutNames, paramTypeStr, keyStr,  plotAgainstWave, 1 , icParamNum = doIcParam)			endif		endif				//call proper display command		if (doPed == 2)			SI_displayVsParam ($somaOutName, $pedOutName, winN, 1, 1, $xAxOutName, $(xAxOutName + "bins"))		elseif (doPed == 1)		//ped only			SI_displayVsParam ($somaOutName, $pedOutName, winN, 0, 1, $xAxOutName, $(xAxOutName + "bins"))		else		//soma only			SI_displayVsParam ($somaOutName, $pedOutName, winN, 1, 0, $xAxOutName, $(xAxOutName + "bins"))		endif		else				//display al together, treat as one big soma		if (!ParamIsDefault(plotAgainstParamTypeStr) && !ParamIsDefault(plotAgainstParamKeyStr))			SI_plotSelections_1Site(somaOutName, xAxOutName, xAxName, keyStrForOutNames, paramTypeStr, keyStr,  plotAgainstWave, -1 , icParamNum = doIcParam, plotAgainstParamTypeStr=plotAgainstParamTypeStr, plotAgainstParamKeyStr=plotAgainstParamKeyStr)		else			SI_plotSelections_1Site(somaOutName, xAxOutName, xAxName, keyStrForOutNames, paramTypeStr, keyStr,  plotAgainstWave, -1 , icParamNum = doIcParam)		endif		//call proper display command		SI_displayVsParam ($somaOutName, $"", winN, 1, 0, $xAxOutName, $(xAxOutName + "bins"))	endifend	//SI_plotSelections2()//TO CHAGNE DISPLAY RULE: SI_getRowDispStatus()function SI_plotSelections_1Site(outName, xAxOutName, xAxName, keyStrForOutNames, paramTypeStr, keyStr,  plotAgainstWave, doPed , [icParamNum, plotAgainstParamTypeStr, plotAgainstParamKeyStr])	String outName			//start of name of output wave  (for plot)	String xAxOutName		//out name for xAx output wave (for plot)	String xAxName 			//name used for v as in vs. xAxName in automatically generated wave names (empty string may usually be passed)	String keyStrForOutNames 	//some keys have negatves etc in their names and should not be used for wave names. pass this when that is the case	String paramTypeStr		//parameter wave type string: e.g. "ccW", "ccG", "ccP", ...	String keyStr				//key names used in header wave for above type parameter waves. e.g. "m1_c1_tau" would be used with "ccW"	Variable doPed			//0 for soma, 1 for ped, less than zero, e.g. -1 to display both together	WAVE plotAgainstWave 	//must be numeric and should match by index to excel_ waves		Variable icParamNum			//allows plotting of icParams instead. 0 = y0, 1 = amp, 2 = tau, 3 = x0	String plotAgainstParamTypeStr, plotAgainstParamKeyStr		//optionally pass BOTH of these in order to plot a parameter vs another parameter on the x axis. naming otherwise as for plotting against length etc.		Variable plotAgainstThreshold = 100				//threshold for smaller or larger bin		WAVE/T cpSummaryIndex		Variable plotAgainstSIparam = 0	if (!ParamIsDefault(plotAgainstParamTypeStr) && !ParamIsDefault(plotAgainstParamKeyStr))		plotAgainstSIparam = 1	endif		Variable doICParam	if (!ParamIsDefault(icParamNum))		doICParam = icParamNum		else		doICParam = -1		//signals function to skip plotting an icParam and plot one of the other param types	endif			Variable numPoints =SI_getNumDispRows()	String siteIndicatorStr		// used in naming	if (doPed < 0)		//negative signifies display all regardless of soma ped		siteIndicatorStr = "B"	else		if (doPed)			siteIndicatorStr = "P"		else			siteIndicatorStr = "S"		endif	endif		Make/O/D/N=(numPoints)  outValsTemp, xAxOutTemp, binsXAxTemp		//outValsTemp is y vals, xAxOutTemp is x vals, binsXAxTemp is binned x vals, 	Make/O/N=(numPoints) outCPIndexTemp							//outCPIndexTemp is the index in cpSummaryIndex for the point		if (strlen(keyStrForOutNames) < 1)		//some keys have negatves etc in their names and should not be used for wave names. pass this when that is the case		keyStrForOutNames = keyStr	endif		Print "keyStrForOutNames: " + keyStrForOutNames		if (strlen(outName) < 1)		outName = "SI_" + siteIndicatorStr + "_" + paramTypeStr +"_" + keyStrForOutNames + "_v" + xAxName + "_n" + num2str(numPoints)	endif	if (strlen(xAxOutName) < 1)		xAxOutName = "SI_X" + siteIndicatorStr + "_v" + xAxName + "_n" + num2str(numPoints)		//param non-specific (fewer redundent x waves generated)	endif			Print outName + " . LEN = " + num2str(strlen(outName))	Print xAxOutName + " . LEN = " + num2str(strlen(xAxOutName))		Variable i, currXAxParamIndex, count = 0	for (i=0;i<DimSize(cpSummaryIndex,0);i+=1)		if (SI_getRowDispStatus(i))				//iterate through all selected						currXAxParamIndex = str2num(cpSummaryIndex[i][14])	//look up x value						//store y if properly soma or ped or both			if (SI_getRowDispStatus(i, pedOnly=doPed))						if (doICParam < 0)							outValsTemp[count] = SI_getParamByKey2(i, paramTypeStr, keyStr)				else					outValsTemp[count] = SI_getICParam(i, doICParam)				endif					else				outValsTemp[count] = NaN			endif					//	Print "row = " + num2stR(i) + ". dispStatus=" + num2str(SI_getRowDispStatus(i)) + "ped_dispstatus=" + num2str(SI_getRowDispStatus(i, pedOnly=doPed)) + "			//store x value in any case where this is selected (allows soma and terminal overlays)			if (!plotAgainstSIparam)				xAxOutTemp[count] = plotAgainstWave[currXAxParamIndex]			else					xAxOutTemp[count] = SI_getParamByKey2(i, plotAgainstParamTypeStr, plotAgainstParamKeyStr)			endif			binsXAxTemp[count] = plotAgainstWave[currXAxParamIndex] > plotAgainstThreshold ? 1 : -1			outCPIndexTemp[count] = i	//store cell index			count +=1		endif	endfor	Duplicate/O outValsTemp, $outName	Duplicate/O xAxOutTemp, $xAxOutName	Duplicate/O binsXAxTemp, $(xAxOutName + "bins")	Duplicate/O outCPIndexTemp, $(outName + "_index")		//for look up	Print "outname = " + outName + ". xAxOutName = " + xAxOutName 	Print "binwave = " + (xAxOutName + "bins") + ". Len = " +num2str(strlen((xAxOutName + "bins")))//	SI_displayVsParam ($somaOutName, $pedOutName, winN, doSoma, doPed, $xAxOutName, $(xAxOutName + "bins"))end		//end SI_plotSelections1site//WARNING CURRENTLY IMPLEMENTED SO SOMA USUALLY HAS TO BE PLOTTED. will cause bug when trying to just plot terminal alone. NOT USED//function SI_plotSelections(somaOutName, pedOutName, xAxOutName, xAxName, winN, keyStrForOutNames, paramTypeStr, keyStr,  plotAgainstWave, doSoma, doPed , [icParamNum, plotAgainstParamTypeStr, plotAgainstParamKeyStr])//	String somaOutName		//start of name of output wave for soma (for plot)//	String pedOutName		//start of name of output wave for ped (for plot)//	String xAxOutName		//out name for soma if xAxName //	String winN				//display window name, optionally pass "" to generate new//	String paramTypeStr		//parameter wave type string: e.g. "ccW", "ccG", "ccP", ...//	String keyStr				//key names used in header wave for above type parameter waves. e.g. "m1_c1_tau" would be used with "ccW"//	Variable doSoma, doPed	//0 or 1 to plot either, some functions mail fail when trying to plot soma only//	WAVE plotAgainstWave 	//must be numeric and should match by index to excel_ waves//	String xAxName 			//name used for v as in vs. xAxName in automatically generated wave names (empty string may usually be passed)//	String keyStrForOutNames 	//some keys have negatves etc in their names and should not be used for wave names. pass this when that is the case//	//	Variable icParamNum			//allows plotting of icParams instead. 0 = y0, 1 = amp, 2 = tau, 3 = x0//	String plotAgainstParamTypeStr, plotAgainstParamKeyStr		//optionally pass BOTH of these in order to plot a parameter vs another parameter on the x axis. naming otherwise as for plotting against length etc.//	//	Variable plotAgainstSIparam = 0//	if (!ParamIsDefault(plotAgainstParamTypeStr) && !ParamIsDefault(plotAgainstParamKeyStr))//		plotAgainstSIparam = 1//	endif//	//	//	Variable doICParam//	if (!ParamIsDefault(icParamNum))//		doICParam = icParamNum	//	else//		doICParam = -1		//signals function to skip plotting an icParam and plot one of the other param types//	endif//	//	Print "keyStrForOutNames: " + keyStrForOutNames//	//	//generates wave with selected parameter for each selected cell. Cell selections should be made in SI_cellsForDisp//	WAVE SI_cellsForDisp, excel_recLens; WAVE/T cpSummaryIndex//	//	Variable numPoints = SI_getNumDispRows()//	Variable numSomas = SI_getNumDispRows(pedOnly = 0)//	Variable numPeds = SI_getNumDispRows(pedOnly = 1)//	////	MAke/O/T/N=(numPoints) outNamesTemp////	Make/O/D/N=(numPoints)  outValsSomaTemp, outValsPedTemp, xAxOutTemp, binsXAxTemp//	//	if (strlen(keyStrForOutNames) < 1)		//some keys have negatves etc in their names and should not be used for wave names. pass this when that is the case//		keyStrForOutNames = keyStr//	endif//	//	if (strlen(somaOutName) < 1)//		somaOutName = "SI_S_" + paramTypeStr +"_" + keyStrForOutNames + "_v" + xAxName + "_n" + num2str(numPoints)//	endif//	if (strlen(pedOutName) < 1)//		pedOutName = "SI_P_"  + paramTypeStr +"_" + keyStrForOutNames + "_v" + xAxName + "_n" + num2str(numPoints)//	endif//	if (strlen(xAxOutName) < 1)//	//		pedOutName = "SI_X_"  + paramTypeStr +"_" + keyStrForOutNames + "_v" + xAxName + "_n" + num2str(numPoints)////		xAxOutName = "SI_X" + "_v" + xAxName + "_n" + num2str(numPoints)		//param non-specific (fewer redundent x waves generated)//	endif	//	Print somaOutName + " . LEN = " + num2str(strlen(somaOutName))//	Print pedOutName + " . LEN = " + num2str(strlen(pedOutName))//	Print xAxOutName + " . LEN = " + num2str(strlen(xAxOutName))//	//	if (strlen(winN) < 1)//		winN = keyStrForOutNames//	endif//	//	Variable i, currXAxParamIndex, somaCount = 0, pedCount = 0//	for (i=0;i<DimSize(cpSummaryIndex,0);i+=1)//		if (SI_getRowDispStatus(i))//			currXAxParamIndex = str2num(cpSummaryIndex[i][14])//			if (stringmatch(cpSummaryIndex[i][2], "S"))	//				if (doICParam < 0)		//					outValsSomaTemp[somaCount] = SI_getParamByKey2(i, paramTypeStr, keyStr)//				else//					outValsSomaTemp[somaCount] = SI_getICParam(i, doICParam)//				endif//				//fill in x axis param wave based on soma//				if (!plotAgainstSIparam)//					xAxOutTemp[somaCount] = plotAgainstWave[currXAxParamIndex]//				else	//					xAxOutTemp[somaCount] = SI_getParamByKey2(i, plotAgainstParamTypeStr, plotAgainstParamKeyStr)//				endif//				binsXAxTemp[somaCount] = excel_recLens[currXAxParamIndex] > 100 ? 1 : -1//				somaCount +=1//			else//				if (doICParam < 0)//					outValsPedTemp[pedCount] = SI_getParamByKey2(i, paramTypeStr, keyStr)//				else//					outValsPedTemp[pedCount] = SI_getICParam(i, doICParam)//				endif//				pedCount +=1//			endif//			//		endif//	endfor////	Duplicate/O outValsSomaTemp, $somaOutName//	Duplicate/O outValsPedTemp, $pedOutName//	Duplicate/O xAxOutTemp, $xAxOutName//	Duplicate/O binsXAxTemp, $(xAxOutName + "bins")//	Print "binwave = " + (xAxOutName + "bins") + ". Len = " +num2str(strlen((xAxOutName + "bins")))//	SI_displayVsParam ($somaOutName, $pedOutName, winN, doSoma, doPed, $xAxOutName, $(xAxOutName + "bins"))//end		//end SI_plotSelections()	//allows one to set how to displayfunction SI_getRowDispStatus(rowNum, [pedOnly])	Variable rowNum	Variable pedOnly		//-1 works as if not passed, 0 soma only, 1 ped only		WAVE/T cpSummaryIndex//	Variable doDisplay = strlen(cpSummaryIndex[rowNum][0]) > 0 		//ALL //	Variable doDisplay = strlen(cpSummaryIndex[rowNum][19]) > 0	//	Variable doDisplay = ( strlen(cpSummaryIndex[rowNum][19]) > 0 ) && ( stringmatch(cpSummaryIndex[rowNum][12], "b") || (strlen(cpSummaryIndex[rowNum][12]) == 0) )		//second half of end allows only before other site break ins to be shown//	Variable doDisplay = ( strlen(cpSummaryIndex[rowNum][19]) > 0 ) && ( stringmatch(cpSummaryIndex[rowNum][20], "1")													//only afters with befores//	Variable doDisplay = ( strlen(cpSummaryIndex[rowNum][19]) > 0 ) && ( stringmatch(cpSummaryIndex[rowNum][20], "0")													//only befores with afters	//	Variable doDisplay = ( strlen(cpSummaryIndex[rowNum][19]) > 0 ) && ( stringmatch(cpSummaryIndex[rowNum][12], "a")													//all afters//	Variable doDisplay = stringmatch(cpSummaryIndex[rowNum][19], "1") && ( stringmatch(cpSummaryIndex[rowNum][20], "0") || ( stringmatch(cpSummaryIndex[rowNum][20], "1")  )		//	Variable doDisplay = ( strlen(cpSummaryIndex[rowNum][19]) > 0 ) && ( stringmatch(cpSummaryIndex[rowNum][12], "b") || (strlen(cpSummaryIndex[rowNum][12]) == 0) )	//[19] portion selects cells that are deemed usable. [12]=="b" is cells that are before break in at other site, or if [12] is blank then they are with other site I=0	Variable doDisplay = ( strlen(cpSummaryIndex[rowNum][19]) > 0 ) && ( stringmatch(cpSummaryIndex[rowNum][19], "0")	)												//only non-simultaneous	if (!doDisplay)		return 0	endif	if (ParamIsDefault(pedOnly) || pedOnly < 0)		return 1	endif	if (pedOnly)		if (stringmatch(cpSummaryIndex[rowNum][2],"*P*"))			return 1		else			return 0		endif			endif		if (stringmatch(cpSummaryIndex[rowNum][2],"*S*"))		return 1	endif		return 0endfunction SI_getNumDispRows([pedOnly])	Variable pedOnly		//optionally pass to count only somas (pedOnly != 1, e.g. 0) or only peds (pedOnly = 1)	WAVE/T cpSummaryIndex		if (ParamIsDefault(pedOnly))		pedOnly = -1	endif		Variable i, count = 0	for (i=0;i<DimSize(cpSummaryIndex,0);i+=1)		if (SI_getRowDispStatus(i, pedOnly = pedOnly))			count +=1		endif	endfor	return countendfunction SI_getICParam(SI_index, paramNum)	Variable SI_index, paramNum		WAVE SI_voltageResponseFits		return SI_voltageResponseFits[SI_index][paramNum]endfunction SI_getParamByKey2(SI_index, paramTypeStr, keyStr)	Variable SI_Index	String keyStr, paramTypeStr		WAVE/T cpSummaryIndex		String paramRef = cpSummaryIndex[SI_index][1] + paramTypeStr		//"ccG" "ccC" "ccW" or "cap" or "rad" or "ccB"	String headerRef													//Variable genParamsCol = 3, compParamsCol = 4, coefWaveCol = 5, displayRefCol = 6, capWaveCol = 7, radWaveCol = 8	if (stringmatch(paramTypeStr, "*ccG*"))		headerRef = "genParamsHeader"	elseif (stringmatch(paramTypeStr, "*ccC*"))		headerRef = "compParamsHeader"	elseif (stringmatch(paramTypeStr, "*ccW*"))		headerRef = "coefWaveHeader"	elseif (stringmatch(paramTypeStr, "*cap*"))		headerRef = "capValsHeader"	elseif (stringmatch(paramTypeStr, "*rad*"))		headerRef = "capValsHeader"	elseif (stringmatch(paramTypeStr, "*ccB*"))		headerRef = SI_getBothParamsHeader()		elseif (stringmatch(paramTypeStr, "*vrP*"))		//v resp params		headerRef = "vRespHeader"	endif		return getParamFromHeader_1D(keyStr, headerRef,paramRef)end//zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzfunction SI_displayVsParam (somaW, pedW, winN, doSoma, doPed, xAxParamWave, binsWave)	String winN	WAVE somaW, pedW	Variable doSoma, doPed	WAVE xAxParamWave			//e.g. axon lengths matched to somaW and/or pedW	WAVE binsWave					//indicate whether a the cell at each index is fovea or peripheral, for instance			WAVE shortBin, longBin			//sets "actual" (Sort of) distance between shortBin and longBin on x axis. so far used shortBin[0] = -1, longBin[0] = 1, only one point in each wave	winN = ReplaceString(" ", winN, "")	//remove spaces	winN = ReplaceString("-", winN, "m")	//remove minus	Print "winN = " + winN	Display/K=1/N=$winN 	winN=S_name	if (doSoma)		AppendToGraph/C=(0,0,0) somaW vs xAxParamWave	endif	if (doPed)		AppendToGraph pedW vs xAxParamWave	endif		Make/D/O/N=1 somaW_short_avg_temp, somaW_long_avg_temp, pedW_short_avg_temp, pedW_long_avg_temp	somaW_short_avg_temp=0; somaW_long_avg_temp=0; pedW_short_avg_temp=0; pedW_long_avg_temp=0	Variable i, shortCount_S = 0, longCount_S = 0, shortCount_P, longCount_P 	for (i=0; i< DimSize(somaW, 0);i+=1)		if (binsWave[i] < 0)		//then a short cone			if (numtype(somaW[i]) == 0)				shortCount_S += 1				somaW_short_avg_temp += somaW[i]			endif			if (numtype(pedW[i]) == 0)				shortCount_P += 1				pedW_short_avg_temp += pedW[i]			endif		else						//long cone			if (numtype(somaW[i]) == 0)				longCount_S += 1				somaW_long_avg_temp += somaW[i]			endif			if (numtype(pedW[i]) == 0)				longCount_P += 1				pedW_long_avg_temp += pedW[i]			endif					endif	endfor		Print "soma short total = " + num2str(shortCount_S)	Print "ped short total = " + num2str(shortCount_P)	Print "soma long total = " + num2str(longCount_S)	Print "ped long total = " + num2str(longCount_P)	somaW_short_avg_temp /= shortCount_S	pedW_short_avg_temp /= shortCount_P	somaW_long_avg_temp /= longCount_S	pedW_long_avg_temp /= longCount_P	Print "soma short total = " + num2str(somaW_short_avg_temp[0])	Print "ped short total = " + num2str(pedW_short_avg_temp[0])	Print "soma long total = " + num2str(somaW_long_avg_temp[0])	Print "ped long total = " + num2str(pedW_long_avg_temp[0])	String somaSNShort_avg= NameOfWave(somaW) + "_sha"	String somaSNLong_avg = NameOfWave(somaW) + "_loa" 	String pedSNShort_avg = NameOfWave(pedW) + "_sha"	String pedSNLong_avg = NameOfWave(pedW) + "_loa"	Duplicate/O somaW_short_avg_temp, $somaSNShort_avg	Duplicate/O somaW_long_avg_temp, $somaSNLong_avg	Duplicate/O pedW_short_avg_temp, $pedSNShort_avg	Duplicate/O pedW_long_avg_temp, $pedSNLong_avg//	KillWaves/Z somaW_short_temp, somaW_long_temp, pedW_short_temp, pedW_long_temp		if (doSoma)		AppendToGraph/B=bottom2/C=(0,0,0) somaW/TN=$(NameOfWave(somaW) + "_binned") vs binsWave	endif	if (doPed)		AppendToGraph/B=bottom2 pedW/TN=$(NameOfWave(pedW) + "_binned") vs binsWave	endif	ModifyGraph mode=3, marker=19		if (doSoma)		AppendToGraph/B=bottom2/C=(0,0,0) $somaSNShort_avg/TN=short_avg_S vs shortBin		ModifyGraph rgb(short_avg_S) = (0,0,0), mode=3, marker(short_avg_S)=7, mrkStrokeRGB(short_avg_S)=(0,0,0)		AppendToGraph/B=bottom2/C=(0,0,0) $somaSNLong_avg/TN=long_avg_S vs longBin		ModifyGraph mode=3, marker(long_avg_S)=7 , mrkStrokeRGB(long_avg_S)=(0,0,0)	endif	if (doPed)		AppendToGraph/B=bottom2 $pedSNShort_avg/TN=short_avg_P vs shortBin		ModifyGraph mode=3, marker(short_avg_P)=7, mrkStrokeRGB(short_avg_P)=(65280,0,0)		AppendToGraph/B=bottom2 $pedSNLong_avg/TN=long_avg_P vs longBin		ModifyGraph mode=3, marker(long_avg_P)=7, mrkStrokeRGB(long_avg_P)=(65280,0,0)	endif	ModifyGraph tick(bottom2)=3,noLabel(bottom2)=2,axisEnab(bottom)={0,0.75};DelayUpdate	ModifyGraph axisEnab(bottom2)={0.9,1},freePos(bottom2)=0; doupdate	//adjust window:	Label left winname(0,1)+"    \f01\U"; //Modifygraph height=1.5*72, width=2*72; 	Label bottom, "x = " +  NameOfWave(xAxParamWave)	GetAxis/Q left; SetAxis left, 0, V_max	GetAxis/Q bottom; SetAxis bottom, 0, V_max	doupdate;	SetWindow $winN, hook(winHook) = cp_cursorClickHook		Print "Nameofwave...", NameOfWave(somaW) + ";" + nameofwave(pedw)	Print "Nameofwave...",NameOfWave($pedSNShort_avg) + ";" + NameOfWave($pedSNLong_avg)	end	//end SI_displayVsParam()function SI_reloadCmd(cpSummaryIndexRow)	Variable cpSummaryIndexRow		WAVE/T cpSummaryIndex	WAVE/T redisplayWave = $cpSummaryIndex[cpSummaryIndexRow][6]	String exampleRedisplayStr = redisplayWave[0]	String cmdRef = StringFromList(4, exampleRedisplayStr)	da_fd_loadWaveFromWaveName(cmdRef)endfunction SI_unsub_overlay(firstRowNum, isFovea)	Variable firstRowNum, isFovea	WAVE/T cpSummaryIndex		String appendStr	if (isFovea)		appendStr = "_fov_"	else		appendStr = "_periph_"	endif	appendStr += "unsub"		Display/K=1/N=$("G" + cpSummaryIndex[firstRowNum][0] + appendStr)	AppendToGraph/L $cpSummaryIndex[firstRowNum][1]	AppendToGraph/R/C=(0,0,0)  $cpSummaryIndex[firstRowNum+1][1]	disp_defaultRange()endfunction/S updateSummaryList(rowNum)	Variable rowNum			//  items of interest: Ri (steady state);  Ra, Rm (2 component model); amps, taus, caps, radius each component	String out = ""		WAVE/T cpSummaryIndex	String dataWaveRef = cpSummaryIndex[rowNum][1]	String genParamsRef = cpSummaryIndex[rowNum][3]	String compParamsRef = cpSummaryIndex[rowNum][4]	String coefWaveRef = cpSummaryIndex[rowNum][5]	String capStorageRef = cpSummaryIndex[rowNum][7]//	Duplicate/O $capStorageRef, capsTemp	String radStorageRef = cpSummaryIndex[rowNum][8]//	Duplicate/O $radStorageRef, radsTemp		Variable deltaV = getDeltaV(rowNum)	Print "deltaV",deltaV	getCapValues(coefWaveRef, "coefWaveHeader", deltaV, capStorageRef)	capValsToRad(capStorageRef, radStorageRef)	Duplicate/O $capStorageRef, capsTemp		Duplicate/O $radStorageRef, radsTemp			String Ri_ss = num2str( getParamFromHeader_1D("ssRin", "genParamsHeader", genParamsRef)			)	String Ra_2c = num2str( getParamFromHeader_1D("1_mT_Ra", "compParamsHeader", compParamsRef)	)	String Rm_2c = num2str( getParamFromHeader_1D("1_mT_Rm", "compParamsHeader", compParamsRef)	)	out += "Ri_ss:" +Ri_ss +";Ra_2c:" + Ra_2c + ";Rm_2c:" +Rm_2c + ";"	getCapValsHeader();	WAVE/T capValsHeader	//good titles for what follows	String currStr_append= "(a,t,c,r):"	Variable i, currHeaderWaveIndex; String currStr, currAmp, currTau, currC, currR, currAmpFindStr, currTauFindStr		for (i=0;i<5;i+=1)		currStr=  capValsHeader[i]			//e.g. m0_c0 (i=0), m2_c2 (i=5)		currAmpFindStr = currStr + "_A"		currTauFindStr = currStr + "_tau"		currAmp = num2str( getParamFromHeader_1D(currAmpFindStr, "coefWaveHeader", coefWaveRef)		)		currTau = num2str( getParamFromHeader_1D(currTauFindStr, "coefWaveHeader", coefWaveRef)		)		currC = num2str(capsTemp[i])		currR = num2str(radsTemp[i])		out+= currStr + currStr_append + currAmp + "," + currTau + "," + currC + "," + currR + ";"	endfor		cpSummaryIndex[rowNum][10] = out	KillWaves/Z capsTemp, radsTemp	return outendfunction SI_calcSubbedWave(somaRow, pedRow)	Variable pedRow, somaRow	WAVE/T cpSummaryIndex		String somaSubbedRef = SI_getSubbedRef(somaRow)	Print "soma subbed ref = " + somaSubbedRef	String pedSubbedRef = SI_getSubbedRef(pedRow)	Print "ped subbed ref = " + pedSubbedRef	WAVE somaHolder = $somaSubbedRef	WAVE pedHolder= $pedSubbedRef	Duplicate/O pedHolder, forSubTemp_out	forSubTemp_out = somaHolder - pedHolder		Duplicate/O forSubTemp_out, $cpSummaryIndex[somaRow][11]	Print "cpSummaryIndex[somaRow][11]",cpSummaryIndex[somaRow][11]	KillWaves/Z forSubTemp_out endfunction SI_displaySubbedAvgs(somaRow, pedRow)	Variable pedRow, somaRow	WAVE/T cpSummaryIndex		String somaSubbedRef = SI_getSubbedRef(somaRow)	String pedSubbedRef = SI_getSubbedRef(pedRow)	String differenceRef = cpSummaryIndex[somaRow][11]	String cmdRef = SI_getCmdRef(somaRow)		Display/N=$("G" + cpSummaryIndex[somaRow][0] + "_SI_avgs")/K=1	AppendToGraph $pedSubbedRef	AppendToGraph/R/C=(0,0,0) $somaSubbedRef	AppendToGraph/L=left1 $differenceRef	AppendToGraph/L=left2/C=(23232,23232,23232) $cmdRef		Modifygraph axisEnab(left2) = {0,.1}, axisEnab(left1) = {.12,.35}, axisEnab(left) ={.37,1}, axisEnab(right)={.37,1}	Modifygraph freepos=0, lblpos=52	disp_defaultRange()	setaxis/A=2 left1	setaxis/A=2 left2endfunction/S SI_getSubbedRef(rowNum)	Variable rowNum	WAVE/T cpSummaryIndex		String dispRef = cpSummaryIndex[rowNum][6]	WAVE/T dispHolder = $dispRef	String redisplayList = dispHolder[0]		String subbedWaveRef = StringfromList(6, redisplayList)	return subbedWaveRefendfunction/S SI_getRefFromDispW(rowNum, modelNum, dispWaveListIndex)	Variable rowNum, modelNum, dispWaveListIndex	WAVE/T cpSummaryIndex		String dispRef = cpSummaryIndex[rowNum][6]	WAVE/T dispHolder = $dispRef	String redisplayList = dispHolder[modelNum]		String returnRef = StringFromList(dispWaveListIndex, redisplayList)	//	String fittRef = StringFromList(3, redisplayList)			//will check on whether there was subtraction later//	String cmdRef = StringfromList(4, redisplayList)//	String sealRef = StringfromList(5, redisplayList)//	String subbedWaveRef = StringfromList(6, redisplayList)//	String modelRef = StringfromList(7, redisplayList)//	String originalWaveBeforeSub		//only placeholder for now	return returnRefendfunction/S SI_getCmdRef(rowNum)	Variable rowNum	WAVe/T cpSummaryIndex		String dispRef = cpSummaryIndex[rowNum][6]	WAVE/T dispHolder = $dispRef	String redisplayList = dispHolder[0]			String cmdRef = StringfromList(4, redisplayList)		return cmdRefendfunction/S SI_getCmdRef_S(rowNum)	Variable rowNum	WAVe/T cpSummaryIndex		String dispRef = cpSummaryIndex[rowNum][6]	WAVE/T dispHolder = $dispRef	String redisplayList = dispHolder[0]			String cmdRef = StringfromList(4, redisplayList)		return cmdRefendfunction SI_plotCol(winN, plotForSoma)	String winN	Variable plotForSoma		WAVE/T cpSummaryIndex		Display/N=$winN /K=1	winN = S_name	Variable i, currRow, plot1, plot2; String currNoteStr, currPosStr	Variable currLen		WAVE SI_rowStartsForDisp	for (i=0;i<DimSize(SI_rowStartsForDisp,0);i+=1)		currRow = SI_rowStartsForDisp[i]	+  plotForSoma//		currNoteStr = cpSummaryIndex[currRow][9]//		currPosStr = cpSummaryIndex[i][2]//		plot1 = stringmatch(currNoteStr, "*use*")//		plot2 = stringmatch(currPosStr, "S")		AppendToGraph/W=$winN $SI_getSubbedRef(currRow)		currLen = str2num(cpSummaryIndex[currRow][12])		if (currLen > 100)			modifygraph rgb($SI_getSubbedRef(currRow))=(0,0,0)		endif	endforendfunction SI_plotAnyCol(winN, useTop, dispCol)	String winN; variable useTop, dispCol		Variable offsetToStepStart = 1		Variable colNum	Variable checkColNum = 2	String colStrMatch = "S"		WAVE/T cpSummaryIndex	WAVE SI_cellsForDisp, excel_recLens		if (!useTop)		Display/N=$winN /K=1		winN = S_name	else		winN = ""	endif	Variable i, plot1, plot2=1; String currCheckNote, currCheckNote2	Variable currStepStart	Variable currLen	for (i=0;i<DimSize(cpSummaryIndex,0);i+=1)		currCheckNote = cpSummaryIndex[i][checkColNum]		currCheckNote2 = cpSummaryIndex[i][2]		plot1 = stringmatch(currCheckNote, colStrMatch) && SI_cellsForDisp[i]	//	plot2 = stringmatch(currCheckNote2, "S")		if (plot1 && plot2)			AppendToGraph/W=$winN/C=(39168,13056,0) $cpSummaryIndex[i][dispCol]			currLen = excel_recLens[findStrInTextWave_1D(cpSummaryIndex[i][0], $"excel_cellNames")]			if (currLen > 100)				modifygraph rgb($cpSummaryIndex[i][dispCol])=(0,0,39168)			endif			if (offsetToStepStart)				currStepStart = SI_getParamByKey2(i, "ccG", "vCmd_t0")				ModifyGraph offset($cpSummaryIndex[i][dispCol]) = {-currStepStart,0}			endif		endif	endforendfunction/S SI_ordered_paramByKey(keyStr, outRef, doPed)	String keyStr, outRef; Variable doPed	WAVE/T cpSummaryIndex_S		Variable startIndex = 0	if (doPed)		startIndex = 1	endif		Make/O/D/N=9 S_temp_out		S_temp_out[] = str2num(StringByKey( keyStr, cpSummaryIndex_S[(2*p) + startIndex][10] ) )		Duplicate/O S_temp_out, $outRef	KillWaves/Z S_temp_out	Print "outRef",outRef	return outRefendfunction/S SI_ordered_compParamByKey(modelNum, compNum, paramNum, outRef, doPed)	String outRef; Variable doPed, modelNum, compNum, paramNum	WAVE/T cpSummaryIndex_S		Variable startIndex = 0	if (doPed)		startIndex = 1	endif		Make/O/D/N=9 S_temp_out		String keyStr = "m" + num2str(modelNum) + "_" + "c" + num2str(compNum) + "(a,t,c,r)"		S_temp_out[] = str2num( Stringfromlist(paramNum, StringByKey( keyStr, cpSummaryIndex_S[(2*p) + startIndex][10] ) , "," )  )		Duplicate/O S_temp_out, $outRef	KillWaves/Z S_temp_out	Print "outRef",outRef	return outRefendfunction SI_doAll(doPed)	Variable doPed		String outStart = "SI_m"		String siteStr = "S"	if (doPed)		siteStr="P"	endif			String currOut, currModelStr, currCompStr	Variable model, component, param	for (model = 0; model < 2; model +=1)		currModelStr = num2str(model)		for (component = 0; component < model + 1; component +=1)			currCompStr = "c" + num2str(component) + "_"			for (param = 0; param < 4; param+=1)				currOut = outStart + currModelStr + currCompStr				if (param == 0)					currOut += "A"				elseif (param ==1)					currOut += "tau"				elseif (param==2)					currOut += "cap"				else					currOut += "rad"				endif								currOut += "_" + siteStr				SI_ordered_compParamByKey(model, component, param, currOut, doPed)			endfor		endfor	endforendfunction SI_dispAll()	String outStart = "SI_m"		String somaStr = "S", pedStr = "P"		String currOut, currOut_S, currOut_P, currModelStr, currCompStr	Variable model, component, param	for (model = 0; model < 2; model +=1)		currModelStr = num2str(model)		for (component = 0; component < model + 1; component +=1)			currCompStr = "c" + num2str(component) + "_"			for (param = 0; param < 4; param+=1)			currOut = outStart + currModelStr + currCompStr				if (param == 0)					currOut += "A"				elseif (param ==1)					currOut += "tau"				elseif (param==2)					currOut += "cap"				else					currOut += "rad"				endif								currOut_S = currOut + "_" + somaStr			//	Print currOut_S				currOut_P = currOut +  "_" + pedStr			//	Print currOut_P			//	SI_displayVsLen($currOut_S, $currOut_P, currOut,1,1)				modifygraph height=1.5*72, width=2*72			endfor		endfor	endfor//	winname 	Print "currently out of date!!!! Uncommentize SI_displayVsLen() to use"endfunction SI_plotCol_normToPeak( winN, doPed, componentNum)	String winN; Variable doPed,componentNum		WAVE/T cpSummaryIndex		String matchStr = "S"	if (doPed)		matchStr = "P"	endif		Variable modelNum = 1	Variable dispWaveListIndex =   9 +     componentNum		Display/N=$winN /K=1	winN = S_name	Variable i, plot1, plot2, firstAppended = 1, currLen; String currNoteStr, currPosStr, currTN	for (i=0;i<DimSize(cpSummaryIndex,0);i+=1)		currNoteStr = cpSummaryIndex[i][9]		currPosStr = cpSummaryIndex[i][2]		plot1 = stringmatch(currNoteStr, "*use*")		plot2 = stringmatch(currPosStr, matchStr)		if (plot1 && plot2)			currTN = SI_getRefFromDispW(i, modelNum, dispWaveListIndex)			AppendToGraph/W=$winN/L=$("L" + cpSummaryIndex[i][0] + matchStr)/C=(39168,13056,0) $currTN			//dark orange for short axons			//offset to 0			ModifyGraph offset($currTN) = {-DimOffset($currTN,0),0}			 			if (firstAppended)				disp_defaultRange()				firstAppended = 0				modifygraph noLabel($("L" + cpSummaryIndex[i][0] + matchStr))=1				Label $("L" + cpSummaryIndex[i][0] + matchStr), winN + " (norm. to peak)"			else				modifygraph noLabel($("L" + cpSummaryIndex[i][0] + matchStr))=2;			endif			ModifyGraph tick($("L" + cpSummaryIndex[i][0] + matchStr))=3; DelayUpdate			ModifyGraph axRGB($("L" + cpSummaryIndex[i][0] + matchStr))=(65535,65535,65535)			Setaxis/A=2 $("L" + cpSummaryIndex[i][0] + matchStr)			currLen = str2num(cpSummaryIndex[i][12])			if (currLen > 100)				modifygraph rgb($currTN)=(0,0,39168)			endif		endif	endfor	modifygraph lblpos = 45, freepos=0	setAxis/A end//plot normalized to peak of main wavefunction SI_plotCol_normToPeakSepGraph(normToTrough, mainTraceWinN, winN, doPed, modelNum, componentNum)	String winN, mainTraceWinN; Variable doPed,componentNum, modelNum, normToTrough		WAVE/T cpSummaryIndex	Variable timeDisplayedBeforeStep = 0.073475 - 0.073258	if (normToTrough)		timeDisplayedBeforeStep =0	endif		Variable timeDisplayedAfterStep = 0.01 //0.08300 - 0.073475		String matchStr = "S"	if (doPed)		matchStr = "P"	endif		Variable dispWaveListIndex =   9 +     componentNum		Display/N=$mainTraceWinN/K=1	mainTraceWinN = S_name	Display/N=$winN /K=1	winN = S_name		winN = S_name	Variable i, plot1, plot2, currFitStart, firstAppended = 1, currLen; String currNoteStr, currPosStr, currMainWinTN,  currAxisN, currCompWinTN	for (i=0;i<DimSize(cpSummaryIndex,0);i+=1)		currNoteStr = cpSummaryIndex[i][9]		currPosStr = cpSummaryIndex[i][2]		plot1 = stringmatch(currNoteStr, "*use*")		plot2 = stringmatch(currPosStr, matchStr)		if (plot1 && plot2)			currCompWinTN = SI_getRefFromDispW(i, modelNum, dispWaveListIndex)			currFitStart = DimOffset($currCompWinTN,0)			currMainWinTN = cpSummaryIndex[i][1]			currAxisN = "L" + cpSummaryIndex[i][0] + matchStr			AppendToGraph/W=$mainTraceWinN/L=$currAxisN/C=(39168,13056,0) $currMainWinTN	//dark orange for short axons			ModifyGraph/W=$mainTraceWinN offset($currMainWinTN) = {-currFitStart,0}			//sets start to 0									SetAxis/W=$mainTraceWinN bottom -timeDisplayedBeforeStep ,timeDisplayedAfterStep			SetAxis/W=$mainTraceWinN/A=2 $currAxisN; doupdate			GetAxis/Q/W=$mainTraceWinN $currAxisN						AppendToGraph/W=$winN/L=$currAxisN/C=(39168,13056,0) $currCompWinTN			//dark orange for short axons			ModifyGraph/W=$winN offset($currCompWinTN) = {-currFitStart,0}			//sets start to 0						SetAxis/W=$winN bottom -timeDisplayedBeforeStep ,timeDisplayedAfterStep			SetAxis/W=$winN $currAxisN V_min, V_max			if (firstAppended)				firstAppended = 0				modifygraph/W=$mainTraceWinN noLabel($currAxisN)=1				Label/W=$mainTraceWinN $currAxisN, winN + " (norm. to peak)"				modifygraph/W=$winN noLabel($currAxisN)=1				Label/W=$winN $currAxisN, winN + " (norm. to peak)"							else				modifygraph/W=$mainTraceWinN noLabel($currAxisN)=2;				modifygraph/W=$WinN noLabel($currAxisN)=2;			endif			ModifyGraph/W=$mainTraceWinN tick($currAxisN)=3; DelayUpdate			ModifyGraph/W=$mainTraceWinN axRGB($currAxisN)=(65535,65535,65535)			ModifyGraph/W=$winN tick($currAxisN)=3; DelayUpdate			ModifyGraph/W=$winN axRGB($currAxisN)=(65535,65535,65535)			currLen = str2num(cpSummaryIndex[i][12])			if (currLen > 100)				modifygraph/W=$mainTraceWinN rgb($currMainWinTN)=(0,0,39168)				modifygraph rgb($currCompWinTN)=(0,0,39168)			endif		endif	endfor	modifygraph/W=$mainTraceWinN lblpos = 45, freepos=0, width=72*4, height=72*2	modifygraph/W=$winN lblpos = 45, freepos=0, width=72*4, height=72*2	endfunction/S SI_getParamByKey(cellName, doPed, keyStr, [index])	String cellName, keyStr; Variable doPed, &index		Variable siteMatchCol = 2, cellNameCol = 0, paramsCol = 10	 WAVE/T cpSummaryIndex	String siteMatchStr = "S"	if (doPed)		siteMatchStr="P"	endif			Variable i, count; String currList	for (i=0;i<DimSize(cpSummaryIndex, 0);i+=1)		if ( stringmatch(cpSummaryIndex[i][siteMatchCol], siteMatchStr) && stringmatch(cpSummaryIndex[i][cellNameCol], cellName) )			if (!ParamIsDefault(index))				index = i			endif			currList = cpSummaryIndex[i][paramsCol]			return StringByKey(keyStr, currList)		endif	endfor		if (!ParamIsDefault(index))		index = -1	endif		return ""endfunction/S SI_getCompParam(cellName, doPed, modelNum, compNum, paramNum)	String cellName; Variable doPed, modelNum, compNum, paramNum		String keyStr = "m" + num2str(modelNum) + "_" + "c" + num2str(compNum) + "(a,t,c,r)"	String compStr = SI_getParamByKey(cellName, doPed, keyStr)		return StringFromList(paramNum, compStr, ",")end//function SI_displayVsLen (somaW, pedW, winN, doSoma, doPed)//	String winN//	WAVE somaW, pedW//	Variable doSoma, doPed//	//	WAVE SI_lens, binsXaxis, shortBin, longBin////	Display/K=1/N=$winN //	winN=S_name//	if (doSoma)//	AppendToGraph/C=(0,0,0) somaW vs SI_lens//	endif//	if (doPed)//	AppendToGraph pedW vs SI_lens//	endif//	//	WAVE binsXaxis//	Make/D/O/N=1 somaW_short_avg_temp, somaW_long_avg_temp, pedW_short_avg_temp, pedW_long_avg_temp//	somaW_short_avg_temp=0; somaW_long_avg_temp=0; pedW_short_avg_temp=0; pedW_long_avg_temp=0//	Variable i, shortCount_S = 0, longCount_S = 0, shortCount_P, longCount_P //	for (i=0; i< DimSize(somaW, 0);i+=1)//		if (binsXaxis[i] < 0)		//then a short cone//			if (numtype(somaW[i]) == 0)//				shortCount_S += 1//				somaW_short_avg_temp += somaW[i]//			endif//			if (numtype(pedW[i]) == 0)//				shortCount_P += 1//				pedW_short_avg_temp += pedW[i]//			endif//		else						//long cone//			if (numtype(somaW[i]) == 0)//				longCount_S += 1//				somaW_long_avg_temp += somaW[i]//			endif//			if (numtype(pedW[i]) == 0)//				longCount_P += 1//				pedW_long_avg_temp += pedW[i]//			endif			//		endif//	endfor//	Print "soma short total = " + num2str(shortCount_S)//	Print "ped short total = " + num2str(shortCount_P)//	Print "soma long total = " + num2str(longCount_S)//	Print "ped long total = " + num2str(longCount_P)//	somaW_short_avg_temp /= shortCount_S//	pedW_short_avg_temp /= shortCount_P//	somaW_long_avg_temp /= longCount_S//	pedW_long_avg_temp /= longCount_P//	Print "soma short total = " + num2str(somaW_short_avg_temp[0])//	Print "ped short total = " + num2str(pedW_short_avg_temp[0])//	Print "soma long total = " + num2str(somaW_long_avg_temp[0])//	Print "ped long total = " + num2str(pedW_long_avg_temp[0])//	String somaSNShort_avg= NameOfWave(somaW) + "_short" + "_avg"//	String somaSNLong_avg = NameOfWave(somaW) + "_long" + "_avg"//	String pedSNShort_avg = NameOfWave(pedW) + "_short" + "_avg"//	String pedSNLong_avg = NameOfWave(pedW) + "_long" + "_avg"//	Duplicate/O somaW_short_avg_temp, $somaSNShort_avg//	Duplicate/O somaW_long_avg_temp, $somaSNLong_avg//	Duplicate/O pedW_short_avg_temp, $pedSNShort_avg//	Duplicate/O pedW_long_avg_temp, $pedSNLong_avg//	KillWaves/Z somaW_short_temp, somaW_long_temp, pedW_short_temp, pedW_long_temp////	if (doSoma)//		AppendToGraph/B=bottom2/C=(0,0,0) somaW/TN=$(NameOfWave(somaW) + "_binned") vs binsXaxis//	endif//	if (doPed)//		AppendToGraph/B=bottom2 pedW/TN=$(NameOfWave(pedW) + "_binned") vs binsXaxis//	endif//	ModifyGraph mode=3, marker=19//	//	if (doSoma)//		AppendToGraph/B=bottom2/C=(0,0,0) $somaSNShort_avg/TN=short_avg_S vs shortBin//		ModifyGraph rgb(short_avg_S) = (0,0,0), mode=3, marker(short_avg_S)=7, mrkStrokeRGB(short_avg_S)=(0,0,0)//		AppendToGraph/B=bottom2/C=(0,0,0) $somaSNLong_avg/TN=long_avg_S vs longBin//		ModifyGraph mode=3, marker(long_avg_S)=7 , mrkStrokeRGB(long_avg_S)=(0,0,0)//	endif////	if (doPed)//		AppendToGraph/B=bottom2 $pedSNShort_avg/TN=short_avg_P vs shortBin//		ModifyGraph mode=3, marker(short_avg_P)=7, mrkStrokeRGB(short_avg_P)=(65280,0,0)//		AppendToGraph/B=bottom2 $pedSNLong_avg/TN=long_avg_P vs longBin//		ModifyGraph mode=3, marker(long_avg_P)=7, mrkStrokeRGB(long_avg_P)=(65280,0,0)//	endif//////	ModifyGraph tick(bottom2)=3,noLabel(bottom2)=2,axisEnab(bottom)={0,0.75};DelayUpdate//	ModifyGraph axisEnab(bottom2)={0.9,1},freePos(bottom2)=0; doupdate//	//adjust window://	Label left winname(0,1)[3,strlen(winName(0,1))] +"    \f01\U"; Modifygraph height=1.5*72, width=2*72; GetAxis/Q left; SetAxis left, 0, V_max//end	function addConstLine(gName, vertAxName, bottomAxName, constVal, [isRightVertAxis])	String gName, vertAxName, bottomAxName; Variable constVal, isRightVertAxis		dowindow gName		String constLineN = winname(0,1) + "_cLine"		//used in making constant wave		Make/O/D/N=(2,2) tempLine		//will be displayed col 0 vs col 1	//col 0	tempLine[0][0] = constVal	tempLine[1][0] = constVal		//col 1	tempLine[0][1] = -inf	tempLine[1][1] = inf		Duplicate/O tempLine, $constLineN		GetAxis/Q $vertAxName	Variable currV_min = V_min	Variable currV_max = V_max	GetAxis/Q $bottomAxName	Variable currB_min = V_min	Variable currB_max= V_max		if (!ParamIsDefault(isRightVertAxis) && isRightVertAxis)		AppendToGraph/R=$vertAxName/B=$bottomAxName $constLineN[][0] vs $constLineN[][1]	else		AppendToGraph/L=$vertAxName/B=$bottomAxName $constLineN[][0] vs $constLineN[][1]	endif	String finalTN = getLastTraceAdded("")	SetAxis $vertAxName, currV_min, currV_max	SetAxis $bottomAxName, currB_min, currB_max	ModifyGraph lstyle($finalTN)=7	ModifyGraph rgb($finalTN)=(21760,21760,21760)		Print "constLineRef = " + constLineNendfunction/S getLastTraceAdded(graphN)		//pass "" for top graph	String graphN	String traceList = TraceNameList(graphN, ";",1)	String finalTN = StringFromList(ITemsInList(traceList)-1, traceList)		return finalTNendfunction SI_update(startRow)	Variable startRow		WAVE/T cpSummaryIndex	Variable i	for (i=startRow; i< DimSize(cpSummaryIndex,0);i+=1)		SI_quickcellparams(i)	endforendfunction SI_getBestFitSlowTau(row, fastestTau)	Variable row, fastestTau		//0 for slowest tau, 1 for fastest tau		Variable bestFitModelNum = SI_getParamByKey2(row, "ccG", "lastPassingModel")		WAVE/T cpSummaryIndex	if (stringmatch(cpSummaryIndex[row][3], "*G15120201_0002*"))		bestFitModelNum = 1		//special case where fit found a very slow component that's barely above noise floor but does better than 2 component, just for this cell at soma (which file 0002 is)	endif		Variable componentNum	if (fastestTau)		componentNum = 0		//always sorted fastest to slowest	else		componentNum = bestFitModelNum		//model num is equal to number of last component in number, e.g. model1 has two components, #0 and #1	endif		String itemStr = "m" + num2str(bestFitModelNum) + "_c" + num2str(componentNum) + "_tau"		return SI_getParamByKey2(row, "ccW", itemStr)endfunction/S getWaveListFromAvgNote(waveRef)	String waveRef		String noteStr = note($waveRef)			String findStr = "AVG: "			Variable startIndex = strsearch(noteStr, findStr,0)	if (startIndex > -1)		//found, so this is an old form of the avg wave note				startIndex += strlen(findStr)		Variable endIndex = strsearch(noteStr, ",;",startIndex)				String outStr = noteStr[startIndex, endIndex]		outStr = ReplaceString(",", outStr, ";" )		return outStr	elseif (stringmatch(noteStr,"*AVG:*"))		//no format with no space after AVG:		return ReplaceString(",",StringByKey("AVG", noteStr),";")	else		Print "Could not find list of waves from which avg was generated for (putative) avg wave:", waveRef		return ""	endif				endfunction/S replaceSiteCurrWithOppCurr(refsList)	String refsList		String replaceStr = "AD", finalStr = "AD"; Variable finalPos	String exampleRef = StringFromList(0, refsList)	Print "exampleRef",exampleRef	Print "exampleRef[strlen(exampleRef)-1, strlen(exampleRef)-1]",exampleRef[strlen(exampleRef)-1, strlen(exampleRef)-1]	Variable currPos = str2num(exampleRef[strlen(exampleRef)-1, strlen(exampleRef)-1])	Print "currPos",currPos//	Variable origSite = currPos < 2 ? 0 : 1			//hs 0 or hs 1 (left or right)	if (currPos == 0)		finalPos = 2	else	//currPos should = 2		finalPos = 0	endif	replaceStr += num2str(currPos)	finalStr += num2str(finalPos)		String outStr = ReplaceString(replaceStr, refsList, finalStr)	Print "outStr", outStr	return outStrendfunction/S replaceSiteCurrWithOppCmd(refsList)	String refsList		String replaceStr = "AD", finalStr = "AD"; Variable finalPos	String exampleRef = StringFromList(0, refsList)	Print "exampleRef",exampleRef	Print "exampleRef[strlen(exampleRef)-1, strlen(exampleRef)-1]",exampleRef[strlen(exampleRef)-1, strlen(exampleRef)-1]	Variable currPos = str2num(exampleRef[strlen(exampleRef)-1, strlen(exampleRef)-1])	Print "currPos",currPos//	Variable origSite = currPos < 2 ? 0 : 1			//hs 0 or hs 1 (left or right)	if (currPos == 0)		finalPos = 3	else	//currPos should = 2		finalPos = 1	endif	replaceStr += num2str(currPos)	finalStr += num2str(finalPos)		String outStr = ReplaceString(replaceStr, refsList, finalStr)	Print "outStr",outStr	return outStrend//set of functions that will calculate average etc to find time constant for second site responsefunction SI_updateI0SiteResponse_all()	WAVE/T cpSummaryIndex	Duplicate/O cpSummaryIndex, cpSummaryIndex_BU	cpSummaryIndex[][15] = getWaveListFromAvgNote(cpSummaryIndex[p][1])		//finds list of waves for current response to vclamp command	cpSummaryIndex[][16] = replaceSiteCurrWithOppCurr(cpSummaryIndex[p][15])	//finds list of waves for response at other site	cpSummaryIndex[][17] = wave_avgFromStrList(cpSummaryIndex[p][16],";","",0,nan,nan,killAfterAvg=1)		//generates average from that latter list, regardless of whether waves were loaded (may need to update file directory)	cpSummaryIndex[][18] = cpSummaryIndex[p][17]  +"vrf0"	SI_fitTerminalVoltages2(1)end//set of functions that will calculate average etc to find time constant for second site responsefunction SI_updateI0SiteResponse_row(row, useHsListCmdTiming)	Variable row, useHsListCmdTiming		WAVE/T cpSummaryIndex	Duplicate/O cpSummaryIndex, cpSummaryIndex_BU		cpSummaryIndex[row][15] = replaceSiteCurrWithOppCurr(getWaveListFromAvgNote(cpSummaryIndex[p][1]))	//finds list of waves for response at other site	cpSummaryIndex[row][16] = wave_avgFromStrList(cpSummaryIndex[p][15],";","",0,nan,nan)		//generates average from that latter list, regardless of whether waves were loaded (may need to update file directory)	cpSummaryIndex[row][17] = cpSummaryIndex[p][16]  +"vrf0"	cpSummaryIndex[row][18] =  cpSummaryIndex[p][1]  + "vrP"			//	cpSummaryIndex[row][15] = getWaveListFromAvgNote(cpSummaryIndex[p][1])		//finds list of waves for current response to vclamp command//	cpSummaryIndex[row][16] = replaceSiteCurrWithOppCurr(cpSummaryIndex[p][15])	//finds list of waves for response at other site//	cpSummaryIndex[row][17] = wave_avgFromStrList(cpSummaryIndex[p][16],";","",killAfterAvg=0)		//generates average from that latter list, regardless of whether waves were loaded (may need to update file directory)//	cpSummaryIndex[row][18] =  cpSummaryIndex[rowNum][1]  + "vrP"		//	SI_fitTerminalVoltages2(useHsListCmdTiming, row=row)	SI_vresp_analysis(row)end//use to pick particular waves. have top graph have soma waves of interestfunction SI_vresp_addSite(rowNum, usePreExistingRow, ccRespMatchStr, vClampAtPed, hsListRow)	Variable rowNum	Variable usePreExistingRow		//if sweeps are to go unchanged from those originally selected for cap transient analysis, pass 1 for this and rowNum of original row, otherwise new row filled in	String ccRespMatchStr	Variable vClampAtPed					//site of voltage clamp. only used if usePreExistingRow = 1. Usually this experiment is performed "from soma"	Variable hsListRow					//also only used if 	usePreExistingRow = 1.	WAVE/T cpSummaryIndex	//	Variable matchNum = str2num(ccRespMatchStr)//	Variable pedMatchNum = matchNum == 2 ? 0 : 2 		Duplicate/O cpSummaryIndex, cpSummaryIndex_BU		cpSummaryIndex[rowNum][15] = wavelist(ccRespMatchStr, ";", "WIN:")		//takes from top graph	cpSummaryIndex[rowNum][16] = wave_avgFromStrList(cpSummaryIndex[rowNum][15],";","",0,nan,nan,killAfterAvg=1)		//generates average from that latter list, regardless of whether waves were loaded (may need to update file directory)	cpSummaryIndex[rowNum][17] = cpSummaryIndex[rowNum][16]  +"vrf0"//	cpSummaryIndex[rowNum][18] = cpSummaryIndex[rowNum][1]  + "vrP"		//up here to group with these, but this is filled in below in case its a newly filled in row		//19 is reserved! 20 is also reserved!	cpSummaryIndex[rowNum][21] = num2str(usePreExistingRow)		//stores that there is a vresp to analyze here. blank is no response to analyze, 0 is response but from new set of waves compared to those used for cpParams, 1 is preExisting cpParams (Save set of waves used for both)		if (!usePreExistingRow)	//then cell params has to be calculated for new set of sweeps selected for somatic response		String capTransientRefsList =  replaceSiteCurrWithOppCurr(cpSummaryIndex[rowNum][15])	//finds list of waves for response at other site		cpSummaryIndex[rowNum][1] = wave_avgFromStrList(capTransientRefsList,";","",0,nan,nan)		cpSummaryIndex[rowNum][0] = StringFromList(0,getFileNameFromWaveName(StringFromList(0,capTransientRefsList), 1))[1,inf]		cpSummaryIndex[rowNum][14] = num2str(hsListRow)		SI_insertRefs(rowNum)		SI_quickCellParams(rowNum)		if (vClampAtPed)			cpSummaryIndex[rowNum][2] = "P"		else			cpSummaryIndex[rowNum][2] = "S"		endif	endif		cpSummaryIndex[rowNum][18] = cpSummaryIndex[rowNum][1]  + "vrP"		//vresp params save refend//Make/O/D/N=(DimSize(cpSummaryIndex,0), numFitParams) SI_voltageResponseFits//get started with SI_vresp_addSitefunction SI_vresp_analysis(row)	Variable row		Variable fitWinSize = 0.01 		//size of fit window	Variable ssAvgWinSize = 0.001	//size of window for trace averaging determing baseline and steady state balues	debug_checkRTErrState(msg="aaaaaaaa000000000000")	WAVE/T cpSummaryIndex	String ccRespRef = cpSummaryIndex[row][16]; WAVE/D ccResp = $ccRespRef	String ccRespFitSaveRef = cpSummaryIndex[row][17]//	String vcmdRef = SI_getCmdRef_S(row)		String ccRespParamsSaveRef = cpSummaryIndex[row][18]	String genParamsRef = cpSummaryIndex[row][3]	analysis_getGenParamsHeader(0)	Variable vCmd_t0 = getParamFromHeader_1D("vCmd_t0", "genParamsHeader", genParamsRef)	Variable vCmd_t1 = getParamFromHeader_1D("vCmd_t1", "genParamsHeader", genParamsRef)	Variable vCmdBaseline = getParamFromHeader_1D("vCmd_baseline", "genParamsHeader", genParamsRef)	Variable vCmdStep = getParamFromHeader_1D("vCmd_step", "genParamsHeader", genParamsRef)	Variable deltaVCmd = vCmdStep - vCmdBaseline	Variable baseMeanStartX = getParamFromHeader_1D("baseMeanStartX", "genParamsHeader", genParamsRef)	Variable baseMeanEndX = getParamFromHeader_1D("baseMeanEndX", "genParamsHeader", genParamsRef)	Variable ssMeanStartX = vCmd_t0 + fitWinSize - ssAvgWinSize	Variable ssMeanEndX = vCmd_t0 + fitWinSize 		debug_checkRTErrState(msg="000000000000")		Variable isNegativeGoing = (deltaVCmd < 0)	Variable edgeType = isNegativeGoing ? 2 : 1		Variable ccBaselineMean = mean(ccResp, baseMeanStartX, baseMeanEndX)	Wavestats/R=(ssMeanStartX, ssMeanEndX) ccResp	Variable ccSSMean = V_avg	Variable ccSS_stdev = V_sdev	Variable ccDelta = ccSSMean - ccBaselineMean	//some params of interest	Variable ccVcmdDiff = ccDelta - deltaVCmd			//how much is current clamp response off from v cmd?	Variable ccVcmdRatio = ccDelta / deltaVCmd		//ratio between values?	Variable deltaSSCurrent = getParamFromHeader_1D("deltaSSCurrent", "genParamsHeader", genParamsRef)	Variable effectiveRes = ccDelta / deltaSSCurrent		//effective resistance, what is the steady state current input value and what change is this driving in the other site, at steady state		//proportions to test as response threshold crossings for intial portion of response	Make/O/D/N=7 testProportionsForStart, testThreshLevelsForStart, thresholdCrossingX			Variable usedPropForFitStart = 0.05		//proportion of total change that at which fit will start, keep this low as possible	testProportionsForStart[0] = usedPropForFitStart	testProportionsForStart[1] = 0.01	testProportionsForStart[2] = 0.02	testProportionsForStart[3] = 0.1	testProportionsForStart[4] = 0.5	testProportionsForStart[5] = 2	testProportionsForStart[6] = 4		testThreshLevelsForStart[0,4] = ccBaselineMean + ( ccDelta * testProportionsForStart[p] )	testThreshLevelsForStart[5,6] = ccBaselineMean + ( (isNegativeGoing ? -1 : 1)*ccSS_stdev*testProportionsForStart[p] )		Variable i, currThresholdVal	for (i=6;i>-1;i-=1)		//go down so that first is last, this is the one that we will show a fit for		currThresholdVal = testThreshLevelsForStart[i]		FindLevel/EDGE=(edgeType)/R=(vCmd_t0, vCmd_t1)/Q ccResp, currThresholdVal		debug_checkRtErrState(msg="Error after FindLevel in SI_vresp_analysis(). Possible that level was not found (threshold index =" + num2str(i) + ", in which case level is stored at NaN")		thresholdCrossingX[i] = V_flag ? NaN : V_levelX 			//make value NaN if level not found	endfor	debug_checkRTErrState(msg="111111111111111")		//further analysis for first proportion threshold	Variable foundLevelX_fitStartX = V_levelX	Variable fitEndX = foundLevelX_fitStartX + fitWinSize		//instantiate to get info on fit failures: Variable V_fitQuitReason	Make/O/D/N=3 singleExpCoefs; Make/O/D/N=5 dblExpCoefs	CurveFit/N=1/Q/W=2 exp_XOffset, kwCWave=singleExpCoefs, ccResp[x2pnt(ccResp, foundLevelX_fitStartX), x2pnt(ccResp, fitEndX)]	analysis_sortExpCoefWave(singleExpCoefs)		CurveFit/N=1/Q/W=2 dblexp_XOffset, kwCWave=dblExpCoefs, ccResp[x2pnt(ccResp, foundLevelX_fitStartX), x2pnt(ccResp, fitEndX)]	analysis_sortExpCoefWave(dblExpCoefs)			//try a 3 component exponential fit as well just in case	Make/O/D/N=7 triExpCoefs	triExpCoefs[0,4] = dblExpCoefs[p]	triExpCoefs[5,6] = dblExpCoefs[p-2]		//initial guess for last amp and tau equal to second component from double exponential, to start with	Variable/G x0 = foundLevelX_fitStartX		//have to set this globally so that funcFit knows what to use as x0	FuncFit/NTHR=0/W=2/N=1/Q=1 myExp, triExpCoefs, ccResp[x2pnt(ccResp, foundLevelX_fitStartX), x2pnt(ccResp, fitEndX)]	analysis_sortExpCoefWave(triExpCoefs)  	debug_checkRTErrState(msg="2222222222222")		//stats_ftest_exp(origWaveRef, simplerCoefRef, moreComplexCoefRef, outParamsRef, fitStartX, fitEndX)	stats_ftest_exp(ccRespRef, "singleExpCoefs", "dblExpCoefs", "cc_fTestExp_singleDbl", foundLevelX_fitStartX, fitEndX)		//compare sinle and dbl exponential	stats_ftest_exp(ccRespRef, "dblExpCoefs", "triExpCoefs", "cc_fTestExp_dblTri", foundLevelX_fitStartX, fitEndX)		//compare dbl and tri exponential 		//compare 2 vs 3	debug_checkRTErrState(msg="333333333333333333")		Variable ftest_signifThresh = 0.05	String ftest_headerRef = stats_getFTestHeader()	Variable fstat_singleDbl = getParamFromHeader_1D("f_pval", ftest_headerRef, "cc_fTestExp_singleDbl")	Variable fstat_dblTri = getParamFromHeader_1D("f_pval", ftest_headerRef, "cc_fTestExp_dblTri")	Variable lastPassingModel	if ( !numtype(fstat_singleDbl) && (fstat_singleDbl < ftest_signifThresh) )		//first model passes, determine if second does too		if ( !numtype(fstat_dblTri) && (fstat_dblTri < ftest_signifThresh) )			lastPassingModel = 2		else 	//first model passes but second doesnt			lastPassingModel = 1		endif	else		//first model fails		lastPassingModel = 0	endif		//	Variable lastJustifiedModel = (fstat_singleDbl > ftest_signifThresh) ? 0 : ( (fstat_dblTri > ftest_signifThresh) ? 1 : 2 )		//if p < threshold, then check if p < threshold for dbltri		Variable resFromVC = getParamFromHeader_1D("ssRin", "genParamsHeader", genParamsRef)	Variable iClampCap_resFromVC = singleExpCoefs[2] / resFromVC		//uses vclamp input resistance as resistance	Variable iClampCap_effectiveRes = singleExpCoefs[2] / effectiveRes	//uses effective resistance as resistance: change of current at steady state (At soma) to put terminal at steady state voltage change		debug_checkRTErrState(msg="444444444444ddddddddddddddddd")		getExpFit(ccRespFitSaveRef, "singleExpCoefs", ccRespRef,  foundLevelX_fitStartX, fitEndX, -1)		debug_checkRTErrState(msg="444444444444aaaaaaaaaaaaaa")		Redimension/N=4 singleExpCoefs;  singleExpCoefs[3] = x0	Redimension/N=6 dblExpCoefs;  dblExpCoefs[5] = x0	Redimension/N=8 triExpCoefs;  triExpCoefs[7] = x0		debug_checkRTErrState(msg="444444444444ccccccccccccccccccccccccc")	//	getExpFit(outWaveRef, coefWaveRef, waveThatWasFitRef, fitStartX, fitEndX, componentNum		Variable numParams = 21	Make/O/D/N=(numParams) SI_vresp_paramsTemp		SI_vresp_paramsTemp[0] = fitWinSize	SI_vresp_paramsTemp[1] = baseMeanStartX	SI_vresp_paramsTemp[2] = baseMeanEndX	SI_vresp_paramsTemp[3] = ssAvgWinSize	SI_vresp_paramsTemp[4] = ssMeanStartX	SI_vresp_paramsTemp[5] = ssMeanEndX	SI_vresp_paramsTemp[6] = isNegativeGoing	SI_vresp_paramsTemp[7] = ccBaselineMean	SI_vresp_paramsTemp[8] = ccSSMean	SI_vresp_paramsTemp[9] = ccSS_stdev	SI_vresp_paramsTemp[10] = ccDelta	SI_vresp_paramsTemp[11] = ccVcmdDiff	SI_vresp_paramsTemp[12] = ccVcmdRatio	SI_vresp_paramsTemp[13] = deltaSSCurrent	SI_vresp_paramsTemp[14] = effectiveRes	SI_vresp_paramsTemp[15] = foundLevelX_fitStartX	SI_vresp_paramsTemp[16] = fitEndX	SI_vresp_paramsTemp[17] = ftest_signifThresh	SI_vresp_paramsTemp[18] = lastPassingModel	SI_vresp_paramsTemp[19] = iClampCap_resFromVC	SI_vresp_paramsTemp[20] = iClampCap_effectiveRes		debug_checkRTErrState(msg="444444444444")	Print "iclamp tau=" + num2str(singleExpCoefs[2]) + ". amp=" + num2str(singleExpCoefs[1]) + ". iClampCap_resFromVC=" + num2str(iClampCap_resFromVC) + ". iClampCap_effectiveRes=" + num2str(iClampCap_effectiveRes)	Concatenate/NP/O/Kill {SI_vresp_paramsTemp, singleExpCoefs, dblExpCoefs, triExpCoefs, testProportionsForStart, testThreshLevelsForStart, thresholdCrossingX, $"cc_fTestExp_singleDbl", $"cc_fTestExp_dblTri"}, $ccRespParamsSaveRefendfunction/S SI_getVrespHeader()	String headerRef = "vRespHeader"		Variable numParams = 21	Make/O/T/N=(numParams) vRespHeaderTemp	vRespHeaderTemp[0] = "fitWinSize"	vRespHeaderTemp[1] = "baseMeanStartX"	vRespHeaderTemp[2] = "baseMeanEndX"	vRespHeaderTemp[3] = "ssAvgWinSize"	vRespHeaderTemp[4] = "ssMeanStartX"	vRespHeaderTemp[5] = "ssMeanEndX"	vRespHeaderTemp[6] = "isNegativeGoing"	vRespHeaderTemp[7] = "ccBaselineMean"	vRespHeaderTemp[8] = "ccSSMean"	vRespHeaderTemp[9] = "ccSS_stdev"	vRespHeaderTemp[10] = "ccDelta"	vRespHeaderTemp[11] = "ccVcmdDiff"	vRespHeaderTemp[12] = "ccVcmdRatio"	vRespHeaderTemp[13] = "deltaSSCurrent"	vRespHeaderTemp[14] = "effectiveRes"	vRespHeaderTemp[15] = "foundLevelX_fitStartX"	vRespHeaderTemp[16] = "fitEndX"	vRespHeaderTemp[17] = "ftest_signifThresh"	vRespHeaderTemp[18] = "lastPassingModel"	vRespHeaderTemp[19] = "iClampCap_resFromVC"	vRespHeaderTemp[20] = "iClampCap_effectiveRes"		Make/O/T singleExpHeader = {"singleExp_y0", "singleExp_amp_c0", "singleExp_tau_c0", "singleExp_x0"}	Make/O/T dblExpHeader = {"dblExp_y0", "dblExp_amp_c0", "dblExp_tau_c0", "dblExp_amp_c1", "dblExp_tau_c1", "dblExp_x0"}	Make/O/T triExpHeader = {"triExp_y0", "triExp_amp_c0", "triExp_tau_c0", "triExp_amp_c1", "triExp_tau_c1",  "triExp_amp_c2", "triExp_tau_c2", "triExp_x0"}		Make/O/T/N=7 testProportionsForStart_H, testThreshLevelsForStart_H, thresholdCrossingX_H			Variable usedPropForFitStart = 0.05		//proportion of total change that at which fit will start, keep this low as possible	testProportionsForStart_H[0] = "usedPropForFitStart"	testProportionsForStart_H[1] = "prop1"	testProportionsForStart_H[2] = "prop1"	testProportionsForStart_H[3] = "prop1"	testProportionsForStart_H[4] = "prop1"	testProportionsForStart_H[5] = "threshBySDMultiplier0"	testProportionsForStart_H[6] = "threshBySDMultiplier1"	testThreshLevelsForStart_H = testProportionsForStart_H[p] + "_level"	thresholdCrossingX_H = testProportionsForStart_H[p] + "_XFound"		Duplicate/O/T $stats_getFTestHeader(), singleDblFTest_H, dblTriFTest_H	singleDblFTest_H += "_singleDbl"	dblTriFTest_H += "_dblTri"		Concatenate/NP/O/Kill/T {vRespHeaderTemp, singleExpHeader, dblExpHeader, triExpHeader, testProportionsForStart_H, testThreshLevelsForStart_H, thresholdCrossingX_H, singleDblFTest_H,dblTriFTest_H}, $headerRef//used:Concatenate/NP/O {SI_vresp_paramsTemp, singleExpCoefs, dblExpCoefs, triExpCoefs, testProportionsForStart, testThreshLevelsForStart, thresholdCrossingX, $"cc_fTestExp_singleDbl", $"cc_fTestExp_dblTri"}, $ccRespParamsSaveRef		return headerRefend//assumes fit wave only covers the range that is of interest for residual calculation -- would have to rewrite for variable boundsfunction stats_ftest(dataWv, simpleFitWv, complexFitWv, numFP_simple, numFP_complex, outParamsRef)	WAVE dataWv, simpleFitWv, complexFitWv; Variable numFP_simple, numFP_complex	//num free params for each model	String outParamsRef		//get residuals info	stats_residualInfo2(dataWv, simpleFitWv, numFP_simple, "simpleFit_resInfo")	stats_residualInfo2(dataWv, simpleFitWv, numFP_complex, "complexFit_resInfo")		//get stats needed for f score (generated by resInfo function)	String statsHeaderRef = "stats_resInfoHeader"	if (!WaveExists($statsHeaderRef))		stats_getResInfoHeader()	endif	Variable ss_res_simple = getParamFromHeader_1D("ss_res", statsHeaderRef, "simpleFit_resInfo")	Variable ss_res_complex = getParamFromHeader_1D("ss_res", statsHeaderRef, "complexFit_resInfo")	Variable df_simple = getParamFromHeader_1D("numCoefs", statsHeaderRef, "simpleFit_resInfo")	Variable df_complex = getParamFromHeader_1D("numCoefs", statsHeaderRef, "complexFit_resInfo")	Variable df_difference = df_complex - df_simple	Variable df_ss_res_complex = getParamFromHeader_1D("ss_res_degFreedom", statsHeaderRef, "complexFit_resInfo")	Variable f_denom = getParamFromHeader_1D("meanOfResiduals", statsHeaderRef, "complexFit_resInfo")			//calculate f stat	Variable f_numer = (ss_res_simple - ss_res_complex) / (df_difference) //f test numerator: (ss_Res_reduced - ss_Res_full) / (df_full - df_reduced). demoniator calculated in resInfo	Variable f_stat = f_numer / f_denom	Variable f_pval =  1 - StatsFCDF(f_stat, df_difference, df_ss_res_complex) 		//p value: f score, difference in free params, d.f. for sum of squares of residuals?		//additional useful calculations	Variable ss_res_difference = ss_res_complex - ss_res_simple	Variable ss_res_foldChange = ss_res_complex / ss_res_simple	Variable r2_simple = getParamFromHeader_1D("r2", statsHeaderRef, "simpleFit_resInfo")	Variable r2_complex = getParamFromHeader_1D("r2", statsHeaderRef, "complexFit_resInfo")	Variable r2_difference = r2_complex - r2_simple	Variable r2_foldChange = r2_complex / r2_simple			Variable numFTestParams = 7	Make/O/D/N=(numFTestParams) stats_ftest_outTemp	stats_ftest_outTemp[0] = f_numer	stats_ftest_outTemp[1] = f_stat	stats_ftest_outTemp[2] = f_pval	stats_ftest_outTemp[3] = ss_res_difference	stats_ftest_outTemp[4] = ss_res_foldChange	stats_ftest_outTemp[5] = r2_difference	stats_ftest_outTemp[6] = r2_foldChange			Concatenate/NP=0/O {stats_ftest_outTemp, $"simpleFit_resInfo", $"complexFit_resInfo"}, $outParamsRef //use stats_GetFTestHeader()end//assumes fit wave only covers the range that is of interest for residual calculation -- would have to rewrite for variable boundsfunction stats_residualInfo2_LH(dataWv, fitWv, numFPs, outParamsRef)	WAVE dataWv, fitWv; Variable numFPs; String outParamsRef		Double fitStartX = DimOffset(fitWv,0)	Variable fitStartP_fitWv = 0	Variable fitStartP_dataWv = ScaleToIndex(dataWv, fitStartX, 0) //position of fitStartX in data wave -- as fit might be over a sub region	Variable fitPnts = DimSize(fitWv,0)	Double fitEndX = IndexToScale(fitWv, fitPnts-1, 0)		//position of last point in fitWv		Double sampleMean = mean(dataWv, fitStartX, fitEndX)		Variable i, dw_i, fw_i		//iterator, dataWave_index, fitWave_index	Double ss_res=0, ss_total=0, ss_reg=0, chi = 0		//chi isn't needed for others	for (i=0;i<fitPnts;i+=1)		dw_i = fitStartP_dataWv + i		fw_i = fitStartP_fitWv + i		ss_res += (dataWv[dw_i] - fitWv[fw_i])^2		//residual sum of squares : [obs(x) - model(x)]^2		ss_reg += (fitWv[fw_i] - sampleMean)^2		//regression sum of squares : [model(x) - obs_mean]^2		ss_total += (dataWv[dw_i] - sampleMean)^2		//total sum of squares : [obs(x) - obs_mean]^2		chi += ( (dataWv[dw_i] - fitWv[fw_i])^2 ) / abs(fitWv[fw_i])	endfor			Variable ss_res_df = fitPnts - numFPs		//degrees of freedom associated with residual sum of squares	Double ms_res = ss_res / ss_res_df			//mean associated residual sum of squares -- f_denom is this value for more complex model		//other stats, not needed for f test		Double r2 = ss_reg / ss_total	Double p_chi = StatsChiCDF(chi,numFPs)		Variable numParams = 15	Make/O/D/N=(numParams) $outParamsRef	WAVE/D stats_residualsInfoTemp = $outParamsRef		dl_assignAndLbl(stats_residualsInfoTemp,0,ss_res,"ss_res")	dl_assignAndLbl(stats_residualsInfoTemp,1,ss_reg,"ss_reg")	dl_assignAndLbl(stats_residualsInfoTemp,2,ss_total,"ss_total") 	dl_assignAndLbl(stats_residualsInfoTemp,3,chi,"chi")	dl_assignAndLbl(stats_residualsInfoTemp,4,p_chi,"p_chi")	dl_assignAndLbl(stats_residualsInfoTemp,5,r2,"r2")	dl_assignAndLbl(stats_residualsInfoTemp,6,sampleMean,"sampleMean")	dl_assignAndLbl(stats_residualsInfoTemp,7,fitPnts,"fitPnts")	dl_assignAndLbl(stats_residualsInfoTemp,8,numFPs,"numCoefs")	dl_assignAndLbl(stats_residualsInfoTemp,9,ss_res_df,"ss_res_df")	dl_assignAndLbl(stats_residualsInfoTemp,10,ms_res,"ms_res")	dl_assignAndLbl(stats_residualsInfoTemp,11,fitStartX,"fitStartX")	dl_assignAndLbl(stats_residualsInfoTemp,12,fitEndX,"fitEndX")	dl_assignAndLbl(stats_residualsInfoTemp,13,fitStartP_fitWv,"fitStartP_fitWv")	dl_assignAndLbl(stats_residualsInfoTemp,14,fitStartP_dataWv,"fitStartP_dataWv")end	//stats_residualInfo2_LH()//this is statistically correct as far as I can tell, and it fits with the output of //stats_ftest_LH(), which should be implementing exactly the same algorithm anyway//these were both updated by GB 12/14/17 after checking multiple sources on linear //regression, multiple linear regression.function stats_ftest_simple(ssres_sim,ssres_cpx,numFP_sim,numFP_cpx,pnts,outref,pcrit)	Double ssres_sim,ssres_cpx	Variable numFP_sim,numFP_cpx,pnts,pcrit	String outref		//pass to have outputs returned rather than printed to command line	//just useful, not needed for model	double betweenModelSsFc = ssres_cpx / ssres_sim	//numerator	double betweenModelRes = ssres_sim-ssres_cpx	double betweenModelDF = numFP_cpx-numFP_sim	double f_numer = betweenModelRes/betweenModelDF	//denonminator	double withinModelDF = pnts-numFP_cpx	double f_denom = ssres_cpx/withinModelDF	//f_stat and p	double f_stat=f_numer/f_denom	double p = 1 - StatsFCDF(f_stat, betweenModelDF, withinModelDF) 	if (strlen(outref) < 1)		print "f_numer",f_numer,"f_denom",f_denom,"f_stat",f_stat,"p",p	else		Variable numParams=15,i		make/o/d/n=(numParams) $outref/wave=out		i+=1;dl_assignandlbl(out,i,ssres_sim,"ssres_sim")		i+=1;dl_assignandlbl(out,i,ssres_cpx,"ssres_cpx")		i+=1;dl_assignandlbl(out,i,betweenModelSsFc,"betweenModelSsFc")		i+=1;dl_assignandlbl(out,i,numFP_sim,"numFP_sim")		i+=1;dl_assignandlbl(out,i,numFP_cpx,"numFP_cpx")		i+=1;dl_assignandlbl(out,i,pnts,"pnts")				i+=1;dl_assignandlbl(out,i,pnts,"pcrit")		i+=1;dl_assignandlbl(out,i,betweenModelRes,"betweenModelRes")		i+=1;dl_assignandlbl(out,i,betweenModelDF,"betweenModelDF")		i+=1;dl_assignandlbl(out,i,f_numer,"f_numer")		i+=1;dl_assignandlbl(out,i,withinModelDF,"withinModelDF")				i+=1;dl_assignandlbl(out,i,f_denom,"f_denom")		i+=1;dl_assignandlbl(out,i,f_stat,"f_stat")		i+=1;dl_assignandlbl(out,i,p,"p")		i+=1;dl_assignandlbl(out,i,p < pcrit,"acceptComplex")	endif	return pend//this is statistically correct as far as I can tell, and it fits with the output of //stats_ftest_LH(), which should be implementing exactly the same algorithm anyway//these were both updated by GB 12/14/17 after checking multiple sources on linear //regression, multiple linear regression.//this version also computes the chiSq p value, but it only has significance for fits weighted by the standard error (SE)function stats_ftestChi_simple(ssres_sim,ssres_cpx,numFP_sim,numFP_cpx,pnts,outref,pcrit)	Double ssres_sim,ssres_cpx	Variable numFP_sim,numFP_cpx,pnts,pcrit	String outref		//pass to have outputs returned rather than printed to command line	//not used in calc but useful	Double betweenModelSsFc = ssres_cpx / ssres_sim		//numerator	double betweenModelRes = ssres_sim-ssres_cpx	double betweenModelDF = numFP_cpx-numFP_sim	double f_numer = betweenModelRes/betweenModelDF	//denonminator	double withinModelDF = pnts-numFP_cpx	double f_denom = ssres_cpx/withinModelDF	//f_stat and p	double f_stat=f_numer/f_denom	double f_p = 1 - StatsFCDF(f_stat, betweenModelDF, withinModelDF)		//chi sq (again, only has significance when fitting was done weighted by standard error)	Double chi_p = 1 - StatsChiCDF(betweenModelRes,betweenModelDF)	if (strlen(outref) < 1)		print "f_numer",f_numer,"f_denom",f_denom,"f_stat",f_stat,"f_p",f_p,"chi_p",chi_p	else		Variable numParams=17,i		make/o/d/n=(numParams) $outref/wave=out		i=0;dl_assignandlbl(out,i,ssres_sim,"ssres_sim")		i+=1;dl_assignandlbl(out,i,ssres_cpx,"ssres_cpx")		i+=1;dl_assignandlbl(out,i,numFP_sim,"numFP_sim")		i+=1;dl_assignandlbl(out,i,numFP_cpx,"numFP_cpx")		i+=1;dl_assignandlbl(out,i,pnts,"pnts")				i+=1;dl_assignandlbl(out,i,pcrit,"pcrit")		i+=1;dl_assignandlbl(out,i,betweenModelRes,"betweenModelRes")		i+=1;dl_assignandlbl(out,i,betweenModelDF,"betweenModelDF")		i+=1;dl_assignandlbl(out,i,f_numer,"f_numer")		i+=1;dl_assignandlbl(out,i,withinModelDF,"withinModelDF")				i+=1;dl_assignandlbl(out,i,f_denom,"f_denom")		i+=1;dl_assignandlbl(out,i,f_stat,"f_stat")		i+=1;dl_assignandlbl(out,i,f_p,"f_p")		i+=1;dl_assignandlbl(out,i,f_p < pcrit,"f_acceptComplex")		i+=1;dl_assignandlbl(out,i,chi_p,"chi_p")				i+=1;dl_assignandlbl(out,i,chi_p < pcrit,"chi_acceptComplex")		i+=1;dl_assignandlbl(out,i,betweenModelSsFc,"betweenModelSsFc")	endif	return chi_pend//SUPERCEDED BY stats_ftesT_simple()!!!//based on stats_ftest() but uses a lbl header//seems to be best working of my iterations of this//assumes fit wave only covers the range that is of interest for residual calculation -- would have to rewrite this and stats_residualInfo2_LH for variable boundsfunction stats_ftest_LH(dataWv,simpleFitWv,complexFitWv,numFP_simple,numFP_complex,outParamsRef)	WAVE dataWv, simpleFitWv, complexFitWv; Variable numFP_simple, numFP_complex	//num free params for each model	String outParamsRef		Variable f_pval_crit = 0.05		//criteria for accepting the more complex model as justified (arbitrary)		//get residuals info	stats_residualInfo2_LH(dataWv, simpleFitWv, numFP_simple, "simpleFit_resInfo");WAVE sim_ri = $"simpleFit_resInfo"	stats_residualInfo2_LH(dataWv, complexFitWv, numFP_complex, "complexFit_resInfo");WAVE cpx_ri = $"complexFit_resInfo"	//calculate f stat	Variable sim_numDFs = sim_ri[%numCoefs]	Variable cpx_numDFs = cpx_ri[%numCoefs]	Double f_numer_p1 = sim_ri[%ss_res] - cpx_ri[%ss_res]		//cpx_ri[%ss_reg] - sim_ri[%ss_reg]		//numerator numerator	Double f_numer_p2 = cpx_numDFs - sim_numDFs					//numerator denominator	Double f_numer = f_numer_p1 / f_numer_p2		Double f_denom = cpx_ri[%ss_res]/(cpx_ri[%fitPnts]-cpx_numDFs)		//cpx_ri[%ms_res]	Variable df_difference = cpx_numDFs - sim_numDFs	Variable stats_fcdf_n2 = cpx_ri[%fitPnts]-cpx_numDFs	Double f_stat = f_numer / f_denom	Double f_pval =  1 - StatsFCDF(f_stat, df_difference, stats_fcdf_n2) 		//p value: f score, difference in free params, d.f. for sum of squares of residuals?	Variable f_useCpx = f_pval <= f_pval_crit		Print "F-stats_ftest_LH():numFP_cpx,",numFP_simple,"numFP_sim",numFP_complex,"ss_res_sim",sim_ri[%ms_res],"ss_res_cpx",cpx_ri[%ms_res],"cpx>sim?",cpx_ri[%ms_res]>sim_ri[%ms_res],"f_stat",f_stat,"f_pval",f_pval		//additional useful calculations	Double ss_res_difference = cpx_ri[%ss_res] - sim_ri[%ss_res]			Double ss_res_foldChange =cpx_ri[%ss_res] / sim_ri[%ss_res]			Double r2_difference = cpx_ri[%r2] - sim_ri[%r2]				Double r2_foldChange = cpx_ri[%r2] / sim_ri[%r2]				Double chi_difference = cpx_ri[%chi] - sim_ri[%chi]			Double chi_foldChange =cpx_ri[%chi] / sim_ri[%chi]			Double pchi_difference = cpx_ri[%p_chi] - sim_ri[%p_chi]		Variable numFTestParams = 17	Make/O/D/N=(numFTestParams) stats_ftest_outTemp	dl_assignAndLbl(stats_ftest_outTemp, 0, f_numer_p1, "f_numer_p1")	dl_assignAndLbl(stats_ftest_outTemp, 1, f_numer_p2, "f_numer_p2")	dl_assignAndLbl(stats_ftest_outTemp, 2, f_numer, "f_numer")	dl_assignAndLbl(stats_ftest_outTemp, 3, f_denom, "f_denom")	dl_assignAndLbl(stats_ftest_outTemp, 4, df_difference, "df_difference")	dl_assignAndLbl(stats_ftest_outTemp, 5, stats_fcdf_n2, "stats_fcdf_n2")	dl_assignAndLbl(stats_ftest_outTemp, 6, f_stat, "f_stat")	dl_assignAndLbl(stats_ftest_outTemp, 7, f_pval, "f_pval")	dl_assignAndLbl(stats_ftest_outTemp, 8, f_pval_crit, "f_pval_crit")	dl_assignAndLbl(stats_ftest_outTemp, 9, f_useCpx, "f_useCpx")	dl_assignAndLbl(stats_ftest_outTemp, 10, ss_res_difference, "ss_res_difference")	dl_assignAndLbl(stats_ftest_outTemp, 11, ss_res_foldChange, "ss_res_foldChange")	dl_assignAndLbl(stats_ftest_outTemp, 12, r2_difference, "r2_difference")	dl_assignAndLbl(stats_ftest_outTemp, 13, r2_foldChange, "r2_foldChange")	dl_assignAndLbl(stats_ftest_outTemp, 14, chi_difference, "chi_difference")	dl_assignAndLbl(stats_ftest_outTemp, 15, chi_foldChange, "chi_foldChange")	dl_assignAndLbl(stats_ftest_outTemp, 16, pchi_difference, "pchi_difference")		//make dim labels for simple and complex differentiable	dl_appendToLbls(sim_ri,0,"sim_",1,-inf,inf)		//appends ahead of pre-existing labels	dl_appendToLbls(cpx_ri,0,"cpx_",1,-inf,inf)			Concatenate/NP=0/O/DL {stats_ftest_outTemp, sim_ri, cpx_ri}, $outParamsRef //use stats_GetFTestHeader()		//killwaves/z sim_ri, cpx_ri,stats_ftest_outTempendfunction stats_ftest_exp(origWaveRef, simplerCoefRef, moreComplexCoefRef, outParamsRef, fitStartX, fitEndX)	String origWaveRef, simplerCoefRef, moreComplexCoefRef, outParamsRef	Variable fitStartX, fitEndX	WAVE/D origWave = $origWaveRef	WAVE/D simpleCoefs = $simplerCoefRef; Variable numSimpleCoefs = DimSize(simpleCoefs,0)	WAVE/D complexCoefs = $moreComplexCoefRef; Variable numComplexCoefs = DimSize(complexCoefs,0)		getExpFit("simpleFit", simplerCoefRef, origWaveRef, fitStartX, fitEndX, -1); WAVE/D simpleFit		//popualted by getExpFit	getExpFit("complexFit", moreComplexCoefRef, origWaveRef, fitStartX, fitEndX, -1); WAVE/D complexFit		//popualted by getExpFit			//get residuals info	stats_residualsInfo(origWaveRef, "simpleFit", simplerCoefRef,"simpleFit_resInfo")	stats_residualsInfo(origWaveRef, "complexFit", moreComplexCoefRef, "complexFit_resInfo")		//get stats needed for f score (generated by resInfo function)	stats_getResInfoHeader()	Variable ss_res_simple = getParamFromHeader_1D("ss_res", "stats_resInfoHeader", "simpleFit_resInfo")	Variable ss_res_complex = getParamFromHeader_1D("ss_res", "stats_resInfoHeader", "complexFit_resInfo")	Variable df_simple = getParamFromHeader_1D("numCoefs", "stats_resInfoHeader", "simpleFit_resInfo")	Variable df_complex = getParamFromHeader_1D("numCoefs", "stats_resInfoHeader", "complexFit_resInfo")	Variable df_difference = df_complex - df_simple	Variable df_ss_res_complex = getParamFromHeader_1D("ss_res_degFreedom", "stats_resInfoHeader", "complexFit_resInfo")	Variable f_denom = getParamFromHeader_1D("meanOfResiduals", "stats_resInfoHeader", "complexFit_resInfo")			//calculate f stat	Variable f_numer = (ss_res_simple - ss_res_complex) / (df_difference) //f test numerator: (ss_Res_reduced - ss_Res_full) / (df_full - df_reduced). demoniator calculated in resInfo	Variable f_stat = f_numer / f_denom	Variable f_pval =  1 - StatsFCDF(f_stat, df_difference, df_ss_res_complex) 		//p value: f score, difference in free params, d.f. for sum of squares of residuals?		//additional useful calculations	Variable ss_res_difference = ss_res_complex - ss_res_simple	Variable ss_res_foldChange = ss_res_complex / ss_res_simple	Variable r2_simple = getParamFromHeader_1D("r2", "stats_resInfoHeader", "simpleFit_resInfo")	Variable r2_complex = getParamFromHeader_1D("r2", "stats_resInfoHeader", "complexFit_resInfo")	Variable r2_difference = r2_complex - r2_simple	Variable r2_foldChange = r2_complex / r2_simple			Variable numFTestParams = 7	Make/O/D/N=(numFTestParams) stats_ftest_outTemp	stats_ftest_outTemp[0] = f_numer	stats_ftest_outTemp[1] = f_stat	stats_ftest_outTemp[2] = f_pval	stats_ftest_outTemp[3] = ss_res_difference	stats_ftest_outTemp[4] = ss_res_foldChange	stats_ftest_outTemp[5] = r2_difference	stats_ftest_outTemp[6] = r2_foldChange			Concatenate/NP/O/Kill {stats_ftest_outTemp, $"simpleFit_resInfo", $"complexFit_resInfo"}, $outParamsRefend	//stats_ftest_expfunction/S stats_getFTestHeader()	String headerRef = "stats_fTestHeader"		Variable numFTestParams = 7	Make/O/T/N=(numFTestParams) stats_ftest_headerTemp	stats_ftest_headerTemp[0] = "f_numer"	stats_ftest_headerTemp[1] = "f_stat"	stats_ftest_headerTemp[2] = "f_pval"	stats_ftest_headerTemp[3] = "ss_res_difference"	stats_ftest_headerTemp[4] = "ss_res_foldChange"	stats_ftest_headerTemp[5] = "r2_difference"	stats_ftest_headerTemp[6] = "r2_foldChange"		Duplicate/O/T $stats_getResInfoHeader(), simpleResHeaderTemp, complexResHeaderTemp	simpleResHeaderTemp += "_S"	complexResHeaderTemp += "_C"	Concatenate/NP/O/Kill {stats_ftest_headerTemp, simpleResHeaderTemp, complexResHeaderTemp}, $headerRef	return headerRefendfunction stats_residualInfo2(dataWv, fitWv, numFPs, outParamsRef)	WAVE dataWv, fitWv; Variable numFPs; String outParamsRef		Variable fitStartX = DimOffset(fitWv,0)	Variable fitEndX = fitStartX + DimDelta(fitWv,0) * (DimSize(fitWv,0)-1)		Variable sampleMean = mean(dataWv, fitStartX, fitEndX)	Variable numSamples = DimSize(fitWv,0)		Variable i, ssRes=0, ssTot=0, ssReg=0, x	for (i=0;i<numSamples;i+=1)		x = pnt2x(fitWv,i)		ssRes += (fitWv(x) - dataWv(x))^2		ssReg += (fitWv(x) - sampleMean)^2		ssTot += (dataWv(x) - sampleMean)^2	endfor	Variable r2 = 1 - (sqrt(ssres) / sqrt(sstot))	Variable ssRes_degFreedom = numSamples - numFPs	Variable meanOfResiduals = ssRes / ssRes_degFreedom		Variable numParams = 12	Make/O/D/N=(numParams) $outParamsRef	WAVE/D stats_residualsInfoTemp = $outParamsRef		stats_residualsInfoTemp[0] = ssRes	stats_residualsInfoTemp[1] = ssReg	stats_residualsInfoTemp[2] = ssTot 	stats_residualsInfoTemp[3] = NaN		//now empty/placeholder	stats_residualsInfoTemp[4] = r2	stats_residualsInfoTemp[5] = NaN		//now empty/placeholder	stats_residualsInfoTemp[6] = NaN		//now empty/placeholder	stats_residualsInfoTemp[7] = sampleMean	stats_residualsInfoTemp[8] = numSamples	stats_residualsInfoTemp[9] = numFPs	stats_residualsInfoTemp[10] = ssRes_degFreedom	stats_residualsInfoTemp[11] = meanOfResidualsend	function stats_residualsInfo(origWaveRef, fitWaveRef, coefWaveRef, outParamsRef)	String origWaveRef, fitWaveRef, coefWaveRef, outParamsRef		WAVE/D origWave = $origWaveRef	WAVE/D fitWave = $fitWaveRef		Variable fitStartX = DimOffset(fitWave,0)	Variable fitEndX = fitStartX + DimDelta(fitWave,0) * DimSize(fitWave,0)		Duplicate/O fitWave, residuals_infoTemp, residualsForX_infoTemp, fit_infoTemp, fit2_infoTemp		//copying fit wave and not original garauntees proper range	Duplicate/O origWave, orig_infoTemp		//calc sum of squres of residuals	residuals_infoTemp = origWave(x) - fitWave(x)	residuals_infoTemp *= residuals_infoTemp	residualsForX_infoTemp = residuals_infoTemp		//save a copy of squared residuals for x2 test	Variable ss_res = sum(residuals_infoTemp)	//calc ss regression residuals	Variable sampleMean = mean(origWave, fitStartX, fitEndX)	fit_infoTemp -= sampleMean		//regression residuals	fit_infoTemp *= fit_infoTemp				//squared regression residuals	Variable ss_reg = sum(fit_infoTemp)			//sum of squared regression residuals	//calc ss orig data (total sum of squares)	orig_infoTemp -= sampleMean	//residuals original data	orig_infoTemp *= orig_infoTemp	//squared	Variable ss_total = sum(orig_infoTemp)	//summed	Variable ss_total_fromSum = ss_res + ss_reg 		//should  be exactly equal to total?	//calc r squred	Variable r2 = 1- (ss_res / ss_total)		Variable numSamples = DimSize(fitWave,0)	Variable numCoefs = DimSize($coefWaveRef,0)	Variable ss_res_degFreedom = numSamples - numCoefs		//used for calculating mean of residuals		//calculate chi-sq value: sum( (data[i] - predicted[i])^2 / predicted[i] ) --numerator is just ss_Res_out, but we'll start the with the squared residuals from above	fit2_infoTemp -= sampleMean		//divide squared residuals by each prediction. not certain about subtracting mean, but it seems sensible and my source (pdfs from Rick Born) isn't clear on the subject	residualsForX_infoTemp /= fit2_infoTemp	Variable x2Stat = sum(residualsForX_infoTemp)	Variable x2pVal = statsChiCDF(x2Stat, numCoefs)		//stat used as f-test denominator 	Variable meanOfResiduals =  ss_res / ss_res_degFreedom		//F test demoninator: Mean of residuals: sum of squares of residuals / d.f. for that (sample N - num free parameters)				Variable numParams = 12	Make/O/D/N=(numParams) $outParamsRef	WAVE/D stats_residualsInfoTemp = $outParamsRef		stats_residualsInfoTemp[0] = ss_res	stats_residualsInfoTemp[1] = ss_reg	stats_residualsInfoTemp[2] = ss_total	stats_residualsInfoTemp[3] = ss_total_fromSum	stats_residualsInfoTemp[4] = r2	stats_residualsInfoTemp[5] = x2Stat	stats_residualsInfoTemp[6] = x2pVal	stats_residualsInfoTemp[7] = sampleMean	stats_residualsInfoTemp[8] = numSamples	stats_residualsInfoTemp[9] = numCoefs	stats_residualsInfoTemp[10] = ss_res_degFreedom	stats_residualsInfoTemp[11] = meanOfResiduals			//Killwaves/Z residuals_infoTemp, residualsForX_infoTemp, fit_infoTemp, orig_infoTempendfunction/S stats_getResInfoHeader()	String headerRef = "stats_resInfoHeader"		Variable numParams = 12	Make/O/T/N=(numParams) $headerRef	WAVE/T stats_residualsInfoHTemp = $headerRef		stats_residualsInfoHTemp[0] = "ss_res"	stats_residualsInfoHTemp[1] = "ss_reg"	stats_residualsInfoHTemp[2] = "ss_total"	stats_residualsInfoHTemp[3] = "ss_total_fromSum"	stats_residualsInfoHTemp[4] = "r2"	stats_residualsInfoHTemp[5] = "x2Stat"	stats_residualsInfoHTemp[6] = "x2pVal"	stats_residualsInfoHTemp[7] = "sampleMean"	stats_residualsInfoHTemp[8] = "numSamples"	stats_residualsInfoHTemp[9] = "numCoefs"	stats_residualsInfoHTemp[10] = "ss_res_degFreedom"	stats_residualsInfoHTemp[11] = "meanOfResiduals"		return headerRefend//basically just calls the find level operation at present function analysis_timeToThreshCross(inRef, thresholdVal, [startX, endX, edgeType])	String inRef; Variable thresholdVal, startX, endX, edgeType		//default is to start at start and end of function	if (ParamIsDefault(startX))		startX = DimOffset($inRef,0)		endif	if (ParamIsDefault(endX))		endX = DimOffset($inRef,0) + (DimDelta($inRef,0) * DimSize($inRef, 0))	endif	if (ParamIsDefault(edgeType))		edgeType = 0	//searched decreasing and increasing	endif		FindLevel/EDGE=(edgeType)/R=(startX, endX) $inRef, thresholdVal	endfunction SI_fitTerminalVoltages2(useHsListCmdTiming, [row])	Variable useHsListCmdTiming	Variable row		//input to just get one row		WAVE/T cpSummaryIndex		Variable fitWin = 0.02			//in S		Variable i, currRow, vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step	Make/O/D/N=3 coefWave	Make/O/D/N=1 W_fitconstants	//named place where curvefit stores x0 constant	Variable numFitParams=4	Make/O/D/N=(DimSize(cpSummaryIndex,0), numFitParams) SI_voltageResponseFits		String currVoltageRef, currCmdRef			Variable count, startRow, endPos		if (ParamIsDefault(row))		startRow = 0; endPos = DimSize(cpSUmmaryIndex,0)	else		startRow = row; endPos = row + 1	endif		for (i=startRow;i<endPos;i+=1)		if (strlen(cpSummaryIndex[i][0])  < 1)		//likely not a real cell worth trying to analyze			continue		endif			currVoltageRef = cpSummaryIndex[i][17]			if (!WaveExists($currVoltageRef))			continue		endif				count +=1						currCmdRef = SI_getCmdRef(i)		if (useHsListCmdTiming)			analysis_getGenParamsHeader(0); 			String genParamsRef = cpSummaryIndex[i][3]			vCmd_t0 = getParamFromHeader_1D("vCmd_t0", "genParamsHeader", genParamsRef)			vCmd_t1 = getParamFromHeader_1D("vCmd_t1", "genParamsHeader", genParamsRef)			vCmd_baseline = getParamFromHeader_1D("fvCmd_baseline", "genParamsHeader", genParamsRef)			vCmd_step = getParamFromHeader_1D("vCmd_step", "genParamsHeader", genParamsRef)		else			analysis_cellParams_S_vCmd(currCmdRef,  vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step)		endif				Variable V_FitQuitReason		CurveFit/N=1/Q/W=2 exp_XOffset, kwCWave=coefWave , $currVoltageRef[x2pnt($currVoltageRef, vCmd_t0), x2pnt($currVoltageRef, vCmd_t0+fitWin)]		Duplicate/O/R=(vCmd_t0, vCmd_t0+fitWin) $currVoltageRef, currFitTemp		currFitTemp = coefWave[0] + coefWave[1]*exp(-(x-W_fitConstants[0])/coefWave[2])		Duplicate/O currFitTemp, $cpSummaryIndex[i][18]				if (V_FitQuitReason != 0)			Variable CFerror = GetRTError(1)			Print "getErrMessage(CFerror)",getErrMessage(CFerror)			Print "error with = " + currVoltageRef + " index = " + num2str(i)			Print "cmd = " + currCmdRef			Print "t0 = " + num2str(vCmd_t0) + ". pnt = " + num2str(x2pnt($currVoltageRef, vCmd_t0))			Print "end = " + num2str(vCmd_t0 + fitWin) + ". pnt = " + num2str(x2pnt($currVoltageRef, vCmd_t0+fitWin))		endif				SI_voltageResponseFits[i][0] = coefWave[0]			//y0		SI_voltageResponseFits[i][1] = coefWave[1]			//a		SI_voltageResponseFits[i][2] = coefWave[2]			//tau		SI_voltageResponseFits[i][3] = W_FitConstants[0]				AppendtoGraph $currVoltageRef		AppendToGraph/C=(0,0,0) $cpSummaryIndex[i][18]	endfor	Print "iterations = " + num2str(count) + "of total = " + num2str(i)end//OLD//function SI_fitTerminalVoltages()//	WAVE/T cpSummaryIndex_S//	//	Variable fitWin = 0.02			//in S//	//	Variable i, currRow, vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step//	Make/O/D/N=3 coefWave//	Make/O/D/N=1 W_fitconstants	//named place where curvefit stores x0 constant//	Variable numFitParams=4//	Make/O/D/N=(DimSize(cpSummaryIndex_S,0)/2, numFitParams) SI_voltageResponseFits//	//	String currVoltageRef, currCmdRef	//	for (i=0;i<DimSize(cpSummaryIndex_S,0)/2;i+=1)//		currRow = i*2//		currVoltageRef = cpSummaryIndex_S[currRow][15]//		Print currVoltageRef//		currCmdRef = SI_getCmdRef_S(currRow)//		analysis_cellParams_S_vCmd(currCmdRef,  vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step)//		CurveFit/N=1/Q/W=2 exp_XOffset, kwCWave=coefWave , $currVoltageRef[x2pnt($currVoltageRef, vCmd_t0), x2pnt($currVoltageRef, vCmd_t0+fitWin)]//		Duplicate/O/R=(vCmd_t0, vCmd_t0+fitWin) $currVoltageRef, currFitTemp//		currFitTemp = coefWave[0] + coefWave[1]*exp(-(x-W_fitConstants[0])/coefWave[2])//		Duplicate/O currFitTemp, $cpSummaryIndex_S[currRow][16]//		//		SI_voltageResponseFits[i][0] = coefWave[0]//		SI_voltageResponseFits[i][1] = coefWave[1]//		SI_voltageResponseFits[i][2] = coefWave[2]//		SI_voltageResponseFits[i][3] = W_FitConstants[0]//	endfor//end//iClampTestPulsePairs analysisfunction icl_addPair(rowNum)	Variable rowNum	WAVE/T iClampTestPulsePairs	Duplicate/O iClampTestPulsePairs, iClampTestPulsePairs_bu				Variable somaHS1 = stringmatch("S", iClampTestPulsePairs[rowNum][1])	Print "soma HS1 = " + num2str(somaHS1)	String vRefMatchStr_S, cmdRefMatchStr_S, vRefMatchStr_P, cmdRefMatchStr_P	String vRef_S, cmdRef_S, vRef_P, cmdRef_P	if (somaHS1)		vRefMatchStr_S = "*AD0"		cmdRefMatchStr_S = "*AD1"		vRefMatchStr_P = "*AD2"		cmdRefMatchStr_P = "*AD3"	else		vRefMatchStr_P = "*AD0"		cmdRefMatchStr_P = "*AD1"		vRefMatchStr_S = "*AD2"		cmdRefMatchStr_S = "*AD3"			endif	vRef_S = graph_getWaveList("", vRefMatchStr_S, "", 0)	iClampTestPulsePairs[rowNum][2] = vRef_S	cmdRef_S = graph_getWaveList("", cmdRefMatchStr_S, "", 0)	iClampTestPulsePairs[rowNum][4] = cmdRef_S	vRef_P = graph_getWaveList("", vRefMatchStr_P, "", 0)	iClampTestPulsePairs[rowNum][6] = vRef_P	cmdRef_P = graph_getWaveList("", cmdRefMatchStr_P, "", 0)	iClampTestPulsePairs[rowNum][8] = cmdRef_P	String avgName_vRef_S = "G" +  iClampTestPulsePairs[rowNum][0] + "icl_vAvg_S"	String avgName_cmdRef_S = "G" +  iClampTestPulsePairs[rowNum][0] + "icl_cAvg_S"	String avgName_vRef_P = "G" +  iClampTestPulsePairs[rowNum][0] + "icl_vAvg_P"	String avgName_cmdRef_P =  "G" + iClampTestPulsePairs[rowNum][0] + "icl_cAvg_P"	iClampTestPulsePairs[rowNum][3] = avgName_vRef_S	iClampTestPulsePairs[rowNum][5] = avgName_cmdRef_S	iClampTestPulsePairs[rowNum][7] = avgName_vRef_P	iClampTestPulsePairs[rowNum][9] = avgName_cmdRef_P		wave_avgFromStrList(vRef_S,";", avgName_vRef_S,0,nan,nan)	wave_avgFromStrList(cmdRef_S,";", avgName_cmdRef_S,0,nan,nan)	wave_avgFromStrList(vRef_P,";", avgName_vRef_P,0,nan,nan)	wave_avgFromStrList(cmdRef_P,";", avgName_cmdRef_P,0,nan,nan)endfunction icl_dispAvgs(rowNum)	Variable rowNum		WAVE/T iClampTestPulsePairs		Display/K=1 $iClampTestPulsePairs[rowNum][7]; AppendToGraph/C=(0,0,0)  $iClampTestPulsePairs[rowNum][3]	baseSub_GenUse("*", 0, 0, 0, xStart=.27, xEnd=.3)	Variable labelPlace = stringmatch(iClampTestPulsePairs[rowNum][1], "S") ? .38 : .82	SetDrawEnv xcoord= bottom,ycoord= left;DrawText labelPlace,0,"From S"endfunction icl_dispAvgs_offsetWithSub(rowNum, subBaseline)	Variable rowNum, subBaseline		WAVE/T iClampTestPulsePairs		String cn = "G" +  iClampTestPulsePairs[rowNum][0] + "bs" + num2str(subBaseline)		Variable baseLineForSubWinSize = 0.002		//in s	Variable baselineShowWinSize = 0.01			//in s	Variable stepWinSize = 0.2		//in s, can't go farther than this for first set of cells analyzed		Variable step1StartX =   str2num(iClampTestPulsePairs[rowNum][11])	Variable step2StartX =   str2num(iClampTestPulsePairs[rowNum][12])	Variable stepDurX = str2num(iClampTestPulsePairs[rowNum][13])		Variable somaHS1 = stringmatch("S", iClampTestPulsePairs[rowNum][1])		Variable offsetToShowSoma = somaHS1 ? -step1StartX : -step2StartX	Variable offsetToShowPed = somaHS1 ? -step2StartX : -step1StartX		//show from soma	Display/K=1/N=$(cn+"somaPedComp") $iClampTestPulsePairs[rowNum][7]/TN=$(cn+"pedAtSoma"); doupdate; AppendToGraph/C=(0,0,0)  $iClampTestPulsePairs[rowNum][3]/TN=$(cn+"somaAtSoma")	AppendtoGraph/L=left_sub  $iClampTestPulsePairs[rowNum][14]/TN=$(cn+"pedAtSoma_sub")			//ped - soma wave	modifygraph offset = {offsetToShowSoma,0}; doupdate	GetAxis/Q bottom	SetAxis bottom, -baselineShowWinSize, stepWinSize		//show for ped	AppendToGraph/B=bottomPed $iClampTestPulsePairs[rowNum][7]/TN=$(cn+"pedAtPed"); AppendToGraph/C=(0,0,0)/B=bottomPed  $iClampTestPulsePairs[rowNum][3]/TN=$(cn+"somaAtPed")	AppendtoGraph/L=left_sub/B=bottomPed  $iClampTestPulsePairs[rowNum][14]/TN=$(cn+"pedAtPed_sub")			//ped - soma wave	modifygraph offset($(cn+"pedAtPed")) = {offsetToShowPed,0},offset($(cn+"somaAtPed")) = {offsetToShowPed,0},offset($(cn+"pedAtPed_sub")) = {offsetToShowPed,0} ; doupdate	GetAxis/Q bottomPed	SetAxis bottomPed, -baselineShowWinSize, stepWinSize		if (subBaseline)		doupdate		baseSub_GenUse("*AtSoma", 0, 0, 1, xStart=-offsetToShowSoma-baselineForSubWinSize, xEnd=-offsetToShowSoma, xoffset=offsetToShowSoma)		baseSub_GenUse("*AtSoma_sub*",0,0,1, xStart=-offsetToShowSoma-baselineForSubWinSize, xEnd=-offsetToShowSoma, xoffset=offsetToShowSoma)		baseSub_GenUse("*AtPed", 0, 0, 1, xStart=-offsetToShowPed-baselineForSubWinSize, xEnd=-offsetToShowPed, xoffset=offsetToShowPed)		baseSub_GenUse("*AtPed_sub",0,0,1,  xStart=-offsetToShowPed-baselineForSubWinSize, xEnd=-offsetToShowPed, xoffset=offsetToShowPed)	endif		modifygraph axisEnab(left) = {.4,1}, axisEnab(left_sub) = {0,.38}, axisEnab(bottom) = {0,0.49}, axisEnab(bottomPed) = {.51,1}, freepos=0, lblpos = 50	SetAxis/A=2 left; SetAxis/A=2 left_Sub	endfunction icl_dispAvgs_offset(rowNum, subBaseline)	Variable rowNum, subBaseline		WAVE/T iClampTestPulsePairs		String cn = "G" +  iClampTestPulsePairs[rowNum][0]		Variable baseLineForSubWinSize = 0.002		//in s	Variable baselineShowWinSize = 0.01			//in s	Variable stepWinSize = 0.2		//in s, can't go farther than this for first set of cells analyzed		Variable step1StartX =   str2num(iClampTestPulsePairs[rowNum][11])	Variable step2StartX =   str2num(iClampTestPulsePairs[rowNum][12])	Variable stepDurX = str2num(iClampTestPulsePairs[rowNum][13])		Variable somaHS1 = stringmatch("S", iClampTestPulsePairs[rowNum][1])		Variable offsetToShowSoma = somaHS1 ? -step1StartX : -step2StartX	Variable offsetToShowPed = somaHS1 ? -step2StartX : -step1StartX		//show from soma	Display/K=1/N=$(cn+"somaPedComp") $iClampTestPulsePairs[rowNum][7]/TN=$(cn+"pedAtSoma")	doupdate;	AppendToGraph/C=(0,0,0)  $iClampTestPulsePairs[rowNum][3]/TN=$(cn+"somaAtSoma")	modifygraph offset = {offsetToShowSoma,0}; doupdate	GetAxis/Q bottom	SetAxis bottom, -baselineShowWinSize, stepWinSize		//show for ped	AppendToGraph/B=bottomPed $iClampTestPulsePairs[rowNum][7]/TN=$(cn+"pedAtPed"); AppendToGraph/C=(0,0,0)/B=bottomPed  $iClampTestPulsePairs[rowNum][3]/TN=$(cn+"somaAtPed")	modifygraph offset($(cn+"pedAtPed")) = {offsetToShowPed,0},offset($(cn+"somaAtPed")) = {offsetToShowPed,0}	GetAxis/Q bottomPed	SetAxis bottomPed, -baselineShowWinSize, stepWinSize		if (subBaseline)		baseSub_GenUse("*AtSoma", 0, 0, 1, xStart=offsetToShowSoma-baselineForSubWinSize, xEnd=offsetToShowSoma)		baseSub_GenUse("*AtSoma_sub",0,0,1, xStart=offsetToShowSoma-baselineForSubWinSize, xEnd=offsetToShowSoma)		baseSub_GenUse("*AtPed", 0, 0, 1, xStart=offsetToShowPed-baselineForSubWinSize, xEnd=offsetToShowPed)		baseSub_GenUse("*AtPed_sub",0,0,1,  xStart=offsetToShowPed-baselineForSubWinSize, xEnd=offsetToShowPed)	endif		modifygraph axisEnab(bottom) = {0,0.49}, axisEnab(bottomPed) = {.51,1}, freepos=0, lblpos = 50		SetAxis/A=2 leftendfunction icl_doSub(rowNum)	Variable rowNum	WAVE/T iClampTestPulsePairs			WAVE somaTemp = $iClampTestPulsePairs[rowNum][3]	WAVE pedTemp = $iClampTestPulsePairs[rowNum][7]		Duplicate/O pedTemp, pedMinusSomaSubTemp, somaMinusPedSubTemp	pedMinusSomaSubTemp = pedTemp - somaTemp	somaMinusPedSubTemp = somaTemp - pedTemp	Duplicate/O pedMinusSomaSubTemp, $iClampTestPulsePairs[rowNum][14]	Duplicate/O somaMinusPedSubTemp, $iClampTestPulsePairs[rowNum][15]	KillWaves/Z pedMinusSomaSubTemp, somaMinusPedSubTempendfunction icl_addNote()	String topName = winname(0,1)		topName = topName[1,8]	Print "topName",topName	WAVE/T iClampTestPulsePairs	WAVE actualAxLenssortedByRecLen	WAVE actualRecLenssortedByRecLen		FindValue/TEXT=(topName) iClampTestPulsePairs	Variable col = floor( V_value/DimSize(iClampTestPulsePairs,0) )	Variable row = V_value - (col*DimSize(iClampTestPulsePairs,0))		String text = "G" + topName + ". AxLen: " + num2str(actualAxLenssortedByRecLen[row]) + ". RecLen: " +num2str(actualRecLenssortedByRecLen[row])	drawaction delete	SetDrawEnv xcoord=abs, ycoord=abs, fsize= 8	DrawText 50,11.5,textendfunction icl_calcStats()	WAVE/T sy = iClampTestPulsePairs	WAVE actualAxLenssortedByRecLen		Variable numICLParams = 20	Make/O/N=(DimSize(sy,0), numICLParams) icl_stats		Variable i, stepStart_S, stepEnd_S, stepStart_P, stepEnd_P, dur	Variable baselineV_S	String currVoltageRef	String currCmdRef	for (i=0;i<DimSize(icl_stats, 0);i+=1)		stepStart_S = str2num(sy[i][11])		dur = str2num(sy[i][13])		stepEnd_P = stepStart_S + dur		stepStart_P = str2num(sy[i][11])		stepEnd_P = stepStart_P + dur		endforendfunction disp_setAxisToA2(matchStr, [winN])	String matchStr //e.g. "L*" for left	String winN		if (ParamIsDefault(winN))		winN = ""		//uses top graph by default	endif		String list = AxisList(winN )		list = ListMatch(list, matchStr)	Variable i,num=ItemsInList(list)	for (i=0;i<num;i+=1)		SetAxis/A=2/W=$winN $StringFromList(i,list)	endforendMenu "Graph"		//procedure is which part of the menu this goes to	"setVertAxesA2/8"Endfunction setVertAxesA2([winN])	String winN		if (PAramISDefault(winN))		disp_setAxisToA2("L*")		disp_setAxisToA2("R*")	else		disp_setAxisToA2("L*",winN=winN)		disp_setAxisToA2("R*",winN=winN)	endifend//To use, run this function, newCommandLineLine_panel(). It will make a new window (which should resized and moved as necessary).//A button with the label "nl" is created in the window. It will insert a new line into the command line when pressed//(by calling the second function, newCommandLineLine)function newCommandLineLine_panel()	if (wintype("commandLineLinePanel"))		dowindow/f commandLineLinePanel	else		newpanel/N=commandLineLinePanel/K=1/W=(50,50,200,100);doupdate;		Button btn0 title="nl", proc=newCommandLineLine	endifend//function called on button clickfunction newCommandLineLine(s) : ButtonControl	STRUCT WMButtonAction &s		if (s.eventcode == 1)			toCommandLine "\r"	endifendMenu "Macros"	"newCommandLineLine_panel/9"endMenu "Macros"	"fd_filePanelToTop/6"endMenu "Macros"	"fd_currGraphToTop/1",/QendMenu "Macros"	"nb_writeToTop/2",/QendMenu "Macros"	"cellParamsStartText/3",/Qend//Menu "Macros"//	"cellParamsStartTextLayers/5",/Q//endmenu "Macros"	"tracing_setZoom/4"end//menu "Macros"//	"doitdoitdoit/7",/Q//end//////function doitdoitdoit()////	String ref=stringfromlist(0,wavelist("*",";","win:"))////	putscraptext "refStarts+=\""+ref+"\";"////	String saveRef=ref+"_pTr_L_pOS_T"////	print dimsize($saveRef,1)////	save/c/o/p=home $saveRef////endfunction tracing_setZoom()	NVAR/Z tracing_followSubRegZoom	if (!Nvar_exists(tracing_followSubRegZoom))		Variable/G tracing_followSubRegZoom	endif	print "tracing_setzoom() running: tracing_followSubRegZoom = 2"	Execute "tracing_followSubRegZoom = 2"	putscraptext "tracing_followSubRegZoom = 6"endfunction cellParamsStartText()	string str = "ro+=1;resps=gcl(0);wmc[ro][%resps]=resps;setdimlabel 0,ro,$text_getInfoFromWaveName_S(stringfromlist(0,resps),0),wmc;\r"	str+="out=analysis_pulseTimedAvg_L(wmc[ro][%resps],\"\",\"\",\"\",nan,nan,\"\",\"\",str2num(wmc[ro][%prePulseAvgDur]),str2num(wmc[ro][%avgLenX]),str2num(wmc[ro][%dcSubStartX]),str2num(wmc[ro][%dcSubLenX]),forcePulseTimingStr=wmc[ro][%stepStartTimes],weightStr=wmc[ro][%weights],outliers=wmc[ro][%outliers])\r"	str+="reps = out[0,strlen(out)-2] + \"R\"\r"	str+="disp_cols_simple($reps,0);modifygraph rgb=(0,0,0,10000);appendtograph $out[][%avg];setaxis bottom -0.00015,0.01;setaxis/A=2 left\r"	str+="wmc[ro][%pulseTimedAvg_outAvg]=out;wmc[ro][%pulseTimedAvg_outReps]=stringbykey(\"pulseTA_out_reps\",note($out))\r"	str+="avg=wmc[ro][%pulseTimedAvg_outAvg];nw_expRef=avg+\"_nwE\";w_expRef = avg +\"_wE\";\r"	//str+="avg=wmc[ro][%pulseTimedAvg_outAvg];nrn_saveForNrn(avg,1,avg,10^9,1,-0.0003,0.015,1);nw_expRef=avg+\"_nwE\";w_expRef = avg +\"_wE\";\r"	str+="cpnOut=analysis_cellParamsNew(avg,avg,str2num(wmc[ro][%vCmdVal]),0,str2num(wmc[ro][%fitWinSizeX]),\"\",\"\",\"\",nw_expRef,w_expRef,4,1,1,respCol=1,semCol=16);wmc[ro][%nw_expOutRef]=nw_expRef;wmc[ro][%w_expOutRef]=w_expRef;wmc[ro][%cellParams_outRef]=cpnOut;wmc[ro][%nw_fitInfoRefs]=nw_fitInfoRefs;wmc[ro][%w_fitInfoRefs]=w_fitInfoRefs;\r"	tocommandline strendfunction cellParamsStartTextLayers()	String wvn="wmc"//String wvn="dcpp"		//"wmct"			string str = "la+=1;resps=gcl(0);"+wvn+"[ro][%resps][la]=resps;setdimlabel 0,ro,$text_getInfoFromWaveName_S(stringfromlist(0,resps),0),"+wvn+";\r"	str+="out=analysis_pulseTimedAvg_L("+wvn+"[ro][%resps][la],\"\",\"\",\"\",nan,nan,\"\",\"\",str2num("+wvn+"[ro][%prePulseAvgDur][la]),str2num("+wvn+"[ro][%avgLenX][la]),str2num("+wvn+"[ro][%dcSubStartX][la]),str2num("+wvn+"[ro][%dcSubLenX][la]),forcePulseTimingStr="+wvn+"[ro][%stepStartTimes][la],weightStr="+wvn+"[ro][%weights][la],outliers="+wvn+"[ro][%outliers][la])\r"	str+="reps = out[0,strlen(out)-2] + \"R\"\r"	str+="disp_cols_simple($reps,0);modifygraph rgb=(0,0,0,10000);appendtograph $out[][%avg];setaxis bottom -0.00015,0.01;setaxis/A=2 left\r"	str+=""+wvn+"[ro][%pulseTimedAvg_outAvg][la]=out;"+wvn+"[ro][%pulseTimedAvg_outReps][la]=stringbykey(\"pulseTA_out_reps\",note($out))\r"	str+="avg="+wvn+"[ro][%pulseTimedAvg_outAvg][la];nw_expRef=avg+\"_nwE\";w_expRef = avg +\"_wE\";\r"	//str+="avg="+wvn+"[ro][%pulseTimedAvg_outAvg];nrn_saveForNrn(avg,1,avg,10^9,1,-0.0003,0.015,1);nw_expRef=avg+\"_nwE\";w_expRef = avg +\"_wE\";\r"	str+="cpnOut=analysis_cellParamsNew(avg,avg,str2num("+wvn+"[ro][%vCmdVal][la]),0,str2num("+wvn+"[ro][%fitWinSizeX][la]),\"\",\"\",\"\",nw_expRef,w_expRef,2,1,1,respCol=1,semCol=16);"+wvn+"[ro][%nw_expOutRef][la]=nw_expRef;"+wvn+"[ro][%w_expOutRef][la]=w_expRef;"+wvn+"[ro][%cellParams_outRef][la]=cpnOut;"+wvn+"[ro][%nw_fitInfoRefs][la]=nw_fitInfoRefs;"+wvn+"[ro][%w_fitInfoRefs][la]=w_fitInfoRefs;\r"	tocommandline strendfunction nb_writetoTop()	if (wintype("nb_write") > 0)		dowindow/F nb_write	endifend//Menu "Macros"//	"fa_hs1_noStepListMacro/1"//end////Menu "Macros"//	"fa_hs2_noStepListMacro/2"//end////Menu "Macros"//	"fa_both_noStepListMacro/3"//end////Menu "Macros"//	"fa_clear_noStepListMacro/4"//end////Menu "Macros"//	"fa_print_noStepListMacro/5"//endMenu "Macros"	"fd_toggleWatchFolder/0"end//Menu "Macros"//	"fa_ssRinIn_Linear/0"//end//Menu "Macros"//	"fa_ssRinIn_Log/9"//end//WATCHES A FOLDER AND AUTOMATICALLY LOADS ANY NEW WAVES -- ABFLOADER MUST ALREADY BE INSTANTIATED!function fd_toggleWatchFolder()	Variable period_secs=1		//how often to check for files	if (!Wintype("filePanel"))		Print "fd_watchFolder() aborting because no filePanel window exists"		return 0	endif	CtrlNamedBackground _all_, status 	Variable i,num=itemsinlist(S_info,"\r")	String taskName,info	for (i=0;i<num;i+=1)		info=stringfromlist(i,S_info,"\r")		taskName = stringbykey("NAME",info)		if (stringmatch(taskName,"fdWatchFolderBGTask"))			CtrlNamedBackground fdWatchFolderBGTask,kill			Print "fd_watchFolder() ending watch"			return 0		endif	endfor		pathinfo fdWatchFolderPath		if (strlen(S_path))		newpath/o fdWatchFolderPath, S_path	else		newpath/o fdWatchFolderPath	endif		if (V_flag)		//failed to set		Print "fd_toggleWatchFolder() failed to set a folder to watch, aborting"		return 0	endif		pathinfo fdWatchFolderPath	print "fd_toggleWatchFolder() beginning to folder",s_path,"to abort use macro CTRL+8 or run: CtrlNamedBackground fdWatchFolderBGTask,kill"		ctrlNamedBackground fdWatchFolderBGTask,period=60*period_secs,start,proc=fd_toggleWatchBgFunc,stop=0		setwindow filePanel userdata(fdWatchFolder)=S_path	setwindow filePanel userdata(fdWatchFolder_files)=indexedfile(fdWatchFolderPath,-1,".abf")endfunction fd_toggleWatchBgFunc(s)	STRUCT WMBackgroundStruct &s		String fdWatchFolder=getuserdata("filePanel","","fdWatchFolder")	String prevFiles=getuserdata("filePanel","","fdWatchFolder_files")		//files added or there to start with	String currFileList=indexedfile(fdWatchFolderPath,-1,".abf")					//current files		//for the sake of speed, assumes no deletions!	String recordedFile=indexedfile(fdWatchFolderPath,-1,".rsv")		String recordefFileWithoutExt=stringfromlist(0,recordedFile,".")	String filePathsToLoad="",filesToLoad=""		Variable num=itemsinlist(currFileList),i	String fileWithExt,fileWithoutExt	//load any file not in prevFiles that doesn't have an rsv (not the recorded file, if any)	for (i=0;i<num;i+=1)		fileWithExt=stringfromlist(i,currFileList)		if (whichlistitem(fileWithExt,prevFiles) < 0)		//not indexed...so load if possible			fileWithoutExt=stringfromlist(0,fileWithExt,".")			if (!stringmatch(recordefFileWithoutExt,fileWithoutExt))		//not currently being recorded, add				print "loading",fileWithExt,"path",fdWatchFolder+":"+fileWithExt				filePathsToLoad+=fdWatchFolder+fileWithExt+"\r"				filesToLoad+=fileWithExt+";"			endif		endif	endfor		Variable toLoad=itemsinlist(filesToLoad)	if (toLoad > 0)		fd_abfLoad(filePathsToLoad)		setwindow filePanel userdata(fdWatchFolder_files)=prevFiles+filesToLoad					//store current files for next round	endif		return 0endfunction fd_filePanelToTop()	bringtotop("filePanel")end//first sets a named axis (or bottom by default) to a given min and max, and then autoscales  axes matching axMatchStr in each window// then calls disp_matchAxisScaling, which://equalizes axis scaling of top two windows, for all axes with names that match axMatchStr that are shared between both windowsfunction disp_matchAxisScalingB(axMatchStr, numWins, fixAxName, fixAxMin, fixAxMax)	String axMatchStr; Variable numWins; String fixAxName; Variable fixAxMin, fixAxMax		if (strlen(fixAxName) < 1)		fixAxName = "bottom"	endif		Variable i	for (i=0;i<numWins;i+=1)		SetAxis/W=$winname(i,1) $fixAxName, fixAxMin, fixAxMax; doupdate		disp_setAxisToA2(axMatchStr,winN=winname(i,1)); doupdate	endfor		disp_matchAxisScaling(axMatchStr, numWins)end//equalizes axis scaling of top two windows, for all axes with names that match axMatchStr that are shared between both windowsfunction disp_matchAxisScaling(axMatchStrOrList, numWins)	String axMatchStrOrList; Variable numWins		if (strlen(axMatchStrOrList) < 1)		axMatchStrOrList = "l*"		//default matchStr, usually will do all left axes	endif	Make/O/T/N=(numWins) matchingAxNameLists	matchingAxNameLists = ""	Make/O/N=(numWins) numMatchingAxNames	Variable i,j, currRow=0, listIterator=0, currMin, currMax	String currAxName, checkedAxesList	=""	//latter stores names of axes that have been checked	String currAxList, currWinN, listOfGraphsWithCurrAx = ""			if (stringmatch(axMatchStrOrList, "*;*"))		//checks for list input instead of matchStr input		String currMatchStr		for (i=0;i<numWins;i+=1)		//check each window for matching axes			currAxList = AxisList(winname(i,1))			for (j=0;j<ItemsInList(axMatchStrOrList);j+=1)				currMatchStr = StringFromList(j, axMatchStrOrList)				matchingAxNameLists[i] += ListMatch(currAxList, currMatchStr)			endfor		endfor	else		matchingAxNameLists[] = ListMatch(AxisList(winname(p,1)), axMatchStrOrList)		//get name of each window from topmost to bottom most, get axis list for win name																				//then store list of matching ax names in row for each window	endif		numMatchingAxNames[] = ItemsInList(matchingAxNameLists[p])				//store number of each	for (i=0;i<sum(numMatchingAxNames);i+=1)		if (listIterator > numMatchingAxNames[currRow] -1)		//checked all ax names for this row/graph, so move to next row/graph, col/listnum goes back to 0			currRow +=1			listIterator = 0		endif		currAxName = StringFromList(listIterator, matchingAxNameLists[currRow])			if (WhichListItem(currAxName, checkedAxesList) < 0)		//new name so check it			checkedAxesList += currAxName +";"					//add to checked list so not checked again			listOfGraphsWithCurrAx = ""						//start new list of graph nums with current axis			currMin = NaN; currMax = NaN						//reset min and max				for (j=0;j<DimSize(matchingAxNameLists,0);j+=1)		//check each axis list to see whether each window has this axis name				currAxList = matchingAxNameLists[j]				if (WhichListItem(currAxName, currAxList) > -1)		//see if current graph has axis name					currWinN = winname(j,1)					listOfGraphsWithCurrAx += currWinN +";"			//		Print "here A, currWinN = " + currWinN + ". currAxName = " + currAxName + ". currMin = " + num2str(currMin) + ". currMax = " + num2str(currMax)					GetAxis/Q/W=$currWinN $currAxName			//		Print "V_min = " + num2str(V_min) + ". V_max = " + num2str(V_max)					currMin = (numtype(currMin) > 0) ? V_min : ( (V_min < currMin) ? V_min : currMin )		//store min if first checked or if new min					currMax = (numtype(currMax) > 0) ? V_max : ( (V_max > currMax) ? V_max : currMax )	//store max if first checked or if new max			//		Print "here B, currWinN = " + currWinN + ". currAxName = " + currAxName + ". currMin = " + num2str(currMin) + ". currMax = " + num2str(currMax)				endif			endfor						for (j=0;j<ItemsInList(listOfGraphsWithCurrAx);j+=1)			//go through each window with axis and set to min and max found				currWinN = StringFromList(j, listOfGraphsWithCurrAx)				SetAxis/W=$currWinN $currAxName, currMin, currMax			endfor		endif			//	Print "i = " + num2str(i) + ". currRow = " + num2str(currRow) + ". listIterator = " +num2str(listIterator)	//	Print "listOfGraphsWithCurrAx=" + listOfGraphsWithCurrAx + ". min = " +num2str(currMin) + ". max = " + num2str(currMax)				listIterator +=1	endfor			KillWaves/Z matchingAxNameLists, numMatchingAxNamesendfunction disp_setMatchingAxes(winMatchStr,axisMatchStr,numWins,V_min,V_max)	String winMatchStr,axisMatchStr; variable numWins,V_min,V_max		STring wins = WinList(winMatchStr, ";", "win:1" )	variable i,j; string win,axes,axis	for (i=0; (i<itemsinlist(wins)) && (i < numWins) ;i+=1)		win = stringfromlist(i,wins)		axes = ListMatch(AxisList(win),axisMatchStr )		for (j=0;j<itemsinlist(axes);j+=1)			axis=stringfromlist(j,axes)			setaxis/w=$win $axis V_min, v_max		endfor	endforendfunction disp_setWinSize(inchWidth,inchHeight,numWins,[windowType,winN])	Variable inchHeight, inchWidth, numWins	Variable windowType	String winN		if (ParamIsDefault(windowType))		windowType = 1		//default is graphs	endif		String winused	if (!paramisdefault(winN) || (strlen(winN)>0) )		Modifygraph/W=$winN height = 72* inchHeight, width = 72*inchWidth		return 0	endif		Variable i	for (i=0;i<numWins;i+=1)		Modifygraph/W=$winname(i,windowType) height = 72* inchHeight, width = 72*inchWidth	endforend//matches axis scaling (to largest scale) for axes in a single window, matches scaling for ax with names matching axMatchStrOrList, which can be a single match string or a list offunction disp_matchAxisScaling_1win(axMatchStrOrList, [winN])	String axMatchStrOrList	String winN		//optionally specify a window name, otherwise uses top		if (ParamIsDefault(winN))		winN = winname(0,1)		//top GRAPH (righthand 1)	endif		String allAxes = AxisList(winN), matchingAxes = "", currMatchStr, currAxisStr		Variable i	for (i=0;i<ItemsInList(axMatchStrOrList);i+=1)		currMatchStr = StringFromList(i, axMatchStrOrList)			//if single matchSt, just takes the name		matchingAxes += ListMatch(allAxes, currMatchStr)	endfor	Variable lowestMin=nan, highestMax=nan	for (i=0;i<ItemsInList(matchingAxes);i+=1)		currAxisStr = StringFromList(i, matchingAxes)		GetAxis/W=$winN /Q $currAxisStr		lowestMin = numtype(lowestMin) > 0 ? V_min : (V_min < lowestMin ? V_min : lowestMin)		//take V_min if lowestMin is NaN or if V_min is lower than lowestMin		highestMax = numtype(highestMax) > 0 ? V_max : (V_max > highestMax ? V_max : highestMax)		//take V_max if highestMax is NaN or if V_max is higher than highestMax	endfor	for (i=0;i<ItemsInList(matchingAxes);i+=1)		currAxisStr = StringFromList(i, matchingAxes)		SetAxis/W=$winN $currAxisStr,	lowestMin, highestMax			endforendfunction/S disp_getWavesWithMatchingTN(traceMatchStr, [winN])	String traceMatchStr	String winN		//top window unless passed		if (ParamIsdefault(winN))		winN = ""	endif		String traceList = ListMatch(TraceNameList(winN, ";", 1 ), traceMatchStr)	Variable i; String waveRefList = "", currRef	for (i=0;i<ItemsInList(traceList);i+=1)		currRef = NameOfWave(TraceNameToWaveRef(winN, StringFromList(i, traceList)))		if (WhichListItem(currRef, waveRefList) < 0)			//check if already in wave list			waveRefList += currRef + ";"			//add if absent		endif		endfor		return waveRefListendfunction saveTopGraphs(numGraphs, pathName, [h, w, res, nStr,cmdStr,type,nt])	Variable numGraphs; String pathName	Variable h, w		//optionally set height. Uses inches by multiplying input value by 72	Variable res		//see otions in switch statement below. 0 or 8 is 8x screen resolution, 1 is 1x, so on	String nStr	//when passed, this is used as start of output name. If more than one graph being saved, naming is [nStr]0, [nStr]1, ...	string cmdStr	//when passed, disp_general(cmdStr) is run on each graph before saving, e.g. "modifygraph fsize=16"	Variable type	//-2 for high res enhanced metafile, -5 for png, -7 for tiff, -8 pdf	Variable nt		//supress transparency		Variable usedType	if (ParamIsDefault(type))	//no type speficiation, use default		usedType = -5			//-2 for high res enhanced metafile (good for illustrator), -5 for png (good for PPT or illustrator by ref), -7 for tiff	else		usedType = type	endif		make/o/t/free typeExtensions = {".emf",".png",".jpg",".tif",".pdf",".svg"}	dl_assignLblsFromList(typeExtensions,0,0,"-2;-5;-6;-7;-8;-9;","",0)		Variable spbt = (ParamIsDefault(nt) || !nt) ? 1 : 0			//Save PNG Background as Transparent (only affects PNGs)		PathInfo $pathName	if (!V_flag)		Newpath/O $pathName				if (V_flag)			Print "saveTopGraphs(): path set canceled; aborting."				endif	endif	PathInfo $pathName	String picSavePath = S_path		if (ParamIsDefault(res) || numtype(res) || (res <= 0))		res = 8	endif		Variable resVal = res*72		//1 to 8 are options for res		String graphWindows = WinList("*", ";", "WIN:1" )		if (!ParamIsDefault(cmdStr))		disp_general(cmdStr, "*", numGraphs)	endif		Variable i, count,maxn=min(numGraphs,ItemsInList(graphWindows)); String picFileName,graphN,infoTxtFileName	make/o/t/free/n=(1,15) picInfo		//put info along one row for easy writing with save/J (delimited text from wave columns)	for (i=0;i<maxn;i+=1)		graphN = StringFromList(i, graphWindows)		//check for height, width changes		if (!ParamIsDefault(h) || !ParamIsDefault(w))			if (!ParamIsDefault(h))				ModifyGraph/W=$graphN height = h*72				ModifyGraph/W=$graphN height = 0		//makes height adjustable again			endif			if (!ParamIsDefault(w))				ModifyGraph/W=$graphN width = w*72				ModifyGraph/W=$graphN width = 0		//makes height adjustable again			endif			doupdate		endif				//check for a custom name		if (ParamIsDefault(nStr))	//no custom name			SavePICT/Z/O/P=$pathName/EF=2/Q=1/B=(resVal)/E=(usedType)/TRAN=(spbt)/WIN=$graphN			picFileName = graphN + typeExtensions[%$num2str(usedType)]		else		//custom name			if (numGraphs < 2)		//just one input, don't append a number to give it a unique name				picFileName = nStr			else					//multiple windows to save, append a number to make sure output name is unique for each one				picFileName = nStr + num2str(count)			endif			picFileName += typeExtensions[%$num2str(usedType)]			SavePICT/Z/O/P=$pathName/EF=2/E=(usedType)/Q=1/B=(resVal)/TRAN=(spbt)/WIN=$graphN as picFileName		endif						if (V_flag == 0)			Print "Saved: " + graphN,"target save name =", picFileName						//save text file with info about this file			Pathinfo home			String traces=tracenamelist(graphN,";",2^0+2^1+2^2+2^3+2^4+2^5),wavesForTraces="",xwavesForTraces=""			Variable j,numTraces=itemsinlist(traces)			for (j=0;j<numTraces;j+=1)				wavesForTraces+=nameofwave(tracenametowaveref(graphN,stringfromlist(j,traces)))				xWavesForTraces+=nameofwave(XWaveRefFromTrace(graphN,stringfromlist(j,traces)))			endfor			picInfo[0][0]="picFileName~"+picFileName			picInfo[0][1]="graphName~"+graphN			picInfo[0][2]="experimentName~"+igorinfo(1)+".pxp"			picInfo[0][3]="experimentFullPath~"+S_path	//from pathinfo home			picInfo[0][4]="lastSaveDate~"+date()			picInfo[0][5]="lastSaveTime~"+time()			picInfo[0][6]="picSavePath~"+picSavePath			picInfo[0][7]="OS_user~"+igorinfo(7)			picInfo[0][8]="saveWidthInch~"+num2str(winDim(graphN,0))			picInfo[0][9]="saveHeightInch~"+num2str(winDim(graphN,1))			picInfo[0][10]="graphFullWaveList~"+wavelist("*",";","WIN:"+graphN)			picInfo[0][11]="graphTraceList~"+traces			picInfo[0][12]="wavesForTraces~"+wavesForTraces			picInfo[0][13]="xWavesForTraces~"+xWavesForTraces			picInfo[0][14]="winRecreation~"+winrecreation(graphN,0)			infoTxtFileName = picFileName +".txt"			save/J/P=$pathName/o/dlim="\r\n"/e=0 picInfo as infoTxtFileName						count+=1		else			Print "Error in saveTopGraphs() from SavePICT. Error code = " , num2str(V_flag) ," on graphN",graphN,"i=",i		endif	endfor	Print "total num saved = " + num2str(count) + " of target num = " + num2str(numGraphs)endfunction winDim(winN,widthOrHeight)	String winN	Variable widthOrHeight		//0 width 1 height, returns in inches		if (strlen(winN) < 1)		winN = winname(0,1)	endif		getwindow $winN,psize		Variable minCoord,maxCoord	if (widthOrHeight)		//height		minCoord = V_top		maxCoord = v_bottom	else		minCoord = V_left		maxCoord = v_right	endif		//getwindow $winN,expand		return (maxCoord - minCoord) / 72// / v_valueendfunction disp_general(cmdStr,listOfMatchStrs,numGraphs[printWinN])	String cmdStr, listOfMatchStrs; Variable numGraphs	Variable printWinN		//optionally pass and use %s in string, suppresses bringing window to top		if (strlen(listOfMatchStrs) < 1)		listOfMatchStrs = "*"		//defaul to all graphs	endif			String list = text_matchesToListOfMatchStrs(winlist("*",";","WIN:1"), listOfMatchStrs)	Variable doPrintWinN=!ParamIsDefault(printWinN) && printWinN		STring finalStr		//only for doPrintWinN	Variable i,numWins=min(numGraphs,itemsinlist(list)); String winN;	for (i=0;i<numWins;i+=1)		winN = StringFromList(i, list)		if (strlen(winN) < 1)			continue		endif				if (doPrintWinN)			sprintf finalStr,cmdStr,winN			Execute finalStr				else			Dowindow/F $winN	//bring to front			if (strlen(cmdStr) > 0)				Execute cmdStr			endif		endif	endfor	dowindow/H/F //send the command window back to the top of the desktop.endfunction/S text_matchesToListOfMatchStrs(list,listOfMatchStrs)	String list		//list to get matching subset from	String listOfMatchStrs		//match strings		Variable i, num = itemsinlist(list)	String checked="",matches="",str	for (i=0;i<num;i+=1)		str=stringfromlist(i,list)		if ( WhichListItem(str,checked) < 0)		//not checked			checked+=str+";"						if (text_matchToListOfMatchStrs(str,listOfMatchStrs))				matches+=str+";"			endif		endif	endfor		return matchesendfunction text_matchToListOfMatchStrs(str,listOfMatchStrs)	String str,listOfMatchStrs		Variable i,num=itemsinlist(listOfMatchStrs)	string out="",matchStr	for (i=0;i<num;i+=1)		matchStr=stringfromlist(i,listOfMatchStrs)		if (stringmatch(str,matchStr))			return 1		endif	endfor	return 0end//run a general command on all traces or labels matching axisOrtraceMatchStr on all graphs (up to num) matching graphMatchStr//formatStr sets the command and must be correctly formatted, e.g.://Modifygraph rgb(%s)=(0,0,0) //for traces//Modifygraph offset(%s) = {0,1} //for traces//"Label %s, \"Ph lag (deg.)\\u#2\"" //for axes//"ModifyGraph lowTrip(%s)=1e-09"	//for axes//could be adapted for labels pretty easilyfunction disp_general_TA(formatStr,tracesAxesOrWaveNames,axisOrTraceMatchStrList,graphMatchStr,numGraphs[,errBarOnly])	String formatStr,axisOrTraceMatchStrList,graphMatchStr	Variable numGraphs	Variable tracesAxesOrWaveNames	//0 to iterate through traces, 1 to iterate through axes, 2 to iterate through traces (as for zero) but substitute wave names not trace names for %s in formatStr								//note that for tracesAxesOrWaveNames==2, traceMatchStrList still examines trace names, not wave names	Variable errBarOnly		//only affect traces with error bars		Variable doErrBarOnly = !ParamIsDefault(errBarOnly) && errBarOnly		if (strlen(graphMatchStr) < 1)		graphMatchStr = "*"		//defaul to all graphs	endif			if (strlen(axisOrTraceMatchStrList) < 1)		axisOrTraceMatchStrList = "*"	//default to all traces	endif		String searchTemp = formatStr + " "		//add a space so that if the string ends in %s itemsinlist will count that	Variable numReps = itemsinlist(searchTemp,"%s") - 1 			variable ig,i,j		//iterator for graphs and traces/labels	String graph,graphs = winlist(graphMatchStr,";","WIN:1"),axsOrTraces,axOrTrace,cmd	variable numWins=min(numGraphs,itemsinlist(graphs)),numAxsOrTraces	string cmdIntermediate_even,cmdIntermediate_odd		for (ig=0;ig<numWins;ig+=1)		graph = stringfromlist(ig,graphs)		if (tracesAxesOrWaveNames==1)			axsOrTraces = AxisList(graph)		else			axsOrTraces = TraceNameList(graph, ";",1)		endif		axsOrTraces = text_ListMatchStrList(axsOrTraces,axisOrTraceMatchStrList)		//could be adapted here to match based on wave name instead of trace name						numAxsOrTraces=itemsinlist(axsOrTraces)		for (i=0;i<numAxsOrTraces;i+=1)			axOrTrace = stringfromlist(i,axsOrTraces)						if (!tracesAxesOrWaveNames && doErrBarOnly && !trace_hasErrorBars(graph,axOrTrace))				continue		//skip trace, it doesn't have error bars			endif									if (tracesAxesOrWaveNames==2)				axOrTrace = nameofwave(tracenametowaveref(graph,axOrTrace))			endif			if (i==0)				dowindow/F $graph	;doupdate;//bring window to front			endif			switch (numReps)				case 1:					sprintf cmd,formatStr,axOrTrace						break				case 2: 						sprintf cmd,formatStr,axOrTrace,axOrTrace						break						case 3:					sprintf cmd,formatStr,axOrTrace,axOrTrace,axOrTrace						break				case 4: 						sprintf cmd,formatStr,axOrTrace,axOrTrace,axOrTrace,axOrTrace						break					case 5:					sprintf cmd,formatStr,axOrTrace,axOrTrace,axOrTrace,axOrTrace,axOrTrace						break				case 6: 						sprintf cmd,formatStr,axOrTrace,axOrTrace,axOrTrace,axOrTrace,axOrTrace,axOrTrace						break					case 7:					sprintf cmd,formatStr,axOrTrace,axOrTrace,axOrTrace,axOrTrace,axOrTrace,axOrTrace,axOrTrace							break				case 8: 						sprintf cmd,formatStr,axOrTrace,axOrTrace,axOrTrace,axOrTrace,axOrTrace,axOrTrace,axOrTrace,axOrTrace						break					case 9: 						sprintf cmd,formatStr,axOrTrace,axOrTrace,axOrTrace,axOrTrace,axOrTrace,axOrTrace,axOrTrace,axOrTrace,axOrTrace					break					case 10:					sprintf cmd,formatStr,axOrTrace,axOrTrace,axOrTrace,axOrTrace,axOrTrace,axOrTrace,axOrTrace,axOrTrace,axOrTrace,axOrTrace						break				case 11: 						sprintf cmd,formatStr,axOrTrace,axOrTrace,axOrTrace,axOrTrace,axOrTrace,axOrTrace,axOrTrace,axOrTrace,axOrTrace,axOrTrace,axOrTrace						break				endswitch			//print "cmd",cmd,"numReps",numReps			execute cmd				endfor	endfor	dowindow/H/F //send the command window back to the top of the desktop.endfunction trace_hasErrorBars(winN,traceN)	String winN,traceN		String info = traceinfo(winN,traceN,0)	String errBars = stringbykey("ERRORBARS",info)	return strlen(errBars) > 0endfunction/S text_ListMatchStrList(list,listOfMatchStrs)	String list,listOfMatchStrs		variable i,j,numMatchStrs = itemsinlist(listOfMatchStrs),numMatches	String matchStr,matches,allMatches="",match	for (i=0;i<numMatchStrs;i+=1)		matchStr = stringfromlist(i,listOfMatchStrs)		matches = listmatch(list,matchStr)		numMatches=itemsinlist(matches)		for (j=0;j<numMatches;j+=1)			match = stringfromlist(j,matches)			if (WhichListItem(match, allMatches) < 0)				allMatches+=match+";"			endif		endfor	endfor	return allMatchesendfunction findStrInTextWave_1D(findStr, textwave)	String findStr; WAVE/T textwave		FindValue/Text=(findStr) textwave		return V_valueendfunction findStrInTextWaveCol_2D(findStr, tWaveRef, colNum)	String findStr; String tWaveRef; Variable colNum		Variable i	WAVE/T temptw = $twaveRef	for (i=0;i<DimSize(temptw,0);i+=1)		if (stringmatch(temptw[i][colNum], findStr))			return i		endif	endfor		return -1endfunction findStrInTextWave_2D(findStr, tWaveRef, row, col)	String findStr; String tWaveRef; Variable &row, &col		FindValue/Text=(findStr) $tWaveRef		col = floor( V_value / DimSize($tWaveRef,0) )	row = V_Value - (col*DimSize($tWaveRef,0))	return V_valueendfunction/S appendToListItems(appendStr, listStr, sepStr, [replacementSepStr])		//take in a string list and append appendStr to each element	String appendStr, listStr, sepStr	String replacementSepStr		//optionally pass to use a sepStr for outlist other than the one used for listStr		if (strlen(sepStr) < 1)		sepStr = ";"	endif		String outSepStr	if (!ParamIsDefault(replacementSepStr))		outSepStr = replacementSepStr	else		outSepStr = sepStr	endif		String outStr = ""	Variable i; String currStr	for (i=0;i<ITemsInList(listStr);i+=1)		currStr = StringFromList(i, listStr, sepStr) + appendStr		outStr += currStr + outSepStr	endfor		return outStrendfunction excel_load()	fio_fd_loadFilesByName("excel_*", ".ibw", "")endfunction excel_save()	Print "NOT SAVED. UPDATE Function"endfunction excel_disp()	String excelList = wavelist("excel_*",";","")	Print "excelList",excelList		disp_appendWaveListToTable(excelList,1)endfunction excel_getParam(cellName, paramNum)	String cellName //e.g. "15092801"	Variable paramNum		if (!WaveExists($"excel_cellNames"))		excel_load()	endif		String excelWaveName = "excel_"	switch (paramNum)		case 0:			excelWaveName += "indices"			break		case 1:			excelWaveName += "recLens"			break		case 2:			excelWaveName += "axLens"			break					case 3:			excelWaveName += "somaBathRes"			break					case 4:			excelWaveName += "somaBridge"			break			case 5:			excelWaveName += "pedBathRes"			break					case 6:			excelWaveName += "pedBridge"			break								endswitch				WAVE excelTemp = $excelWaveName				Variable index = findStrInTextWave_1D(cellName, $"excel_cellNames")				return excelTemp[index]endfunction/S fio_saveWavesByName(matchStrOrWvList, pathName, appendSavePath, [saveListStr, out_saveListStr, out_saveCount,deleteAfterSave])	String matchStrOrWvList	String pathName		//if blank, prompts user	String saveListStr	//pass to save specific waves by name. matchStr must still apply and can just be "*" to save all these waves	String &out_saveListStr	//optionally pass string (by ref) to get list of waves that were saved. saved list is APPENDED to out_saveListStr, unless out_saveListStr is empty or zero length	Variable appendSavePath	//pass to append full path for save to wave note (useful if you know other related waves were saved in the same place/time and then can be found)	Variable &out_saveCount	//pass variable into which successful save count is returned	Variable deleteAfterSave	//pass true to delete waves from experiment after a successful save		if (strlen(pathName) == 0)		pathName = "saveMatchingWavesPath"		NewPath/O/Z $pathName				if (V_flag)			Print "fio_saveWavesByName aborted. Failed to create path with pathName = " + pathName		endif	endif		PathInfo $pathName	if (!V_flag)		Print "Resetting path in fio_saveWavesByName()..."		NewPath/O/Z $pathName	endif	String full_path = S_path		if (strlen(matchStrOrWvList) == 0)		matchStrOrWvList = "*"	endif	String list		//load list	if (StringMatch(matchStrOrWvList, "*;*"))		//if has semi-colon, assume wave list		list = matchStrOrWvList	else		list = wavelist(matchStrOrWvList, ";","")	//String excelWavesList = wavelist("excel_*", ";","")										//wavelist also pre-selects for waves that exist, so no need to check the reference 	endif	list = RemoveFromList("",list)	//avoid ";;;;" reps																													Variable i, errorCode	String currRef, savedList = "", killedList=""	Variable out_saveCount_temp = 0		//attempts to count succesful saves, but may not be accurate depending on the states thrown by save call	for (i=0;i<ItemsInList(list);i+=1)		currRef = StringFromList(i, list)		//if additional saveListStr passed, check that this wave is present there and skip if not		if (!ParamIsDefault(saveListStr))			if (WhichListItem(currRef, saveListStr) == -1)				continue		//if saveListStr is passed and the current wave is not in the list, skip it			endif		endif				//check that wave exists; if not, let user know and skip		if (!strlen(currRef))			continue	//dont bother alerting for this case, likely just an extra ";"		endif		if ( !WaveExists($currRef) )			Print "fio_saveWavesByName(): failed to save waveRef=", currRef, ". Wave does not exist. Wave skipped."			continue		endif				//append save path if requested		if (appendSavePath)			Note/nocr $currRef, "fio_savePath:" + full_path + ";"		endif		debug_checkRTErrState(msg="Just before call to SAVE in fio_saveWavesByName()")		//clears any RT error		//save the wave		SAVE/C/O/P=$pathName $currRef				//report errors		errorCode = GetRTError(1)		//clears any RT error, but this error should be specific to save		if (errorCode)			Print "Error in fio_saveWavesByName, likely while saving wave = " + StringFromList(i, list) + ". Error msg = " + GetErrMessage(errorCode)		else			out_saveCount_temp += 1			if (deleteAfterSave)				killwaves/z $currRef				killedList += currRef + ";"			endif		endif				savedList += currRef + ";"	endfor		if (!ParamIsDefault(out_saveListStr))		if (strlen(out_saveListStr) == NaN)			out_saveListStr = savedList		else			out_saveListStr += savedList		endif	endif		if (!ParamIsDefault(out_saveCount))		out_saveCount = out_saveCount_temp	endif			Print "fio_saveWavesByName(): killed waves after seemingly successful save:",killedList		return pathNameend	//fio_saveWavesByNamefunction/S  fio_fd_loadFilesByName(matchStr, extensionStr, pathName, [loadListStr])	String matchStr			//e.g. "excel_*"	String extensionStr		//e.g. ".ibw" for igor binary files	String pathName			//prompts user if blank		String &loadListStr				if (strlen(pathName) == 0)		if (ParamIsDefault(loadListStr))			pathName = fio_loadfiles(matchStr, extensionStr)		//	multiload("excel_*", ".ibw", pathName = "excelPath")		else			pathName = fio_loadfiles(matchStr, extensionStr, out_waveListStr = loadListStr)		endif	else		if (ParamIsDefault(loadListStr))			pathName = fio_loadfiles(matchStr, extensionStr, pathName = pathName)		//	multiload("excel_*", ".ibw", pathName = "excelPath")		else			pathName = fio_loadfiles(matchStr, extensionStr, pathName = pathName, out_waveListStr = loadListStr)		endif	endif		return pathNameendfunction fio_saveCPData(pathName)	String pathName		String savedWaveList = ""		String usedPath = fio_saveWavesByName("cpSummaryIndex", pathName, 1,out_saveListStr = savedWaveList)		//assignment in case input path is empty string and so determined by called function	fio_saveWavesByName("excel_*", usedPath, 1,out_saveListStr = savedWaveList)	fio_saveWavesByName("hsList", usedPath, 1,out_saveListStr = savedWaveList)	fio_saveRefsInWave("hsList", usedPath,0, saveListStr = savedWaveList)	fio_saveRefsInWave("cpSummaryIndex", usedPath,0, saveListStr = savedWaveList)		Print "PathName = " + usedPath + ". Num waves saved = " + num2str(ItemsInList(savedWaveList)) + ". List:",savedWaveListendfunction/S fio_loadCPData(pathName)	String pathName		String loadedWaveList = ""	String usedPath = fio_fd_loadFilesByName("cpSummaryIndex", "", pathName, loadListStr = loadedWaveList)		//assignment in case input path is empty string and so determined by called function	fio_fd_loadFilesByName("excel_*", "", usedPath, loadListStr = loadedWaveList)	fio_fd_loadFilesByName("hsList", "", usedPath, loadListStr = loadedWaveList)	//	fio_loadRefsInWave("hsList", "", usedPath,0, loadListStr = loadedWaveList)//	fio_loadRefsInWave("cpSummaryIndex", "", usedPath,0, loadListStr = loadedWaveList)		Print "PathName = " + usedPath + ". Num waves loaded = " + num2str(ItemsInList(loadedWaveList)) + ". List:",loadedWaveList	return loadedWaveListendfunction fio_loadRefsInWave(textWaveOfRefsRef, extensionStr, pathName, includeLists, [loadListStr])	String textWaveOfRefsRef	String extensionStr			String pathName	Variable includeLists			//if not 0 or -1, saves lists if found. If 0, lists are ignored. if -1, saves only first								//currently assumes lists are semi-colon delimited	String &loadListStr		//see fio_saveWavesByName for info on this																WAVE/T textWaveOfRefs = $textWaveOfRefsRef		Variable i,j,k, isList; String currRef	for (i=0;i<DimSize(textWaveOfRefs,0);i+=1)		//should work for 1D as well as 2D, but haven't tested 1D yet		for (j=0;j<DimSize(textWaveOfRefs,1);j+=1)				currRef = textWaveOfRefs[i][j]			isList = stringmatch(currRef, "*;*")			if (!isList)		//not list, see if working standard ref				if (ParamIsDefault(loadListStr))					fio_fd_loadFilesByName(currRef, extensionStr, pathName)				else					fio_fd_loadFilesByName(currRef, extensionStr, pathName, loadListStr = loadListStr)				endif			else				//list, either ignore, save first, or save all				switch(includeLists)						case 0:		//save no elements						break									case -1: 		//save first element						if (ParamIsDefault(loadListStr))							fio_fd_loadFilesByName(StringFromList(0, currRef), extensionStr, pathName)						else							fio_fd_loadFilesByName(StringFromList(0, currRef), extensionStr, pathName, loadListStr = loadListStr)						endif						break							default:		//include lists is not -1 or 0										if (ParamIsDefault(loadListStr))									for (k=0;k<ItemsInList(currRef);k+=1)								fio_fd_loadFilesByName(StringFromList(k, currRef), extensionStr, pathName)							endfor								else							for (k=0;k<ItemsInList(currRef);k+=1)								fio_fd_loadFilesByName(StringFromList(k, currRef), extensionStr, pathName, loadListStr = loadListStr)							endfor						endif						endswitch			endif					endfor		endforend//iterates through text wave, checking if refs to any waves are present; if so, attempts to save them to pathName. If pathName is "" or not yet set, allows user to setfunction fio_saveRefsInWave(textWaveOfRefsRef, pathName, includeLists, [saveListStr])	String textWaveOfRefsRef	String pathName	Variable includeLists			//if not 0 or -1, saves lists if found. If 0, lists are ignored. if -1, saves only first								//currently assumes lists are semi-colon delimited	String &saveListStr		//see fio_saveWavesByName for info on this																WAVE/T textWaveOfRefs = $textWaveOfRefsRef		Variable i,j,k, isList; String currRef	for (i=0;i<DimSize(textWaveOfRefs,0);i+=1)		//should work for 1D as well as 2D, but haven't tested 1D yet		for (j=0;j<DimSize(textWaveOfRefs,1);j+=1)				currRef = textWaveOfRefs[i][j]			isList = stringmatch(currRef, "*;*")			if (!isList)		//not list, see if working standard ref				if (ParamIsDefault(saveListStr))					fio_saveWavesByName(currRef, pathName,1)				else					fio_saveWavesByName(currRef, pathName,1, out_saveListStr = saveListStr)				endif			else				//list, either ignore, save first, or save all				switch(includeLists)						case 0:		//save no elements						break									case -1: 		//save first element						if (ParamIsDefault(saveListStr))							fio_saveWavesByName(StringFromList(0, currRef), pathName,1)						else							fio_saveWavesByName(StringFromList(0, currRef), pathName,1, out_saveListStr = saveListStr)						endif						break							default:		//include lists is not -1 or 0										if (ParamIsDefault(saveListStr))									for (k=0;k<ItemsInList(currRef);k+=1)								fio_saveWavesByName(StringFromList(k, currRef), pathName,1)							endfor								else							for (k=0;k<ItemsInList(currRef);k+=1)								fio_saveWavesByName(StringFromList(k, currRef), pathName,1, out_saveListStr = saveListStr)							endfor						endif						endswitch			endif					endfor		endforend//displays a window with the named waves and allows keyboard up and down to move through them one at a timefunction disp_waveBrowse(matchStr)	String matchStr		String waveBrowserList = wavelist(matchStr, ";","TEXT:0")	Variable waveBrowserIterator = 0		Print "waveBrowserList", waveBrowserList		String winN = "waveBrowser"		Display/K=1/N=$winN $StringFromList(waveBrowserIterator, waveBrowserList)	winN = S_Name		//Igor auto appends 0 etc if dups		SetWindow $winN, hook(hook0) = winHook0	String iteratorVarName = winN + "_iter"	String listVarName = winN + "_list"	Variable/G $iteratorVarName = waveBrowserIterator	String/G $listVarName = waveBrowserList	Print "New wave browser, name = " + s_nameend	//window hook function: attemp to kill waves when window is killed. Prompts user first!function winHook_killWaves(s)	STRUCT WMWinHookStruct &s			if (s.eventCode == 17)		String/G winHook_killWaves_wavesToKill = WaveList("*", ";", "WIN:" + s.winName )		vis_clearGraph(s.winName); doupdate	endif		if (s.eventCode != 2)			//only continue for window killed		return 0	endif		SVAR/Z winHook_killWaves_wavesToKill	if (!SVAR_Exists(winHook_killWaves_wavesToKill))		Print "no winHook_killWaves_wavesToKill string list found"		return 0	endif			Variable attemptWaveKill = 1			Prompt attemptWaveKill, "Kill these waves? " + winHook_killWaves_wavesToKill	DoPrompt "Win: " + s.WinName + " (winHook_killWaves)", attemptWaveKill		if (V_flag)		return 0	endif		if (attemptWaveKill)		killWavesInStrList(winHook_killWaves_wavesToKill,reportFailures = 1)	endif			killStrings/Z winHook_killWaves_wavesToKillend	//window hook function: attemp to kill waves when window is killed. Prompts user first!	//prespecified waves are killed ony as opposed to winHook_killWaves which will kill anything on the graphfunction winHook_killPresetWaves(s)	STRUCT WMWinHookStruct &s			if (s.eventCode == 17)		String/G winHook_killWaves_wavesToKill = getuserdata(s.winname,"","winHook_killPresetWaves_lList")//WaveList("*", ";", "WIN:" + s.winName )		winHook_killWaves_wavesToKill=text_ListMatchStrList(winHook_killWaves_wavesToKill,WaveList("*", ";", "WIN:" + s.winName ))	//get subset from list that is still on window		Variable shiftIsSet=s.eventMod & 2^1		winHook_killWaves_wavesToKill="!Shifted="+num2str(shiftIsSet)+";"+winHook_killWaves_wavesToKill		vis_clearGraph(s.winName); doupdate	endif		if (s.eventCode != 2)			//only continue for window killed		return 0	endif		SVAR/Z winHook_killWaves_wavesToKill	if (!SVAR_Exists(winHook_killWaves_wavesToKill))		Print "no winHook_killWaves_wavesToKill string list found"		return 0	endif		String shiftStr=stringfromlist(0,winHook_killWaves_wavesToKill)	winHook_killWaves_wavesToKill=removelistitem(0,winHook_killWaves_wavesToKill)	Variable wasShifted = str2num(stringfromlist(1,shiftStr,"="))			Variable attemptWaveKill = 1		if (!wasShifted)		Prompt attemptWaveKill, "Kill these waves? " + winHook_killWaves_wavesToKill		DoPrompt "Win: " + s.WinName + " (winHook_killWaves)", attemptWaveKill				if (V_flag)			return 0		endif	endif		if (attemptWaveKill)		killWavesInStrList(winHook_killWaves_wavesToKill,reportFailures = 1)	endif			killStrings/Z winHook_killWaves_wavesToKillendfunction winHook_killPresetWaves_set(winN)	String winN	if (strlen(winN)<1)		winN=winname(0,1)	endif		String currentWvList=wavelist("*",";","WIN:"+winN)	setwindow $winN,userdata(winHook_killPresetWaves_lList)=currentWvList,hook(winHook_killPresetWaves)=winHook_killPresetWavesendfunction winHook0(s)	STRUCT WMWinHookStruct &s	if (s.eventCode != 11 && s.eventCode != 2)			//NOT Keyboard event		return 0	endif		String winN = s.winName 	Print "winN",winN	String iteratorVarName = winN + "_iter"	String listVarName = winN + "_list"	NVAR iteratorRef = $iteratorVarName	SVAR listRef = $listVarName		if (s.eventCode == 2)	//window killed, kill used global variables (killing in this way, by reference, will actually kill them)		KillStrings listRef		KillVariables iteratorRef		return 1	endif			Variable numWaves = ItemsInList(listRef)	switch (s.keycode)		case 28:		//left			break		case 29:		//right arrow			break		case 30:		//up arrow			vis_clearGraph("")			iteratorRef +=1			if (iteratorRef == numWaves)				iteratorRef = 0		//had used mod operation, but this is nice because it allows easy reporting of the number			endif			Print "iteratorRef",iteratorRef			AppendToGraph/W=$winN $StringFromList(iteratorRef, listRef)			break		case 31:		//down arrow			vis_clearGraph("")			iteratorRef -=1			if (iteratorRef == -1)				iteratorRef = numWaves -1		//keeping it positive, ya know!			endif			AppendToGraph/W=$winN $StringFromList(mod(iteratorRef, numWaves), listRef)			Print "iteratorRef",iteratorRef			break				endswitch				return 1endfunction disp_winHook_dispTWaveRefs(s)	STRUCT WMWinHookStruct &s			if ((s.eventCode == 3) && ( (s.eventMod & 2^3) != 0))		//left side is only mouse down, right side is cntl down		String ref = disp_winHook_tWaveVals(s)		Print "ref",ref		String winN = "disp_winHook_dispTWaveRefs"		if (winType(winN) > 0)			vis_clearGraph(winN)			AppendToGraph/W=$winN	 $ref		elseif (winType(winN + "*") > 0)			winN = StringFromLisT(0, WinList(winN + "*", ";", "WIN:1" ))	//take top GRAPH (win:1) with matchign name			vis_clearGraph(winN)			AppendToGraph/W=$winN	 $ref		else		//no window by similar name found			Display/K=1/N=$winN  $ref		endif	endifendfunction/S disp_winHook_tWaveVals(s)	STRUCT WMWinHookStruct &s//	if ((s.eventCode == 3) && ( (s.eventMod & 2^3) != 0))		//left side is only mouse down, right side is cntl down	Variable row, col;	String tableWaveRef		//set by disp_getTableSel	table_getTableSel(s.winname, row, col, tableWaveRef)		WAVE/T tableWave = $tableWaveRef	return tableWave[row][col]end//taken from igor help files on window hook functions and modifiedFunction winHookExample(s)	STRUCT WMWinHookStruct &s		Variable hookResult = 0	// 0 if we do not handle event, 1 if we handle it.		Print "eVent in win name = " + s.winName	switch(s.eventCode)		case 11:					// Keyboard event			switch (s.keycode)				case 28:					Print "Left arrow key pressed."					hookResult = 1					break				case 29:					Print "Right arrow key pressed."					hookResult = 1					break				case 30:					Print "Up arrow key pressed."					hookResult = 1					break				case 31:					Print "Down arrow key pressed."					hookResult = 1					break						endswitch			break	endswitch	return hookResult	// If non-zero, we handled event and Igor will ignore it.Endfunction cp_cursorClickHook(s)	STRUCT WMWinHookStruct &s		Variable hookResult = 0	// 0 if we do not handle event, 1 if we handle it.		if (s.eventCode != 7)		//only continue for cursor move		return 0	endif			String graphN = s.winName	String traceN = s.traceName	String waveRef = NameOfWave(TraceNameToWaveRef(graphN, traceN))	WAVE waveTemp = $waveRef	String cursorN = s.cursorName	Variable point = s.pointNumber	Variable yVal = waveTemp[point][0]	Variable xVal = waveTemp[point][1]	Variable len = waveTemp[point][4]	Variable cpIndex = waveTemp[point][2]	Variable isPed = waveTemp[point][3]	WAVE/T cpSummaryIndex	Variable hsListRow = str2num(cpSummaryIndex[cpIndex][14])	String cellName = cpSummaryIndex[cpIndex][0]	Print "in cp_cursorClickHook(s). cursor " + cursorN + " on " + graphN + ". TN=" + traceN + ". WN=" + waveRef + ". point=" + num2str(point) + ". yVal=" + num2str(yVal) + ". xVal=" + num2stR(xval)	Print "cpIndex=" + num2str(cpIndex) + ". hsListRow=" + num2str(hsListRow) + ". point=" + num2str(point) +  ". isPed=" + num2str(isPed) + ". cellname="+cellName//	if (WaveExists($(waveRef + "_index")))//		WAVE temp = $(waveRef + "_index")//		WAVE/T cpSummaryIndex//		Variable cpIndexPos = temp[point]//		Print "CPIndex= " + num2str(cpIndexPos) + ".cellN= " + cpSummaryIndex[cpIndexPos][0] + ".S/P = " + cpSummaryIndex[cpIndexPos][2] + ".avgRef= " + cpSummaryIndex[cpIndexPos][1] + ".B/A= " + cpSummaryIndex[cpIndexPos][12] + "(indexwv="+(waveRef + "_index")+")"//		Variable currVmin, currVmax//		disp_makeOrClear("cursorDispWin", vMinOut = currVmin, vMaxOut = currVmax)	//		AppendToGraph/W=cursorDispWin/L=L_out $cpSummaryIndex[cpIndexPos][1]//		//		AppendToGraph/W=cursorDispWin/L=L_cmd $hs_getVcmdRef( str2num(cpSummaryIndex[cpIndexPos][14]) , stringmatch(cpSummaryIndex[cpIndexPos][2],"P") )//		SetAxis/W=cursorDispWin bottom, currVmin, currVmax//		SetAxis/W=cursorDispWin/A=2 L_out//		SetAxis/W=cursorDispWin/A=2 L_cmd//		Modifygraph/W=cursorDispWin axisEnab(L_out) = {0.18,1}, axisEnab(L_cmd) = {0,0.15}, lblpos = 48, freepos=0//	endif		return 1	endfunction disp_cursorClickHook(s)	STRUCT WMWinHookStruct &s		Variable hookResult = 0	// 0 if we do not handle event, 1 if we handle it.		if (s.eventCode != 7)		//only continue for cursor move		return 0	endif			if (s.isFree)		//not on a point		return 0	endif	return 0	//Print "hook disabled"		String graphN = s.winName	String traceN = s.traceName	String waveRef = NameOfWave(TraceNameToWaveRef(graphN, traceN))	WAVE waveTemp = $waveRef	String cursorN = s.cursorName	Variable row = s.pointNumber	String traceInf = traceinfo(graphN,traceN,0) 	//print "traceInf",traceInf		String yRange = stringbykey("YRANGE",traceInf)	String yRange_scan = stringfromlist(1,yRange,"][")			//now have yCol]	yRange_scan = ReplaceString("]",yRange_scan,"")				//now have yCol	Variable y_displayedCol = str2num(yRange_scan)		String xRange = stringbykey("XRANGE",traceInf)	String xRange_scan = stringfromlist(1,xRange,"][")			//now have xCol]	xRange_scan = ReplaceString("]",xRange_scan,"")				//now have xCol	Variable x_displayedCol = str2num(xRange_scan)		String rowLbl = GetDimLabel(waveTemp, 0, row )	String yColLbl = getdimlabel(wavetemp,0,y_displayedCol)	String xColLbl = getdimlabel(wavetemp,0,x_displayedCol)		//wrong if x wave differs		print "row",row,"rowLbl",getdimlabel(wavetemp,0,row),"yColLbl",yColLbl,"xColLbl",xColLbl,"y_displayedCol",y_displayedCol,"x_displayedCol",x_displayedCol	//	Print "disp_cursorClickHook(): traceN",traceN,"waveRef",waveRef,"row",row,"rowLbl",rowLbl,"y_displayedCol",y_displayedCol,"yColLbl",yColLbl,"x_displayedCol",x_displayedCol,"xColLbl(if no x wave)",xColLbl			return 0	//rest was for reading off one particular wave note structure			String info = note(waveTemp)	String colInfo = stringbykey("paramListColList",info)	colInfo = replacestring("|",colInfo,";")	String y_colInfo = ReplaceString(",",stringfromlist(y_displayedCol,colInfo),";")	String x_colInfo = ReplaceString(",",stringfromlist(x_displayedCol,colInfo),";")			String refSources = ReplaceString("|",stringbykey("sourcesList",info),";")	String refIndices = ReplaceString("|",stringbykey("sourcesIndices",info),";")	Variable y_paramRefListIndex = str2num(stringfromlist(7,y_colInfo)); String y_paramRefSource="",y_paramRefSourceIndices=""; Variable y_paramRefSource_ind	if (!numtype(y_paramRefListIndex))		y_paramRefSource = stringfromlist(y_paramRefListIndex,refSources)		y_paramRefSourceIndices = ReplaceString(",",stringfromlist(y_paramRefListIndex,refIndices),";")		y_paramRefSource_ind = str2num(stringfromlist(row,y_paramRefSourceIndices))		WAVE/T yParamRefWv = $y_paramRefSource	endif		Variable x_paramRefListIndex = str2num(stringfromlist(7,x_colInfo))		String paramWaveRef = Stringfromlist(3,y_colInfo)	String paramName = Stringfromlist(1,y_colInfo)	Print "disp_cursorClickHook(): csr("+cursorN+") sel row",row,"sel label=",GetDimLabel($waveRef, 0, row ),"wave=",waveRef,"trace=",traceN	Print "xAxInfo: col",x_displayedCol,"paramName",Stringfromlist(1,x_colInfo),"paramHeader",Stringfromlist(2,x_colInfo),"paramWvRef",paramWaveRef,"paramWvRow",Stringfromlist(4,x_colInfo),"paramWvCol",Stringfromlist(5,x_colInfo)	Print "yAxInfo: col",y_displayedCol,"paramName",paramName,"paramHeader",Stringfromlist(2,y_colInfo),"paramWvRef",Stringfromlist(3,y_colInfo),"paramWvRow",Stringfromlist(4,y_colInfo),"paramWvCol",Stringfromlist(5,y_colInfo)	Print "y_paramRefListIndex",y_paramRefListIndex,"y_paramRefSource",y_paramRefSource,"y_paramRefSource_ind",y_paramRefSource_ind	Print "sourceFileName", getdimlabel(yParamRefWv,0,y_paramRefSource_ind),"sourceFileInfoStr saved to ySourceInfo"	String/G ySourceInfo = yParamRefWv[y_paramRefSource_ind]		String cp_rowStr = stringbykey("cp_row",ySourceInfo)	if (strlen(cp_rowStr))		Variable cp_row = str2num(cp_rowStr)		if (!numtype(cp_row))			fio_stream_dispCellParams(cp_row,1,text_getinfofromwavename_s(getdimlabel(yParamRefWv,0,y_paramRefSource_ind),1))			String keyAppendStr = ""			String postAppendStr = "_po"				String ccAppendStr = "_c"			String vc_sim_appendStr = "_vs"			Variable fixedNamePortionEnd = strsearch(paramWaveRef, "_wn", 0)			if (stringmatch(paramWaveRef[fixedNamePortionEnd,inf],"*"+postAppendStr+"*"))				keyAppendStr += postAppendStr			endif			if (stringmatch(paramWaveRef[fixedNamePortionEnd,inf],"*"+ccAppendStr+"*"))				keyAppendStr += ccAppendStr			endif			if (stringmatch(paramWaveRef[fixedNamePortionEnd,inf],"*"+vc_sim_appendStr+"*"))				keyAppendStr += vc_sim_appendStr			endif						Print "keyAppendStr",keyAppendStr,"paramWaveRef[fixedNamePortionEnd,inf]",paramWaveRef[fixedNamePortionEnd,inf]			variable rowForInfo = str2num(stringbykey("rowForInfo"+keyAppendStr,ySourceInfo))			variable pcsr_a = str2num(stringbykey("pcsr_a"+keyAppendStr,ySourceInfo))			variable pcsr_b = str2num(stringbykey("pcsr_b"+keyAppendStr,ySourceInfo))			string csrwave_a = stringbykey("csrwv_a"+keyAppendStr,ySourceInfo)			variable pcsr_c = str2num(stringbykey("pcsr_c"+keyAppendStr,ySourceInfo))			variable pcsr_d = str2num(stringbykey("pcsr_d"+keyAppendStr,ySourceInfo))			string csrwave_c = stringbykey("csrwv_c+keyAppendStr",ySourceInfo)			String cursor_paramName			if (stringmatch(paramName,"p*"))				cursor_paramName = "IS_VC1"			else				cursor_paramName = "IS_VC0"			endif			//stringbykey("paramName",Stringfromlist(3,y_colInfo))			Print "cp_row",cp_row,"rowForInfo",rowForInfo,"pcsr_a",pcsr_a,"pcsr_b",pcsr_b,"csrwave_a",csrwave_a,"pcsr_c",pcsr_c,"pcsr_d",pcsr_d,"csrwave_c",csrwave_c			Cursor/P A  $cursor_paramName  pcsr_a			Cursor/P B  $cursor_paramName  pcsr_a			Cursor/P C  $cursor_paramName  pcsr_c			Cursor/P D  $cursor_paramName  pcsr_d		endif	endif		//temporary to list all plotted cells	SVAR wnPlottedCellList	wnPlottedCellList += rowLbl + ";"	//	Print traceinfo(graphN,traceN,0)end					//0		column					//1		paramName			//2	 header			//3		paramWvRef		//4		paramWv row	//5	 paramWv col	//6 is bin	//7 is paramRefIndex or NaN for excel//col info  num2str(out_excel_binned_col)+","+excelParamStr+","+""+","+nameofwave(excel_info)+","+num2str(excel_row)+","+num2str(excel_col)+","+"bin"+","+"paramRefListIndex","|"	function fa_markCellsInWvList(waveToMark,markVal,listOfMatchStrsToMark,appendAsterisk)	WAVE waveToMark; variable markVal,appendAsterisk	String listOfMatchStrsToMark		Duplicate/O waveToMark, waveToMark_bu		variable i,j	string dl,matchStr	for (i=0;i<dimsize(wavetoMark,0);i+=1)		dl = getdimlabel(waveToMark,0,i)		for (j=0;j<itemsinlist(listOfMatchStrsToMark);j+=1)			if (appendAsterisk)				matchStr = "*" + stringfromlist(j,listOfMatchStrsToMark) + "*"			else				matchStr = stringfromlist(j,listOfMatchStrsToMark)			endif						if (stringmatch(dl,matchStr))				wavetoMark[i] = markVal				break			endif		endfor	endfor	endfunction VI_cursorClickHook(s)	STRUCT WMWinHookStruct &s		Variable hookResult = 0	// 0 if we do not handle event, 1 if we handle it.		if (s.eventCode != 7)		//only continue for cursor move		return 0	endif			NVAR/Z pauseWinHooks	if (NVAR_Exists(pauseWinHooks) && pauseWinHooks)		return 0		endif		String graphN = s.winName	String traceN = s.traceName	String waveRef = NameOfWave(TraceNameToWaveRef(graphN, traceN))	WAVE waveTemp = $waveRef	String cursorN = s.cursorName	Variable point = s.pointNumber	Variable yVal = waveTemp[point]		String cellNAme = StringFromLisT(0,getFileNameFromWaveName(waveRef, 0))	String cellNameShort = StringFromLisT(0,getFileNameFromWaveName(waveRef, 1))[1,inf]		WAVE/T VI_index, hsList	WAVE/D excel_recLens, excel_DIV		Variable VI_row = findStrInTextWaveCol_2D(cellName + "*", "VI_index", 7)	Variable hsListRow =  findStrInTextWaveCol_2D(cellNameShort + "*", "hsList", 0)	//	VI_disp_overlays(VI_row, 0, graphN ="VI_csrPrev")		Print "in VI_cursorClickHook(s). on" + graphN + ". TN= " + traceN + ". WN= " + waveRef + ". cell=" + cellNameShort + ".VI_row=" + num2str(VI_Row) + ". point= " + num2str(point) + ". yVal= " + num2str(yVal)	Print "hsListRow=" + num2str(hsListRow) + ". recLen=" + num2str(excel_recLens[hsListRow]) + ". DIV=" + num2str(excel_DIV[hsListRow]) + ". hs_getComment="	Print "hs_getComment:", hs_getComment(hsListRow)	Print "somaticRin = " 	Print "somaticRa = "		return 1	endfunction FD_tableHook(s)	STRUCT WMWinHookStruct &s	if ((s.eventCode == 3) && ( (s.eventMod & 2^3) != 0))		//left side is only mouse down, right side is cntl down		Variable row, col; String selWaveRef		table_getTableSel(s.winname, row, col, selWaveRef)		WAVE/T tempWave = $selWaveRef		String potentialCellName = tempWave[row][col]		if (strlen(potentialCellName) > 3)			fd_selectMatchingFiles(1, matchStr = ( "*" + potentialCellName + "*"))			if (stringmatch("hsList", StringFromList(1,selWaveRef,":")))				WAVE/T hsList				Print "Selected cell: " + potentialCellName + ". hsList Row = " + num2str(row) + ". HS1 Ped ? = " + hsList[row][2]				Print "hs_getComment=" + hsList[row][40]			endif		endif	endifend//column dim labels not supportedfunction table_fd_goTofiles(s)	STRUCT WMWinHookStruct &s		if (s.eventCode != 3)		//click only		return 0			endif 		if (!(s.eventmod & 2^3))		//ctrl click only		return 0	endif		Variable dlRowsOnly = 1		String wref = table_getTableSel2(s.winname,"table_getSelStats_temp")		if (wavetype($wref,1)!=2)		//not text		return 0	endif	WAVE ti = $"table_getSelStats_temp"		//Variable inRowDLs = ti[%hasDimLabels] && (ti[%waveTargetCol] == 0)		//not reliable		WAVE/T wv=$wref	string selStr		selStr = getdimlabel(wv,0,ti[%firstRow])				print "table_fd_goTofiles():", selStr		Variable fileStrStart = stringmatch(selStr,"G*") 		Variable fileNameLen = 12		fd_selectMatchingFiles(1, matchStr="*" + selStr[fileStrStart,fileNameLen+fileStrStart] + "*",ignoreFields=1)	endfunction table_getSelSum(tableN)	STring tableN		String ref = table_getTableSel2(tableN,"table_getSelStats_temp")	WAVE ti = $"table_getSelStats_temp"		Duplicate/O $ref, table_getSelStats_map_temp	Redimension/B/U table_getSelStats_map_temp	table_getSelStats_map_temp = 1	table_getSelStats_map_temp[ti[%firstRow],ti[%lastRow]][ti[%firstcol],ti[%lastCol]]  = 0//region of interest		ImageStats/R=table_getSelStats_map_temp $ref		killwaves/z table_getSelStats_map_temp,table_getSelStats_temp		return V_avg * V_npnts	endfunction/S table_getTableSel2(tableN,outRef)	String tableN	String outRef//stores selection info for selected wave		Variable waveTargetRow, waveTargetCol, tableTargetCol		//tableinfo works with index of column on table not in wave (tableCol) so find index of waveTargetCol in wave below		//get selected column,row and selection info	String info_all = TableInfo(tableN, -2), into_tableCol		//-2 gives info about whole table, including selection	String selStr = StringByKey("TARGETCELL", info_all)	if (!strlen(selStr))		return ""	endif	sscanf selStr, "%d,%d", waveTargetRow, tableTargetCol			String info_tableCol = TableInfo(tableN, tableTargetCol)		//use col to find name of actual wave that has column selected	String selWaveRef = getwavesdatafolder($StringByKey("WAVE", info_tableCol),2)			String info_selection = Stringbykey("SELECTION",info_all)	Variable firstRow = str2num(stringfromlist(0,info_selection,","))	Variable firstCol = str2num(stringfromlist(1,info_selection,","))	Variable lastRow = str2num(stringfromlist(2,info_selection,","))	Variable lastCol = str2num(stringfromlist(3,info_selection,","))		Variable hasDimLabels = stringmatch(stringbykey("TYPE",TableInfo(tableN, 0)),"Label")	Variable selWaveFirstCol = nan, rowPlaceholder, col_iterator	Variable numWaveCols=0		//this tracks number of columns associated with waves	Variable numTableCols = str2num(stringbykey("COLUMNS",info_all))		//number of columns in table -- any difference from numWaveCols is likely a dim label column edit/ wavename.l column	String currColWaveRef ,lastColWaveRef = ""	for (col_iterator = 0; col_iterator < tableTargetCol; col_iterator+=1)		info_tableCol = TableInfo(tableN, col_iterator)		currColWaveRef = StringByKey("WAVE", info_tableCol)		if (numtype(selWaveFirstCol) && stringmatch(selWaveRef, currColWaveRef))		//numtype(selWaveFirstCol) is true until its set to a real number			selWaveFirstCol = col_iterator		endif	endfor	Variable likelyInRowDLs,likelyInColDLs	if (hasDimLabels)		likelyInRowDLs = tableTargetCol<1				//waveTargetRow<1		likelyInColDLs = waveTargetRow<1	endif	waveTargetCol = tableTargetCol - selWaveFirstCol	- hasDimLabels	//4th table column selected and wave starts on 4th column, selected wave column is 0	firstCol = firstCol - selWaveFirstCol - hasDimLabels	lastCol = lastCol - selWaveFirstcol - hasDimLabels		Make/O/N=(9) $outRef/wave=out	dl_assignAndLbl(out, 0, firstRow, "firstRow")	dl_assignAndLbl(out, 1, firstCol, "firstCol")	dl_assignAndLbl(out, 2, lastRow, "lastRow")	dl_assignAndLbl(out, 3, lastCol, "lastCol")	dl_assignAndLbl(out, 4, waveTargetRow, "waveTargetRow")	dl_assignAndLbl(out, 5, waveTargetCol, "waveTargetCol")	dl_assignAndLbl(out, 6, hasDimLabels, "hasDimLabels")	dl_assignAndLbl(out, 7, likelyInRowDLs, "likelyInRowDLs")	dl_assignAndLbl(out, 8, likelyInColDLs, "likelyInColDLs")		return selWaveRefendfunction/S table_getTableSel(tableN, row, col, selWaveRef)	String tableN	Variable &row, &col	String &selWaveRef		Variable tableCol		//column selected on table, not column of wave selected		String info = TableInfo(tableN, -2)		//-2 gives info about whole table, including selection	String selStr = StringByKey("TARGETCELL", info)	sscanf selStr, "%d,%d", row, tableCol	info = TableInfo(tableN, tableCol)		//use col to find name of actual wave that has column selected	selWaveRef = StringByKey("WAVE", info)		Variable selWaveFirstCol, rowPlaceholder	String currColWaveRef	for (selWaveFirstCol = 0; selWaveFirstCol < tableCol; selWaveFirstCol+=1)		info = TableInfo(tableN, selWaveFirstCol)		currColWaveRef = StringByKey("WAVE", info)		if (stringmatch(selWaveRef, currColWaveRef))			break		endif	endfor	col = tableCol - selWaveFirstCol		//4th table column selected and wave starts on 4th column, selected wave column is 0	endfunction/S disp_makeOrClear(winN, [vMinOut, vMaxOut])	String winN	Variable &vMinOut, &vMaxOut		//if clearing graph and if these are passed, graph x ax min and max will be stored here		if (WinType(winN) != 1)		KillWindowsByName(winN)		Display/K=1/N=$winN		winN = S_name	else		if (!ParamIsDefault(vMinOut) || !ParamIsDefault(vMaxOut))			GetAxis/Q/W=$winN bottom		endif		if (!ParamIsDefault(vMinOut))			vMinOut = V_min		endif		if (!ParamIsDefault(vMaxOut))			vMaxOut = V_max		endif		vis_clearGraph(winN)	endif		return winNendfunction getCsrMean(winSizeS, csrName, [winN])	Variable winSizeS		//window size for mean, in seconds. Currently centered around cursor	String csrName 			//e.g. "A"	String winN				//optionally win name for cursor, helpful when computing things in one statement from multiple windows		if (ParamIsDefault(winN))		winN = ""		//causes csr functions to default to top graph	endif		Variable halfWidth = winSizeS/2		return mean($csrwave($csrName, winN), xcsr($csrName,winN) - halfWidth, xcsr($csrName,winN) + halfWidth)endfunction printMeans(matchStr)	String matchStr		String list = wavelist(matchStr, ";", "TEXT:0")		Variable i; String currN	for (i=0;i<ItemsInList(list);i+=1)		currN = StringFromList(i,list)		Print "mean for index ",num2str(i) + ". Name = " + currN + ". Mean = " + num2str(mean($currN))		endfor	endfunction disp_stretch()	ModifyGraph height=0, width=0	endfunction disp_wh(width_in,height_in)	Variable width_in, height_in		ModifyGraph height=72*height_in, width=72*width_inend	function excel_plotted_update()	WAVE/T cpSummaryIndex	WAVE excel_plotted		Variable i, hsListIndex; String foundCellStr, listOfFoundCells = ""	for (i=0;i<DimSize(cpsummaryIndex,0);i+=1)		if (strlen(cpSummaryIndex[i][19]) > 0)			foundCellStr = cpSummaryIndex[i][0]			hsListIndex = findStrInTextWave_1D(foundCellStr, $"excel_cellNames")			if (hsListIndex < 0)				Print "cpIndex = " + num2stR(i) + ". cellStr = " + foundCellStr			else				excel_plotted[hsListIndex] = 1				if (!stringmatch(listOfFoundCells, "*" + foundCellStr + "*"))					listOfFoundCells += foundCellStr +";"				endif							endif		endif	endfor	Print "list = " + listOfFoundCells	Print "# plotted cells  = " + num2str(itemsInList(listOfFoundCells))endfunction quickRin([vStep,avgWinSizeX])	Variable Vstep,avgWinSizeX			Vstep = ParamIsDefault(vStep) ? nan : vStep	avgWinSizeX=ParamIsDefault(avgWinSizeX) ? nan : avgWinSizeX			return analysis_quickRin(Vstep=vstep,avgWinSizeX=avgWinSizeX)endfunction analysis_quickRin([vStep, avgWinSizeX])	//cursor A on current; cursor B on voltage	//window straddles step and does not include any other changes	Variable vStep	Variable avgWinSizeX		double rin	if (ParamIsDefault(avgWinSizeX) || numtype(avgWinSizeX))		avgWinSizeX = 0.0005	endif		String outRef = csrwave(A)	if (ParamIsDefault(vStep) || numtype(vStep))		String cmdRef = csrwave(B)	endif		Variable do2SiteInput = 0	if ( (strlen(csrinfo(C)) > 0) && (strlen(csrinfo(D)) > 0) )		do2SiteInput = 1	endif		GetAxis/Q bottom	if (do2SiteInput)		String cmdRef1 = csrwave(B)		String outRef2 = csrwave(C)		String cmdRef2 = csrwave(D)				Variable input1 =  ( mean($cmdRef, V_max,  V_max - avgWinSizeX) - mean($cmdRef, V_min,  V_min + avgWinSizeX) ) /   ( mean($outRef, V_max,  V_max - avgWinSizeX) - mean($outRef, V_min,  V_min + avgWinSizeX) )		Variable input2 =  ( mean($cmdRef2, V_max,  V_max - avgWinSizeX) - mean($cmdRef2, V_min,  V_min + avgWinSizeX) ) /   ( mean($outRef2, V_max,  V_max - avgWinSizeX) - mean($outRef2, V_min,  V_min + avgWinSizeX) )		Variable inputTotal = analysis_totalRin({input1, input2})		Print "Input (Rin1, Rin2, totalRin) = " + num2str(input1) + ", " + num2str(input2) + ", " + num2str(inputTotal)			else		if (ParamIsDefault(vStep) || numtype(vStep))			rin=( mean($cmdRef, V_max,  V_max - avgWinSizeX) - mean($cmdRef, V_min,  V_min + avgWinSizeX) ) /   ( mean($outRef, V_max,  V_max - avgWinSizeX) - mean($outRef, V_min,  V_min + avgWinSizeX) )		else			rin=vStep /   ( mean($outRef, V_max,  V_max - avgWinSizeX) - mean($outRef, V_min,  V_min + avgWinSizeX) ) 		endif		print "rin",rin		return rin	endif	 endfunction analysis_totalRin(RinWave)		//takes in set of values, return sum in parrallel for resistators (inverse sum)	WAVE/D rinWave		return rinwave[0] * rinwave[1] / (rinwave[0] + rinwave[1])			//= 1 / ( (1/r1) + (1/r2) )endfunction/S fd_getWaveListStarter()	String out	out="root:channelSelWaveTitles,root:fileSelList,root:fileInfoWaveColumnTitles,root:sweepsTracker,root:channelSelList,root:channelList,root:sweepsSelList,root:sweepsListWave,root:sweepsSelWaveTitles,root:dispPrefsList,root:dispPrefsSelWave,root:dispPrefsTitleWave,root:sweepsDispSelWave,root:sweepsDispList,root:sweepsDispTitleWave,root:fileSelListByNums,root:fileDirBackup,root:fileInfoWaveBackup,"	out+="root:matchesTemp,root:hashTemp,root:fileSelFields,root:sweepsDispSelWaveByNums,root:axesForEachPlottedChannel,root:lastSweepsDispSelWaveByNums"	return outendfunction fd_saveAll()	SVAR fdlist_waves, fdlist_stringvars, fdlist_numvars	//	NewPath fd_savePath 	//	Variable i		savedata/I/J=(fdlist_waves +  fdlist_stringvars + fdlist_numvars)	//	SAVE/C/O/B/P=fd_savePath fdlist_wavesendfunction/S fd_savePaths()	Make/O/T/N=2 fd_savedPaths	String currPaths = "", origPaths = ""		WAVE/T fileDirectory	Variable i	for (i=0;i<DimSize(fileDirectory,0);i+=1)		currPaths += fileDirectory[i][0] + ";"		origPaths += fileDirectory[i][2] + ";"	endfor		fd_savedPaths[0] = origPaths	fd_savedPaths[1] = currPaths		NewPath fd_savePath		String saveName = NameOfWave(fd_savedPaths) + "_" + text_getFormattedDate() 	SAVE/C/O/P=fd_savePath fd_savedPaths as (saveName + ".ibw")	return saveNameendfunction/S text_getFormattedDate()	String dateStr = date()		String yearStr = StringFromList(2, dateStr, ",")		yearStr = yearStr[3,inf]		//throw out first letter as its a space, and next two because they are the beginning of 20XX	String monthDay = StringFromList(1, dateStr, ",")	String monthStr; Variable dayNum	sscanf monthDay, " %s %d", monthStr, dayNum	String dayStr = num2str(dayNum)	if (strlen(dayStr) < 2)		dayStr = "0" + dayStr		//1 digit numbers get a 0	endif		String monthNumStr = text_monthStrToMonthNumStr(monthStr)	return yearStr + monthNumStr + dayStrendfunction/S text_monthStrToMonthNumStr(monthStr)	String monthStr		String monthNumStr		//output			strswitch (monthStr)		case "Jan":			monthNumStr = "01"			break		case "Feb":			monthNumStr = "02"			break		case "Mar":			monthNumStr = "03"			break		case "Apr":			monthNumStr = "04"			break		case "May":			monthNumStr = "05"			break		case "Jun":			monthNumStr = "06"			break		case "Jul":			monthNumStr = "07"			break		case "Aug":			monthNumStr = "08"			break		case "Sep":			monthNumStr = "09"			break		case "Oct":			monthNumStr = "10"			break		case "Nov":			monthNumStr = "11"			break		case "Dec":			monthNumStr = "12"			break	endswitch		return monthNumStrendfunction drift_main(chanNum_S,chanNum_P,startx,endx)	Variable chanNum_S,chanNum_P		//channel numbers for each response or invalid numbers (e.g. negative or nan) if not present	Variable startX,endX		String ref_S = stringfromlist(0,gcl(chanNum_S))	String ref_P = stringfromlist(0,gcl(chanNum_P))		if (numtype(startX) == 2)		startX = -inf	endif	if (numtype(endx) == 2)		endx = inf	endif		string rangeStr = num2str(startX) + " "  + num2str(endx)			if (strlen(ref_S))		Print/d mean($ref_S,startX,endX),ref_S,rangeStr	endif	if (strlen(ref_P))		Print/d mean($ref_P,startX,endX),ref_P,rangeStr	endif		endfunction wave_smooth(matchStrOrListOfWaves,smoothNum)	STring matchStrOrListOfWaves	Variable smoothNum		matchStrOrListOfWaves = list_fromListOrMatchStr(matchStrOrListOfWaves, "WIN:")		Variable i	for (i=0;i<itemsinlist(matchStrOrListOfWaves);i+=1)		smooth smoothNum, $Stringfromlist(i,matchStrOrListOfWaves)	endforend//stepInfoWaves {testPulse_baselineStartX, step_baselineStartX, step_lastNegSweep, step_zeroCurrentSweep}//resp_s_matchStr and all match strings may be wave lists instead (helpful when want to re-order waves, adding in sweeps from others)//for waves, use ";", for match strings, do not use ";"function vi_main_2sweep(resp_S_fS_matchStr,stim_S_fS_matchStr,resp_P_fS_matchStr,stim_P_fS_matchStr,resp_S_fP_matchStr,stim_S_fP_matchStr,resp_P_fP_matchStr,stim_P_fP_matchStr,somaStepInfo,pedStepInfo,doDisplay,streamTags)	String resp_S_fS_matchStr,stim_S_fS_matchStr,resp_P_fS_matchStr,stim_P_fS_matchStr,resp_S_fP_matchStr,stim_S_fP_matchStr,resp_P_fP_matchStr,stim_P_fP_matchStr	//match strings for responses and stim at soma and then at ped	WAVE/D somaStepInfo, pedStepInfo	 //stepInfoWaves: {testPulse_baselineStartX, step_baselineStartX, step_lastNegSweep, step_zeroCurrentSweep}. Pass NaN for all relevant values if any particular aspect is not present.	Variable doDisplay	//pace to auto display results with VI_disp_overlays_g	String streamTags					Variable numBridgeVals_proximal = 2		//perform bridge correction at proximal site, and if so, how many r vals to consider (2 is usually good for my sampling rate of 20kHz)	Variable numBridgeVals_distal = 0		//allow stepInfo inputs of length one to signify nans for all values	Variable origDimSizeInfo_s = dimsize(somaStepInfo,0)	if (origDimSizeInfo_s < 4)		redimension/N=(4) somaStepInfo		somaStepInfo[origDimSizeInfo_s,] = NaN		//fill in any blanks with nans	endif	Variable origDimSizeInfo_p = dimsize(pedStepInfo,0)	if (origDimSizeInfo_p < 4)		redimension/N=(4) pedStepInfo		pedStepInfo[origDimSizeInfo_p,] = NaN		//fill in any blanks with nans	endif	//list_fromListOrMatchStr handles lists and match strings	String resp_S_fS = list_fromListOrMatchStr(resp_S_fS_matchStr,"WIN:")	String stim_S_fS = list_fromListOrMatchStr(stim_S_fS_matchStr,"WIN:")	String resp_P_fS = list_fromListOrMatchStr(resp_P_fS_matchStr,"WIN:")	String stim_P_fS = list_fromListOrMatchStr(stim_P_fS_matchStr,"WIN:")	String resp_S_fP = list_fromListOrMatchStr(resp_S_fP_matchStr,"WIN:")	String stim_S_fP = list_fromListOrMatchStr(stim_S_fP_matchStr,"WIN:")	String resp_P_fP = list_fromListOrMatchStr(resp_P_fP_matchStr,"WIN:")	String stim_P_fP = list_fromListOrMatchStr(stim_P_fP_matchStr,"WIN:")		String cellName,fName;variable cellFileNum	if (numtype(somaStepinfo[0]))		//likely no stimulus/resp at soma .. use ped to get info		cellName = text_getInfoFromWaveName_S(StringFromList(0,resp_S_fP),0)		fName = cellName + "_" + text_getInfoFromWaveName_S(StringFromList(0,resp_S_fP),1)		cellFileNum = text_getInfoFromWaveName_V(StringFromList(0,resp_S_fP), 1)	else		cellName = text_getInfoFromWaveName_S(StringFromList(0,resp_S_fS),0)		fName = cellName + "_" + text_getInfoFromWaveName_S(StringFromList(0,resp_S_fS),1)		cellFileNum = text_getInfoFromWaveName_V(StringFromList(0,resp_S_fS), 1)		endif	Print "cellName",cellName,"fName",fName,"cellFileNum",cellFileNum	VI_repsAndFamily2Site(resp_S_fS,stim_S_fS,resp_P_fS,stim_P_fS,resp_S_fP,stim_S_fP,resp_P_fP,stim_P_fP,somaStepInfo,pedStepInfo,fName,cellName,cellFileNum,numBridgeVals_proximal,numBridgeVals_distal,doDisplay,streamTags)end //vi_main_2sweep()//repStep is a constant step given during the family of sweeps//testStep is a variable level step in the family of sweeps//bsx blx is baselineStartX, baselineEndX//function VI_repsAndFamily2Site(rFam_S,rFam_P,sFam_S,sFam_P,reps_bsx_S,reps_blx_S,test_bsx_S,test_blx_S,lastNeg_S,zeroCurr_S,//function VI_repsAndFamily2Site(respFamily_S, respFamily_P, stimFamily, repStep_bsx, repStep_blx, testStep_bsx, testStep_blx, stepAtTerminal, lastNegativeSweep, zeroCurrentSweep, outRef_S, outRef_P, [cellName, cellFileNum])//repStep Header: //testStep Header: analysis_getStep1SiteHeader()function vi_main_update_all(doDisplay,killAfter)	Variable doDisplay,killAfter	wave/T vi_refs_main0		String skipList = ""		variable i	for (i=0;i<dimsize(vi_refs_main0,0);i+=1)		if (WhichListItem(num2str(i), skipList) < 0)			vi_main_update(i,doDisplay,killAfter)		endif	endforendfunction vi_main_update(row,doDisplay,killAfter)	Variable row,doDisplay,killAfter		doDisplay = killAfter ? 0 : doDisplay			//no display if you want to kill things!		String knownStreamTags = "PUTATIVE_ROD;specificallyFromSomaOrPed;holding;"		//specificallyFromSomaOrPed likely redundent below		WAVE/T VI_refs_main0	String info = VI_refs_main0[row] 			String stepInfoStr_S = c2sc(stringbykey("stepInfoStr_s",info))	String stepInfoStr_P = c2sc(stringbykey("stepInfoStr_p",info))	if (strlen(stepInfoStr_S))		Make/O/N=(4) somaStepInfo		somaStepInfo = str2num(stringfromlist(p,stepInfoStr_S))	else		Make/O/N=(1) somaStepInfo; somaStepInfo = {nan}	endif		if (strlen(stepInfoStr_P))		Make/O/N=(4) pedStepInfo		pedStepInfo = str2num(stringfromlist(p,stepInfoStr_P))	else		Make/O/N=(1) pedStepInfo; pedStepInfo = {nan}	endif		Variable testSteps_fS = !numtype(somaStepInfo[0])	Variable repSteps_fS = !numtype(somaStepInfo[1])	Variable testSteps_fP = !numtype(pedStepInfo[0])	Variable repSteps_fP = !numtype(pedStepInfo[1])		Print/D "somaStepInfo",somaStepInfo	Print/D "pedStepInfo",pedStepInfo		Variable specificallyFromSomaOrPed = str2num(stringbykey("specificallyFromSomaOrPed",info))		String r_Fam_S_key = "rFam_S"	String s_Fam_S_key = "sFam_S"	String r_Fam_P_key = "rFam_P"	String s_Fam_P_key = "sFam_P"		Variable usesNewKeys = stringmatch(info,"*;rfam_S_fS:*") || stringmatch(info,"*;rfam_P_fP:*")		if (usesNewKeys)		if (specificallyFromSomaOrPed == 0)		//from soma specifically			r_Fam_S_key += "_fS"			s_Fam_S_key += "_fS"			r_Fam_P_key += "_fS"			s_Fam_P_key += "_fS"		elseif (specificallyFromSomaOrPed == 1)			r_Fam_S_key += "_fP"			s_Fam_S_key += "_fP"			r_Fam_P_key += "_fP"			s_Fam_P_key += "_fP"						else		//specifically from soma or ped is NaN, so sweeps contain both sites at once			if (testSteps_fS)		//if recording at both sites, then family lists are the same fS and fP				r_Fam_S_key += "_fS"				s_Fam_S_key += "_fS"				r_Fam_P_key += "_fS"				s_Fam_P_key += "_fS"						else						//if no testSteps at soma, then must only be test steps at ped				r_Fam_S_key += "_fP"				s_Fam_S_key += "_fP"				r_Fam_P_key += "_fP"				s_Fam_P_key += "_fP"							endif		endif			else		//old keys, nice and simple		//leave keys as they are	endif				String da_fd_loadList = ""	String rFam_S = c2sc(stringbykey(r_Fam_S_key,info));da_fd_loadList+=rFam_S	String sFam_S = c2sc(stringbykey(s_Fam_S_key,info));da_fd_loadList+=sFam_S	String rFam_P = c2sc(stringbykey(r_Fam_P_key,info));da_fd_loadList+=rFam_P	String sFam_P = c2sc(stringbykey(s_Fam_P_key,info));da_fd_loadList+=sFam_P	variable i; string currTag, currInfo, streamTags = ""	for (i=0;i<itemsinlist(knownStreamTags);i+=1)		currTag = stringfromlist(i,knownStreamTags)		currInfo = stringbykey(currTag,info)		streamTags += currTag + ":" + currInfo + ";"	endfor		da_fd_loadWavesFromWaveName(da_fd_loadList,1)		vi_main_1sweep(rFam_S,sFam_S,rFam_P,sFam_P,somaStepInfo,pedStepInfo,doDisplay,streamTags,specificallyFromSomaOrPed)		if (killAfter)		String killExample		if (strlen(rFam_S))			killExample = stringfromlist(0,rFam_S)		else			killExample = stringfromlist(0,rFam_P)		endif		killwavesbyname(text_getInfoFromWaveName_S(killExample, 9)+"*")	endif	endfunction vi_mainc(respChaNum_S,stimChanNum_S,respChanNum_P,stimChanNum_P,somaStepInfo,pedStepInfo,doDisplay,streamTags,specificallyFromSomaOrPed)	Variable respChaNum_S,stimChanNum_S,respChanNum_P,stimChanNum_P	WAVE/D somaStepInfo, pedStepInfo	 //stepInfoWaves: {testPulse_baselineStartX, step_baselineStartX, step_lastNegSweep, step_zeroCurrentSweep}. Pass NaN for all relevant values if any particular aspect is not present.	Variable doDisplay	//pace to auto display results with VI_disp_overlays_g	String streamTags	Variable specificallyFromSomaOrPed	//pass 0 for soma, 1 for ped to append specify that though there is a stimulus from soma or ped, they're being processed seperately (usually because the stimuli were delivered in different sweeps)				//pass nan if just or or both together, pass 0 for soma and ped is a seperate call to vi_main/vi_mainc, 1 for ped and soma a seperate call			vi_main_1sweep("*AD"+num2str(respChaNum_S),"*AD"+num2str(stimChanNum_S),"*AD"+num2str(respChanNum_P),"*AD"+num2str(stimChanNum_P),somaStepInfo,pedStepInfo,doDisplay,streamTags,specificallyFromSomaOrPed)end//stepInfoWaves {testPulse_baselineStartX, step_baselineStartX, step_lastNegSweep, step_zeroCurrentSweep}//resp_s_matchStr and all match strings may be wave lists instead (helpful when want to re-order waves, adding in sweeps from others)//for waves, use ";", for match strings, do not use ";"function vi_main_1sweep(resp_S_matchStr,stim_S_matchStr,resp_P_matchStr,stim_P_matchStr,somaStepInfo,pedStepInfo,doDisplay,streamTags,specificallyFromSomaOrPed)	String resp_S_matchStr,stim_S_matchStr,resp_P_matchStr,stim_P_matchStr	//match strings for responses and stim at soma and then at ped	WAVE/D somaStepInfo, pedStepInfo	 //stepInfoWaves: {testPulse_baselineStartX, step_baselineStartX, step_lastNegSweep, step_zeroCurrentSweep}. Pass NaN for all relevant values if any particular aspect is not present.	Variable doDisplay	//pace to auto display results with VI_disp_overlays_g	String streamTags	Variable specificallyFromSomaOrPed	//pass to append specify that though there is a stimulus from soma or ped, they're being processed seperately (usually because the stimuli were delivered in different sweeps)				//pass nan if just or or both together, pass 0 for soma and ped is a seperate call to vi_main/vi_mainc, 1 for ped and soma a seperate call					Variable numBridgeVals_proximal = 2		//perform bridge correction at proximal site, and if so, how many r vals to consider (2 is usually good for my sampling rate of 20kHz)	Variable numBridgeVals_distal = 0		//allow stepInfo inputs of length one to signify nans for all values	Variable origDimSizeInfo_s = dimsize(somaStepInfo,0)	if (origDimSizeInfo_s < 4)		redimension/N=(4) somaStepInfo		somaStepInfo[origDimSizeInfo_s,] = NaN		//fill in any blanks with nans	endif	Variable origDimSizeInfo_p = dimsize(pedStepInfo,0)	if (origDimSizeInfo_p < 4)		redimension/N=(4) pedStepInfo		pedStepInfo[origDimSizeInfo_p,] = NaN		//fill in any blanks with nans	endif	//list_fromListOrMatchStr handles lists and match strings	String resp_S = list_fromListOrMatchStr(resp_S_matchStr,"WIN:")	String stim_S = list_fromListOrMatchStr(stim_S_matchStr,"WIN:")	String resp_P = list_fromListOrMatchStr(resp_P_matchStr,"WIN:")	String stim_P = list_fromListOrMatchStr(stim_P_matchStr,"WIN:")		String cellName = text_getInfoFromWaveName_S(StringFromList(0,resp_S),0)	String fName = cellName + "_" + text_getInfoFromWaveName_S(StringFromList(0,resp_S),1)	Variable cellFileNum = text_getInfoFromWaveName_V(StringFromList(0,resp_S), 1)		Print "cellName",cellName,"fName",fName,"cellFileNum",cellFileNum	VI_repsAndFamily2Site(resp_S,stim_S,resp_P,stim_P,resp_S,stim_S,resp_P,stim_P,somaStepInfo,pedStepInfo,fName,cellName,cellFileNum,numBridgeVals_proximal,numBridgeVals_distal,doDisplay,streamTags)end //vi_main()//determine if input is a list (containing semi-colon) or a matchStr (not containing semi colon)//return list of waves based on input (return is the input in case of lists)//match strings with ";" not handledfunction/S list_fromListOrMatchStr(listOrMatchStr, waveListMod)	String listOrMatchStr	String waveListMod		//in case of matchstring, pass modifiers e.g. "WIN:" for top win		String outList		if (stringmatch(listOrMatchStr, "*;*"))		//list		outList = listOrMatchStr	else			//assumed match string		outList = wavelist(listOrMatchStr, ";", waveListMod)	endif		return outList	end//basically won't work with any duplicates in either list..function/S list_reorder(list,orderList)	String list		//list of waves to reorder	String orderList	//newPositions for each list items		Variable numItems = itemsinlist(list)		String outList = ""// text_getRepeatedStr(";",numItems)		Variable i,newPos; string stringToMove,stringInNewPos	for (i=0;i<numItems;i+=1)		stringToMove = stringfromlist(i,list)		newPos = str2num(stringfromlist(i,orderList))		outList = AddListItem(stringToMove, outList , ";",newPos)	endfor		return outListendfunction VI_auto_load()	PathInfo vi_path		if (!V_flag)		newpath vi_path	endif		loadwave/O/H/P=VI_path		String wname = StringFromList(0, S_waveNames)	WAVE inWv = $wname	String wnote = note(inWv)	String fName = StringByKey("fName", wnote)		String listWvRef = "VI_all_list"	Variable currIndex = -1, i	WAVE/Z/T listWv = $listWvRef	Variable numParams = 10	if (!WaveExists(listWv))		Print "Making new VI_all_list. name = " + listWvRef		Make/O/N=(1,numParams)/T $listWvRef/WAVE=listWv		currIndex = 0	else		if (numParams > DimSize(listWv,1))			Redimension/N=(-1, numParams) listWv		endif			//find row that this file is at 		for (i=0;i<DimSize(listWv,0);i+=1)			if (stringmatch(fName, listWv[i][0]))				currIndex = i				break			endif		endfor				if (currIndex < 0)		//not found bc default was -1			currIndex = Dimsize(listWv,0)			Redimension/N=(currIndex+1,numParams) listWv		endif	endif		//inputs: soma  {0testPulse_baselineStartX, 1step_baselineStartX, 2step_lastNegSweep, 3step_zeroCurrentSweep}. ped  {4testPulse_baselineStartX, 5step_baselineStartX, 6step_lastNegSweep, 7step_zeroCurrentSweep}., 8cell fileNum	Variable hasRepsFromSoma = numtype(inWv[0]) == 0	Variable hasRepsFromPed = numtype(inWv[4]) == 0	Variable hasStepsFromSoma = numtype(inWv[1]) == 0	Variable hasStepsFromPed = numtype(inWv[5]) == 0	Variable fileNum = inWv[8]		listWv[currIndex][0] = fName	listWv[currIndex][1] = 	num2str(hasStepsFromSoma)		//num2str(hasStepsFromSoma || str2num(listWv[currIndex][1]) ? 1 : 0)		//retain old settig if already found one for other site	listWv[currIndex][2] = 	num2str(hasStepsFromPed)		//num2str(hasStepsFromPed || str2num(listWv[currIndex][2]) ? 1 : 0)	listWv[currIndex][3] = 	num2str(hasRepsFromSoma)		//num2str(hasRepsFromSoma || str2num(listWv[currIndex][3]) ? 1 : 0)	listWv[currIndex][4] = 	num2str(hasRepsFromPed	)	//num2str(hasRepsFromPed || str2num(listWv[currIndex][4]) ? 1 : 0)	listWv[currIndex][5] = num2str(fileNum)	listWv[currIndex][6] = wname	//	listWv[currIndex][7]   //RESERVED FOR INFO ABOUT PAIRED WAVE, user should input other site's row in VI_all_list		//link up fa info for cell params	PathInfo fa_path	if (!V_flag)		//path does not exist		NewPath fa_path	endif	Print "Select somatic FA"	String somatic_fa = fa_load(0,1)	Print "Select terminal FA"	String term_fa = fa_load(0,1)	listWv[currIndex][8] = somatic_fa	listWv[currIndex][9] = term_fa			//column 7 reserved for writing paired rowsendfunction/s list_contSubset(strList,startIndex,num)		//returns items in list from startIndex up to num	String strList	Variable startIndex,num		if (startIndex < 0)		startIndex = 0	endif		variable i,ind,maxInd=itemsinlist(strList)-1; string out=""	for (i=0;i<num;i+=1)		ind=i+startIndex		if (ind>maxInd)			break		endif		out+=stringfromlist(ind,strList)+";"	endfor	return outendfunction/S fa_load(resetPath, loadParams)	Variable resetPath, loadParams		//pass latter to loadparams wave autoamatically		PathInfo fa_path	if (!V_flag || resetPath)		//path does not exist		NewPath/O fa_path	endif		loadwave/O/H/P=fa_path			String wname = StringFromList(0, S_waveNames)		note/nocr $wname, "load_path:"+s_path+";"		String paramWvName = StringByKey("paramWv", note($wname))		if (loadParams)	//assumes params wave stored in same file		loadwave/o/h s_path+paramWvName	endif		return wname		end//VI_dispParam_g(49, "lineBaselineCross","stim_step - baseline","testSteps_SfS","testSteps_PfS","testSteps_Diffs_fS",0,0,diffAx="")//VI_dispParam_g(49, "threshProportions_6_pB_rDX","stim_step - baseline","testSteps_SfS","testSteps_PfS","testSteps_Diffs_fS",0,0,diffAx="")//VI_dispParam_g(49, "threshProportions_6_pB_rDX","stim_step - baseline","testSteps_SfP","testSteps_PfP","testSteps_Diffs_fP",1,1,diffAx="")//VI_dispParam_g(49, "peakBaselineDiff","stim_step - baseline","testSteps_SfS","testSteps_PfS","testSteps_Diffs_fS",0,0,diffAx="")//VI_dispParam_g(49, "peakBaselineDiff","stim_step - baseline","testSteps_SfP","testSteps_PfP","testSteps_Diffs_fP",1,1,diffAx="")//VI_dispParam_g(49, "resp_deltas_2","stim_step - baseline","testSteps_SfS","testSteps_PfS","testSteps_Diffs_fS",0,0,diffAx="")//VI_dispParam_g(49, "resp_deltas_2","stim_step - baseline","testSteps_SfP","testSteps_PfP","testSteps_Diffs_fP",1,1,diffAx="")//"resp_deltas_2;peakBaselineDiff;threshProportions_6_pB_rDX;lineBaselineCross;"//"stim_step - baseline"///savetopgraphs(4,"t",w=2.6,h=2) is a good size for overlays//savetopgraphs(4,"t",w=2.2,h=2) is a good size for paramsfunction VI_dispParams(somaParamWv, pedParamWv, diffParamWv, yParamList, xParam)	WAVE somaParamWv, pedParamWv, diffParamWv	String yParamList, xParam		//pass blank for presets		if (!strlen(yParamList))		yParamList = "resp_deltas_2;peakBaselineDiff;threshProportions_6_pB_rDX;lineBaselineCross;"	endif	if (!strlen(xParam))		xParam = "stim_step - baseline"	endif			Variable i	for (i=0;i<ItemsInList(yParamList);i+=1)		VI_dispParam(somaParamWv, pedParamWv, diffParamWv, StringFromList(i,yParamList), xParam)	endforendfunction VI_dispParam(somaParamWv, pedParamWv, diffParamWv, yParam, xParam)	WAVE somaParamWv, pedParamWv, diffParamWv	String yParam, xParam	//(65280,0,0)	Display/K=1		String VI_HeaderRef = analysis_getStep1SiteHeader()		Variable yParamRow = findInHeader(yParam, VI_HeaderRef)	Variable xParamRow = findInHeader(xParam, VI_HeaderRef)		appendtograph/C=(0,0,0) somaParamWv[yParamRow][] vs  somaParamWv[xParamRow][]; Label left, yParam; Label bottom, xParam	appendtograph/C=(65280,0,0) pedParamWv[yParamRow][] vs  pedParamWv[xParamRow][]	appendtograph/R/C=(0,0,65280) diffParamWv[yParamRow][] vs  somaParamWv[xParamRow][]; Label right, "Difference"end//add a note to a list of wavesfunction wave_note(refList,noteStr,nocr,kill,[retrieveFromKeyListWithOptions])	String refList		//list of wave refs to add note to	String noteStr	Variable	nocr,kill		//pass true for these to include these note function options	Variable retrieveFromKeyListWithOptions		//pass as 0 if list is a key list where KEYS are wave names; pass 1 if list is a key list where ITEMS are wave names		if (!ParamIsDefault(retrieveFromKeyListWithOptions) && !numtype(retrieveFromKeyListWithOptions))		refList=list_allStrings_fromKeyedList(refList,retrieveFromKeyListWithOptions)	endif		variable i;string ref	for (i=0;i<itemsinlist(refList);i+=1)		ref = stringfromlist(i,reflist)		if (Waveexists($ref))			if (nocr && kill)				note/nocr/k $ref, noteStr			elseif (nocr)				note/nocr $ref, noteStr			elseif (kill)				note/k $ref, noteStr			else				note $ref, noteStr			endif		endif	endforendfunction wavesExist(reflist)	String reflist		Variable i	for (i=0;i<ItemsInList(reflist);i+=1)		if (!WaveExists($StringFromList(i, reflist)))			return 0		endif	endfor		return 1	end//analysis_stepAndStimulus//calculates statistics of a command step, for use in calculating cell parameters etc. currently only works for the first step //revised May 2016 to work with the more reliable step stats function analysis_cellParamsSimple_cmdfunction analysis_stepChangeStats(inRef, outRef, isNegativeGoing, minStepSizeMagnitude, searchStart)	String inRef 					//cmd step ref	String outRef					//see below for order of params	Variable  isNegativeGoing		//1 for negative going, 0 for positive going		//seems to primarily effect readout of level, not step timing. The larger the better therefore for a true step function where the response should be flat before and after. 		//if accuracy is crucial, better to average across as large a window before during and after step	Variable minStepSizeMagnitude			//Depends on size of step. ALWAYS POSITIVE. 3 pA ( 3*10^-12) seems like a good size for CC stimuli	Variable searchStart			//where to start looking for step		WAVE findStepChangeTemp = $inRef		Variable preCheckForStep = 0	Variable  t0, t1, baseline, step, final			//t0 and t1 are step start and end, baseline is baseline value, step is step value, final is post step value	analysis_cellParamsSimple_cmd(inRef, 1, 1, searchStart,  isNegativeGoing,  t0, t1, baseline, step, preCheckForStep, cmd_final=final, storeAndOrForceMinStepSize=minStepSizeMagnitude)		Variable numParams = 18	Make/O/D/N=(numParams) $outRef		//avoiding duplications	WAVE/D outTemp = $outRef		//output params:	Variable r	r=0;dl_assignAndLbl(outTemp,r,	baseline,"baseline")	r=1;dl_assignAndLbl(outTemp,r,	step,"step")	r=2;dl_assignAndLbl(outTemp,r,	final,"final")	r=3;dl_assignAndLbl(outTemp,r,	t0,"t0")	r=4;dl_assignAndLbl(outTemp,r,	t1,"t1")	r=5;dl_assignAndLbl(outTemp,r,	step - baseline,"step - baseline")	r=6;dl_assignAndLbl(outTemp,r,	final - baseline,"final - baseline")	r=7;dl_assignAndLbl(outTemp,r,	final - step,"final - step")	//about analyzed wave:	r=8;dl_assignAndLbl(outTemp,r,	DimDelta(findStepChangeTemp,0),"DimDelta")	r=9;dl_assignAndLbl(outTemp,r,	DimOffset(findStepChangeTemp,0),"DimOffset")	//about this analysis:	r=10;dl_assignAndLbl(outTemp,r,	isNegativeGoing,"isNegativeGoing")	r=11;dl_assignAndLbl(outTemp,r,	NaN,"edgePaddingX")	//edgePaddingX	r=12;dl_assignAndLbl(outTemp,r,	NaN,"edgeBaseAveraging")	//edgeBaseAveraging	r=13;dl_assignAndLbl(outTemp,r,	minStepSizeMagnitude,"minStepSizeMagnitude")	r=14;dl_assignAndLbl(outTemp,r,	searchStart,"searchStart")	r=15;dl_assignAndLbl(outTemp,r,	NaN	,"baselineLenX")//baselineLenX	r=16;dl_assignAndLbl(outTemp,r,	NaN,"searchStart") 	//searchStart	r=17;dl_assignAndLbl(outTemp,r,	NaN,"treatAsTrueStepFunc")	//treatAsTrueStepFunc		Note outTemp, "analysis_stepChangeStats();DATAWAVE:" + inRef + ";"//	Print "Step info: orig.end=" + num2str(stepEnd) + "basel.=" + num2str(baseline) + ". step=" + num2str(step) + ". t0=" + num2str(t0) + ". t1=" + num2str(t1) + ". final=" + num2str(final) +". isNegGoing=" + num2str(isNegativeGoing)endfunction/S analysis_getStepChangeHeader()	String outRef = "analysis_stepChangeHeader"	Variable numParams = 18	Make/O/T/N=(numParams) $outRef	WAVE/T tempHeader = $outRef	//output params:	tempHeader[0] = "stim_baseline"	tempHeader[1] = "stim_step"	tempHeader[2] = "stim_final"	tempHeader[3] = "stim_t0"	tempHeader[4] = "stim_t1"	tempHeader[5] = "stim_step - baseline"	tempHeader[6] = "stim_final - baseline"	tempHeader[7] = "stim_final - step"	//about analyzed wave:	tempHeader[8] = "stim_DimDelta"	tempHeader[9] = "stim_DimOffset"	//about this analysis:	tempHeader[10] = "stim_isNegativeGoing"	tempHeader[11] = "stim_edgePaddingX"	tempHeader[12] = "stim_edgeBaseAveraging"	tempHeader[13] = "stim_minStepSizeMagnitude"	tempHeader[14] = "stim_baselineStartX"	tempHeader[15] = "stim_baselineLenX"	tempHeader[16] = "stim_searchStartOffsetX"	tempHeader[17] = "stim_treatAsTrueStepFunc"			return outRefend//proper header for 1 site step infofunction/S analysis_getStep1SiteHeader()	String outRef = "analysis_step1SiteHeader"	Variable numInitialParams = 8	Variable numDerivedParams = 25	Make/O/T/N=(numInitialParams) outTemp_initial		//stores initial fit info, e.g. fit win size	Make/O/T/N=(numDerivedParams) outTemp_derived	//stores derived values	outTemp_derived[0] = "peakVal"		outTemp_derived[1] = "peakLoc"	outTemp_derived[2] = "timeToPeak"	outTemp_derived[3] = "peakBaselineDiff"	outTemp_derived[4] = "peakSSDiff"		outTemp_derived[5] = "troughVal"	outTemp_derived[6] = "troughX"	outTemp_derived[7] = "peakMinusTrough"	outTemp_derived[8] = "timeToTrough"		outTemp_derived[9] = "baselineSD"		outTemp_derived[10] = "lineStartProp"		outTemp_derived[11] = "lineEndProp"		outTemp_derived[12] = "lineEndX"		outTemp_derived[13] = "lineStartX"	outTemp_derived[14] = "lineEndVal"	outTemp_derived[15] = "lineStartVal"	outTemp_derived[16] = "lineSlope"	outTemp_derived[17] = "lineZeroCross"	outTemp_derived[18] = "lineBaselineCross"	outTemp_derived[19] = "lineStartX_relStep"// = lineStartX - t0	outTemp_derived[20] = "lineEndX_relStep"// = lineEndX - t0	outTemp_derived[21] = "lineZeroCross_relStep"// = lineZeroCross-t0	outTemp_derived[22] = "lineBaselineCross_relStep"// = lineBaselineCross - t0				outTemp_derived[23] = "storedSweepNum"	outTemp_derived[24] = "storedCellFileNum"		outTemp_initial[0] = "resp_stepLen"	outTemp_initial[1] = "resp_fitWinSize"	outTemp_initial[2] = "resp_numPolyFitParams"	outTemp_initial[3] = "resp_numBaselineProportions"	outTemp_initial[4] = "resp_numStepProportions"	outTemp_initial[5] = "resp_defaultBaselineProportion"	outTemp_initial[6] = "resp_defaultStepProportion"	outTemp_initial[7] = "resp_numPolyFitParams"		Variable numBaselineProportions = 5, numStepProportions = 5	Make/O/T/N=(numBaselineProportions) baselineProportions, baselineLens, baselineAvgs	Make/O/T/N=(numStepProportions) stepProportions, stepLens, stepAvgs, deltas, Rins			//proportions of step considered SS in avg for ss. deltas and Rins use defaultBaselineProportionForRin	baselineProportions = "resp_baselineProportions_" + num2str(p)	baselineLens = "resp_baselineLens_" + num2str(p)	baselineAvgs = "resp_baselineAvgs_" + num2str(p)	stepProportions = "resp_stepProportions_" + num2str(p)		stepLens = "resp_stepLens_" + num2str(p)	stepAvgs = "resp_stepAvgs_" + num2str(p)	deltas = "resp_deltas_" + num2str(p)	Rins = "resp_Rins_" + num2str(p)		Make/O/T/N=20 polyHeader		//first place for x0, rest for the 19 coefs		polyHeader[0] = "polyfit_constant_x0"	polyHeader[1,] = "polyfit_coef_" + num2str(p-1)		Variable numThreshParams = 9	Make/O/T/N=(numThreshParams) thresholdProportions,thresholdVals_peakToBase,thresholdVals_peakToSS,thresholdTimes_peakToBase_Rise,thresholdTimes_peakToBase_Fall,thresholdTimes_peakToSS_Rise,thresholdTimes_peakToSS_Fall	Make/O/T/N=(numThreshParams) widthAtThresh_peakToBase,widthAtThresh_pB_pSS,timeToThresh_peakToBase_Rise,timeToThresh_peakToBase_Fall,timeToThresh_peakToSS_Rise,timeToThresh_peakToSS_Fall	thresholdProportions[] = "threshProportions_" + num2str(p)	thresholdProportions[7] = "threshProp_2sdev"			//threhsold set as 2*sdev	thresholdProportions[8] = "threshProp_4sdev"			//threshold set as 4*sdev	thresholdVals_peakToBase = thresholdProportions + "_pB_V"	thresholdVals_peakToSS = thresholdProportions + "_ssB_V"	thresholdTimes_peakToBase_Rise = thresholdProportions + "_pB_rX"		//X (time) value	thresholdTimes_peakToBase_Fall = thresholdProportions + "_pB_fX"	thresholdTimes_peakToSS_Rise = thresholdProportions + "_ssB_rX"	thresholdTimes_peakToSS_Fall = thresholdProportions + "_ssB_fX"		widthAtThresh_peakToBase = thresholdProportions  + "_pB_W"	widthAtThresh_pB_pSS = thresholdProportions  + "_ssB_W"	timeToThresh_peakToBase_Rise = thresholdProportions + "_pB_rDX"		//delta X (change in time)	timeToThresh_peakToBase_Fall = thresholdProportions + "_pB_fDX"		//delta X (change in time)		timeToThresh_peakToSS_Rise = thresholdProportions + "_ssB_fDX"		timeToThresh_peakToSS_Fall = thresholdProportions + "_ssB_fDX"			//	Concatenate /NP /O /D /KILL {$analysis_getStepChangeHeader(),outTemp_initial,outTemp_derived,baselineProportions,baselineLens,baselineAvgs,stepProportions,stepLens,stepAvgs,deltas,Rins,polyHeader}, $outRef	Concatenate/NP/O/D/Kill {$analysis_getStepChangeHeader(),outTemp_initial,outTemp_derived,baselineProportions,baselineLens,baselineAvgs,stepProportions,stepLens,stepAvgs,deltas,Rins}, VI_parOut0	Concatenate/NP/O/D/Kill {VI_parOut0,thresholdProportions,thresholdVals_peakToBase,thresholdVals_peakToSS,thresholdTimes_peakToBase_Rise,thresholdTimes_peakToBase_Fall,thresholdTimes_peakToSS_Rise,thresholdTimes_peakToSS_Fall}, VI_parOut1	Concatenate/NP/O/D/Kill {VI_parOut1,widthAtThresh_peakToBase,widthAtThresh_pB_pSS,timeToThresh_peakToBase_Rise,timeToThresh_peakToBase_Fall,timeToThresh_peakToSS_Rise,timeToThresh_peakToSS_Fall}, VI_parOut2	Concatenate/NP/O/D/Kill {VI_parOut2, polyHeader}, $outRef	return outRefendfunction/S analysis_getStep1Site(stepParamsRef)	String stepParamsRef	String headerRef = analysis_getStep1SiteHeader() 	String/G analysis_stepSummary, analysis_headerSummary	wfprintf analysis_stepSummary, "%g;", $stepParamsRef	wfprintf analysis_headerSummary, "%s;", $headerRef	Variable i; String list = ""	for (i=0; i< ItemsInList(analysis_stepSummary);i+=1)		list += StringFromList(i, analysis_headerSummary)  + ":" + StringFromList(i, analysis_stepSummary) + ";"	endfor//	Print list	KillStrings analysis_stepSummary, analysis_headerSummary	return listend	//good size for saving to one page:// (4 overlays)  savetopgraphs(4,"t",w=2.6,h=2)// (4 param graphs) savetopgraphs(4,"t",w=2.2,h=2)//good window sizes for zoomed in : //setaxis bottom, -0.0025, 0.01;setaxis/A=2 L_0; disp_matchAxisScaling("L_0;", 2)//for zoomed out:////setaxis bottom, -0.02, 0.3;setaxis/A=2 L_0; disp_matchAxisScaling("L_0;", 2)//good windows for two injection site traces: function VI_disp_overlays_g(fromPed, subBaselineAndAlignTo0, somaParamsRef, pedParamsRef, rFam_S,sFam_S,rFam_P,sFam_P, [graphN, hsRow])	Variable fromPed, hsRow	String somaParamsRef, pedParamsRef, rFam_S,sFam_S,rFam_P,sFam_P	String graphN	Variable subBaselineAndAlignTo0	Variable zeroCurrentSweep = NaN		String cellName	if (ParamIsDefault(hsRow))		String mainRef		if (fromPed)			mainRef = stringfromlist(0,rFam_P)		else			mainRef = StringfromList(0,rFam_S)		endif		cellName = text_getInfoFromWaveName_S(mainRef, 0)	else		WAVE/T VI_index				WAVE/T hsList, excel_cellNames, excel_cultureDesc, excel_tissueSource		cellName = excel_cellNames[hsRow]	endif	Variable attemptOldWindow	if (ParamIsDefault(graphN))		attemptOldWindow = 0		if (fromPed)			graphN = "G" + cellName + "_VI_fromPed"				//graphN = "G" + VI_index[row][0] + "_VI"		else			graphN = "G" + cellName + "_VI_fromSoma"					endif	else		attemptOldWindow = 1	endif			wave_checkList(rFam_S)	wave_checkList(sFam_S)	wave_checkList(rFam_P)	wave_checkList(sFam_P)			String somaRespFamily_comma = ReplaceString(";",rFam_S,",") + ";"		//replacement makes suitable format for disp_overlays()	String somaStimFamily_comma = ReplaceString(";",sFam_S,",") + ";"	String pedRespFamily_comma =ReplaceString(";", rFam_P,",") + ";"	String pedStimFamily_comma = ReplaceString(";",sFam_P,",") + ";"		String labelStr	if (ParamIsDefault(hsRow))		labelStr = cellName	else		WAVE excel_recLens		WAVE excel_DIV		labelStr = excel_cellNames[hsRow] + ". Len=" + num2str(excel_recLens[hsrow]) + ". From Ped =" + num2str(fromPed)	endif			String paramsRefForTiming	if (fromPed)		paramsRefForTiming = pedParamsRef	else		paramsRefForTiming = somaParamsRef	endif	WAVE paramsWvForTiming = $paramsRefForTiming		if (subBaselineAndAlignTo0)		Variable t0 = paramsWvForTiming[%stim_ri_t0_start_X]		//getParamFromHeader_2D("stim_t0", "analysis_step1SiteHeader", paramsRefForTiming, 0)		Variable t1 = paramsWvForTiming[%stim_fa_t0_end_X]		//getParamFromHeader_2D("stim_t1", "analysis_step1SiteHeader", paramsRefForTiming, 0)		Variable baselineUsed = paramsWvForTiming[%resp_defaultBaselineProportion]		//getParamFromHeader_2D("resp_defaultBaselineProportion", "analysis_step1SiteHeader", paramsRefForTiming, 0)		Variable baselineLen = paramsWvForTiming[%resp_baselineLens0]		//getParamFromHeader_2D("resp_baselineLens_" + num2str(baselineUsed), "analysis_step1SiteHeader", paramsRefForTiming, 0)	endif	String overlayRefsStr = somaRespFamily_comma + pedRespFamily_comma + somaStimFamily_comma + pedStimFamily_comma		Variable left,top, right, bottom	Variable winKilled = killWindowsByName(graphN, lastLeft=left, lastTop=top, lastRight=right, lastBottom=bottom)	disp_overlays(graphN, attemptOldWindow, overlayRefsStr, "L_0;L_0;L_1;L_2", "b;R;b;R;", axisPairs=".26,1;.26,1;0,.12;.13,.25")	Label/W=$graphN bottom,  labelStr		if (subBaselineAndAlignTo0)		doupdate;		baseSub_GenUse("*AD0", 1, 0, 0, xStart=(t0-baselineLen), xEnd=t0, xOffset=-t0, winN = graphN)		//no bs win		baseSub_GenUse("*AD2", 1, 0, 0, xStart=(t0-baselineLen), xEnd=t0, xOffset=-t0, winN = graphN)		baseSub_GenUse("*AD1", 1, 0, 0, xStart=(t0-baselineLen), xEnd=t0, xOffset=-t0, winN = graphN)		baseSub_GenUse("*AD3", 1, 0, 0, xStart=(t0-baselineLen), xEnd=t0, xOffset=-t0, winN = graphN)			//baseline sub'd window		String graphN_bs = graphN+"_bs";				String somaLineFitRefs,pedLineFitRefs		if (!numtype(zeroCurrentSweep))			somaLineFitRefs = VI_getLineFits_alt(rFam_S, somaParamsRef,0,fromPed,zeroCurrentSweep)			pedLineFitRefs = VI_getLineFits_alt(rFam_P, pedParamsRef,1,fromPed,zeroCurrentSweep)		else			somaLineFitRefs =	VI_getLineFits_g(rFam_S, somaParamsRef,0,fromPed)			// VI_getLineFits(row,0)		//returns list of line fit refs, and generates line fits as well							 pedLineFitRefs = 	VI_getLineFits_g(rFam_P, pedParamsRef,1,fromPed)			//VI_getLineFits(row,1)		//returns list of line fit refs, and generates line fits as well			endif				somaLineFitRefs = ReplaceString(";",somaLineFitRefs,",")			//comma delim again for use in disp overlays		pedLineFitRefs = ReplaceString(";",pedLineFitRefs,",")			String lineFitRefs = somaLineFitRefs + ";" + pedLineFitRefs + ";"				String appendStr		if (fromPed)			appendStr = "fP"		else			appendStr = "fS"		endif				disp_overlays(GraphN_bs, attemptOldWindow, overlayRefsStr + lineFitRefs, "L_0;L_0;L_1;L_2;L_0;L_0;", "b;R;b;R;t;p;", axisPairs=".26,1;.26,1;0,.12;.13,.25;.26,1;.26,1;")		vis_modifyGraphForTraces(GraphN_bs,"*_viLF"+appendStr+"*", "lstyle", "7")		vis_modifyGraphForTraces(GraphN_bs,"*_viLF"+appendStr+"*", "lsize", "1.5")		if (winKilled)			setWindowPos(left, top, right, bottom, winN=GraphN_bs)		endif		Label/W=$GraphN_bs bottom,  labelStr		baseSub_GenUse("*AD0", 0, 0, 0, xStart=(t0-baselineLen), xEnd=t0, xOffset=-t0, winN = GraphN_bs, rideAlongByNameSub="*AD0_viLF"+appendStr+";")		//bs win		baseSub_GenUse("*AD2", 0, 0, 0, xStart=(t0-baselineLen), xEnd=t0, xOffset=-t0, winN = GraphN_bs,  rideAlongByNameSub="*AD2_viLF"+appendStr+";")		baseSub_GenUse("*AD1", 1, 0, 0, xStart=(t0-baselineLen), xEnd=t0, xOffset=-t0, winN = GraphN_bs)		baseSub_GenUse("*AD3", 1, 0, 0, xStart=(t0-baselineLen), xEnd=t0, xOffset=-t0, winN = GraphN_bs)		doupdate;disp_matchAxisScaling_1win("L_1;L_2", winN=graphN)		//sets these axes to have same scaling, using scaling from axis with larger range. Must update first or range doesnt exist yet		doupdate;disp_matchAxisScaling_1win("L_1;L_2",  winN=GraphN_bs)		endif	end//VI_disp_overlays_g()function/S VI_getLineFits_g(respFamilyRefs, paramsWvRef, doPed, fromPed)	Variable doPed		//0 for soma, 1 for ped	String respFamilyRefs,paramsWvRef	Variable fromPed		//was stim given from ped? (gives different names to traces from soma and from ped so as not to overwrite when in same file			WAVE/D paramsWv = $paramsWvRef		Variable sweepNum_row =	FindDimLabel(paramsWv, 0, "resp_storedSweepNum" )		// findInHeader("storedSweepNum", "analysis_step1SiteHeader")	Variable x0_row = FindDimLabel(paramsWv, 0, "resp_lineStartX" )		// paramsWv[%resp_lineStartX]		//findInHeader("lineStartX", "analysis_step1SiteHeader")	Variable x1_row = FindDimLabel(paramsWv, 0, "resp_lineEndX" )		//paramsWv[%resp_lineEndX]		//findInHeader("lineEndX", "analysis_step1SiteHeader")	Variable xBaselineCross_row = FindDimLabel(paramsWv, 0, "resp_lineBaselineCross" )			//findInHeader("lineBaselineCross", "analysis_step1SiteHeader")	Variable y0_row = FindDimLabel(paramsWv, 0, "resp_lineZeroCross" )		//paramsWv[%resp_lineZeroCross]		// findInHeader("lineZeroCross", "analysis_step1SiteHeader")	Variable slope_row = FindDimLabel(paramsWv, 0, "resp_lineSlope" )	//findInHeader("lineSlope", "analysis_step1SiteHeader")			String appendStr	if (fromPed)		appendStr = "fP"	else		appendStr = "fS"	endif		String fitFamilyRefs = ""		//append _viLF for VI line fit to make each out ref	Variable currSweepNum, famIter, x0, x1, xBaselineCross, y0, slope; String currRespRef, currFitRef, currExpectedFitRefStart		for (famIter = 0;famIter < DimSize(paramsWv, 1); famIter+=1)		currSweepNum = paramsWv[sweepNum_row][famIter]		currRespRef = GetDimLabel(paramsWv, 1, famIter )		currFitRef = currRespRef + "_viLF"	+ appendStr		x0 = paramsWv[x0_row][famIter]; x1 = paramsWv[x1_row][famIter]		y0 = paramsWv[y0_row][famIter]		xBaselineCross = paramsWv[xBaselineCross_row][famIter]		slope = paramsWv[slope_row][famIter]		fitFamilyRefs += currFitRef + ";"		Duplicate/O/R=(xBaselineCross, x1) $currRespRef, $currFitRef		//this way should plot back to line = baseline		WAVE/D currFitWv = $currFitRef		currFitWv[] = slope*x + y0	endfor		return fitFamilyRefsendfunction/S VI_getLineFits_alt(respFamilyRefs, paramsWvRef, doPed, fromPed, zeroCurrentSweepNum)	Variable doPed		//0 for soma, 1 for ped	String respFamilyRefs,paramsWvRef	Variable fromPed		//was stim given from ped? (gives different names to traces from soma and from ped so as not to overwrite when in same file	Variable zeroCurrentSweepNum		WAVE/D paramsWv = $paramsWvRef		Variable sweepNum_row =	FindDimLabel(paramsWv, 0, "resp_storedSweepNum" )		// findInHeader("storedSweepNum", "analysis_step1SiteHeader")	Variable x0_row = FindDimLabel(paramsWv, 0, "resp_lineStartX" )		// paramsWv[%resp_lineStartX]		//findInHeader("lineStartX", "analysis_step1SiteHeader")	Variable x1_row = FindDimLabel(paramsWv, 0, "resp_lineEndX" )		//paramsWv[%resp_lineEndX]		//findInHeader("lineEndX", "analysis_step1SiteHeader")	Variable xBaselineCross_row = FindDimLabel(paramsWv, 0, "resp_lineBaselineCross" )			//findInHeader("lineBaselineCross", "analysis_step1SiteHeader")	Variable y0_row = FindDimLabel(paramsWv, 0, "resp_lineZeroCross" )		//paramsWv[%resp_lineZeroCross]		// findInHeader("lineZeroCross", "analysis_step1SiteHeader")	Variable slope_row = FindDimLabel(paramsWv, 0, "resp_lineSlope" )	//findInHeader("lineSlope", "analysis_step1SiteHeader")					String appendStr	if (fromPed)		appendStr = "fP"	else		appendStr = "fS"	endif		String fitFamilyRefs = ""		//append _viLF for VI line fit to make each out ref	Variable currSweepNum, famIter, x0, x1, xBaselineCross, y0, slope; String currRespRef, currFitRef, currExpectedFitRefStart	for (famIter = 0;famIter < DimSize(paramsWv, 1); famIter+=1)		currSweepNum = paramsWv[sweepNum_row][famIter]		if (currSweepNum != zeroCurrentSweepNum)		//skip zero current sweep			currRespRef = GetDimLabel(paramsWv, 1, famIter )			currFitRef = currRespRef + "_viLF"	+ appendStr			x0 = paramsWv[x0_row][famIter]; x1 = paramsWv[x1_row][famIter]; y0 = paramsWv[y0_row][famIter]			xBaselineCross = paramsWv[xBaselineCross_row][famIter]; slope = paramsWv[slope_row][famIter]			fitFamilyRefs += currFitRef + ";"			Duplicate/O/R=(xBaselineCross, x1) $currRespRef, $currFitRef		//this way should plot back to line = baseline			WAVE/D currFitWv = $currFitRef			currFitWv[] = slope*x + y0		else			fitFamilyRefs += " ;"		endif	endfor		return fitFamilyRefsendfunction/S VI_getLineFits(row, doPed)	Variable row, doPed		//0 for soma, 1 for ped		WAVE/T VI_index	String respFamilyRefs = VI_index[row][7 + 2*doPed]			WAVE/D paramsWv = $VI_index[row][17 + doPed]	//	Variable linearFitStartDelay = 0.0005//	Variable linearFitLen = 0.005//	////	//calculate line through slope start and end points//	Variable lineStartX = t0 + linearFitStartDelay				//thresholdTimes_peakToBase_Rise[lineStartProp]//	Variable lineEndX = t0 + lineStartX + linearFitLen			// thresholdTimes_peakToBase_Rise[lineEndProp]//	Make/O/D/N=2 lineCoefsWv//	CurveFit/Q/N=1 line, kwCWave=lineCoefsWv, resp(lineStartX,lineEndX)//	Variable lineSlope = lineCoefsWv[1]//	Variable lineZeroCross = lineCoefsWv[0]//	Variable lineBaselineCross = (defaultBaselineVal - lineZeroCross) / lineSlope	//	Variable lineEndVal = thresholdVals_peakToBase[lineEndProp]//	Variable lineStartVal = thresholdVals_peakToBase[lineStartProp]		Variable sweepNum_row = findInHeader("storedSweepNum", "analysis_step1SiteHeader")//	Variable fileNum_row = findInHeader("storedCellFileNum", "analysis_step1SiteHeader")	Variable x0_row = findInHeader("lineStartX", "analysis_step1SiteHeader")	Print "x0_row = " + num2str(x0_row)	Variable x1_row = findInHeader("lineEndX", "analysis_step1SiteHeader")	Print "x1_row = " + num2str(x1_row)	Variable xBaselineCross_row = findInHeader("lineBaselineCross", "analysis_step1SiteHeader")	Variable y0_row = findInHeader("lineZeroCross", "analysis_step1SiteHeader")	Variable slope_row = findInHeader("lineSlope", "analysis_step1SiteHeader")		String waveRefStart = text_getInfoFromWaveName_S(StringFromList(0, respFamilyRefs), 0) + "_" +  text_getInfoFromWaveName_S(StringFromList(0, respFamilyRefs), 1) + "_"		Print "waveRefStart = " + waveRefStart		String fitFamilyRefs = ""		//append _viLF for VI line fit to make each out ref	Variable currSweepNum, famIter, x0, x1, xBaselineCross, y0, slope; String currRespRef, currFitRef, currExpectedFitRefStart	for (famIter = 0;famIter < DimSize(paramsWv, 1); famIter+=1)		currSweepNum = paramsWv[sweepNum_row][famIter]		currExpectedFitRefStart = waveRefStart + num2str(currSweepNum + 1) + "_*"		Print "currExpectedFitRefStart = " + currExpectedFitRefStart		Print "listmatch = " + ListMatch(respFamilyRefs,currExpectedFitRefStart)		currRespRef = StringFromList(0,ListMatch(respFamilyRefs,currExpectedFitRefStart))				//StringFromList(famIter, fitFamilyRefs)		currFitRef = currRespRef + "_viLF"			x0 = paramsWv[x0_row][famIter]; x1 = paramsWv[x1_row][famIter]; y0 = paramsWv[y0_row][famIter]		xBaselineCross = paramsWv[xBaselineCross_row][famIter]; slope = paramsWv[slope_row][famIter]		fitFamilyRefs += currFitRef + ";"		Duplicate/O/R=(xBaselineCross, x1) $currRespRef, $currFitRef		//this way should plot back to line = baseline		WAVE/D currFitWv = $currFitRef		currFitWv[] = slope*x + y0	endfor		return fitFamilyRefsendfunction vis_modifyGraphForTraces(winN, matchStr, keyStr, modStr)	String winN,matchStr, keyStr, modStr		winN = vis_checkWinN(winN,1)		String traceNames = ListMatch(TraceNameList(winN, ";", 1), matchStr)	Print winN + " == " + traceNames		Variable i; String currCmd, currTN	for (i=0;i<ItemsInList(traceNames);i+=1)		currTN = StringFromList(i, traceNames)		sprintf currCmd, "ModifyGraph/W=%s %s(%s)=%s", winN, keyStr, currTN, modStr	//	Print num2str(i) + "===" + currCmd		Execute currCmd		endforendfunction/S vis_checkWinN(winN, windowType)	String winN; Variable windowType		//1 for graph		if (strlen(winN) == 0)		winN = winname(0,windowType)	endif		return winNendfunction VI_disp_polyCoefs(VI_row, fromSoma, fromPed, somaColorStr, pedColorStr, leftAxName, [winN])	Variable VI_row, fromSoma, fromPed	//latter stores x constant from fit	String winN, leftAxName				//latter is requisite	String somaColorStr, pedColorStr		WAVE/T VI_index		if (ParamIsDefault(winN))		winN = ""	endif		Variable coefStartPos = findInHeader("polyfit_coef_0", "analysis_step1SiteHeader")	Variable fitConstPos = findInHeader("polyfit_constant_x0", "analysis_step1SiteHeader")	Variable fitStartPos = findInHeader("stim_t0", "analysis_step1SiteHeader")	Variable fitLenPos = findInHeader("resp_fitWinSize", "analysis_step1SiteHeader")		Variable i,j, atPed, fitStartX, fitEndX, currX0; String exampleWvRef, fitSaveList_S, fitSaveList_P, currFitSaveList, fitSaveNameStart, currSaveName		for (i=0;i<(fromSoma+fromPed);i+=1)		if (i==0)			if (fromSoma)				atPed = 0			else				atPed = 1			endif		else			atPed = 1		endif			exampleWvRef = StringFromList(0, VI_index[VI_row][7+(1*atPed)])		if (atPed)			fitSaveNameStart = StringFromList(0, getFileNameFromWaveName(exampleWvRef,0)) + "_pFit_p_"		else			fitSaveNameStart = StringFromList(0, getFileNameFromWaveName(exampleWvRef,0)) + "_pFit_s_"		endif		WAVE/D tempParams = $VI_index[VI_row][17+atPed]		exampleWvRef = StringFromList(0, VI_index[VI_row][7+(1*atPed)])				Print "poly fit. i = " + num2str(i) + "atPed = " + num2str(atPed)				currFitSaveList = ""		for (j=0;j<DimSize(tempParams,1);j+=1)			currSaveName = fitSaveNameStart + num2str(j)			currFitSaveList+=currSaveName +";"			Duplicate/O/R=[coefStartPos,][j] tempParams, coefWaveTemp			currX0 = tempParams[fitConstPos][j]			fitStartX = tempParams[fitStartPos][j]			fitendX = fitStartX + tempParams[fitLenPos][j]			Duplicate/O/R=(fitStartX, fitendX) $exampleWvRef, fitTemp			fitTemp = poly(coefWaveTemp, x-currX0)		//poly(ssFitCoefWave,x-W_fitconstants[0])			Duplicate/O fitTemp, $currSaveName		endfor		if (atPed)			fitSaveList_P = currFitSaveList		else			fitSaveList_S = currFitSaveList	//		Print "here saving S, s = " + fitSaveList_S		endif	endfor		Print "fitSaveList_S = " + fitSaveList_S	Print "fitSaveList_P = " +  fitSaveList_P	Variable red,green,blue	for (i=0;i<ItemsInList(	fitSaveList_S);i+=1)		vis_getColorForGraph(somaColorStr, red, green, blue)		AppendToGraph/L=$leftAxName/C=(red, green, blue) $StringFromList(i, fitSaveList_S)	endfor		for (i=0;i<ItemsInList(	fitSaveList_P);i+=1)		vis_getColorForGraph(pedColorStr, red, green, blue)		AppendToGraph/L=$leftAxName/C=(red, green, blue) $StringFromList(i, fitSaveList_P)	endfor				return fitendX - fitStartXend//good disp param commands//calculate difference waves by subtracting distal site from proximal site//VI_dispParam_g(49, "lineBaselineCross","stim_step - baseline","testSteps_SfS","testSteps_PfS","testSteps_Diffs_fS",0,0,diffAx="")//VI_dispParam_g(49, "threshProportions_6_pB_rDX","stim_step - baseline","testSteps_SfS","testSteps_PfS","testSteps_Diffs_fS",0,0,diffAx="")//VI_dispParam_g(49, "threshProportions_6_pB_rDX","stim_step - baseline","testSteps_SfP","testSteps_PfP","testSteps_Diffs_fP",1,1,diffAx="")//VI_dispParam_g(49, "peakBaselineDiff","stim_step - baseline","testSteps_SfS","testSteps_PfS","testSteps_Diffs_fS",0,0,diffAx="")//VI_dispParam_g(49, "peakBaselineDiff","stim_step - baseline","testSteps_SfP","testSteps_PfP","testSteps_Diffs_fP",1,1,diffAx="")//VI_dispParam_g(49, "resp_deltas_2","stim_step - baseline","testSteps_SfS","testSteps_PfS","testSteps_Diffs_fS",0,0,diffAx="")//VI_dispParam_g(49, "resp_deltas_2","stim_step - baseline","testSteps_SfP","testSteps_PfP","testSteps_Diffs_fP",1,1,diffAx="")//"resp_deltas_2;peakBaselineDiff;threshProportions_6_pB_rDX;lineBaselineCross;"//"stim_step - baseline"///savetopgraphs(4,"t",w=2.6,h=2) is a good size for overlays//savetopgraphs(4,"t",w=2.2,h=2) is a good size for paramsfunction VI_dispParams_g(hsListrow, y_paramList, x_paramStr, paramRef_SfS, paramRef_PfS, diffParamsRef_fS, paramRef_SfP, paramRef_PfP, diffParamsRef_fP, baseName)	String y_paramList		//list of y params to plot ,each gets own window	String x_paramStr		//x_paramStr commonly "stim_step - baseline"	WAVE paramRef_SfS, paramRef_PfS, paramRef_SfP, paramRef_PfP,  diffParamsRef_fS, diffParamsRef_fP			Variable hsListrow	String baseName		Variable diffAx		Variable i; String currParam, winN	for (i=0;i<ItemsInList(y_paramList);i+=1)		currParam = StringFromList(i,y_paramList)		winN = text_makeStrPresentable(baseName + currParam)		Display/K=1/N=$winN		winN = S_name		if (waveExists(paramRef_SfS) > 0)			 diffAx = waveExists(diffParamsRef_fS) 			VI_dispParam_g(hsListRow, currParam, x_paramStr, paramRef_SfS, paramRef_PfS, diffParamsRef_fS, 0, 1, gName = winN, diffAx = diffAx)		endif		if (waveExists(paramRef_SfP) > 0)			diffAx = waveExists(diffParamsRef_fP) 			VI_dispParam_g(hsListRow, currParam, x_paramStr, paramRef_SfP, paramRef_PfP, diffParamsRef_fP, 1, 1, gName = winN, diffAx = diffAx)		endif					endforendfunction VI_dispParam_g(hsListrow, y_paramStr, x_paramStr, paramRef_S, paramRef_P, diffParamsRef, fromPed, addToTopG, [gName,diffAx])	String y_paramStr, x_paramStr	WAVE paramRef_S, paramRef_P, diffParamsRef	Variable hsListrow, fromPed	String gName	Variable diffAx		//optionally pass to put difference on own axis		Variable addToTopG			//instead of creating a new window, appends to top graph	debug_checkRTERRstate()	String labelStr = ""	if (!numtype(hsListRow))		WAVE/T excel_cellNames; WAVE/D excel_recLens		labelStr = excel_cellNames[hsListRow] + ". Len=" + num2str(excel_recLens[hsListRow])	endif		debug_checkRTERRstate()	if (ParamIsDefault(gName))		gName = ""		if (!numtype(hsListRow))			gName = excel_cellNames[hsListRow] + "_" + y_paramStr			if (fromPed)				gName += "fP"			else				gName += "fS"			endif			gName = text_makeStrPresentable(gName)		endif	endif	debug_checkRTERRstate()	String headerRef = analysis_getStep1SiteHeader()		Variable y_row = findInHeader(y_paramStr, headerRef)	Variable x_row = findInHeader(x_paramStr, headerRef)	debug_checkRTERRstate()	if (  (y_row < 0) || (y_row > DimSize(paramRef_S,0))  || (y_row < 0) || (y_row > DimSize(paramRef_S,0)) )		Print "Parameter name not found in header. VI_dispParam_g aborted"		return 0	endif		Variable r_s = 0, g_s=0,b_s=0	Variable r_p=65280, g_p=0,b_p=0	Variable r_d=0, g_d=0,b_d=52224		String tnAppendStr = ""	if (fromPed)		tnAppendStr += "_fP"	else		tnAppendStr += "_fS"	endif	debug_checkRTERRstate()	if (addToTopG)		gName = winname(0,1)		Print "gNAme = " + gname	else		KillWindowsByName(gName + "*")		display/K=1/N=$gName	endif		debug_checkRTERRstate()	String soma_tn = "soma" + tnAppendStr, ped_tn = "ped" + tnAppendStr, diff_tn = "diff" + tnAppendStr		Print "gName = ", gName,"paramRef_S",NameOfWave(paramRef_S),"paramRef_P",NameOfWave(paramRef_P)			AppendToGraph/W=$gName/C=(r_s,g_s,g_s) paramRef_S[y_row][]/TN=$soma_tn vs paramRef_S[x_row][]	AppendToGraph/W=$gName/C=(r_p,g_p,g_p) paramRef_P[y_row][]/TN=$ped_tn vs paramRef_P[x_row][]	debug_checkRTERRstate()		if (waveExists(diffParamsRef) > 0)		if (!ParamIsDefault(diffAx) && diffAx)			AppendToGraph/W=$gName/C=(r_d,g_d,b_d)/R=R_0 diffParamsRef[y_row][]/TN=$diff_tn vs paramRef_S[x_row][]				ModifyGraph/W=$gName freepos = 0, lblpos = 35			Label/W=$gName R_0 "Change at distal site \U"		else			AppendToGraph/W=$gName/C=(r_d,g_d,b_d) diffParamsRef[y_row][]/TN=$diff_tn vs paramRef_S[x_row][]			endif	endif		ModifyGraph/W=$gName mode($soma_tn)=4,mode($ped_tn)=4,mode($diff_tn)=4	ModifyGraph/W=$gName marker($soma_tn)=19,marker($ped_tn)=19,marker($diff_tn)=19	ModifyGraph/W=$gName msize($soma_tn)=1.5,msize($ped_tn)=1.5,msize($diff_tn)=1.5		if (fromPed)		ModifyGraph/W=$gName marker($soma_tn)=8,marker($ped_tn)=8,marker($diff_tn)=8		ModifyGraph/W=$gName lstyle($soma_tn)=2,lstyle($ped_tn)=2,lstyle($diff_tn)=2	endif		Label/W=$gName bottom "\\u#2\\F'Wingdings 3'r\\F'Arial'Stimulus \U \\\\ " + labelStr + " \\\\"	Label/W=$gName left y_paramStr		debug_checkRTERRstate()endfunction VI_calcDiffs(row)	Variable row		WAVE/T VI_index		//first pulse	Duplicate/O $VI_index[row][11], $VI_index[row][13]	WAVE/D outputWv =  $VI_index[row][13], somaWv = $VI_index[row][11], pedWv = $VI_index[row][12]	outputWv = pedWv - somaWv	//second pulse	Duplicate/O $VI_index[row][11+3], $VI_index[row][13+3]	WAVE/D outputWv =  $VI_index[row][13+3], somaWv = $VI_index[row][11+3], pedWv = $VI_index[row][12+3]	outputWv = pedWv - somaWv	//step	Duplicate/O $VI_index[row][11+6], $VI_index[row][13+6]	WAVE/D outputWv =  $VI_index[row][13+6], somaWv = $VI_index[row][11+6], pedWv = $VI_index[row][12+6]	outputWv = pedWv - somaWv	endfunction/S disp_overlays(graphN,newClearOrAdd,tWaveRefOrTextList,axesList,colorsList,[axisPairs,traceNamesList,normalizationGroupsList,x1,x2,reloadOptions])	String graphN	String tWaveRefOrTextList		//ref to text wave with row[0] = list of waves for axis 0, row[1] = list of waves for axis 1, and so on							//or string list with wv0, wv1, wv2; wv3,wv4;wv5,wv6,wv7; where semi-colons delimite sets of waves on diff axes, and commas delimite waves in a given axis	String axesList		//axis names associated with each list, should be semi colon delim	String colorsList		//colors LIST associated with each list; each trace gets its own, comma delimited, semicolon between traces on diff axes, in parrelel with new row/list of waveOfLists						//one special case: if an axis has multiple graphs, but only one color is passed, that color is applied to all	Variable newClearOrAdd		//0, new graph by name. 1, if possible, clear graph by this name and use. 2, if possible, add to graph by this name	String axisPairs		//ordered list of axis start and ends, order corresponds to axesList. format is "axis1Start, axis1End,;axis2Start, axis2End,;..."	String traceNamesList	//ordered as for axisPairs and colorsList. similar special case as for colorsList: if just one name is passed for a given axis						//and that axis has multiple traces, then all traces are named as their wavename + the string in traceNames	String normalizationGroupsList		//same order as colorsList (no special case, though). Give each trace a group by assigning it a number									//waves with same letters will be normalized together by the wave that has "number_letter" for that groups letter									//or by the first wave encountered with that number, from the start of the list									//REQUIRES String list passed tWaveRefOrTextList, not wave. (easily modified, though). x1, x2 also required in case of normalizing a region	Variable x1, x2					//plot start and end, optional. only implemented for BOTTOM axis at present					Variable reloadOptions		//options for attempting wave reloading							switch (newClearOrAdd)		case 1:			if (strlen(graphN) == 0)				graphN = winname(0,1)		//top graph			endif			if (winType(graphN) > 0)				vis_clearGraph(graphN)			else				Display/K=1/N=$graphN				graphN = S_name			endif			break		case 2:		//if win exists do nothing			if (strlen(graphN) == 0)				graphN = winname(0,1)		//top graph			endif			if (winType(graphN) == 0)				Display/K=1/N=$graphN				graphN = S_name			endif			break			default:			if (strlen(graphN) == 0)				graphN = "Graph"			elseif (winType(graphN) > 0)				killwindowsbyname(graphN)			endif						Display/K=1/N=$graphN			graphN = S_name	endswitch			Variable isStrList, numLists, listNum, traceNum	Variable singleAxisColor, singleAxisTraceName		//handle special cases of one color per axis and one traceName per axis	String traceSepStr, currList, currRef, currColorList, currColor, currTraceNameList, currTraceName, currAxisName, currAxStart	Variable red, green, blue			//stores color variables	Variable traceNamesPassed = !ParamIsDefault(traceNamesList)	if (stringmatch(tWaveRefOrTextList,"*;*") || stringmatch(tWaveRefOrTextList,"*,*"))				isStrList = 1		traceSepStr = ","		numLists = ItemsInList(tWaveRefOrTextList)	else		WAVE/T tWave = $tWaveRefOrTextList		isStrList = 0		traceSepStr = ";"		numLists = DimSize(tWave,0)	endif					Variable i,j, doGroupNorm	//GROUPWISE NORMALIZATION PROCEDURE	if (!ParamIsDefault(normalizationGroupsList) && isStrList && !ParamIsDefault(x1) && !ParamIsDefault(x2))		doGroupNorm = 1		Make/O/T/N=(1,3) groups		//T wave, one row per group, first col is groupChar, second is groupLeaderRef, third is semi-colon delim list of waves in group		groups = ""		String currSubList, currGroupStr		Variable currGroupNum			//user input, doesn't actually factor into name/order of groups		Variable currGroupIndex		Variable groupLeaderFound, groupsFound = 0	//should almost certainly be 1 at this point but just in case something changes			for (i=0;i<ItemsInList(normalizationGroupsList);i+=1)			currSubList = StringFromList(i, normalizationGroupsList)				for (j=0;j<ItemsInLisT(currSubList,",");j+=1)				currGroupStr = StringFromList(j,currSubList,",")				currGroupNum = str2num(currGroupStr)			//seems to work even with trailing letters; it gets rid of these, so to store currGroupNum as string use num2str first				groupLeaderFound =  stringmatch(currGroupStr, "*a*")				currGroupIndex = findStrInTextWaveCol_2D(num2str(currGroupNum), "groups", 0)								currRef = StringFromList(j, StringFromList(i, tWaveRefOrTextList), ",")				if (currGroupIndex < 0)				//new group found					groupsFound +=1					Redimension/N=(groupsFound, DimSize(groups,1) ) groups		//does nothing for first group found					currGroupIndex = groupsFound - 1								//if first group, this is 0					groups[currGroupIndex][0] = num2str(currGroupNum)					groups[currGroupIndex][1] = currRef		//allows default of first found as group leader				else		//wave in previously found group					if (groupLeaderFound)						groups[currGroupIndex][1] = currRef		//if group leader found, store. In this implementation if more than one group leader is passed, last is used					endif				endif				//in any case, add found wave to its group (new or old)				groups[currGroupIndex][2] += currRef + ";"						endfor				endfor			//handle actual rescaling		Variable currNormFactor, searchStartX, searchEndX; String currGroupList		GetAxis/Q/W=$graphN bottom		searchStartX =  x1		searchEndX =  x2				Make/O/D/N=(groupsFound) groupNormFactors				for (i=0;i<groupsFound;i+=1)			//get min and max for group leader			Wavestats/Q/R=(searchStartX, searchEndX) $groups[i][1]			groupNormFactors[i] = 1/(V_max - V_min)			currGroupList = groups[i][2]		endfor	else		doGroupNorm = 0	endif						//PLOTTING			for (listNum = 0;listNum<numLists;listNum+=1)		if (isStrList)			currList = StringFromList(listNum, tWaveRefOrTextList)		else			currList = tWave[listNum]		endif				currColorList = StringFromList(listNum, colorsList)		singleAxisColor = ItemsInList(currColorList, ",") > 1 ? 0 : 1		//new		currAxisName = StringFromList(listNum, axesList)		currAxStart = currAxisName[0]				if (traceNamesPassed)			currTraceNameList = StringFromList(listNum, traceNamesList)				singleAxisTraceName = ItemsInList(currTraceNameList, ",") > 1 ? 0 : 1		endif				strswitch (currAxStart)			case "R":				for (traceNum = 0; traceNum < ItemsInList(currList, traceSepStr);traceNum +=1)					currRef = StringFromList(traceNum, currList, traceSepStr)					currColor = StringFromList(singleAxisColor ? 0 : traceNum, currColorList, ",")			//altered, embedded if was just trace num					vis_getColorForGraph(currColor, red, green, blue)					if (traceNamesPassed)						if (singleAxisTraceName)							currTraceName = currRef + StringFromList(0, currTraceNameList, ",")							else							currTraceName = StringFromList(traceNum, currTraceNameList, ",")							endif					else						currTraceName = currRef					endif					AppendToGraph/W=$graphN/R=$currAxisName/C=(red, green, blue) $currRef/TN=$currTraceName					if (doGroupNorm)						currGroupStr = num2str(str2num(StringFromList(traceNum,StringFromList(listNum, normalizationGroupsList),",")))		//conversion to num and back gets rid of potential trailing a to mark a group leader						currGroupIndex = findStrInTextWaveCol_2D(currGroupStr, "groups", 0)						currNormFactor = groupNormFactors[currGroupIndex]						ModifyGraph/W=$graphN muloffset($currTraceName) = {0,currNormFactor}					endif				endfor				break			case "B":				for (traceNum = 0; traceNum < ItemsInList(currList, traceSepStr);traceNum +=1)					currRef = StringFromList(traceNum, currList, traceSepStr)					currColor = StringFromList(singleAxisColor ? 0 : traceNum, currColorList, ",")			//altered, embedded if was just trace num					vis_getColorForGraph(currColor, red, green, blue)					if (traceNamesPassed)						if (singleAxisTraceName)							currTraceName = currRef + StringFromList(0, currTraceNameList, ",")							else							currTraceName = StringFromList(traceNum, currTraceNameList, ",")							endif					else						currTraceName = currRef					endif					AppendToGraph/W=$graphN/B=$currAxisName/C=(red, green, blue) $currRef/TN=$currTraceName					if (doGroupNorm)						currGroupStr = num2str(str2num(StringFromList(traceNum,StringFromList(listNum, normalizationGroupsList),",")))		//conversion to num and back gets rid of potential trailing a to mark a group leader						currGroupIndex = findStrInTextWaveCol_2D(currGroupStr, "groups", 0)						currNormFactor = groupNormFactors[currGroupIndex]						ModifyGraph/W=$graphN muloffset($currTraceName) = {0,currNormFactor}					endif				endfor				break			case "T":				for (traceNum = 0; traceNum < ItemsInList(currList, traceSepStr);traceNum +=1)					currRef = StringFromList(traceNum, currList, traceSepStr)					currColor = StringFromList(singleAxisColor ? 0 : traceNum, currColorList, ",")			//altered, embedded if was just trace num					vis_getColorForGraph(currColor, red, green, blue)					if (traceNamesPassed)						if (singleAxisTraceName)							currTraceName = currRef + StringFromList(0, currTraceNameList, ",")							else							currTraceName = StringFromList(traceNum, currTraceNameList, ",")							endif					else						currTraceName = currRef					endif					AppendToGraph/W=$graphN/T=$currAxisName/C=(red, green, blue) $currRef/TN=$currTraceName					if (doGroupNorm)						currGroupStr = num2str(str2num(StringFromList(traceNum,StringFromList(listNum, normalizationGroupsList),",")))		//conversion to num and back gets rid of potential trailing a to mark a group leader						currGroupIndex = findStrInTextWaveCol_2D(currGroupStr, "groups", 0)						currNormFactor = groupNormFactors[currGroupIndex]						ModifyGraph/W=$graphN muloffset($currTraceName) = {0,currNormFactor}					endif				endfor				break			default:				for (traceNum = 0; traceNum < ItemsInList(currList, traceSepStr);traceNum +=1)					currRef = StringFromList(traceNum, currList, traceSepStr)					currColor = StringFromList(singleAxisColor ? 0 : traceNum, currColorList, ",")			//altered, embedded if was just trace num					vis_getColorForGraph(currColor, red, green, blue)					if (traceNamesPassed)						if (singleAxisTraceName)							currTraceName = currRef + StringFromList(0, currTraceNameList, ",")							else							currTraceName = StringFromList(traceNum, currTraceNameList, ",")							endif					else						currTraceName = currRef					endif					AppendToGraph/W=$graphN/L=$currAxisName/C=(red, green, blue) $currRef/TN=$currTraceName					if (doGroupNorm)						currGroupStr = num2str(str2num(StringFromList(traceNum,StringFromList(listNum, normalizationGroupsList),",")))		//conversion to num and back gets rid of potential trailing a to mark a group leader						currGroupIndex = findStrInTextWaveCol_2D(currGroupStr, "groups", 0)						currNormFactor = groupNormFactors[currGroupIndex]						ModifyGraph/W=$graphN muloffset($currTraceName) = {0,currNormFactor}					endif				endfor		endswitch	endfor		//AXIS RANGE	if (!ParamIsDefault(axisPairs))		Variable currStart, currEnd; String currPair		for (i=0;i<ItemsInList(axisPairs);i+=1)			currPair = StringFromList(i, axisPairs)			currStart = str2num(StringFromList(0, currPair,","))			currEnd = str2num(StringFromList(1, currPair,","))			currAxisName = StringFromList(i, axesList)			modifygraph/W=$graphN axisEnab($currAxisName) = {currStart, currEnd}		endfor	endif			modifygraph/W=$graphN lblpos = 48, freepos = 0	return graphNendfunction math_SA_cylinder(rad, h)	Variable rad,h		return (2*pi*rad*h) + (2*pi*rad^2)endfunction math_SA_rotationalEllipse(rad, h)		//wrong despite that formulas look right to me	Variable rad, h		Variable eSqr, eVal	if (h < rad)		//squished, prolate		eSqr = 1 - (h^2)/(rad^2)		eVal = sqrt(eSqr)		return 2*pi*(rad^2)*( 1+((1-eSqr)/eVal)*atanh(eVal) )				elseif (h == rad)	//sphere, easy case	//	Print "sphere input"		return 4*pi*rad^2	endif		//else (h > rad)  	stretched, oblate	eSqr = 1 - (rad^2)/(h^2)	eVal = sqrt(eSqr)	return 2*pi*(rad^2)*( 1+( h/(rad*eVal) )*asin(eVal) )endfunction math_arcsinh(x)	Variable x		return log( x+sqrt(1+x^2) )		//valid for all real numbers	end// ImageLoad/O/S=0/C=-1/LR3D/N=tiffc/RAT "C:Users:Alan:Desktop:gb anatomy:151201 Album 4 cell 01 75 0f 80_15-60raw.tif"//setwindow $"" hook(winH) = img_hookfunction img_newImage(imgWvRef, promptNewLoad, useFileName)	String imgWvRef	Variable promptNewLoad		//0 to display an image already in imgWvRef, 1 to prompt loading of a new image (img will be stored in imgWvRef, if ref is passed)	Variable useFileName	//use loaded file name for wave name		Variable decentInchesPerPixelForMyTiffs = 0.01		if (promptNewLoad)		img_loadImage(imgWvRef,useFileName)	endif		if (!waveexists($imgWvRef))		Print "img_newImage() no image found, aborting. (perhaps wave load was aborted?)"		return 0	endif		if (dimsize($imgWvRef,2) < 1)		Print "img_newImage() adding layer to 3rd dimension for tracing compatibility."		redimension/n=(-1,-1,2) $imgWvRef	endif		NewImage/K=1 $imgWvRef	String winN = S_name	doupdate;	SetWindow $winN, userdata=imgWvRef		//store name of displayed image in userdata	doupdate;	img_addHook()	doupdate;	img_fixedSizeAtAspectRatio(winN, imgWvRef, decentInchesPerPixelForMyTiffs)	img_addZoomHook()		//add slider (code from menu defitions in WMMenus.ipf that shipped with Igor 7). Error does still occur	Execute/P/Q/Z "INSERTINCLUDE <ImageSlider>";Execute/P/Q/Z "COMPILEPROCEDURES ";Execute/P/Q/Z "WMAppend3DImageSlider()"		Print "run: img_updateHist(1, 0)"end//load an image with Igor's ImageLoad. Works well for Tiff Stacks and probably not much else. //pass imgWvRef,a ref into which the image will be saved (overwrites this destination)function/S img_loadImage(imgWvRef,useFileName)	String imgWvRef; variable useFileName		if (useFileName)		imgWvRef="img_loadImageTemp"	endif		if (strlen(imgWvRef) < 1)		//no name passed, get used to make it		prompt imgWvRef, "Enter reference name into which image will be saved"		doprompt "Image name:", imgWvRef	endif		ImageLoad/O/S=0/C=-1/LR3D/N=$imgWvRef/p=home	if (V_flag)		//load successful		if (useFileName)			string out=replacestring(".",S_fileName,"_")[0,31]	//make extension into acceptable string and truncate if needed			duplicate/o $imgWvRef,$out					if (strlen(S_fileName) > 31)				Print "img_loadImage: fileName",s_fileName,"is too long and being truncated to wavename",out			endif		endif		note/nocr $imgWvRef, "img_loadPath:"+S_path+";"		return S_path	endif		return ""//load failed if reached hereendfunction/S img_setImageLoadPath(imgWvRef)	String imgWvRef		String appendStr = "forPathTemp"		//append string so that image is not overwritten		String path = img_loadimage(imgWvRef + appendStr,0)		note/nocr $imgWvRef, "img_loadPath:"+path+";"	killwaves/Z $(imgWvRef + appendStr)	return pathendfunction img_addHook()	setwindow $"" hook(scrollAndTraceHook) = img_hookendfunction img_addZoomHook()	setwindow $"" hook(zoomHook) = img_zoomHookendfunction img_fixedSizeAtAspectRatio(winN, imgWvName, inchesPerPixel)	Variable inchesPerPixel	String winN, imgWvName		Variable decentInchesPerPixelForMyTiffs = 0.01		//only used if inchesPerPixel not passed		if (numtype(inchesPerPixel) > 0)		//NaN or +/-inf		inchesPerPixel = decentInchesPerPixelForMyTiffs	endif		Variable arbUnitPerInch = 72		if (strlen(winN) < 1)		winN = winname(0,1)	endif		if (strlen(imgWvName) < 1)		imgWvName = stringfromlist(0,wavelist("*",";","WIN:"+winN))	endif		Variable xPixels = DimSize($imgWvName,0)	Variable yPixels = DimSize($imgWvName,1)		Variable w = arbUnitPerInch*xPixels*inchesPerPixel	Variable h = arbUnitPerInch*yPixels*inchesPerPixel		ModifyGraph/W=$winN width=w, height=h	endfunction img_hook(s)	STRUCT WMWinHookStruct &s		//		Variable actionType = 0		//default will be actionType = 0 causing a return, having done nothing			//new action type added 170613 .. the whole actionType thing is a bit circuitous but it's where we're at...	//keyCode 13 is enter down. eventmod 2 is alt; so alt+ enter will copy in last radius; keycode 11 and 12 are page up and down.. used to copy over previous or next point radius	if ( ((s.keyCode == 13) && (s.eventmod & 2^2) ) || (s.keyCode == 11) || (s.keyCode == 12) ) 		actionType = 3		elseif	( ((s.eventCode == 22) || (s.eventCode == 3)) || (s.keyCode == 13) ) //22 is mouseWheel, 3 is mouse down, keyCode 13 is enter down. So only continue for mouse wheel, mouse down, OR enter	//	if ( ((s.eventCode == 22) || (s.eventCode == 3)) || (s.keyCode == 13) )		//changed to if elseif 170613		actionType = 1	endif		//handles follow with ctrl + left/right arrow key	if ( (s.keycode == 28) || (s.keycode == 29) )		actiontype = 2	endif	//handles cross section sizer change with ctrl + up/down arrow key	//do cross section update -- handles wheel scrolling and arrow up/down with ctrl key (and shift modification for coarse/fine	Variable keyEventHandling = tracing_updatesCrossSect(s)		if (!actionType)		return keyEventHandling	endif		//170613 added actionType 3 to support updating of selecting point to a new radius	//most useful is page up or page down (no longer requires alt) which stores the radius of the preceding point (down) or next point (up) for this point	//use alt + left right arrow to move through points	//then use ctrl + scroll with or without shift (which gives a coarser modulation) to set radius measurement circle	//then hit alt + enter to store the new radius for this point	if (actionType == 3)		switch (s.keyCode)			case 13:		//enter key, just store this points value				tracing_storeZValueForCurrPnt(s.winname)				break			case 11:				tracing_storeZValueForCurrPnt(s.winname,useValFromDelta=1)				break			case 12:				tracing_storeZValueForCurrPnt(s.winname,useValFromDelta=-1)				break		endswitch		return 1		//return one lets Igor know not to use this key event, which would normally bring up the command line	endif			//actionType = 1 handles commands related to actually adding and removing points	if (actionType == 1)	//starts or continues tracing by adding the first or an additional new point		if ( (s.eventCode == 3) && ( (s.eventMod & 2^3) != 0) || ((s.eventMod & 2^1) != 0) )			// click with control button down			tracing_saveCrossSectLastInWv()		//allows previous point to be saved. also called when a new section is being created to catch the last point			tracing_addPointFromClickLoc(s)			return keyEventHandling		endif				if (s.keyCode == 13)		//enter, allow duplicate entry of last point added			tracing_saveCrossSectLastInWv()			tracing_repeatPoint(s.winName)			return keyEventHandling		endif				img_scroll(s)		//scroll control		tracing_doUpdates(s.winname,nan,nan,nan)	endif	//	Print s.eventcode, s.eventmod		//actionType == 2 or other things also going with actionType == 1	//these handle 	//170613 changed to using control key not alt key + arrows to move	//2^3 is ctrl, keyCode 28 and 29 are left and right arrow key... so this handles what to do with left/right arrow key//	if ( (s.eventmod & 2^3) && ( (s.keycode == 28) || (s.keycode == 29) ) )			//(s.eventCode == 22) )		if  ( (s.keycode == 28) || (s.keycode == 29) ) 			Variable follow_wheelMult = 3		//for some reason -3 and 3 are s.wheeldx vals		tracing_follow(s.winname,nan,	s.keycode-28 == 0 ? -1 : 1,1)		//s.wheelDx/follow_wheelMult,1)		return 1		//return one lets Igor know not to use this key event, which would normally bring up the command line	endif		//img_updateOrthoViews(s)endfunction img_updateOrthoViews(s) 	STRUCT WMWinHookStruct &s		String images = ImageNameList(s.winname,";" )		Variable leftLoc=disp_getMouseLoc(s,"left")	Variable topLoc=disp_getMouseLoc(s,"top")		Variable i,num=itemsinlist(images)	String pzRef,zqRef,imgRef,pzWin,zqWin		//check that waves exist	for (i=0;i<num;i+=1)		imgRef=stringfromlist(i,images)		//standard is p,q,r as y,x,z		pzRef=imgRef+"pz" //p vs z with q in layers, equiv y vs z with x in layers -- swap for [p][r][q] 		zqRef=imgRef+"zq" //z vs q with 	p in layers, equiv z vs x with y in layers -- swap for [r][q][p]		pzWin=pzRef+"W"		zqWin=zqRef+"W"		if (!WAveExists($pzRef))			//for xz need y to go into layers and z to go into rows			imagetransform/g=1 transposeVol $imgRef   		//[p][r][q] 			WAVE M_VolumeTranspose			duplicate/o M_VolumeTranspose $pzRef		endif		if (!WaveExists($zqRef))			imagetransform/g=3 transposeVol $imgRef   		//[r][q][p]			WAVE M_VolumeTranspose			duplicate/o M_VolumeTranspose,$zqRef		endif		if (Wintype(pzWin)==0)			newimage/k=1/n=$pzWin $pzRef		endif		if (Wintype(zqWin)==0)			newimage/k=1/n=$zqWin $zqRef		endif					if (numtype(leftLoc)==0)		//find x (q) position and show it's layer			ModifyImage/W=$pzWin $pzRef plane=leftLoc		else			print "A"		endif					if (numtype(topLoc)==0)		//find y (p) position and show it's layer			ModifyImage/W=$zqWin $zqRef plane=topLoc		else			print "B"		endif	endfor	endfunction tracing_follow(winN,goToPnt,deltaFromCurrPnt,doSetZ)	String winN	Variable goToPnt		//pass nan to use deltaFromCurrPnt	Variable deltaFromCurrPnt	//ignored if goToPnt is not NaN	Variable doSetZ		//pass to set z to the goToPnt's z location		String followSubRegZoomVarName = "tracing_followSubRegZoom"		//string is empty or non-existant for no following																				//for following it's "x;y;" where x is multiplier/zoom factor in x and y in y		Variable autoStoreChangesInCrossSect = 1		String tracedWaveName = tracing_getTracedWvNmFromWinN(winN)	String combinedSegRef = tracing_getCombinedSegref(tracedWaveName)	WAVE/D/Z combinedSegWv = $combinedSegRef		if (!WaveExistS(combinedSegWv))		return 0	endif	if (!strlen(winN))		winN = winname(0,1)	endif		Variable totalNumPnts = dimsizE(combinedSegWv,0)		//in all segs	Variable currPnt,newPnt,usesDelta		if (numtype(goToPnt) == 2)	//nan -- use delta		currPnt = tracing_getSelPntData(winN,nan)		newPnt = currPnt + deltaFromCurrPnt		usesDelta = 1	else		newPnt = goToPnt		usesDelta = 0	endif		newPnt = tracing_truncPntValueIfNeeded(newPnt,winN)		if (newPnt == inf)	//only likely with goToPnt		newPnt = totalNumPnts - 1	elseif (newPnt == -inf)		newPnt = 0	elseif (newPnt < 0)		newPnt = totalNumPnts + newPnt		//should wrap around to positive	elseif (newPnt >= totalNumPnts)		newPnt = mod(newPnt,totalNumPnts)	//should also wrap around	endif		//leave newPnt unchanged if a real number that is in 0 and totalNumPnts -1	String segLabel = 	GetDimLabel(combinedSegWv, 0, newPnt)		if (!strlen(segLabel))		return 0	endif		Variable segNum = tracing_segNumFromSegRef(segLabel)	Variable segPntNum = tracing_getSegPntFromSegRef(segLabel)	String lastSegLabel = GetDimLabel(combinedSegWv, 0, currPnt)	Variable lastSegNum = tracing_segNumFromSegRef(lastSegLabel)	Variable lastSegPntNum = tracing_getSegPntFromSegRef(lastSegLabel)	//for delta, try to update cross sect wave	if (autoStoreChangesInCrossSect && usesDelta)		tracing_storeZValueForCurrPnt(winN)		//store the current size shown for that last point	endif		//change plane to that of newly selected point	if (doSetZ)		Variable zPixLoc = combinedSegWv[newPnt][%zPixLoc]			img_setDisplayedPlane(winN, zPixLoc)	endif		//update displayed points (e.g., shape and size) which should highlight new point and segment	tracing_setSelPntData(newPnt,winN)		//170613 changed this to precede tracing_doUpdates call, as wasn't seeing point highlighting	tracing_doUpdates(winN,segPntNum,segNum,segPntNum)	String combinedSegTableN = tracing_getCombinedSegRefTableN(combinedSegRef)	if (wintype(combinedSegTableN))		//go to region of pnt on table		Modifytable/W=$combinedSegTableN topleftcell = (newPnt-5,0)		modifytable/W=$combinedSegTableN selection=(newPnt,0,newPnt,dimsize(combinedSegWv,1),newPnt,0)	endif		NVAR/Z followSubRegZoom = $followSubRegZoomVarName	if (NVAR_Exists(followSubRegZoom) && (numtype(followSubRegZoom)==0) && followSubRegZoom > 1)		WAVE traceWv = $tracedWaveName		Variable xNativeRange = dimsize(traceWv,0)		Variable yNativeRange = dimsize(traceWv,1)		Variable maxNativeRange = max(xNativeRange,yNativeRange)		Variable xIsMaxNativeRange = xNativeRange >= yNativeRange		Variable range = maxNativeRange / followSubRegZoom		Variable xCenterPos = combinedSegWv[newPnt][%xPixLoc]		Variable xRangeStart = xCenterPos - range/2		Variable xRangeEnd = xCenterPos + range		Variable yCenterPos = combinedSegWv[newPnt][%yPixLoc]		Variable yRangeStart = yCenterPos - range/2		Variable yRangeEnd = yCenterPos + range		//user should check that graph is square		setaxis/w=$winN top xRangestart,xRangeEnd		setaxis/w=$winN left yRangeEnd,yRangeStart	//y axis usually flipped		modifygraph/w=$winN width=72*7,height=72*7;doupdate		modifygraph/w=$winN width=0,height=0	endif		Variable autoRadiusPerformed=str2num(GetUserData(winN,"", "autoRadiusPerformed" ))	if (autoRadiusPerformed)		String autoRadiusDispWin=winN+"ARD"				Variable newGraph		if (wintype(autoRadiusDispWin) < 1)			display/k=1/n=$autoRadiusDispWin			String crossSectXYWvRef=tracing_getCrossSectXYWvRef()			appendtograph/l=left2/b=bottom2/w=$autoRadiusDispWin $combinedSegRef[][%radiusPix]			appendtograph/l=left2/b=bottom2/w=$autoRadiusDispWin $crossSectXYWvRef[][6] vs $crossSectXYWvRef[][7]			ModifyGraph/w=$autoRadiusDispWin marker=19,mode($crossSectXYWvRef)=3			ModifyGraph/w=$autoRadiusDispWin mode($combinedSegRef)=4,msize($combinedSegRef)=1,lsize($combinedSegRef)=1,rgb($combinedSegRef)=(0,0,0)			dowindow/f $winN		endif				String traceNames=tracenamelist(autoRadiusDispWin,";",1)				String interpRef=winN+ "ORTHO"		String interpFitRef=winN+"ORTHOF"		String interpXVals="winN"+"ORTHOX"		String interpYVals="winN"+"ORTHOY"		String interpWidth="winN"+"ORTHOW"				if (waveexists($interpRef))			if (whichlistitem(interpRef,traceNames) < 0 )				appendtograph/c=(0,0,0)/w=$autoRadiusDispWin $interpRef[][newPnt]			else				replacewave/w=$autoRadiusDispWin trace=$interpref, $interpRef[][newPnt]				modifygraph/w=$autoRadiusDispWin freepos=0,lblpos=50,axisEnab(bottom2)={0.53,1},axisEnab(bottom)={0,0.47},freePos(left2)={-8,bottom2}			endif		endif		if (waveexists($interpFitRef))			if (whichlistitem(interpFitRef,traceNames) < 0 )				appendtograph/w=$autoRadiusDispWin $interpFitRef[][newPnt]			else				replacewave/w=$autoRadiusDispWin trace=$interpFitRef, $interpFitRef[][newPnt]				modifygraph/w=$autoRadiusDispWin freepos=0,lblpos=50,axisEnab(bottom2)={0.53,1},axisEnab(bottom)={0,0.47},freePos(left2)={-8,bottom2}			endif		endif				String autoRadiusAllRef = combinedSegRef + "_rad"		if (WaveExists($autoRadiusAllRef))			variable plotStart=finddimlabel($autoRadiusAllRef, 1, "interpStart" )			if (whichlistitem(autoRadiusAllRef,traceNames) < 0 )				if (!WaveExists($"autoRadiusDispPlaceholder"))					make/o/n=2 autoRadiusDispPlaceholder					autoRadiusDispPlaceholder=0				endif				appendtograph/w=$autoRadiusDispWin/vert $autoRadiusAllRef[newPnt][plotStart,plotStart+1] vs $"autoRadiusDispPlaceholder"				modifygraph/w=$autoRadiusDispWin lsize($autoRadiusAllRef)=2,rgb($autoRadiusAllRef)=(52428,1,41942,45875)			else				replacewave/w=$autoRadiusDispWin trace=$autoRadiusAllRef,$autoRadiusAllRef[newPnt][plotStart,plotStart+1] 			endif			endif				WAVE interpX=$interpXVals		WAVE interpY=$interpYVals		WAVE tracing_interpxyvals		duplicate/o/r=[][newPnt] $interpWidth,interpWidthDisp		duplicate/o/r=[][newPnt] $interpRef,interpTest		duplicate/o/r=[][newPnt] interpX,tracing_interpxyvals		duplicate/o/r=[][newPnt]/free interpy,ytemp		concatenate/np=1 {ytemp},tracing_interpxyvals		//tracing_interpxyvals[][0] = interpX[p][newPnt]		//tracing_interpxyvals[][1] = interpY[p][newPnt]				String tracingTraces=tracenamelist(winN,";",1)					//interpolation display//		if (whichlistitem("tracing_interpXYVals",tracingTraces) < 0)		//main interp xy val display//			appendtograph/t/l/w=$winN tracing_interpXYVals[][1] vs tracing_interpXYVals[][0]//			ModifyGraph/w=$winN lsize(tracing_interpXYVals)=2//			ModifyGraph/w=$winN zColor(tracing_interpXYVals)={interpTest,*,*,BlueRedGreen,0}//		endif					//determined width/diameter display//		if (whichlistitem("tracing_interpXYVals_width",tracingTraces) < 0)		//main interp xy val display//			appendtograph/t/l/w=$winN tracing_interpXYVals[][1]/tn=tracing_interpXYVals_width vs tracing_interpXYVals[][0]//			ModifyGraph/w=$winN lsize(tracing_interpXYVals_width)=2//			ModifyGraph/w=$winN zColor(tracing_interpXYVals_width)={interpWidthDisp,0.5,2,Magenta,0},lsize(tracing_interpXYVals_width)=5,zcolorMin(tracing_interpXYVals_width)=nan//			ModifyGraph/w=$winN rgb(tracing_currCrossSectXYPos)=(65535,0,0,13107)//		endif		endifend//tracing_follow//this implements wrapping around for pnt values, so one can increment and come back to the beginning of the row dimension for the combined wave of pointsfunction tracing_truncPntValueIfNeeded(pntNum,winN)	Variable pntNum	String winN		if (!strlen(winN))		winN = winname(0,1)	endif	String tracedWaveName = tracing_getTracedWvNmFromWinN(winN)	String combinedSegRef = tracing_getCombinedSegref(tracedWaveName)		Variable totalNumPnts = dimsizE($combinedSegRef,0)		//in all segs			if (pntNum == inf)	//only likely with goToPnt		pntNum = totalNumPnts - 1	elseif (pntNum == -inf)		pntNum = 0	elseif (pntNum < 0)		pntNum = totalNumPnts + pntNum		//should wrap around to positive	elseif (pntNum >= totalNumPnts)		pntNum = mod(pntNum,totalNumPnts)	//should also wrap around	endif		//leave newPnt unchanged if a real number that is in 0 and totalNumPnts -1				return pntNum	endfunction tracing_getSelPntData(winN,segNum)	String winN	Variable segNum		//if segNum is a real, valid seg num, then returns the row within the segment, if segNum is -1, returns row within current segment, if segNum is nan, returns the row of the pnt with in combiendSegref							//actually right now it appears any real number just returns the point's row in its segment	Variable pnt	if (!strlen(winN))		winN = winname(0,1)	endif		String pntStr = GetUserData(winN, "", "tracing_follow_currPnt")	if (!strlen(pntStr))		//likely no pnt set -- default to start at zero		pnt = 0		//first point in order of all segments. make 0 to start at first pnt		tracing_setSelPntData(pnt,winN)	else		pnt = str2num(pntStr)		if (numtype(pnt) || (pnt < 0))			pnt = 0			tracing_setSelPntData(pnt,winN)		endif	endif 		if (numtype(segNum))		return pnt		//pnt is row within combinedSegRef	else		String tracedWaveName = tracing_getTracedWvNmFromWinN(winN)		String combinedSegRef = tracing_getCombinedSegref(tracedWaveName)		WAVE/D combinedSegWv = $combinedSegRef				if (!strlen(combinedSegRef) || !WaveExistS(combinedSegWv))			return 0		endif				String segLabel = 	GetDimLabel(combinedSegWv, 0, pnt )				// "pntStr",pntStr,"pnt",pnt,"segLabel",segLabel						if (!strlen(segLabel))			return 0		endif			//	Variable segNum = tracing_segNumFromSegRef(segLabel)		return tracing_getSegPntFromSegRef(segLabel)		endifendfunction tracing_setSelPntData(pnt,winN)	String winN	Variable pnt		//row in combined seg wave that is currently the selected / focused pnt		if (!strlen(winN))		winN = winname(0,1)	endif		setwindow $winN, userdata(tracing_follow_currPnt) = num2str(pnt)		Variable/G tracing_follow_currPnt=pnt  //only used in case one wants to set up a dependency. probably things will run faster without thisendfunction tracing_getCurrSegNum(winN)	String winN		SVAR/Z tracing_currTracingWaveName	if (!svar_Exists(tracing_currTracingWaveName))		String/G tracing_currTracingWaveName = ""		return -1	endif		if (strlen(tracing_currTracingWaveName))		String tracedWaveName = tracing_getTracedWvNmFromWinN(winN)		String indexRef =  tracing_getTracingIndexWaveRef(tracedWaveName)		WAVE/T indexWv = $indexRef		Variable index = FindDimLabel(indexWv, 0, tracing_currTracingWaveName)		if (index < 0)		//likely not found..one possibility is that dim labels aren't there			Variable i			for (i=0;i<DimSize(indexWv,0);i+=1)				SetDimLabel 0,i,$indexWv[i][0],indexWv			endfor		endif		return FindDimLabel($indexRef, 0, tracing_currTracingWaveName)			else		return -1	endif 		return -1endfunction tracing_editAtSeg(winN,segNum)	String winN	Variable segNum		//segment number e.g. that in # _c#		if (!strlen(winN))		winN = winname(0,1)	endif	String tracedWaveName = tracing_getTracedWvNmFromWinN(winN)	String indexRef =  tracing_getTracingIndexWaveRef(tracedWaveName)	WAVE/T indexWv = $indexRef		SVAR/Z tracing_currTracingWaveName	if (!svar_Exists(tracing_currTracingWaveName))		String/G tracing_currTracingWaveName	endif		Variable numSegs = dimsize(indexWv,0)	if (segNum < 0)		segNum = 0	endif	if (segNum > numSegs-1)		segNum = numSegs - 1	endif		tracing_currTracingWaveName = indexWv[segNum][0]		Print "tracing_editAtSegment(): tracing_currTracingWaveName",tracing_currTracingWaveName	end//forces two segments to abut by inserting a new first point in the segment for segNum_post//and settings this new first point to all the values of the point in the last segmentfunction tracing_makeSegsAbut(winN,segNum_pre,segNum_post[,noUpdates])	variable segNum_pre,segNum_post		//pass NaN for segNum_pre to do all	Variable noUpdates	String winN//tracing winN	if (!strlen(winN))		winN = winname(0,1)	endif	String tracedWaveName = tracing_getTracedWvNmFromWinN(winN)	String indexRef =  tracing_getTracingIndexWaveRef(tracedWaveName)	WAVE/T indexWv = $indexRef		if (numtype(segNum_pre) > 0)			Variable i,numSegs = dimsize(indexWv,0)		for (i=1;i<numSegs;i+=1)			tracing_makesegsAbut(winN,i-1,i,noUpdates=1)		endfor		return 1	endif		WAVE/Z segWv_pre = $indexWv[segNum_pre][0]	if (!WAveExists(segWv_pre))		Print "tracing_makeSegsAbut(): pre segnemt",indexWv[segNum_pre][0],"not found, aborting"		return 0	endif	WAVE/Z segWv_post = $indexWv[segNum_post][0]	if (!WAveExists(segWv_post))		Print "tracing_makeSegsAbut(): pre segnemt",indexWv[segNum_post][0],"not found, aborting"		return 0	endif		InsertPoints/M=0 0, 1, segWv_post	segWv_post[0][] = segWv_pre[DimSize(segWv_pre,0)-1][q]		if (ParamIsDefault(noUpdates) || !noUpdates)		tracing_doupdates(winN,nan,nan,nan)		//(winN,currSegRow_forCrossSect,highlightedSeg,highlightedSegPnt)	endif			return 1endfunction tracing_deleteSeg(winN,segNum)	String winN		//name of tracing window or "" for top	Variable segNum			//make the new segment wave	String tracedWaveName = tracing_getTracedWvNmFromWinN(winN)	String indexWvRef = tracing_getTracingIndexWaveRef(tracedwaveName)	WAVE/T indexWv = $indexWvRef		DeletePoints/M=0 segNum, 1, indexWv		//remove indexing of the combined waves, saving only the first		//rename tracing segment waves based on shift in order	Variable firstAffectedSeg = segNum,i,j,numPointsInSeg		//next segment is now at position of deleted seg	Variable numSegs=dimsize(indexwv,0)	String oldRef,newRef	for (i=firstAffectedSeg;i<numSegs;i+=1)		newRef = tracedWaveName + "_c" + num2str(i)		//name = [tracedWaveName]_c[row#]		oldRef = indexWv[i][0]		Duplicate/O $oldRef,$newRef		//cant use rename because wave may pre-exist and be in a window so it can't be killed		killwaves/Z $oldRef		//might not be killed if were in window, e.g. as the current tracing wave gets displayed in a table		indexWv[i][0] = newRef		SetDimLabel 0,i,$newRef,indexWv				//then update the row labels in the segment wave		WAVE segWv = $newRef		numPointsInSeg = dimsize(segWv,0)		for (j=0;j<numPointsInSeg;j+=1)			setdimlabel 0,j,$(newRef+"_"+num2str(j)),segWv		endfor	endforendfunction tracing_combineSegs(winN,startSegNum,endSegNum,newSegName)	String winN		//name of tracing window or "" for top	Variable startSegNum	//first segment for combining -- seg nums are their row in the index (_ind) wave	Variable endSegNum		//last segment for combining. segs must be contiguous,a common input would be start=3,end=4 to combine segs 3 and 4	String newSegName		//new name for segment, e.g. if old segments were is and is1 or ax0,ax1,ax2 is or ax would be reasonable. pass "" to just use the name of the first segment		//make the new segment wave	String tracedWaveName = tracing_getTracedWvNmFromWinN(winN)	String indexWvRef = tracing_getTracingIndexWaveRef(tracedwaveName)	WAVE/T indexWv = $indexWvRef	String firstSegRef = indexWv[startSegNum][0]		//all other waves are appended to this segment; its name doesn't need to change		Variable maxSegNum = dimsize(indexWv,0)-1	endSegNum = maxSegNum < endSegNum ? maxSegNum : endSegNum		//truncate end seg to last possible if needed		Variable numSegs = endSegNum - startSegNum + 1	if (numSegs < 2)		return 0	endif		if (!strlen(newSegName))		newSegName = indexWv[startSegNum][1]		//use the current name of the first segment if no segment is passed	endif		String nextSegRef	Variable i, numCats = numSegs-1	for (i=0;i<numCats;i+=1)		nextSegRef = indexWv[startSegNum+1+i][0]		concatenate/NP=0/Kill nextSegRef+";",	$firstSegRef	endfor	//row labels are fixed up automatically upon update via the call to tracing_showSegTable_ref		//fix up the index wave	indexWv[startSegNum][1] =  newSegName		//store the new name	DeletePoints/M=0 startSegNum+1, numCats, indexWv		//remove indexing of the combined waves, saving only the first		//rename tracing segment waves based on shift in order	Variable newLastSegNum = dimsize(indexWv,0),j,numPointsInSeg	String oldRef,newRef	for (i=startSegNum+1;i<newLastSegNum;i+=1)		newRef = tracedWaveName + "_c" + num2str(i)		//name = [tracedWaveName]_c[row#]		oldRef = indexWv[i][0]		Duplicate/O $oldRef,$newRef		//cant use rename because wave may pre-exist and be in a window so it can't be killed		killwaves/Z $oldRef		//might not be killed if were in window, e.g. as the current tracing wave gets displayed in a table		indexWv[i][0] = newRef		SetDimLabel 0,i,$newRef,indexWv				//then update the row labels in the segment wave		WAVE segWv = $newRef		numPointsInSeg = dimsize(segWv,0)		for (j=0;j<numPointsInSeg;j+=1)			setdimlabel 0,j,$(newRef+"_"+num2str(j)),segWv		endfor	endfor		SVAR tracing_currTracingWaveName	tracing_currTracingWaveName = indexWv[startSegNum][0]	tracing_doUpdates(winN,nan,nan,nan)	end//ccPntNum will be the first point in the second of two segments created from one segmentfunction tracing_splitSeg(winN,ccPntNum,preSegName,postSegName)	String winN	Variable ccPntNum		//pass nan to use currently selected point on GUI	String preSegName,postSegName		//name of new segments. pass "" for pre to use pre-existing name		if (!strlen(winN))		winN = winname(0,1)	endif		if (numtype(ccPntNum))		ccPntNum = tracing_getSelPntData(winN,nan)		//current selection	endif	String tracedWaveName = tracing_getTracedWvNmFromWinN(winN)	String indexWvRef = tracing_getTracingIndexWaveRef(tracedwaveName)	WAVE/T indexWv = $indexWvRef	String combinedSegRef = tracing_getCombinedSegref(tracedWaveName)	WAVE/D ccWv = $combinedSegRef	String segLabel = 	GetDimLabel(ccwv, 0, ccPntNum)	if (!strlen(segLabel))		Print "tracing_interp(): could not find seg label! aborting"		return 0	endif	Variable segNum = tracing_segNumFromSegRef(segLabel)	Variable preSegNum = segNum, postSegNum = segNum+1, nextSegNum = segNum + 2	Variable segPntNum = tracing_getSegPntFromSegRef(segLabel)	String segRef = tracing_getSegNameForCCPnt(winN,ccPntNum)	String origSegName = indexWv[segNum][1]	WAVE segWv= $segRef	if (!strlen(preSegName))		preSegName = origSegName		//get the segment name	endif		//set the new names for the two new segments	String preRef = tracedWaveName + "_c" + num2str(segNum)		//should be the same as original segRef, won't actually use this. just a sanity check in debug	String postRef = tracedWaveName + "_c" + num2str(segNum+1)		//should be the same as original segRef		//make room in the index wave for the new segment and update the index wave	InsertPoints/M=0 postSegNum, 1,indexWv			//give the new segments proper names	indexWv[preSegNum][0] = preRef	indexWv[postSegNum][0] = postRef	indexWv[preSegNum][1] = preSegName	indexWv[postSegNum][1] = postSegName	indexWv[preSegNum][2] = "1"	//supposed to be a show/hide option. not sure I've ever used, anyway, default to show with 1	indexWv[postSegNum][2] = "1"		//rename the references to remaining segments appopriately	Variable i,numSegs = dimsize(indexWv,0); String currSegRef, changeToRef	for (i=numSegs-1;i>=nextSegNum;i-=1)		//start with last segment to avoid overwriting existing segments before renaming		currSegRef = indexWv[i][0]		changeToRef = tracedWaveName + "_c" + num2str(i)		Duplicate/o $currSegRef, $changeToRef		indexWv[i][0] = changeToRef	endfor		//now split the original segment into the two new ones	Duplicate/O/R=[segPntNum,*][*] segWv,$postRef		//new wave starts with segPntNum	Redimension/N=(segPntNum+1,-1) segWv 								//old wave ends with segPntNum +1 is because otherwise would go from pnt 0 to segPntNum-1. this way segments abut		//now update row labels in all segments following the preSeg--the preSeg and those before it are unchanged because their number hasn't changed	Variable j,numPointsInSeg;	for (i=postSegNum;i<numSegs;i+=1)		currSegRef = indexWv[i][0]		WAVE segWv = $currSegRef		numPointsInSeg = dimsize(segWv,0)		for (j=0;j<numPointsInSeg;j+=1)			setdimlabel 0,j,$(currSegRef+"_"+num2str(j)),segWv		endfor		endfor	Print "split segment at ccPnt",ccPntNum,"segPnt",segPntNum,"orig segnum",segNum,"named",origSegName,"into pre-seg num",preSegNum,"named",preSegName,"and post-seg num",postSegNum,"named",postSegName	tracing_doUpdates(winN,nan,nan,nan)		//refreshes ccWvendfunction/S tracing_getLabelForCCPnt(winN,combinedWvPntNum)	String winN	Variable combinedWvPntNum		if (!strlen(winN))		winN = winname(0,1)	endif		String tracedWaveName = tracing_getTracedWvNmFromWinN(winN)	String combinedSegRef =  tracing_getCombinedSegref(tracedWaveName)		if (numtype(combinedWvPntNum))		combinedWvPntNum = tracing_getselpntdata(winN,nan)	endif				if (!WAveExists($combinedSegRef))		return ""	endif		return getdimlabel($combinedSegRef,0,combinedWvPntNum)end function tracing_segNumFromSegRef(segref)	String segRef		variable numSpace = itemsinlist(segRef,"_")	string segAppendStr = stringfromlist(numSpace-2,segRef,"_")[1,inf]		//remove "c" at start"	return str2num(segAppendStr)endfunction tracing_getSegPntFromSegRef(segref)	//good for gettign segment pnt from combined wave dim label	String segRef		variable numSpace = itemsinlist(segRef,"_")	string pntNumStr = stringfromlist(numSpace-1,segRef,"_")	return str2num(pntNumStr)end//for a row in the combined wave, returns the corresponding row in a segment wavefunction tracing_getSegPntNumForCCPnt(winN,combinedWvPntNum)	String winN	Variable combinedWvPntNum	String combinedWvRowLbl = tracing_getLabelForCCPnt(winN,combinedWvPntNum)	return tracing_getSegPntFromSegRef(combinedWvRowLbl)endfunction tracing_getSegNumForCCPnt(winN,combinedWvPntNum)	String winN	Variable combinedWvPntNum	String combinedWvRowLbl = tracing_getLabelForCCPnt(winN,combinedWvPntNum)	return tracing_segNumFromSegRef(combinedWvRowLbl)endfunction/S tracing_getSegNameForCCPnt(winN,combinedWvPntNum)	String winN;Variable combinedWvPntNum		//nan to get segName of selPnt	String combinedWvRowLbl = tracing_getLabelForCCPnt(winN,combinedWvPntNum)	Variable lastUS = strsearch(combinedWvRowLbl,"_",inf,1)	//Variable secondLastUS = strsearch(combinedWvRowLbl,"_",lastUS-1,1)	return combinedWvRowLbl[0,lastUS-1]end//returns wave in which ellipse points are stored for plottingfunction/S tracing_getPlottedEllipseWvName(winN)	String winN		return winN + "_ell"end	function wave_4d_multDim(waveRef, outRef, dim, indexStart, indexEnd, mult)	String waveREf, outRef; Variable dim,  indexStart, indexEnd, mult		if (!stringmatch(waveRef, outRef))		Duplicate/O $waveRef, $outRef	endif	WAVE out = $outRef		switch (dim)		case 0:			out[ indexStart, indexEnd][][][] *= mult			break		case 1:			out[][ indexStart, indexEnd][][] *= mult			break		case 2:			out[][][ indexStart, indexEnd][] *= mult			break		case 3:			out[][][][ indexStart, indexEnd] *= mult			break	endswitchend	//run this function to get started with tracing an image in a window called winNfunction disp_storeClickLocs(winN,horizAxName,vertAxName,mouseLocWvRef,showOverlay)	String winN		//name of window	String horizAxName,vertAxName		//name of horizontal and vertical axes for coordinate plane	String mouseLocWvRef			//name of a wave to store the horizontal and vertical coordinates in (created if it does not exist)	Variable showOverlay		//pass true to overlay click points on window		if (strlen(winN) < 1)		winN=winname(0,1)	endif		setwindow $winN userdata(mouseLocWvRef)=mouseLocWvRef	setwindow $winN userdata(horizAxName)=horizAxName	setwindow $winN userdata(vertAxName)=vertAxName	setwindow $winN userdata(showOverlay)=num2str(showOverlay)	setwindow $winN hook(disp_storeClickHook)=disp_storeClickHookend//main hook function to track when (ctrl) clicks occur and store their locationfunction disp_storeClickHook(s)		//main 	STRUCT WMWinHookStruct &s		Variable mouseUp = s.eventcode == 5	Variable ctrlClick = s.eventmod & 2^3		if (!mouseUp || !ctrlClick)		return 0		//ignore all other events 	endif		String mouseLocWvRef = GetUserData(s.winname, "", "mouseLocWvRef" )	String horizAxName = GetUserData(s.winname, "", "horizAxName" )	String vertAxName = GetUserData(s.winname, "", "vertAxName" )	Variable showOverlay = str2num(GetUserData(s.winname, "", "showOverlay" ))		Variable row	if (!WaveExists($mouseLocWvRef))		make/o/d/n=(1,2) $mouseLocWvRef/wave=mouseLocWv		row=0				SetDimLabel 1,0,$horizAxName,mouseLocWv 		setdimlabel 1,1,$vertAxName,mouseLocWv	else		WAVE mouseLocWv=$mouseLocWvRef		row=dimsizE(mouseLocWv,0)		redimension/n=(row+1,-1) mouseLocWv	endif		mouseLocWv[row][0] = disp_getMouseLoc(s,horizAxName)	mouseLocWv[row][1] = disp_getMouseLoc(s,vertAxName)			//check that mouseLocWv is plotted if it should be	if (showOverlay && !itemsinlist(WaveList(mouseLocWvRef, ";", "WIN:"+s.winname)))		String horAxisType = StringByKey("AXTYPE", AxisInfo(s.winName, horizAxName))		String vertAxisType = StringByKey("AXTYPE", AxisInfo(s.winName, vertAxName))				if (stringmatch(horAxisType,"right") && stringmatch(vertAxisType,"bottom"))			appendtograph/R $mouseLocWvref[][1] vs $mouseLocWvref[][0]		elseif (stringmatch(horAxisType,"left") && stringmatch(vertAxisType,"bottom"))			appendtograph $mouseLocWvref[][1] vs $mouseLocWvref[][0]		elseif (stringmatch(horAxisType,"right") && stringmatch(vertAxisType,"top"))			appendtograph/R/T $mouseLocWvref[][1] vs $mouseLocWvref[][0]		else		//last combination is left top			appendtograph/T $mouseLocWvref[][1] vs $mouseLocWvref[][0]		endif	endifend//helper function to get mouse click locationsfunction disp_getMouseLoc_old(s, axisNameStr)	STRUCT WMWinHookStruct &s	String axisNameStr		//name of axis of interest			string axInfo=AxisInfo(s.winName, axisNameStr)	String axisType = StringByKey("AXTYPE", axInfo)		//determine if vertical, return y position if so, x position if not	Variable isVert = stringmatch(axisType, "left") || stringmatch(axisType, "right")		//find proportion along vert or horiz	Variable prop; getWindow $s.winName, psizeDC	if (isVert)		prop = (s.mouseLoc.v - V_top) / (V_bottom - V_top)		else		prop = (s.mouseLoc.h - V_left) / (V_right - V_left)		endif		//find start and end values of axis as shown	GetAxis/Q $axisNameStr; Variable shownRange, rangeStart, relPos,rangeEnd	if (V_max > V_min)			//standard direction axis, low to high ordering		shownRange = V_max - V_min		rangeStart = V_min		rangeEnd = V_max	else			shownRange = V_min - V_max		rangeStart = V_max		rangeEnd = V_min	endif		//is the axis reversed (as for images)	String axFlags=stringbykey("SETAXISFLAGS",axInfo)	VAriable isReversed= StringMatch(axFlags, "*/R") || stringmatch(axFlags,"*/R/*")		if (shownRange == 0)		relPos = nan 	else		if (isReversed)			relPos = rangeStart + prop*shownRange		else			relPos = rangeEnd - prop*shownRange			endif	endif		Print "axisNameStr",axisNameStr,"relPos",relPos,"isReversed",isReversed		return relPosend	function disp_getMouseLoc(s,axNameStr)	STRUCT WMWinHookStruct &s	String axNameStr		//name of axis of interest		string axInfo=AxisInfo(s.winName, axNameStr)	String axisType = StringByKey("AXTYPE", axInfo)		//determine if vertical, return y position if so, x position if not	Variable isVert = stringmatch(axisType, "left") || stringmatch(axisType, "right")		if (isVert)		return AxisValFromPixel(s.winName, axNameStr, s.mouseLoc.v )	else		return AxisValFromPixel(s.winName, axNameStr, s.mouseLoc.h )	endifend//checks if one or more points are traced onto winN, returns 1 if sofunction tracing_doPlot(winN)	String winN	String tracedWaveName = img_getImageName(winN)	String zWaveName = tracing_getZWaveRef(tracedWaveName)	if (!WaveExists($zWaveName))		return 0	endif		WAVE/T zWv= $zWaveName	return strlen(zWv[0][0]) != 0		//true if there's a string in this position (empty when no points yet plotted)endfunction transform_3DBinaryTo3ColWave(inRef, outRef)	String inRef, outRef		WAVE binaryWv = $inRef	Variable numPoints = sum(binaryWv)	Make/O/N=(numPoints,3) $outRef	WAVE outWv = $outRef		Variable i,j,k, count = 0	for (i=0 ; (i< DimSize(binaryWv,0)) && (count < numPoints) ;i+=1)		if (mod(i,50) == 0)			Print "(reporting every ~50th row) at row = " + num2str(i)		endif		for (j=0; (j< DimSize(binaryWv,1)) && (count < numPoints) ;j+=1)			for (k=0; (k< DimSize(binaryWv,2)) && (count < numPoints) ;k+=1)				if (binaryWv[i][j][k])					outWv[count][0] = i					outWv[count][1] = j					outWv[count][2] = k					count +=1				endif			endfor		endfor	endfor					end//use this function in case you know the name of the window that was attempted to be used originally//and to which Igor may have added numbers afterwards//not a perfect function because this will also return longer namesfunction/S win_getFirstDerivedWinName(parentWinN)	String parentWinN	String wins = winList(parentWinN + "*",";","")		//list of all windows matching name with anything following		//only those wins with one or more digits following name	//avoids non-digit etc. after the parentWinN that would indicate a window name	//that contains parentWinN but has a longer, different name	//based on this example from the help files:	//	Function DemoSplitString()//	String subject = "Thursday, May 7, 2009"//	String regExp = "([[:alpha:]]+), ([[:alpha:]]+) ([[:digit:]]+), ([[:digit:]]+)"//	String dayOfWeek, month, dayOfMonth, year//	SplitString /E=(regExp) subject, dayOfWeek, month, dayOfMonth, year//	Print dayOfWeek, month, dayOfMonth, year//	End//	The output from Print is://	Thursday  May  7  2009			Variable i, followingNum	Variable valueOfLowestRepFound = inf	Variable indexOfLowestRepFound = NaN	String currN, trailingText, followingNumStr		String regExp = "parentWinN" + "([[:digit:]]+)([[:alpha:]]+)"	for (i=0;i<ItemsInList(wins);i+=1)		currN = StringFromList(i, wins)				if (strlen(currN) == strlen(parentWinN))			return parentWinN		endif				SplitString/E=(regExp) currN, followingNumStr, trailingText				if (strlen(followingNumStr) && !strlen(trailingText))	//then there is length to followingNumStr, so see if this is the lowest numbered match			followingNum = str2num(followingNumStr)					if (followingNum < valueOfLowestRepFound)				indexOfLowestRepFound = i			endif					endif		endfor		if (numtype(indexOfLowestRepFound))	//check if indexOfLowestRepFound still inf, if so return empty bc nothing found 		return ""	endif		return StringFromLisT(indexOfLowestRepFound,wins)endfunction tracing_clearTracingOverlay(winN)	String winN		String tracedWaveName = img_getImageName(winN)	String overlayWvSaveName = tracing_getOverlayWvRef(tracedWaveName)	String colorWvSaveName = tracing_getOverlayColorsWvRef(tracedWaveName)		Make/D/O/N=(1,3) $overlayWvSaveName	Make/O/N=(1,3) $colorWvSaveName	WAVE overlayWv = $overlayWvSaveName; Wave colorWv = $colorWvSaveName		overlayWv = NaN	colorWv = NaN	endfunction tracing_refreshTracingOverlay(winN,highlightedSeg,highlightedSegPnt)	String winN	Variable highlightedSeg		//pass a valid segment number to fill in all points from that segment	Variable highlightedSegPnt	//pass a valid pntNumber (row number) in highlightedSeg to highlight that point			if (!strlen(winN))		winN = winname(0,1)	endif		Variable zDistTol = 0.5		//count pixels in plane that are within half a z pixel, exclusive			String tracedWaveName = img_getImageName(winN)	String zWaveName = tracing_getZWaveRef(tracedWaveName)	String indexWaveName = tracing_getTracingIndexWaveRef(tracedWaveName)	String overlayWvSaveName = tracing_getOverlayWvRef(tracedWaveName)	String colorWvSaveName = tracing_getOverlayColorsWvRef(tracedWaveName)	String markerWvSaveName = tracing_getOverlayMarkerWvRef(tracedWaveName)	Variable zCenter = img_getDisplayedPlane(winN)		if (numtype(highlightedSeg))		highlightedSeg = tracing_getCurrSegNum(winN)	endif		if ( numtype(highlightedSegPnt) && (numtype(highlightedSeg) == 0) )		highlightedSegPnt = tracing_getSelPntData(winN,highlightedSeg)	endif				if (!tracing_doPlot(winN))		tracing_clearTracingOverlay(winN)		return 0	endif		//color	Variable planeDepth = 25			//how far out of plane one can "see"	Variable positiveGun = 0			//positive red (gun 0)	Variable negativeGun = 2			//negative blue	Variable maxColorVal = 50000	Variable minColorVal = 1000	Variable colorWorkingRange = maxColorVal -  minColorVal		//transparency	Variable alphaGun = 3	Variable alphaVal	String opacSliderN = tracing_getOpacSliderName()	String opacWinN = win_getFirstDerivedWinName(opacSliderN)	//marker	Variable nonHighlightedSegMarkerNum = 7		//8 is unfilled circle		//19 is filled circle	Variable highlightedSegMarkerNum = 8		//0 is filled cicle		//54 is open hexagons		//7 is open diamond	Variable nonHighlightedPntMarkerNum  = nonHighlightedSegMarkerNum	//not really worth differentiating random points in other segments?	Variable highlightedPntMarkerNum  = 19		//17 is closed triangle	//55 is closed hexagons		//18 is closed diamond		//41 is open circle with center dot		if ( (strlen(opacWinN) < 1) || (wintype(opacWinN) == 0))		alphaVal = -1 + 2^16	else		ControlInfo/W=$opacWinN $opacSliderN		alphaVal = V_Value	endif		WAVE/T zWv = $zWaveName	WAVE/T indexWv = $indexWaveName		if (strlen(zWv[0][0]) == 0)		//empty, so cleared		tracing_clearTracingOverlay(winN)	endif		Variable i,j, overlayIndex=0, currPixel_z, numPoints, currPointRow, currPixelVal_x, currPixelVal_y, currTracingComponentNum	String currPointsList, currTraceWvPntPair, currTraceWvRef	Variable currZDist, normalizedZDepth		//latter relative to plane depth	Variable firstDrawnZFound = 0		Variable pntSegNum, isHighlightedSeg, isHighlightedSegPnt		//tracks whether each pnt is in the highlighted segment or is the highlighted pnt	Variable markerNum	//markerNum to be applied to each pnt (Determined by comparing pntSegNum,currPointRow with isHighlightedSeg, isHighlightedSegPnt	)	for (i=0;i<DimSize(zWv,0);i+=1)		currPixel_z = str2num(zWv[i][0])		numPoints = str2num(zWv[i][1])		currPointsList = zWv[i][2]		currZDist = zCenter - currPixel_z				if (abs(currZDist) > planeDepth)		//skip z values out of plane depth			continue		endif					normalizedZDepth = abs(currZDist) / planeDepth		if (firstDrawnZFound==0)		//first row, make new wave with correct number of points			Make/O/N=(numPoints,3) $overlayWvSaveName/WAVE=overlayWv			Make/U/O/N=(numPoints,4) $colorWvSaveName/WAVE=colorWv		//made type unsigned in later			Make/U/O/N=(numPoints) $markerWvSaveName/WAVE=markerWv			firstDrawnZFound = 1		else			Redimension/N=(DimSize(overlayWv,0) + numPoints,-1) overlayWv			Redimension/N=(DimSize(colorWv,0) + numPoints,-1) colorWv			Redimension/N=(DimSize(markerWv,0) + numPoints) markerWv		endif				for (j=0;j<numPoints;j+=1)			currTraceWvPntPair = StringFromList(j, currPointsList)			currTraceWvRef = StringFromList(0, currTraceWvPntPair,",")						currPointRow = str2num(StringFromList(1, currTraceWvPntPair,","))			pntSegNum = str2num(stringfromlist(2,currTraceWvPntPair,","))			currTracingComponentNum = str2num(StringFromList(2, currTraceWvPntPair, ","))		//get the component number for this point			currPixelVal_x = getWaveV_val_2D(currTraceWvRef, currPointRow, 0)			//takes precise click loc rather than pixel val			currPixelVal_y = getWaveV_val_2D(currTraceWvRef, currPointRow, 1)								if (str2num(indexWv[currTracingComponentNum][2]))		//is there a one in the 2nd column of the row of the component for this point?				colorWv[overlayIndex][alphaGun] = alphaVal		//sets transparency to current value			else				colorWv[overlayIndex][alphaGun] = 0		//sets transparency to zero (implements hiding of segments			endif						overlayWv[overlayIndex][0] = currPixelVal_x			overlayWv[overlayIndex][1] = currPixelVal_y			overlayWv[overlayIndex][2] = currPixel_z						if (abs(currZDist) < zDistTol)		//at exact plane of focus				colorWv[overlayIndex][0] = 32792				colorWv[overlayIndex][1] = 65535					colorWv[overlayIndex][2] = 1							//make white			else				colorWv[overlayIndex][0,2] = minColorVal + colorWorkingRange*(normalizedZDepth)	//moving towards brightest as farther away				if (currZDist < 0)		//below plane					colorWv[overlayIndex][positiveGun] = maxColorVal		//always brightest				else						//above plane					colorWv[overlayIndex][negativeGun] = maxColorVal				endif			endif					//handle how to "highlight" pnt by marker type			isHighlightedSeg = pntSegNum == highlightedSeg			isHighlightedSegPnt = currPointRow == highlightedSegPnt			if (isHighlightedSeg)				if (isHighlightedSegPnt)					markerNum = highlightedPntMarkerNum				else					markerNum = highlightedSegMarkerNum				endif			else				if (isHighlightedSegPnt)					markerNum = nonHighlightedPntMarkerNum				else					markerNum = nonHighlightedSegMarkerNum				endif			endif			markerWv[overlayIndex] = markerNum									overlayIndex += 1		endfor	endfor			//handle if there is nothing to plot at present (e.g. moved too far from plane of tracing)	if (overlayIndex == 0)		tracing_clearTracingOverlay(winN)	else			//handle plotting if there is something to plot		Variable waveOnGraph = ItemsInList(ListMatch(text_getWvListFromTraceList(winN,traceNameList(winN,";",1)), overlayWvSaveName))		if (!waveOnGraph && (DimSize(overlayWv,1) > 1) )			AppendtoGraph/W=$winN/T/L overlayWv[][1]/TN=$overlayWvSaveName vs overlayWv[][0]		//y_pixels vs x_pixels			ModifyGraph/W=$winN zColor($overlayWvSaveName)={$colorWvSaveName,*,*,directRGB,0}, mode=3,msize=2			ModifyGraph/W=$winN zmrkNum($overlayWvSaveName)={$markerWvSaveName}			 		//	String pzWin=tracedWaveName+"pzW" //p vs z with q in layers, equiv y vs z with x in layers -- swap for [p][r][q] 		//	String zqWin=tracedWaveName+"zqW" //z vs q with 	p in layers, equiv z vs x with y in layers -- swap for [r][q][p]			//			if (wintype(pzWin) > 0)			//pz keeps y so plot y vs z//				AppendtoGraph/W=$pzWin/T/L overlayWv[][1] vs overlayWv[][2]//				Modifygraph/W=$pzWin zColor={$colorWvSaveName,*,*,directRGB,0},mode=3,msize=2,zmrkNum($overlayWvSaveName)={$markerWvSaveName}//			endif//			if (wintype(zqWin) > 0)			//zq keeps x so plot z vs x//				AppendtoGraph/W=$zqWin/T/L overlayWv[][2] vs overlayWv[][0]//				Modifygraph/W=$zqWin zColor={$colorWvSaveName,*,*,directRGB,0},mode=3,msize=2,zmrkNum($overlayWvSaveName)={$markerWvSaveName}//			endif		endif	endif				String pzWin=tracedWaveName+"pzW" 			String zqWin=tracedWaveName+"zqW"				//AppendtoGraph/W=$pzWin/T/L overlayWv[][1] vs overlayWv[][2]		//plot is y along top and z along x/left				//Modifygraph/W=$pzWin zColor={$colorWvSaveName,*,*,directRGB,0},mode=3,msize=2,zmrkNum($overlayWvSaveName)={$markerWvSaveName}				//AppendtoGraph/W=$zqWin/T/L overlayWv[][2] vs overlayWv[][0]		//plot is z along top and x along x/left				//Modifygraph/W=$zqWin zColor={$colorWvSaveName,*,*,directRGB,0},mode=3,msize=2,zmrkNum($overlayWvSaveName)={$markerWvSaveName}end//tracing_refreshTracingOverlay()function disp_isWaveOnGraph(winN, waveRef)	String winN, waveRef		if (strlen(winN) == 0)		winN = winname(0,1)	endif		return ItemsInList(ListMatch(text_getWvListFromTraceList(winN,traceNameList(winN,";",1)), waveRef)) > 0 endfunction disp_isTraceOnGraph(winN, traceN)	String winN, traceN		if (strlen(winN) == 0)		winN = winname(0,1)	endif		return ItemsInList(ListMatch(traceNameList(winN,";",1), traceN)) > 0 end	function getWaveV_val_2D(waveRef, row, col)	String waveRef; Variable row, col		WAVE/z temp = $waveRef	if (!waveexists(temp))		return nan	endif	return temp[row][col]endfunction getWaveV_val_1D(waveRef,row)	String waveRef; Variable row		WAVE/z temp = $waveRef	if (!waveexists(temp))		return nan	endif	return temp[row]end	function tracing_addPointFromClickLoc(s)	STRUCT WMWinHookStruct &s	Variable xPixelVal, yPixelVal	xPixelVal = disp_getMouseLoc(s, "top")		yPixelVal = disp_getMouseLoc(s, "left")		String imgName = img_getImageName(s.winName)	Variable zPixel = img_getDisplayedPlane(s.winName)		Variable redoRows =  (s.eventMod & 2^1) != 0		//shift click, overwrites last added point instead of adding a new one	Variable overwritePnt = redoRows && ( (s.eventMod & 2^3) != 0	)	//CTRL + SHIFT click -- overwrite point selection//	print "redoRows",redoRows,"overwritePnt",overwritePnt	Variable numPointsToDelete,deleteWithoutAddition=0	if (redoRows && !overwritePnt)		//ignore redo rows if overwriting a point		numPointsToDelete = 1		//sets default num pnts to delete at 1		prompt numPointsToDelete, "Enter num points to remove"		prompt deleteWithoutAddition,"skip addition?"		doprompt "Remove points", numPointsToDelete,deleteWithoutAddition	else				numPointsToDelete = 0	endif		if (overwritePnt)		Variable selPnt = tracing_getSelPntData(s.winname,nan)		tracing_addPoint(s.winName,xPixelVal,yPixelVal,zPixel,numPointsToDelete,overwriteCCPnt=selPnt,noAddition=deleteWithoutAddition)	else		tracing_addPoint(s.winName,xPixelVal,yPixelVal,zPixel,numPointsToDelete,noAddition=deleteWithoutAddition)	endifendfunction/S tracing_getOpacSliderName()	return "tracing_opacity"end//MUST have traced image on topfunction tracing_showOpacitySlider()	String opacWinN = tracing_getOpacSliderName()		Variable maxVal = (2^16)-1		//assumes 16 bit "RGBa" color. default is to have full opacity (a)		String tracingWinN = winname(0,1)		if (!Wintype(opacWinN))		Display/K=1/N=$opacWinN		Slider $opacWinN limits={0,maxVal,0}, size={50,100}, pos={0,0}, proc=tracing_opacSliderAction, userdata=tracingWinN, value=maxVal	endifendfunction tracing_opacSliderAction(s)	STRUCT WMSliderAction &s//	String camName = StringFromList(0, s.ctrlName, "_")//	ModifyCamera/W=$camName setSharpening=s.curval	tracing_refreshTracingOverlay(s.userdata,nan,nan)endfunction tracing_addPoint(winN,xPixelVal,yPixelVal,zPixel,numPointsToDelete,[overwriteCCPnt,noAddition])	String winN;	Variable xPixelVal, yPixelVal	//stored as float point closest to click--maps onto axis space not pixel space, round to integer to get pixel	Variable zPixel				//maps onto layer space, so consider each slice an integer pixel	Variable numPointsToDelete			//if zero, a new point is added (standard use). If 1 or greater, input starts from that many points preceding, up to the beginning of the Segment	Variable noAddition		//allows point deletion without addition of subsequent new points. pass true, otherwise ignored	Variable overwriteCCPnt		//optionally pass to overwrite the point at the index passed -- numPointsToDelete is ignored!	Variable autoRadius_pixels = 30	Variable highlightCurrSeg = 1	//set whether to highlight the current seg and pnt (see tracing_refreshTracingOverlay)	Variable highlightCurrPnt = 1	Variable numStoredTraceParams = 7	SVAR/Z tracing_currTracingWaveName		if (!Svar_exists(tracing_currTracingWaveName))		Print "tracing_addPoint(): Failed to find required global string tracing_currTracingWaveName. Likely need to use tracing_addSeg(seg#,\"segName\") to instantiate it"		return 0	endif		String imgName = img_getImageName(winN)		Variable xNearestPixel = round(xPixelVal)	Variable yNearestPixel = round(yPixelVal)		Variable currRow 		String combinedSegRef,usedSegRef="",savedSegRef=""	if (!ParamIsDefault(overwriteCCPnt))		combinedSegRef = tracing_getCombinedSegref(imgName)		WAVE/Z/D combinedSegWv = $combinedSegRef		if (!WaveExists(combinedSegWv))			Print "tracing_addPoint() request to overwrite ccPnt",overwriteCCPnt,"failed. combinedSegRef",combinedSegRef,"does not exist.aborting"			return 0		endif		Variable pnts = dimsize(combinedSegWv,0)		if (numtype(overwriteCCPnt) || (overwriteCCPnt<0) ||  (overwriteCCPnt>(pnts-1))  )			Print "tracing_addPoint() request to overwrite ccPnt",overwriteCCPnt,"failed. overwriteCCPnt is out of range or not a real number. aborting"			return 0		endif				savedSegRef=tracing_currTracingWaveName		usedSegRef=tracing_getSegNameForCCPnt(winN,overwriteCCPnt)		tracing_currTracingWaveName = usedSegRef		Variable selPnt_segIndex = tracing_getSegPntNumForCCPnt(winN,overwriteCCPnt)		currRow = selPnt_segIndex	endif			WAVE/Z/D currTracingWv = $tracing_getSegNameForCCPnt(winN,nan)		if (!WaveExists(currTracingWv))		Make/O/N=(1,numStoredTraceParams)/D $tracing_currTracingWaveName		//5 stores radius of current point in absolute value, 6 does it in pixels 		WAVE/Z/D currTracingWv = $tracing_currTracingWaveName		tracing_setSegColumnsLbls(tracing_currTracingWaveName)		currRow = 0	else		if (numtype(currTracingWv[0][0]) != 0)		//filled with NaNs if no points yet			currRow = 0		elseif (!ParamIsDefault(overwriteCCPnt) && overwriteCCpnt && (numPointsToDelete < 1))			//do nothing! Point will be filled in with new values				else		//normal case, 			currRow = tracing_getSelPntData(winN,-1)+1 //DimSize(currTracingWv,0) <-- had been setting for years but means no points always add at end of segment, which is bad for adding out of order			if (numPointsToDelete)		//shift key down, redo last point)				deletepoints/M=(0) currRow - numPointsToDelete, numPointsToDelete, currTracingWv								currRow -= numPointsToDelete				if (currRow < 0)					currRow = 0		//truncate at zero				endif			endif			insertpoints/m=(0)/v=(nan) currRow,1,currTracingWv		endif	endif 	Variable rows=dimsize(currTracingWv,0),i	for (i=currRow;i<rows;i+=1)		SetDimLabel 0,i,$(tracing_currTracingWaveName+"_"+num2str(i)),currTracingWv	endfor		if (ParamIsDefault(noAddition) || !noAddition)		currTracingWv[currRow][0] = xPixelVal		currTracingWv[currRow][1] = yPixelVal		currTracingWv[currRow][2] = xNearestPixel		currTracingWv[currRow][3] = yNearestPixel		currTracingWv[currRow][4] = zPixel	endif		if (ParamIsDefault(overwriteCCPnt))		//save the cross section information for the previous wave		if  (currRow > 0)			currTracingWv[currRow][5,6] = currTracingWv[currRow-1][q]			Variable currCrossSectInPix = currTracingWv[currRow][6]			if (numtype(currCrossSectInPix) == 0)		//not NaN etc.				tracing_setCurrCrossSectSize(currTracingWv[currRow][5])			endif		else			Variable segNum = tracing_getCurrSegNum(winN)			if (segNum == 0)		//very first point, just make something up for radius				currTracingWv[0][6] = autoRadius_pixels				currTracingWv[0][5] = img_pixelsToAbsCircleMrkSize(winN, autoRadius_pixels, 0)			else				//first point in segment, get the radius of the last point in the preceding segment and copy that over					String tracingIndexWvRef = tracing_getTracingIndexWaveRef(imgName)				WAVE/T tracingIndexWv = $tracingIndexWvRef						String lastTracingWvRef = tracingIndexWv[segNum-1][0]				WAVE lastTracingWv = $lastTracingWvRef				Variable lastWvLastPnt = dimsize(lastTracingWv,0) - 1				if ( (lastWvLastPnt < 0) || numtype(lastWvLastPnt) )		//no pnts in that wave .. set to automatic value					currTracingWv[0][6] = autoRadius_pixels					currTracingWv[0][5] = img_pixelsToAbsCircleMrkSize(winN, autoRadius_pixels, 0)												else					currTracingWv[currRow][5,6] = lastTracingWv[lastWvLastPnt][q]				endif						endif			endif	endif	//	Print "currTracingWvRef",nameofwave(currTracingWv),"usedSegRef",usedSegRef,"savedSegRef",savedSegRef,"currRow",currRow,"xVal=" + num2str(xPixelVal ) + ". xNearestPixel=" + num2str(xNearestPixel ) + ". yVal=" + num2str(yPixelVal ) + ". yNearestPixel=" + num2str(yNearestPixel )		tracing_updateZWave(imgName)	tracing_showSegTable_ref(imgName);		Variable displaySegment, displayPnt; STRING indexRef,searchStr			if (highlightCurrPnt)		searchStr = tracing_currTracingWaveName + "_" + num2str(currRow)		combinedSegRef = tracing_getCombinedSegref(imgName)		WAVE/T segWv = $combinedSegRef		if (WaveExists(segWv))			displayPnt = FindDimLabel(segWv, 0, searchStr )			if (displayPnt < 0)				displayPnt = DimSize(segWv,0)-1			endif		else			displayPnt = NaN		endif	else		displayPnt = NaN		endif		if (ParamIsDefault(overwriteCCPnt))		tracing_follow(winN,displayPnt,nan,0)		//might be good to substitute this for tracing_doUpdates in future. that function is called by follow anyway		tracing_updateCrossSectXYWv(winN, tracing_currTracingWaveName, currRow)	else		tracing_follow(winN,overwriteCCPnt,nan,0)		tracing_currTracingWaveName = savedSegRef	endifendfunction tracing_doUpdates(winN,currSegRow_forCrossSect,highlightedSeg,highlightedSegPnt)	String winN	Variable currSegRow_forCrossSect	Variable highlightedSeg,highlightedSegPnt	//see tracing_refreshTracingOverlay		Variable tracingWvFollowsHighlightedSeg = 1		//170613 new option: change tracing wave to that of selected point																//previously tracing wave was always that assigned during tracing																	if (!strlen(winN))		winN = winname(0,1)	//topgraph	endif		String imgName = img_getImageName(winN)		if (tracingWvFollowsHighlightedSeg)		String tracingIndexWvRef = tracing_getTracingIndexWaveRef(imgName)		WAVE/T/Z tracingIndexWv = $tracingIndexWvRef		if (!WaveExists(tracingIndexWv))			return 0		endif		//is the selected segment a valid, traced segment?		if ( (highlightedSeg >= 0) && (highlightedSeg < dimsize($tracingIndexWvRef,0)) )			String/G tracing_currTracingWaveName = tracingIndexWv[highlightedSeg][0]			//Print "tracing_currTracingWaveName set to",tracing_currTracingWaveName,"segName",tracingIndexWv[highlightedSeg][1]		endif	endif		SVAR/Z tracing_currTracingWaveName	if (!Svar_exists(tracing_currTracingWaveName))		Print "tracing_doUpdates(): failed to find current tracing wave!"		return 0	endif		tracing_updateZWave(imgName)	tracing_updateCrossSectXYWv(winN, tracing_currTracingWaveName, currSegRow_forCrossSect,setRadiusToStoredVal=1)	tracing_showSegTable_ref(imgName)//,1)		tracing_refreshTracingOverlay(winN,highlightedSeg,highlightedSegPnt)		end//calls tracing_repeatPoint() if enter click event is passedfunction tracing_enterRepeatsPoint(s)	STRUCT WMWinHookStruct &s		if (s.keycode != 13)		return 0	endif		tracing_repeatPoint(s.winName)end//currently called by pressing enter. See tracing_enterRepeatsPoint(s)function tracing_repeatPoint(winN)		String winN		WAVE/D crossSectSizeWv = $tracing_getCrossSectSizeWvRef()	WAVE/D crossSectXYPosWv = $tracing_getCrossSectXYWvRef()		Variable lastPixelVal_x = crossSectXYPosWv[0][0]	Variable lastPixelVal_y = crossSectXYPosWv[0][1]	Variable lastPixel_z = img_getDisplayedPlane(winN)		tracing_addPoint(winN, lastPixelVal_x, lastPixelVal_y, lastPixel_z, 0)	end		//CROSS SECTION ESTIMATES: current cross section estimate stored in tracing_currCrossSectSizes, xy pos for this in tracing_currCrossSectXYPos//this info stored in  tracing_getCrossSectSizeWvRef()	 and tracing_getCrossSectXYWvRef()//170613 modified to move for ctrl + scroll wheel or ctrl + up down arrow keyfunction tracing_updatesCrossSect(s)	STRUCT WMWinHookStruct &s		Variable scrollEvent = (s.eventCode == 22) && ((s.eventMod & 2^3) != 0)		//22 is wheel event	Variable arrowKeysEvent =  (s.keycode == 30) || (s.keycode == 31 )		if (!scrollEvent && !arrowKeysEvent)		return 0	endif				Variable fineOrCoarse = (s.eventMod & 2^1) != 0		//returns true WITH SHIFT key, so USE SHIFT (along with cntrl) key to get COARSE		Variable scrollVal		if (scrollEvent)		scrollVal = s.wheelDy  == 0 ? 0 : (s.wheelDy > 0 ? 1 : -1)		//the case of equal to zero probably never happens																					//but different types of mice (particularly laptop pads vs actual mice) have different scales, so the +/- == 1/-1 equalizes	elseif (arrowKeysEvent)		scrollVal = s.keycode == 30 ? 1 : -1		//up arrow is 30, down is 31	else		return 0	endif		if (tracing_doPlot(s.winName))		tracing_incrCrossSectSize(scrollVal, fineOrCoarse)	endif		return arrowKeysEvent		//return 1 to tell passing function to also return 1 and deal with the keyboard event, rather than letting Igorendfunction tracing_incrCrossSectSize(V_arbitIncrement, fineOrCoarse)	Variable V_arbitIncrement	//arbitrary unit (for scroll its -1 or +1), scaling set here	Variable fineOrCoarse		Variable sizeChangePerArbitraryUnit	if (fineOrCoarse)		sizeChangePerArbitraryUnit = 4		//coarse. 1 before igor 7	else		sizeChangePerArbitraryUnit = .25		//fine. 0.2 before igor7	endif		Variable scaledIncrement = V_arbitIncrement * sizeChangePerArbitraryUnit		tracing_setCurrCrossSectSize(tracing_getCurrCrossSectSize() + scaledIncrement)endfunction tracing_saveCrossSectLastInWv()		SVAR/Z tracing_currTracingWaveName		if (!svar_exists(tracing_currTracingWaveName))		Print "tracing_saveCrossSectLastInWv(): Failed to find required global string tracing_currTracingWaveName. Likely need to use tracing_addSeg(seg#,\"segName\") to instantiate it"		return 0	endif		Variable currCrossSectSize = tracing_getCurrCrossSectsize()			WAVE/Z tracingWv = $tracing_currTracingWaveName	if (!WaveExists(tracingWv))		Print "tracing_saveCrossSectLastInWv(): Failed to find required wave in ref tracing_currTracingWaveName. Likely need to use tracing_addSeg(seg#,\"segName\") to instantiate it"		return 0	endif		variable lastPntRow = DimSize(tracingWv,0)-1	if (lastPntRow < 0)		lastPntRow=0		//truncate at zero		redimension/n=(1,-1) tracingWv		//can actually get zero rows and cause an error!	endif		tracingWv[lastPntRow][5] = tracing_getCurrCrossSectsize()	tracingWv[lastPntRow][6] = tracing_getCurrCrossSectsize(winN=winname(0,1))end//added 170613//FOR USE WITH TRACKING BACK TO POINTS AFTER TRACING, when one wants to update cross section//not originally intended for updating cross section while in the process in tracing, not sure//how that would go.function tracing_storeZValueForCurrPnt(winN,[useValFromDelta,setToPixelVal,setDisplay])	String winN	Variable useValFromDelta	//pass to store the radius for this point not as what is currently displayed but instead a point number offset from this one by the passed value									//passing 0 should behave as if the optional parameter wasnt passed	Variable setToPixelVal	//set to command a new pixel value width; this has priority	Variable setDisplay		//if passed and true, tracing_setCurrCrossSectSize is called to update that to the value for this point		if (!strlen(winN))		winN = winname(0,1)	endif	Variable selPnt_overallIndex = tracing_getSelPntData(winN,nan)	Variable selPnt_segIndex = tracing_getSegPntNumForCCPnt(winN,selPnt_overallIndex)	Variable selPntSegNum = tracing_getSegNumForCCPnt(winN,selPnt_overallIndex)			String tracedWaveName = img_getImageName(winN)		String indexWvRef = tracing_getTracingIndexWaveRef(tracedWaveName)	WAVE/T/z indexWv = $indexWvRef		if (!WaveExists(indexWv))		return 0	endif		if (selPntSegNum >= dimsize(indexWv,0))		Print "tracing_storeZValueForCurrPnt(): z value not stored because sel pnt is now not in an existing segment, likely segments were combined or deleted"		return 0	endif	if (numtype(selPntSegNum))		selPntSegNum=0	endif	String segWvRef = indexWv[selPntSegNum][0]	WAVE segWv = $segWvRef			Variable crossSectSize_pnts,crossSectSize_pix		if (!ParamIsDefault(setToPixelVal))		crossSectSize_pix = setToPixelVal		crossSectSize_pnts = img_pixelsToAbsCircleMrkSize(winN, crossSectSize_pix, 0)	elseif (ParamIsdefault(useValFromDelta))		crossSectSize_pnts = tracing_getCurrCrossSectsize()		crossSectSize_pix = tracing_getCurrCrossSectsize(winN=winN)		else		String combinedSegRef = tracing_getCombinedSegref(tracedWaveName)		WAVE combinedSegWv = $combinedSegRef		Variable indexToGetCrossSectFrom = selPnt_overallIndex + useValFromDelta		indexToGetCrossSectFrom = tracing_truncPntValueIfNeeded(indexToGetCrossSectFrom,winN)		crossSectSize_pix = combinedSegWv[indexToGetCrossSectFrom][6]			crossSectSize_pnts = img_pixelsToAbsCircleMrkSize(winN, crossSectSize_pix, 0)				//seems redundent (in truth the former might be) but also need to set the displayed cross section radius to avoid the former change being overwritten		//added bonus of immediately updating the display to be consistent with the stored value		String crossSectSizeWvRef = tracing_getCrossSectSizeWvRef()		WAVE crossSectSizeWv = $crossSectSizeWvRef		crossSectSizeWv[0] = crossSectSize_pnts		endif	if (numtype(selPnt_segIndex))		selPnt_segIndex=0	endif		segWv[selPnt_segIndex][5] = crossSectSize_pnts	segWv[selPnt_segIndex][6] = crossSectSize_pix		if (!ParamIsDefault(setDisplay) && setDisplay)		tracing_setCurrCrossSectSize(crossSectSize_pnts)	endif		//tracing_doUpdates(winN,nan,nan,nan)end//RETURNS NaN IF CROSS SECT ESTIMATOR IS HIDDENfunction tracing_getCurrCrossSectsize([winN])	String winN		//returns in pixels if win name is passed		String crossSectSizeWvRef = tracing_getCrossSectSizeWvRef()	WAVE crossSectSizeWv = $crossSectSizeWvRef			if (ParamIsDefault(winN))		return tracing_isSectWaveHidden() ? NaN : crossSectSizeWv[0]			//returns abs value if section wave is visible, NaN if absnet	endif		return tracing_isSectWaveHidden() ? NaN : img_absCircleMrkToPixels(winN, crossSectSizeWv[0], 0)		//returns scaled section estimate if section wave is visibleendfunction tracing_setCurrCrossSectSize(absSize)	Variable absSize		String crossSectSizeWvRef = tracing_getCrossSectSizeWvRef()	WAVE crossSectSizeWv = $crossSectSizeWvRef	crossSectSizeWv[0] = absSizeend//alters position of cross section estimater wave on image, usually this will be called to keep the cross section estimator wave over the last traced pointfunction/S tracing_updateCrossSectXYWv(winN, tracingWaveRef, pointRow, [setRadiusToStoredVal])	String winN	String tracingWaveRef		//ref to Segment storing point	Variable pointRow		//row of point to plot	Variable setRadiusToStoredVal		//170613 added optional pass meant for use with follow function, so pre-set radius of each point is shown.											//not sure of behavior during original tracing 		WAVE/D tracingWv = $tracingWaveRef		if (!WaveExists(tracingWv))		return ""	endif		if (strlen(winN) == 0)		winN = winname(0,1)	endif		String tracedWaveName = tracing_getTracedWvNFromN(tracingWaveRef)		String crossSectionXYRef = tracing_getCrossSectXYWvRef()	String crossSectSizeWvRef = tracing_getCrossSectSizeWvRef()		Make/O/D/N=(1,8) $crossSectionXYRef	WAVE/D tracingCrossSectXYWv = $crossSectionXYRef		if (numtype(pointRow) == 0)		//do nothing for inf nan input		if (pointRow < dimsize(tracingWv,0))			tracingCrossSectXYWv[0][0,6] = tracingWv[pointRow][q]		//xPixel,yPixel,xNearestPixel,yNEarestPixel,zPixel,RadiusPnts,radiusPixels,ccPntNum			tracingCrossSectXYWv[0][7] = tracing_getSelPntData(winN,nan)		//current selection		else			print "tracing_updateCrossSectXYWv() error pointRow",pointRow,"is out of range of tracing wave",tracingWv,"need to fix this relatively new bug. use tracing_makeSegsAbut() for now"		endif			if (!ParamIsDefault(setRadiusToStoredVal) && setRadiusToStoredVal)			WAVE crossSectSizeWv = $crossSectSizeWvRef			Variable lastStoredRadius_pix =  tracingWv[pointRow][6]				Variable lastStoredRadius_currSize = img_pixelsToAbsCircleMrkSize(winN, lastStoredRadius_pix, 0)			crossSectSizeWv[0] = lastStoredRadius_currSize		endif	endif		if (!disp_isWaveOnGraph(winN, crossSectionXYRef))	//	RemoveFromGraph/W=$winN $crossSectionXYRef		AppendtoGraph/W=$winN/T=top/L=left tracingCrossSectXYWv[][1]/TN=$crossSectionXYRef vs tracingCrossSectXYWv[][0]		ModifyGraph/W=$winN mode=4,marker=8				ModifyGraph/W=$winN zmrkSize($crossSectionXYRef)={$crossSectSizeWvRef,0,500,1e-05,500}		ModifyGraph zmrkSize($crossSectionXYRef)={$crossSectSizeWvRef,0,20,1,20}	endif				end//this is stored in userdata (when tracing from image plotted with img_newImage)function/S tracing_getTracedWvNameFromWin()		String topWinN = winname(0,1)		return tracing_getTracedWvNmFromWinN(topWinN)endfunction/S tracing_getTracedWvNmFromWinN(winN)	String winN		if (!strlen(winN))		winN = winname(0,1)	endif		getWindow $winN userdata		return S_valueendfunction/s tracing_getTracedWvNFromIndRef(tracingIndexRef)	STring tracingIndexRef		return stringfromlist(0,tracingindexref,"_ind")end//parses wave name of form blah_c# and returns blahfunction/S tracing_getTracedWvNFromN(tracingWaveRef)	String tracingWaveRef		return stringfromlist(0,tracingwaveref,"_c")		//old (not used)	String tracedWaveName		//wave being traced, looked up from first part of tracingWaveRef	String tempStr = ReplaceString("_c", tracingWaveRef,  " ")	sscanf tempStr, "%s", tracedWaveName		return tracedWaveNameendfunction tracing_updateZWave(tracedWaveName)	String tracedWaveName		WAVE/T/Z tracingIndexWave = $tracing_getTracingIndexWaveRef(tracedWaveName)		if (!WaveExists(tracingIndexWave))		return 0	endif		String zPixelsWvRef = tracing_getZWaveRef(tracedWaveName)			Make/O/T/N=(1,3) $zPixelsWvRef	WAVE/T zPixelsWv = $zPixelsWvRef	zPixelsWv = ""		Variable i,j, foundRow, uniqueSlicesFound = 0, currZPixel	String currWaveName	for (i=0;i<DimSize(tracingIndexWave,0);i+=1)	//for each segment		currWaveName = tracingIndexWave[i][0]		if (!WaveExists($currWaveName))			continue				endif		Duplicate/O $currWaveName, currTracingWv//		Print "currWaveName = " + currWaveName				for (j=0;j<DimSize(currTracingWv,0);j+=1)	//for each point (in each segment)			currZPixel = currTracingWv[j][4]		//	Print "currZPixel = " + num2str(currZPixel)						if (numtype(currZPixel) != 0)		//indicates no point here yet				continue			endif			foundRow =  findStrInTextWaveCol_2D(num2str(currZPixel), zPixelsWvRef, 0)		//does this pixel val already have a row?		//	Print "foundRow = " + num2str(foundRow)			if (foundRow < 0)		//true if not found, no row for this pixel, so make one				Redimension/N=(uniqueSlicesFound+1,-1) zPixelsWv		//avoids having to treat the first row as special				foundRow = uniqueSlicesFound				zPixelsWv[foundRow][0] = num2str(currZPixel)			//stores curr z pixel				zPixelsWv[foundRow][1] = "0"		//will be made one in a moment (stores point num)				zPixelsWv[foundRow][2] = ""		//need to instantiate to increment later				uniqueSlicesFound += 1			endif			zPixelsWv[foundRow][1] = text_increment(zPixelsWv[foundRow][1],1)			zPixelsWv[foundRow][2] += currWaveName + "," + num2str(j) + "," + num2str(i)	+ "," + ";"		//component name, point number, component number		endfor	endforend//tracing_updateZWave()//presently assumes x axis = "top" and y axis = "left"function img_absCircleMrkToPixels(winN, absVal, forYNotForX)	String winN	Double absVal	Variable forYNotForX	//0 for x, 1 for y		String vertAxName = "left"	String horizAxName = "top"			if (strlen(winN) == 0)		winN = winname(0,1)	endif			getWindow $winN, psize		//I used to use psizeDC but the output of that no longer makes any sense to me		if (forYNotForX)		//if true, return for y		Variable absRange_y = V_bottom - V_top		GetAxis/Q/W=$winN $vertAxName		Variable pixelRange_y = abs(V_max - V_min)		Variable pixelsPerAbsUnit_y = pixelRange_y / absRange_y				return absVal*pixelsPerAbsUnit_y	else		Variable absRange_x = V_right - V_left		GetAxis/Q/W=$winN $horizAxName		Variable pixelRange_x = abs(V_max - V_min)		Variable pixelsPerAbsUnit_x = pixelRange_x / absRange_x		return absVal*pixelsPerAbsUnit_x	endif		endfunction img_pixelsToAbsCircleMrkSize(winN, pixelVal, forYNotForX)	String winN	Double pixelVal	Variable forYNotForX	Variable currentMrkSizeToPixFactor = img_absCircleMrkToPixels(winN, 1, 0)		//current number of pixels for a marker size of one (units: pix/markerSize)	Variable absVal = pixelVal / currentMrkSizeToPixFactor //convert to current marker size for last stored pixels. units: pix /(pix/markerSize) = markerSize	return absValendfunction checkWinDims()	getwindow $"", pSizeDC		PRint "top", V_top, "bottom", V_bottom, "left", V_left, "right", V_rightendfunction checkLocalWinDims()	getwindow $"", pSize		PRint "top", V_top, "bottom", V_bottom, "left", V_left, "right", V_rightendfunction tracing_getCurrCrossSectInPix()	Variable forXforY		String crossSectSizeRef = "tracing_currCrossSectSizes"		WAVE crossSectSizeWv = $crossSectSizeRef	//using top window by default with ""	return img_absCircleMrkToPixels("",2*crossSectSizeWv[0], 0)		//goes by x ax scaling. 2 is beacuse size seems to correspond to radius of circleend//must have window selectedfunction tracing_addSeg_oldversion(newOrSegmentNumToOverwrite, SegmentNameStr)	Variable newOrSegmentNumToOverwrite		//-1 for new, or num of Segment to overwrite (numbered 0 to N-1 for N Segments)	String SegmentNameStr		String tracedWaveName = img_getImageName(winname(0,1))		//assumes working with top graph	Print "tracedWaveName",tracedWaveName		//used for displaying tracing results	String/G traceResultsTableN = "currTracingMeasurements"	if (Wintype(traceResultsTableN) == 0)		Edit/K=1/N=$traceResultsTableN		traceResultsTableN = S_name		//in case naming fails		tracing_showOpacitySlider()	else				table_clear(traceResultsTableN)		//remove anything 	endif		Variable numStoredTraceParams = 7		String tracedWaveIndexRef = tracing_getTracingIndexWaveRef(tracedWaveName)		Variable numIndexCols = 3		//160330 increased to 3 from 2 to make room for user to show/hide a given segment		WAVE/T/Z tracedWvIndex = $tracedWaveIndexRef	Variable SegmentRowToMod; String currTracingWaveName	Variable reallyOverwrite = 1, cancelButtonUsed		//user is prompted to set to 0 if NOT overwriting, which will abort	if (!WaveExists(tracedWvIndex))		Make/O/T/N=(1,numIndexCols)  $tracedWaveIndexRef			//160330		WAVE/T/Z tracedWvIndex = $tracedWaveIndexRef		segmentRowToMod = 0	else		//Segments already exist, so check if currently plotting a Segment, if so, save the size of the last point before continuing		prompt reallyOverwrite, "Overwrite seg " + num2str(newOrSegmentNumToOverwrite)		doprompt "Overwrite seg (" + num2str(newOrSegmentNumToOverwrite) + ")? (0 or cancel button to abort)", reallyOverwrite		cancelButtonUsed = V_flag		//generated by do prompt, 0 for ok, 1 for cancel				if ( (reallyOverwrite != 1) || cancelButtonUsed)			Print "Overwrite of segment",newOrSegmentNumToOverwrite,"aborted by user input."			return 0		endif				if (tracing_doPlot(winname(0,1)))		//tracing in progress			tracing_saveCrossSectLastInWv()		endif		Variable numSegments = DimSize(tracedWvIndex,0)			//if -1 or out of range, just make a new Segment		if ( (newOrSegmentNumToOverwrite < 0) || (newOrSegmentNumToOverwrite > numSegments-1) )			Redimension/N=(numSegments+1, numIndexCols) tracedWvIndex			SegmentRowToMod = numSegments		else		//overwrite existing Segment!			SegmentRowToMod = newOrSegmentNumToOverwrite		endif	endif	currTracingWaveName = tracedWaveName + "_c" + num2str(SegmentRowToMod)	Make/O/N=(1,numStoredTraceParams) $currTracingWaveName	WAVE currTracingWv = $currTracingWaveName; currTracingWv = NaN	String/G tracing_currTracingWaveName = currTracingWaveName	tracedWvIndex[SegmentRowToMod][0] = tracing_currTracingWaveName	tracedWvIndex[SegmentRowToMod][1] = SegmentNameStr	tracedWvIndex[SegmentRowToMod][2] = "1"			//default is to show 		tracing_updateZWave(tracedWaveName)	String zPixelsWvRef = tracing_getZWaveRef(tracedWaveName)		Print "new Segment added:" + tracing_currTracingWaveName +". (indexWv=" + tracedWaveIndexRef + ", zDispWv="+zPixelsWvRef+")"	AppendToTable/W=$traceResultsTableN $tracing_currTracingWaveName, $tracedWaveIndexRef		//display on this table the current tracing measuremens and the index wave	ModifyTable/W=$traceResultsTableN width($tracing_currTracingWaveName) = 40, width($tracedWaveIndexRef) = 60end//must have window selectedfunction tracing_addSeg(newOrSegmentNumToOverwrite,overwriteOrInsert,SegmentNameStr)	Variable newOrSegmentNumToOverwrite		//-1 for new, or num of Segment to overwrite (numbered 0 to N-1 for N Segments) or insert BEFORE	Variable overwriteOrInsert				//0 for overwrite, 1 for insert BEFORE the segment at number passed in newOrSegmentNumToOverwrite	String SegmentNameStr		Variable promptForRepeatPntOnFirstPnt = 1		//With the exception of the first segment, new segments should repeat the last point from the last segment		Variable rowRequested = newOrSegmentNumToOverwrite		String winN = winname(0,1)		String tracedWaveName = img_getImageName(winN)		//assumes working with top graph	Print "tracedWaveName",tracedWaveName		//used for displaying tracing results	SVAR/Z traceResultsTableN, allTraceResultsTableN	if (!Svar_exists(traceResultsTableN))		String/G traceResultsTableN = "currTracingMeasurements"	endif	if (!Svar_exists(allTraceResultsTableN))		String/G allTraceResultsTableN = "currSegmentTracingMeasurements"	endif		if (Wintype(traceResultsTableN) == 0)		Edit/K=1/N=$traceResultsTableN		traceResultsTableN = S_name		//in case naming fails		tracing_showOpacitySlider()	else				table_clear(traceResultsTableN)		//remove anything 	endif		Variable numStoredTraceParams = 7		String tracedWaveIndexRef = tracing_getTracingIndexWaveRef(tracedWaveName)		Variable numIndexCols = 3		//160330 increased to 3 from 2 to make room for user to show/hide a given segment		WAVE/T/Z tracedWvIndex = $tracedWaveIndexRef	String currTracingWaveName; variable i; string replacethisString,withThisString, oldName,newName	Variable reallyOverwrite = 1, cancelButtonUsed		//user is prompted to set to 0 if NOT overwriting, which will abort	if (!WaveExists(tracedWvIndex))		Make/O/T/N=(1,numIndexCols)  $tracedWaveIndexRef	/wave =tracedWvIndex		//160330		rowRequested = 0	else		WAVE/T tracedWvIndex = $tracedWaveIndexRef				if (overwriteOrInsert)		//insert if true			if (rowRequested > DimSize(tracedWvIndex,0) -1)			//insert before last				rowRequested = DimSize(tracedWvIndex,0) -1			elseif (rowRequested < 0)										//insert before first				rowRequested = 0						endif						//redimension, shift if necessary			Redimension/N=(DimSize(tracedWvIndex,0)+1,-1) tracedWvIndex			if (rowRequested <  DimSize(tracedWvIndex,0) -1)		//if not the last point anyway				for (i=DimSize(tracedWvIndex,0)-1;i>rowRequested;i-=1)	//shift everything passed insertion point up one row					tracedWvIndex[i][] = tracedWvIndex[i-1][q]					replaceThisString = "_c"+num2str(i-1)					withThisString = "_c"+num2str(i)					oldName = tracedWvIndex[i][0]					newName = replacestring(replaceThisString,tracedWvIndex[i][0],withThisString)					tracedWvIndex[i][0] = newName					SetDimLabel 0,i,$newName,tracedWvIndex					if (WaveExists($oldName))						Duplicate/O $oldname, $newname					endif				endfor			endif								else			//overwrite			if ( (rowRequested > DimSize(tracedWvIndex,0) -1) || (rowRequested < 0) )			//insert after last				rowRequested = DimSize(tracedWvIndex,0)				Redimension/N=(rowRequested+1,-1) tracedwvIndex			else			//check whether user really wants to overwrite row				prompt reallyOverwrite, "Overwrite seg " + num2str(rowRequested)				doprompt "Overwrite seg (" + num2str(rowRequested) + ")? (0 or cancel button to abort)", reallyOverwrite				cancelButtonUsed = V_flag		//generated by do prompt, 0 for ok, 1 for cancel						if ( (reallyOverwrite != 1) || cancelButtonUsed)					Print "Overwrite of segment",rowRequested,"aborted by user input."					return 0				endif												endif		endif				//if not a new tracedWvIndex, save last pnt		if (tracing_doPlot(winN))		//tracing in progress			tracing_saveCrossSectLastInWv()		endif	endif			currTracingWaveName = tracedWaveName + "_c" + num2str(rowRequested)	Make/O/N=(1,numStoredTraceParams) $currTracingWaveName/WAVE=currTracingWv	currTracingWv = NaN	String/G tracing_currTracingWaveName = currTracingWaveName	tracedWvIndex[rowRequested][0] = tracing_currTracingWaveName	tracedWvIndex[rowRequested][1] = SegmentNameStr	tracedWvIndex[rowRequested][2] = "1"			//default is to show 	SetDimLabel 0,rowRequested,$currTracingWaveName,tracedWvIndex		tracing_updateZWave(tracedWaveName)	String zPixelsWvRef = tracing_getZWaveRef(tracedWaveName)		Print "new Segment added:" + tracing_currTracingWaveName +". (indexWv=" + tracedWaveIndexRef + ", zDispWv="+zPixelsWvRef+")"	AppendToTable/W=$traceResultsTableN $tracing_currTracingWaveName, $tracedWaveIndexRef		//display on this table the current tracing measuremens and the index wave	ModifyTable/W=$traceResultsTableN width($tracing_currTracingWaveName) = 40, width($tracedWaveIndexRef) = 60	tracing_showSegTable_ref(tracedWaveName)//,0)	doupdate;		if (promptForRepeatPntOnFirstPnt && (rowRequested > 0) )		Variable automaticallyRepeatLastPnt = 1		String msgStr = "Repeat final point from last segment as first for new segment (recommended)?"		prompt automaticallyRepeatLastPnt, msgStr		doprompt msgStr, automaticallyRepeatLastPnt		if (automaticallyRepeatLastPnt)			tracing_repeatPoint(winN)		endif	endifendfunction/S text_increment(text, V_increment)	String text; Variable V_increment		return num2str(str2num(text) + V_increment)endfunction/S tracing_getTracingIndexWaveRef(tracedwaveName)	String tracedWaveName		return  tracedWaveName + "_ind"endfunction/S tracing_getCrossSectSizeWvRef()		String crossSectSizeWvRef = "tracing_currCrossSectSizes"		Variable defaultCrossSectSize = 3	//absolute units		if (!WaveExists($crossSectSizeWvRef))		Make/O/D/N=1 $crossSectSizeWvRef		WAVE/D temp = $crossSectSizeWvRef		temp[0] = defaultCrossSectSize	endif	return crossSectSizeWvRefendfunction/S tracing_getCrossSectXYWvRef()	String crossSectXYWvRef = "tracing_currCrossSectXYPos"		if (!WaveExists($crossSectXYWvRef))		Make/O/D/N=(1,2) $crossSectXYWvRef		WAVE/D temp = $crossSectXYWvRef		temp = NaN	endif			return crossSectXYWvRefendfunction/S tracing_getZWaveRef(tracedWaveName)	STring tracedWaveName		return tracedWaveName + "_z"endfunction/S tracing_getOverlayWvRef(tracedWaveName)	String tracedWaveName		return tracedWaveName + "_OL"endfunction/S tracing_getOverlayColorsWvRef(tracedWaveName)	String tracedWaveName		return tracedWaveName + "_OLC"endfunction/S tracing_getOverlayMarkerWvRef(tracedWaveName)	String tracedWaveName		return tracedWaveName + "_OLM"endfunction/S tracing_getCombinedSegref(tracedWaveName)	STring tracedWaveName	return tracedWaveName + "_cc"endfunction/s tracing_getCombinedSegRefTableN(combinedSegRef)	string combinedSegRef		String savedName = stringbykey("display_table_name",note($combinedSegRef))		if (strlen(savedName))		return savedName	else		return combinedSegRef + "tab"	endifendfunction tracing_toggleHideSectWv()	String crossSectXYWvRef = tracing_getCrossSectXYWvRef()		disp_toggleTraceHide("", crossSectXYWvRef)		//"" defaults to top graphendfunction tracing_isSectWaveHidden()	String crossSectXYWvRef = tracing_getCrossSectXYWvRef()		return disp_isTraceHidden("", crossSectXYWvRef)	//"" makes top graph defaultendfunction disp_toggleTraceHide(winN, traceN)	String winN, traceN		if (strlen(winN) == 0)		winN = winname(0,1) //top graph default	endif		Variable traceIsHidden = disp_isTraceHidden(winN, traceN)		ModifyGraph/W=$winN hideTrace($traceN) = !traceIsHiddenendfunction tracing_edgeAndImageToColor(edgeImgRef, origImgRef, outRef)	String edgeImgRef, origImgRef, outRef		WAVE origWv = $origImgRef	WAVE edgeWv = $edgeImgRef		Duplicate/O edgeWv, $outRef	WAVE outWv = $outRef		Redimension/N=(DimSize(origWv,0), DimSize(origWv, 1), 3, DimSize(origWv,2)) outWv	outWv[][][0,1][] = edgeWv[p][q][s]	//edge wave to layers 0 and 1 (r and g guns)	outWv[][][2][] = origWv[p][q][s]	//origin wave to layer 2 (blue gun)		//Duplicate/O tiffb, tiffChunks//Redimension/N=(DimSize(tiffb,0), DimSize(tiffb,1), 3, DimSize(tiffb,2)) tiffChunks//tiffChunks[][][0,1][] = tiffb[p][q][s]	//tiffChunks[][][2][] = tiffc[p][q][s]	endfunction disp_isTraceHidden(winN, traceN)	String winN, traceN		if (strlen(winN) == 0)		winN = winname(0,1) //top graph default	endif		return str2num(StringByKey("hideTrace(x)", traceinfo(winN, traceN, 0),"="))end	function img_scroll(s)	STRUCT WMWinHookStruct &s	//if ((s.eventMod & 2^1) != 0)		// Shift	//if ((s.eventMod & 2^3) != 0)		// control down		Variable slowUnit = 1/3		//slow is one frame per scroll. igor7: wheel.dy is 6 not 1	Variable fastUnit = 1		//fast frames per scroll		if ( (s.eventCode != 22) || ((s.eventMod & 2^3) != 0))		//must be scroll WITHOUT control down		return 0	endif		Variable step = s.wheelDy			if  ((s.eventMod & 2^1) != 0)		//shift down, go faster		step *= fastUnit	else		step *= slowUnit	endif		step = floor(step)		//laptop scroll can be 3 or more than 3 if you swipe faster		img_setDisplayedPlane(s.winName, img_getDisplayedPlane(s.winName) + step)endfunction img_checkSliderStatus()	//may have to open an image for this to compile in igor 7. image package option not availableim//	WMAppend3DImageSlider()		//does nothing if already there, creates subfolders etc for images if not there	//either commentize above or go to analysis -> packages -> image processing and load that image processing packageendfunction/S img_getImageName(winN)	String winN		if (!strlen(winN))		winN = winname(0,1)	endif			String dfSav= GetDataFolder(1)		//store current data folder, return to here after executing function	String target_df = "root:Packages:WM3DImageSlider:"+winN	if (DataFolderExists(target_df))		SetdataFolder $target_df			//set to the data folder for this window	else		df_makeFolder(target_df,inf)		//make data folder and set to last subdirectory	endif	 	SVAR/Z imageName		if (!Svar_exists(imageName) || !strlen(imageName) || !WaveExists($imageName))		setDataFolder dfSav		//have to have global view for access to waves?		String allWaves = wavelist("*",";","WIN:"+winN)		String myWave = stringfromlist(0,allwaves)		setdatafolder target_df		String/G imageName = myWave	endif		SetDataFolder dfSav		//returns data folder back to whatever it was	return imageNameendfunction df_makeFolder(df_pathStr, setToLevel)	String df_pathStr		//string of data folder hierarchy	Variable setToLevel	//-1 to return to current position, 0 or higher for each position in df_pathStr		String dfSav= GetDataFolder(1)		//store current data folder, return to here after executing function	Variable i,numLevels = ItemsInList(df_pathStr,":")	String df, dfs = ""	for (i=0;i<numLevels;i+=1)		df = StringFromLisT(i,df_pathStr,":")		if (Stringmatch(df, "root"))		//root folder always exists, go to it if requested			SetDataFolder root:		else		//enter folder, creating it if it does not exist			if (DataFolderExists(df))				SetDataFolder $df			else				NewDataFolder/O/S $df			endif		endif				if (i==setToLevel)			dfSav= GetDataFolder(1)	//store position of data folder for requested level		endif	endfor		if (setToLevel < numLevels)	//change to level other than last level if needed		SetDataFolder dfSav	endif	endfunction img_getDisplayedPlane(winN)	String winN		img_checkSliderStatus()	String dfSav= GetDataFolder(1)	SetDataFolder root:Packages:WM3DImageSlider:$(winN)	NVAR/Z gLayer	if (!NVAR_Exists(gLayer))		Variable/G gLayer = 0	endif	SetDataFolder dfSav		//returns data folder back to whatever it was	return gLayerendfunction img_setDisplayedPlane(winN, layer)	String winN; Variable layer		img_checkSliderStatus()	String dfSav= GetDataFolder(1)	SetDataFolder root:Packages:WM3DImageSlider:$(winN)	NVAR gLayer		gLayer = layer//	String imageName = img_getImageName(winN)//	ModifyImage/w=$winN  $imageName plane=(gLayer)		String images = ImageNameList(winN,";" )	variable i	for (i=0;i<itemsinlist(images);i+=1)		ModifyImage/W=$winN $StringFromList(i,images) plane=(gLayer)		endfor			SetDataFolder dfSav		//returns data folder back to whatever it was		return gLayerend//when enabled, zooms into plot at cursor based on two primary axes, which are assumed to be top for horizontal and left for vertical, maintains aspect ratiofunction img_zoomHook(s)	STRUCT WMWinHookStruct &s	//Print "here"	if ( (s.keycode < 6) || (s.keycode > 252))		//0 is no key, 1 is mouse scroll, and 254 255 is mouse scroll		return 0		//ignore non-keyboard use	endif		return 0		//disabled for now	//	Print "key code. keycode = " + num2str(s.keycode)		Variable zoomInNotOut, resetView	if (s.keyCode == 43)		//+ with shift, determined empirically)		zoomInNotOut = 1	elseif (s.keycode == 95)		zoomInNotOut = 0	elseif (s.keycode == 41)		//shift zero key		resetView = 1	else		return 0	endif		String horizAxName = "top"	String vertAxName = "left"	String winN= s.winName		Variable zoomFoldChange = .25		//if .25, viewing range gets 25% smaller for zoomInNotOut true, or 25% large for zoomInNotOut false	Variable changeRatio = zoomInNotOut ? 1 - zoomFoldChange : 1 + zoomFoldChange	Print "changeRatio",changeRatio		if (resetView)		img_resetView(winN)		return 1	endif		Variable xMousePixel = disp_getMouseLoc(s, horizAxName)		Variable yMousePixel = disp_getMouseLoc(s, vertAxName)		GetAxis/Q/W=$winN $horizAxName	Variable horizCurrStart = V_min	Variable horizCurrEnd = V_max	Variable horizFlipped = V_min > V_max	Variable horizCurrMin = horizFlipped ? horizCurrEnd : horizCurrStart	Variable horizCurrMax = horizFlipped ? horizCurrStart : horizCurrEnd		Variable horizRange = (horizCurrMax - horizCurrMin) * changeRatio	Variable horizNewMin =  (xMousePixel - horizRange/2)	Variable horizNewMax = (xMousePixel + horizRange/2)		GetAxis/Q/W=$winN $vertAxName	Variable vertCurrStart = V_min	Variable vertCurrEnd = V_max	Variable vertFlipped = V_min > V_max	Variable vertCurrMin = vertFlipped ? vertCurrEnd : vertCurrStart	Variable vertCurrMax = vertFlipped ? vertCurrStart : vertCurrEnd		Variable vertRange = (vertCurrMax - vertCurrMin) * changeRatio	Variable vertNewMin =  (xMousePixel - vertRange/2)	Variable vertNewMax = (xMousePixel + vertRange/2)		if (zoomInNotOut)		//if zooming off to side, then zooming can bring out of viewed window, so check not to do that		if (horizNewMin < horizCurrMin)			horizNewMin = horizCurrMin		endif		if (horizNewMax > horizCurrMax)			horizNewMax = horizCurrMax		endif		if (vertNewMin < vertCurrMin)			vertNewMin = vertCurrMin		endif		if (vertNewMax > vertCurrMax)			vertNewMax = vertCurrMax		endif	endif		if (!horizFlipped)		SetAxis/W=$winN top, horizNewMin, horizNewMax	else		SetAxis/W=$winN top, horizNewMax, horizNewMin	endif		if (!vertFlipped)		SetAxis/W=$winN left, vertNewMin, vertNewMax	else		SetAxis/W=$winN left, vertNewMax, vertNewMin	endif		return 1			endfunction 	img_resetView(winN)	String winN		String imgWvRef = img_getImageName(winN)		Variable xMax = DimSize($imgWvRef,0)	Variable yMax = Dimsize($imgWvRef,1)		SetAxis/W=$winN top, 0, xMax	SetAxis/W=$winN left, yMax, 0		//default is flippedendfunction wave_4d_extractLayer(inRef, outRef, layerNum)	String inRef, outRef; Variable layerNum		Variable tempWvGenerated	if (!stringmatch(inRef, outRef))	//safe to do everything "in place", in outRef, since outRef is not the same as inRef		Duplicate/O $inRef, $outRef		//use duplicate instead of make to carry over wave type (e.g. float or integer)		tempWvGenerated = 0		WAVE inWv = $inRef	else			//since outRef IS inRef, need to store the result somewhere else during computation so that outRef is not overwritten		Duplicate/O $inRef, tempWv_literalName, $outRef		tempWvGenerated = 1		WAVE inWv = tempWv	endif	WAVE outWv = $outRef		Redimension/N=(DimSize(inWv,0), DimSize(inWv,1), DimSize(inWv,3)) outWv	outWv[][][] = inWv[p][q][layerNum][r]		if (tempWvGenerated)		KillWaves/Z tempWv_literalName	endifendfunction img_thresholdLayers(origRef, displayedRef, saveWindows, rStartProp, rEndProp, rGamma, gStartProp, gEndProp, gGamma, bStartProp, bEndProp, bGamma)	String origRef, displayedRef		//suggested to keep orig ref untouched, display displayed ref, which is a thresholded (DIRECTLY MODIFIED) version of origRef	Variable saveWindows		//if passed, windows (min, max, scale factor) stored in lastLayerWindows	Variable rStartProp, rEndProp, gStartProp, gEndProp, bStartProp, bEndProp		//threshold levels by proportion for each color	Variable rGamma, gGamma, bGamma		//gamma correction values 		Variable minVal = 0, maxVal = 65535	//this is the case for my waves so far, I think that's for 16 bit unsigned integer maybe? Color RGB might change that	Variable fullRange = maxVal - minVal	//each layer will be scaled to this		if (stringmatch(origRef, displayedRef))		Print "Warning, function img_thresholdLayers() will not allow you to overwrite the original wave as data may be lost"		return 0	endif		Variable k, numLayers = DimSize($origRef, 2)	if (saveWindows)		Make/O/D/N=(numLayers,4) lastLayerWindows	endif	Variable usedMin, usedMax, usedScaleFactor, usedGamma		for (k=0;k<numLayers;k+=1)		Print "starting layer = " + num2stR(k)		if (k==0)			usedGamma = rGamma			img_thresholdLayer(origRef, displayedRef, 0, k, rStartProp, rEndProp, usedGamma, usedMin=usedMin,usedMax=usedMax, usedScaleFactor=usedScaleFactor)		elseif (k==1)			usedGamma = gGamma			img_thresholdLayer(origRef, displayedRef, 1, k,  gStartProp, gEndProp, usedGamma, usedMin=usedMin,usedMax=usedMax, usedScaleFactor=usedScaleFactor)		else	//k==2			usedGamma = bGamma			img_thresholdLayer(origRef, displayedRef, 1, k,  bStartProp, bEndProp, usedGamma, usedMin=usedMin,usedMax=usedMax, usedScaleFactor=usedScaleFactor)		endif		if (saveWindows)			lastLayerWindows[k][0] = usedMin; lastLayerWindows[k][1] = usedMax; lastLayerWindows[k][2] = usedScaleFactor; lastLayerWindows[k][3] = usedGamma; 	//store used values		endif	endfor		if (saveWindows)		Print "layerWindows saved in waveRef = " + nameofwave(lastLayerWindows)	endifendfunction img_applyLayerThresholds(origRef, displayedRef, layerWindowsRef)	String origRef, displayedRef, layerWindowsRef		Variable k, numLayers = DimSize($origRef, 2)	for (k=0;k<numLayers;k+=1)		Print "in img_applyLayerThresholds. starting layer = " + num2str(k)		if (k==0)			img_applyLayerThreshold(origRef, displayedRef, 0, k, layerWindowsRef)		//start afresh from original wave for first layer		else			img_applyLayerThreshold(origRef, displayedRef, 1, k, layerWindowsRef)		//then work with displayed wave to keep progress instead of overwriting it		endif	endforendfunction img_applyLayerThreshold(origRef, displayedRef, useDisplayedRef, layer, layerWindowsRef)	String origRef, displayedRef; Variable layer	Variable useDisplayedRef		String layerWindowsRef	//as generated by img_thresholdLayers()		Variable minVal = 0, maxVal = 65535		WAVE/D layerWindowsWv = $layerWindowsRef	if (!useDisplayedRef)		Duplicate/O $origRef, $displayedRef		//last is a placeholder, better to dup and redimension then to make from scratch bc wavetype will be conserved		WAVE origWv = $origRef; WAVE dispWv = $displayedRef	else		WAVE origWv = $displayedRef; WAVE dispWv = $displayedRef	//assignment statement will be performed in place, preserving displayedRef otherwise	endif		dispWv[][][layer][] = wave_valueThreshold(dispWv[p][q][layer][s], layerWindowsWv[layer][0], layerWindowsWv[layer][1], layerWindowsWv[layer][2], minVal, maxVal, 0, 1, layerWindowsWv[layer][3])	//dispWv[][][layer][] = wave_valueThreshold(dispWv[p][q][layer][s], adjustedLayerMin, layerScaleFactor, minVal, maxVal, 0, 1)endfunction img_thresholdLayer(origRef, displayedRef, useDisplayedRef, layer, firstPixValProp, lastPixValProp, gammaVal, [usedMin, usedMax, usedScaleFactor])	String origRef, displayedRef; Variable layer	Variable firstPixValProp		//proportion for first pixel. e.g. 0.1 will exclude lowest 10% of pixel values. negative values should be ok, e.g. -0.1 will set min to 10% beyond min	Variable lastPixValProp		//e.g. 0.9 will exclude highest 10%. values greater than one should be ok, e.g. 1.1 will set max to 10% ABOVE max value. sizes relative to range 		//firstPix val must be less than lastpixval, both have to be within range of 0 to maxPixelValue	Variable useDisplayedRef		//pass to avoid overwriting work on previous layers, e.g. in a loop through all the layers, first time pass 0 to begin anew, then pass 1	Variable gammaVal			//1 for no correction	Variable &usedMin, &usedMax, &usedScaleFactor		//pass BY REF to save used values	Variable minVal = 0, maxVal = 65535	//this is the case for my waves so far, I think that's for 16 bit unsigned integer maybe? Color RGB might change that	Variable fullRange = maxVal - minVal		//this full range will always be used		if (firstPixValProp > lastPixValProp)		Print "img_thresholdLayer(...) cannot take firstPixValProp > lastPixValProp. no thresholding performed"		return 0	endif		if (stringmatch(origRef, displayedRef))		Print "Warning, function img_thresholdLayers() will not allow you to overwrite the original wave as data may be lost"		return 0	endif	if (!useDisplayedRef)		Duplicate/O $origRef, $displayedRef		//last is a placeholder, better to dup and redimension then to make from scratch bc wavetype will be conserved		WAVE origWv = $origRef; WAVE dispWv = $displayedRef	else		WAVE origWv = $displayedRef; WAVE dispWv = $displayedRef	//assignment statement will be performed in place, preserving displayedRef otherwise	endif		wave_4d_extractLayer(origRef, "layerTemp", layer)	WAVE layerTemp	Variable layerMin = wavemin(layerTemp)	Variable layerMax = wavemax(layerTemp)	Variable layerMean = mean(layerTemp)	Variable layerRange = layerMax - layerMin	Variable adjustedLayerMin = floor(layerMin + layerRange*firstPixValProp)		//keeps these as integers 	//threshold so that 	if (adjustedLayerMin < 0)		adjustedLayerMin = 0	endif	Variable adjustedLayerMax = ceil(layerMin + layerRange*lastPixValProp)	if (adjustedLayerMax > maxVal)		adjustedLayerMax = maxVal	endif	Variable adjustedLayerRange = adjustedLayerMax - adjustedLayerMin		Variable layerScaleFactor = fullRange / adjustedLayerRange		//what value to multiply by to make layerRange = fullRange	dispWv[][][layer][] = wave_valueThreshold(dispWv[p][q][layer][s], adjustedLayerMin, adjustedLayerMax, layerScaleFactor, minVal, maxVal, 0, 1, gammaVal)	//dispWv[][][layer][] = (dispWv[p][q][layer][s] - adjustedLayerMin) * layerScaleFactor	if (!ParamIsDefault(usedMin))		usedMin = adjustedLayerMin	endif	if (!ParamIsDefault(usedMax))		usedMax = adjustedLayerMax	endif	if (!ParamIsDefault(usedScaleFactor))		usedScaleFactor = layerScaleFactor	endif				//offsets values in layer to have lowest at zero, then multiplies by scale factor	Print "layer = " + num2str(layer) + "origMin=" + num2str(layerMin) + ". origMax=" + num2str(layerMax) + ". range=" + num2str(layerRange) + ". mean=" + num2str(layerMean)+ "adjustedLayerMin = " + num2str(adjustedLayerMin) + "adjustedLayerMax = " + num2str(adjustedLayerMax) + "(adjustedLayerRange=" + num2str(adjustedLayerRange) +")"endfunction wave_copyScalesLbls(fromWv,toWv[to_appendLbl,appendLblBeforeNotAfter])	WAVE fromWv,toWv	String to_appendLbl		//optionally append to dimension labels	Variable appendLblBeforeNotAfter		//if appending, append before not after -- defaults to after		//we'll see if just setting higher dims causes errors	setscale/p x,dimoffset(fromWv,0),dimdelta(fromWv,0),waveunits(fromWv,0),toWv	setscale/p y,dimoffset(fromWv,1),dimdelta(fromWv,1),waveunits(fromWv,1),toWv	setscale/p z,dimoffset(fromWv,2),dimdelta(fromWv,2),waveunits(fromWv,2),toWv	setscale/p t,dimoffset(fromWv,3),dimdelta(fromWv,3),waveunits(fromWv,3),toWv		Variable i,dims=4	for (i=0;i<dims;i+=1)		dl_lblsToLbls(nameofwave(fromwv),i,0,inf,nameofwave(toWv),i,0,selectstring(ParamIsDefault(to_appendLbl),to_appendLbl,""),!ParamIsDefault(appendLblBeforeNotAfter) && appendLblBeforeNotAfter)	endforendfunction wave_valueThreshold(origVal, adjustedMin, adjustedMax, scaleFactor, rangeMin, rangeMax, valBelowMin, valAboveMax, gammaVal)	Variable origVal, adjustedMin, adjustedMax, scaleFactor	Variable rangeMin, rangeMax	//cut off thresholds, valBelowMin set for below min, valBelowMax for above	Variable valBelowMin, valAboveMax	Variable gammaVal		Variable result =  (origVal - adjustedMin) * scaleFactor 		if (result < rangeMin)		return valBelowMin	endif	if (result > rangeMax)		return valAboveMax	endif			if (  ((result / (rangeMax - rangeMin))^gammaVal)	> 1)		Print "gamma output greater than 1!"		if ( (result / (rangeMax - rangeMin)) > 1)			Print "gamma input greater than 1!"		endif	endif		//		(input normalized to range)^gamma	--this a value between 0 and 1			// which is multiplied back onto the full range by the right hand side	result = ((result / (rangeMax - rangeMin))^gammaVal)			* (rangeMax - rangeMin)			return resultendfunction img_updateHist(new, autoRange, [newMinPixelVal, newMaxPixelVal, gammaVal])	Variable new		//1 to start a new histogram	Variable autoRange	//range is min pixel to max pixel	Variable newMinPixelVal, newMaxPixelVal, gammaVal		NVAR/Z img_minThreshold, img_maxThreshold	//set below if not existing		if (new)		String/G histImageWinRef = winname(0,1)		String/G histImageRef = img_getImageName(histImageWinRef)			String/G histWinN = histImageRef + "_imgH"		String/G histWvRef = histImageRef + "imgH_win"		String/G gammaWvRef = histImageRef + "imgH_g"	else		SVAR histImageWinRef, histImageRef, histWinN, histWvRef, gammaWvRef		doWindow/F $histImageWinRef;doupdate/W=$histImageWinRef	//bring image win to top, some functions only work with it on top	endif		Variable numBins = 500	//can check that a wave is 16 bin unsigned: wavetype(w) & 0x20, returns >0 for 16 bit;  wavetype(w) & 0x40 returns >0 for unsigned. Max val is then 2^16 = 65536	Variable maxDispVal = 2^16	Variable minDispVal = 0	Variable binWidth = (maxDispVal-minDispVal) / numBins		if (!WaveExists($gammaWvRef) || new)		if (ParamIsDefault(gammaVal))			gammaVal = 1		//linear default		endif		//otherwise gamma val is already passed and defined 		Make/O/D/N=10000 $gammaWvRef		SetScale/P x, 0, 1/10000, $gammaWvRef		WAVE/D gammaWv = $gammaWvRef		gammaWv = x^gammaVal		doWindow/F $histImageWinRef;doupdate/W=$histImageWinRef; ModifyImage/W=$histImageWinRef $histImageRef, lookup=$gammaWvRef	else		if (!ParamIsDefault(gammaVal))		//gamma wave may need update			WAVE/D gammaWv = $gammaWvRef			gammaWv = x^gammaVal			Print "new gamma = " +num2str(gammaVal)		endif	endif		doWindow/F $histImageWinRef;doupdate/W=$histImageWinRef; 	//	if (new)		Variable isFrom3ColorWave = img_getDisplayedRegion("imgTempForHist", winN=histImageWinRef)	//	endif	Variable currMinPixelVal, currMaxPixelVal		if(NVAR_Exists(img_minThreshold) && !new)		img_minThreshold = ParamIsDefault(newMinPixelVal) ? img_minThreshold : newMinPixelVal	else		Variable/G img_minThreshold = ParamIsDefault(newMinPixelVal) ?  wavemin($"imgTempForHist") : newMinPixelVal	endif		if(NVAR_Exists(img_maxThreshold) && !new)		img_maxThreshold = ParamIsDefault(newMaxPixelVal) ?  img_maxThreshold : newMaxPixelVal	else		Variable/G img_maxThreshold = ParamIsDefault(newMaxPixelVal) ? wavemax($"imgTempForHist")  : newMaxPixelVal	endif			if (autoRange)		currMinPixelVal =  wavemin($"imgTempForHist")		currMaxPixelVal =  wavemax($"imgTempForHist") 	endif	Print "img thresholds",img_minThreshold,img_maxThreshold	doWindow/F $histImageWinRef;doupdate/W=$histImageWinRef; ModifyImage/W=$histImageWinRef $histImageRef, ctab= {img_minThreshold,img_maxThreshold,Grays,0}		Variable pixelIntensityRange = img_maxThreshold - img_minThreshold			Make/O/D/N=1 $histWvRef	histogram/B={minDispVal, binWidth, numBins} $"imgTempForHist", $histWvRef		WAVE histWv = $histWvRef	Variable histMax = wavemax(histWv)	histWv /= histMax		if (wintype(histWinN) == 0)		Display/K=1/N=$histWinN $histWvRef		histWinN = S_name				SetWindow $histWinN, hook(updateImgByHistHook)  = 	img_histAdj_winHook		AppendtoGraph/W=$histWinN/L=L_gamma $gammaWvRef		ModifyGraph/W=$histWinN freepos=0, lblpos=52		ModifyGraph/W=$histWinN tick(L_gamma)=3,noLabel(L_gamma)=2, freePos(L_gamma)=500				//fill gamma wave to bottom		ModifyGraph/W=$histWinN mode($gammaWvRef)=7,usePlusRGB($gammaWvRef)=1,hbFill($gammaWvRef)=6		ModifyGraph/W=$histWinN useNegPat($gammaWvRef)=1,plusRGB($gammaWvRef)=(16384,65280,16384)		ReorderTraces/W=$histWinN  $histWvRef,{$gammaWvRef}		//put histogam ahead so it can be seen above fill			Label/W=$histWinN bottom "Pixel value\\U (Histogram)\r\\Z08\\f01SHIFT\\f00: Set lower threshold, \\f01CTRL+SHIFT\\f00: Set upper threshold (by horizontal mouse position)\r\\f01CTRL\\f00 alone=Set gamma (by vertical mouse position)"	endif	ModifyGraph/W=$histWinN offset($gammaWvRef)={img_minThreshold,0}, muloffset($gammaWvRef)={pixelIntensityRange,0}	doWindow/F $histImageWinRef;doupdate/W=$histImageWinRef; endfunction img_histAdj_winHook(s)	STRUCT WMWinHookStruct &s	if (s.eventCode != 3)	//mouse not down		return 0	endif		//alt down	//now have normal mouse events only		if ( ((s.eventMod & 2^2) != 0))		//alt not allowed		return 0	endif		Variable mouseAxisLoc 	if (  ((s.eventMod & 2^3) != 0)	&& ((s.eventMod & 2^1) == 0) )	//cntl down without shift		mouseAxisLoc = disp_getMouseLoc(s, "L_gamma")	//between 0 and 1		img_updateHist(0,0,gammaVal=mouseAxisLoc/0.5)		return 0	endif		mouseAxisLoc = disp_getMouseLoc(s, "bottom")		if ((s.eventMod & 2^1) != 0)		//shift key, adjust left hist region		if ((s.eventMod & 2^3) == 0)		//ctrl down WITHOUT shift key -- set lower range			img_updateHist(0,0,newMinPixelVal=mouseAxisLoc)			return 0		else				img_updateHist(0,0,newMaxPixelVal=mouseAxisLoc)			return 0		endif	endif		//	img_updateHist(0,0,newMinPixelVal=mouseAxisLoc)	endfunction img_getDisplayedRegion(outRef, [winN])	String outRef, winN		if (ParamIsDefault(winN))		winN = winname(0,1)	else		doWindow/F $winN; doupdate/W=$winN	endif		String imgName = img_getImageName(winN)	Variable zPlaneNum = img_getDisplayedPlane(winN)		Variable xFlipped=0, yFlipped=0, xMin, xMax, yMin, yMax	GetAxis/W=$winN top	if (V_max < V_min)		xFlipped = 1		xMin = V_max; xMax = V_min	else		xMin = V_min; xMax = V_max	endif	GetAxis/W=$winN left	if (V_max < V_min)		xFlipped = 1		yMin = V_max; yMax = V_min	else		yMin = V_min; yMax = V_max	endif			Variable isFrom3ColorWave		if (DimSize($imgName,3) > 1)	//then 4D wave with layers as colors		Duplicate/O/R=[xMin, xMax][yMin,yMax][][zPlaneNum] $imgName, $outRef		isFrom3ColorWave = 1	else		//3D wave with layers as different z planes		if (dimsize($imgName,2) == 0)		//2D image, no layers			Duplicate/O/R=[xMin, xMax][yMin,yMax] $imgName,$outRef		else			Duplicate/O/R=[xMin, xMax][yMin,yMax][zPlaneNum] $imgName, $outRef		endif		isFrom3ColorWave = 0	endif		return isFrom3ColorWaveendfunction img_redisplayView()	String/G redisplayImgName = "img_redisplayRef"		//holds redisplay wave that is actually displayed	String/G redisplayImgOrigName = "img_redisplayRef_orig"	//holds redisplay wave original, basis for modifications, untouched but used for calculations	img_getDisplayedRegion(redisplayImgName)	Duplicate/O $redisplayImgName, $redisplayImgOrigName		NewImage/K=1/N=$redisplayImgName $redisplayImgName	String/G redisplayImgWinName = S_nameend//this version of tracing_calcParams requires tracing window to be top window (other than command line window) at time of use//this started out exactly like the standard tracing_calcParams but has been modified to allow pipette inputs//and there's not the same support for naming/renaming and saving to streamfunction tracing_calcParams_P(winSizeIs1XNot2X,z,dispResultsTable,somaPip_ccPnt,pedPip_ccPnt_fromEnd,hasOS,forceBaseName)	Double winSizeIs1XNot2X		//0 for 2x, 1 for 1x, 2 for one 510 value, otherwise enter the value, if near an integer number be wary of rounding	Variable dispResultsTable	Variable somaPip_ccPnt		//pnts from start at which soma pipette was placed e.g. 0 for on inner segment end	Variable pedPip_ccPnt_fromEnd		//pnts from end at which ped pipette was placed e.g. 0 for on terminal end	Variable hasOS					//pass if has an OS segment, in which case a placeholder is not added	String forceBaseName		//see tracing_calcParams_explicit2 parameter of same name	Double z// = 2.2315431//0.4//0.4503956//0.3980472// nan		//had been a passed parameter: optionally pass z step depth to set other than 1, pass nan to avoid			String streamTags = ""	String nameBase	= ""		//for saving to analysis stream. should be cell name. Only used if calcVersion = 1	String oldNameToReplaceWithNameBase = ""		//if image had a generic name like "main", pass that generic name to have it replaced by nameBase			Variable savetostream = 0			String nameBaseSaveAppendStr = "_img"		String tracedWaveName = tracing_getTracedWvNameFromWin()	String tracingIndexRef = tracing_getTracingIndexWaveRef(tracedWaveName)	String combinedSegsRef = tracing_getCombinedSegref(tracedWaveName)		if (strlen(nameBase) < 1)		nameBase = tracedWaveName	endif		String linearParamsRef		Variable micronsPerPixel	String paramsRef = tracing_calcParams_explicit2(tracingIndexRef, winSizeIs1XNot2X,z,nan,nan,forceBaseName,out_micronsPerPixel=micronsPerPixel)	String img_loadPath = stringbykey("img_loadPath",note($tracedWaveName)); note/nocr $paramsRef, "img_ref:"+tracedWaveName+";img_loadPath:"+img_loadPath+";"		//make a linear version of the params ref; this will be different lengths for different cells if number of compartments differ	linearParamsRef = paramsRef + "_L"	WAVE paramsWv = $paramsRef	Variable numParams = dimsize(paramsWv,0)	Variable numSegs = dimsize(paramsWv,1)	Variable linearParamNum = numParams * numSegs	Make/O/D/N=(linearParamNum) $linearParamsRef/wave=linearParamsWv	Variable i	Variable segStartIndex	String segLbl	for (i=0;i<numSegs;i+=1)		segLbl = GetDimLabel(paramsWv, 1, i) + "_"		segStartIndex = i*numParams		linearParamsWv[segStartIndex,segStartIndex+numParams-1] = paramsWv [p-segStartIndex][i] 		dl_lblsToLbls(paramsRef,0,0,nan,linearParamsRef,0,segStartIndex,segLbl,1)	endfor		//make a version with added OS position	String linearParams_pOSRef = linearParamsRef+"_pOS"	Variable linearParamNum_pOS = hasOS ? linearParamNum : (linearParamNum+numParams)	Make/O/D/N=(linearParamNum_pOS) $linearParams_pOSRef/wave=linearParamsWv_pOS	Variable actSegNum		if (hasOS)			for (i=0;i<numSegs;i+=1)			segStartIndex = i*numParams			actSegNum = i			segLbl = GetDimLabel(paramsWv, 1, i) + "_"			linearParamsWv_pOS[segStartIndex,segStartIndex+numParams-1] = paramsWv [p-segStartIndex][i] 			dl_lblsToLbls(paramsRef,0,0,nan,linearParams_pOSRef,0,segStartIndex,segLbl,1)			endfor				else					for (i=0;i<(numSegs+1);i+=1)			segStartIndex = i*numParams			if (i==0)				actSegNum = i				segLbl = GetDimLabel(paramsWv, 1, actSegNum) + "_"			elseif (i==1)				segLbl = "os-s0_"				linearParamsWv_pOS[segStartIndex,segStartIndex+numParams-1] = nan				dl_lblsToLbls(paramsRef,0,0,nan,linearParams_pOSRef,0,segStartIndex,segLbl,1)					continue								else //i>1				actSegNum = i-1				segLbl = GetDimLabel(paramsWv, 1, actSegNum) + "_"				segLbl = segLbl[0,strlen(segLbl)-3]+num2str(actSegNum)+"_"			endif						linearParamsWv_pOS[segStartIndex,segStartIndex+numParams-1] = paramsWv [p-segStartIndex][actSegNum] 			dl_lblsToLbls(paramsRef,0,0,nan,linearParams_pOSRef,0,segStartIndex,segLbl,1)				endfor					endif		//store pipette positions	redimension/N=(linearParamNum+2) linearParamsWv	dl_assignAndLbl(linearParamsWv, linearParamNum, somaPip_ccPnt, "somaPip_ccPnt")	dl_assignAndLbl(linearParamsWv, linearParamNum+1, pedPip_ccPnt_fromEnd, "pedPip_ccPnt_fromEnd")		redimension/N=(linearParamNum_pOS+2) linearParamsWv_pOS	dl_assignAndLbl(linearParamsWv_pOS, linearParamNum_pOS, somaPip_ccPnt, "somaPip_ccPnt")	dl_assignAndLbl(linearParamsWv_pOS, linearParamNum_pOS+1, pedPip_ccPnt_fromEnd, "pedPip_ccPnt_fromEnd")		//calculate params for total wave, with and without portions beyond pipettes lobbed off	if (numtype(somaPip_ccPnt))		//make sure these are zero not nan		somaPip_ccPnt=0	endif	if (numtype(pedPip_ccPnt_fromEnd))		pedPip_ccPnt_fromEnd=0	endif		String paramsRef_cc = tracing_calcParams_explicit2(tracingIndexRef, winSizeIs1XNot2X,z,somaPip_ccPnt,pedPip_ccPnt_fromEnd,forceBaseName)	img_loadPath = stringbykey("img_loadPath",note($tracedWaveName)); note/nocr $paramsRef_cc, "img_ref:"+tracedWaveName+";img_loadPath:"+img_loadPath+";"		//make a linear version of the params ref; this will be different lengths for different cells if number of compartments differ	String linearParamsRef_cc = paramsRef_cc + "_Lc"	WAVE paramsWv_cc = $paramsRef_cc	numParams = dimsize(paramsWv_cc,0)	numSegs = dimsize(paramsWv_cc,1)	linearParamNum = numParams * numSegs	Make/O/D/N=(linearParamNum) $linearparamsRef_cc/wave=linearparamsWv_cc	for (i=0;i<numSegs;i+=1)		segLbl = GetDimLabel(paramsWv_cc, 1, i) + "_"		segStartIndex = i*numParams		linearparamsWv_cc[segStartIndex,segStartIndex+numParams-1] = paramsWv_cc [p-segStartIndex][i] 		dl_lblsToLbls(paramsRef_cc,0,0,nan,linearparamsRef_cc,0,segStartIndex,segLbl,1)	endfor			concatenate/DL/NP=0 {$linearParamsRef_cc}, $linearParamsRef		//append combined params to linearized segment params	concatenate/DL/NP=0 {$linearParamsRef_cc}, $linearParams_pOSRef		//append combined params to linearized segment params		//transpose these for easy copying as one row (not one column)	redimension/n=(-1,1) $linearParamsRef,$linearParams_pOSRef	SetDimLabel 1,0,$namebase,$linearParamsRef,$linearParams_pOSRef 	String linearParamsRef_T = linearParamsRef+"_T"	Duplicate/O $linearParamsRef, $linearParamsRef_T	MatrixTranspose $linearParamsRef_T	String linearParams_pOSRef_T = linearParams_pOSRef+"_T"	Duplicate/O $linearParams_pOSRef, $linearParams_pOSRef_T	MatrixTranspose $linearParams_pOSRef_T		if (dispResultsTable)		edit/k=1 $paramsRef.ld,$linearParamsRef.ld,$linearParams_pOSRef.ld,$linearParamsRef_cc.ld		edit/k=1 $linearParamsRef_T.ld		edit/k=1 $paramsRef_cc.ld		edit/k=1 $linearParams_pOSRef_T.ld	endif		String xdOutRef=nameBase+"_xd",segInfoRef=nameBase+"_segInfo"	tracing_getDistStats(combinedSegsRef,micronsPerPixel,tracingIndexRef,xdOutRef,segInfoRef)			Print "tracedWaveName",tracedWaveName,"tracingIndexRef",tracingIndexRef,"xdOutRef",xdOutRef,"segInfoRef",segInfoRef,"paramsRef",paramsRef,"linearParamsRef",linearParamsRef,"linearParamsRef_T",(tracingIndexRef+"_T"),"linearParams_pOSRef",linearParams_pOSRef,"linearParams_pOSRef_T",(linearParams_pOSRef+"_T")	Print "paramsRef_cc",paramsRef_cc	String noteStr = "tracing_nameBase:"+nameBase+";tracing_winSizeIs1XNot2X:"+num2str(winSizeIs1XNot2X)+";tracing_img_loadPath:"+img_loadPath+";tracing_expName:"+igorinfo(1)+";xdOutRef:"+xdOutRef+";segInfoRef:"+segInfoRef+";"	note/nocr $paramsRef,noteStr	note/nocr $linearParamsRef,noteStr	note/nocr $linearParams_pOSRef,noteStr	note/nocr $linearParamsRef_cc,noteStr	note/nocr $linearParamsRef_T,noteStr	note/nocr $linearParams_pOSRef_T,noteStr		save/c/o/p=home $linearParams_pOSRef_T	putscraptext linearParams_pOSRef_Tendfunction tracing_getDistStats(combinedSegsRef,micronsPerPixel,tracingIndexRef,outref_xd,outRef_segInfo)	String combinedSegsRef,tracingIndexRef,outref_xd,outRef_segInfo; Double micronsPerPixel	print "micronsPerPixel",micronsPerPixel	VAriable numSegs = dimsize($tracingIndexRef,0)	//calculate dist,diam 	wave ccWc = $combinedSegsRef	duplicate/o ccWc,$outref_xd/wave=xd	String segInfoLbls="segStartP;segEndP;segLenP;segStart_um;segEnd_um;segLen_um;"	Variable numSegPArams=itemsinlist(segInfoLbls)	make/o/d/n=(numSegs,numSegPArams) $outref_seginfo/wave=segInfo	dl_assignLblsFromList(segInfo,1,0,segInfoLbls,"",0)	setdimlabel 1,1,segName,$tracingIndexRef	String segNames = wave_colList($tracingIndexRef,"segName","segName,*",0,"",1)	dl_assignLblsFromList(segInfo,0,0,segNames,"",0)		Variable startCol=dimsize(xd,1),rows=dimsize(xd,0),l=startCol-1,i	Variable newPars=11	Redimension/n=(-1,startCol+newPars) xd	l+=1;setdimlabel 1,l,xMicronLoc,xd;xd[][%xMicronLoc]=xd[p][%xPixLoc]*micronsPerPixel	l+=1;setdimlabel 1,l,yMicronLoc,xd;xd[][%yMicronLoc]=xd[p][%yPixLoc]*micronsPerPixel	l+=1;setdimlabel 1,l,zMicronLoc,xd;xd[][%zMicronLoc]=xd[p][%zPixLoc]		l+=1;setdimlabel 1,l,deltaDist_um,xd	//distance traversed between points	xd[0][%deltaDist_um]=0	xd[1,][%deltaDist_um]=sqrt(     ((xd[p][%xMicronLoc] - xd[p-1][%xMicronLoc])^2) + ((xd[p][%yMicronLoc] - xd[p-1][%yMicronLoc])^2) + ((xd[p][%zMicronLoc] - xd[p-1][%zMicronLoc])^2)     )	//xd[1,][%deltaDist_um]=sqrt( ( (micronsPerPixel*(xd[p][%xPixLoc]-xd[p-1][%xPixLoc]))^2 ) + ( (micronsPerPixel*(xd[p][%yPixLoc]-xd[p-1][%yPixLoc]))^2 ) + ( (micronsPerPixel*(xd[p][%zPixLoc]-xd[p-1][%zPixLoc]))^ 2) )//xd[p][%deltaDist]*micronsPerPixel	// (ccWv[p][xInd]-ccWv[p-1][xInd])^2 + (ccWv[p][yInd]-ccWv[p-1][yInd])^2 + (ccWv[p][zInd]-ccWv[p-1][zInd])^2 ) 		l+=1;setdimlabel 1,l,dist_um,xd;	//total distance up to the start of this point	xd[0][%dist_um]=0	xd[1,][%dist_um]=xd[p-1][%dist_um]+xd[p][%deltaDist_um]		//first point has a delta dist of zero		l+=1;setdimlabel 1,l,radius_um,xd	xd[][%radius_um]=xd[p][%radiusPix]*micronsPerPixel		l+=1;setdimlabel 1,l,diam_um,xd	xd[][%diam_um]=xd[p][%radius_um]*2		//segStartP;segEndP;segLenP;segStart_um;segEnd_um;segLen_um;"	segInfo=nan	segInfo[0][%segStartP]=0	segInfo[0][%segStart_um]=0		//find the start of each seg, then label all 	l+=1;setdimlabel 1,l,firstRowInSeg,xd	l+=1;setdimlabel 1,l,lastRowInSeg,xd	Variable currSegNum=xd[0][%segNum],currFirstRow=0,segCount=0,lastPntInLastSeg		//segCount should always equal segNum but just in case of weirdness, will count separately too	Variable pastLastPnt,iterEnd=rows+1		//need to go one extra round to deal with end of last segment	for (i=0;i<iterEnd;i+=1)		pastLastPnt = i==rows		if (pastLastPnt || (xd[i][%segNum] != currSegNum)	)	//latter is for after last row			lastPntInLastSeg=i-1	//i is in the next segment				//finish info for last seg			segInfo[segCount][%segEndP]=lastPntInLastSeg			segInfo[segCount][%segLenP]=lastPntInLastSeg-segInfo[segCount][%segStartP]+1			segInfo[segCount][%segEnd_um]=xd[pastLastPnt ? (i-1) : i][%dist_um]		//bit of an ambiguity whether to use last pnt or current -- in truth shouldnt matter if points are appropriately matched at ends			segInfo[segCount][%segLen_um]=segInfo[segCount][%segEnd_um]-segInfo[segCount][%segStart_um]			if (currFirstRow <= lastPntInLastSeg)	//if there is at least one cell to fill with last seg (pretty much always should be)				xd[currFirstRow,lastPntInLastSeg][%lastRowInSeg] = i - 1			endif			if (pastLastPnt)				break			endif				//fill info for next seg			currSegNum=xd[i][%segNum]			currFirstRow=i			segCount+=1			segInfo[segCount][%segStartP]=i			segInfo[segCount][%segStart_um]=xd[i][%dist_um]		endif		xd[i][%firstRowInSeg]=currFirstRow	endfor			l+=1;setdimlabel 1,l,distInSeg_um,xd	xd[][%distInSeg_um]=xd[p][%dist_um]-xd[xd[p][%firstRowInSeg]][%dist_um]		l+=1;setdimlabel 1,l,distRelSeg,xd	xd[][%distRelSeg]=xd[p][%distInSeg_um] / xd[xd[p][%lastRowInSeg]][%distInSeg_um]endfunction tracing_alignNrn(xNrnWv,xdWv,segInfoWv,imageDistXRef)		WAVE xNrnWv	//output from vxt_run in vxt_run.hoc, has sectionNums and sectionPositions (x) as columns, nodes as points	WAVE xdWv,segInfoWv	//outputs from tracing_getDistStats, usually called by tracing_calcparams_p after tracing in Igor	String imageDistXRef	//output of distances .. rows = nodes + 1 for rules of image x waves, last point is final point distance (just beyond last node)	Variable i,nodes=dimsize(xNrnWv,0)	String params = "dist_um;interpDiam_um;",param	Variable numParams=itemsinlist(params),col	for (i=0;i<numParams;i+=1)		param=stringfromlist(i,params)		if (finddimlabel(xNrnWv,1,param)<0)			col=dimsize(xNrnwv,1)			redimension/n=(-1,col+1) xNrnWv			setdimlabel 1,col,$param,xNrnWv					endif	endfor		//need some single-column waves for interp	duplicate/o/free/r=[][finddimlabel(xdWv,1,"dist_um")] xdwv,distWv;redimension/n=(-1) distWv	duplicate/o/free/r=[][finddimlabel(xdWv,1,"diam_um")] xdwv,diamWv;redimension/n=(-1) diamWv			Double xPosInSeg,segStart_um,segLen_um,dist_um	Variable segNum	for (i=0;i<nodes;i+=1)		segNum=xNrNwv[i][%sectionNums]		xPosInSeg=xNrNwv[i][%sectionPositions]		segLen_um=segInfoWv[segNum][%segLen_um]			segStart_um=segInfoWv[segNum][%segStart_um]		dist_um=segStart_um+xPosInSeg*segLen_um				xNrNWv[i][%dist_um]=dist_um		xNrnWv[i][%interpDiam_um]=interp(dist_um,distWv,diamWv)				setdimlabel 0,i,$getdimlabel(segInfoWv,0,segNum),xNrnWv	endfor		duplicate/o/r=[][finddimlabel(xNrNwv,1,"dist_um")] xNrnWv,$imageDistXRef/wave=xvals	xvals[0]=0		//even though first node is usually at non zero because they are spaced throughout the segment, it looks better to plot from zero	redimension/n=(nodes+1) xvals		xvals[nodes]=distWv[dimsize(distWv,0)-1]end//OLD VERSION USE tracing_calcParams_P now//this version of tracing_calcParams requires tracing window to be top window (other than command line window) at time of usefunction tracing_calcParams(winSizeIs1XNot2X, nameBase, oldNameToReplaceWithNameBase, dispResultsTable,streamTags[z])	Double winSizeIs1XNot2X		//0 for 2x, 1 for 1x,	String nameBase			//for saving to analysis stream. should be cell name. Only used if calcVersion = 1	String oldNameToReplaceWithNameBase		//if image had a generic name like "main", pass that generic name to have it replaced by nameBase	Variable dispResultsTable	String streamTags	Double z		//optionally pass z step depth to set other than 1		Variable savetostream = 0		Variable calcVersion =1	//old or new format for params, new format (calcVersion = 1) is saved to an analysis stream		String nameBaseSaveAppendStr = "_img"		String tracedWaveName = tracing_getTracedWvNameFromWin()	String tracingIndexRef = tracing_getTracingIndexWaveRef(tracedWaveName)	String combinedSegsRef = tracing_getCombinedSegref(tracedWaveName)		if (strlen(nameBase) < 1)		nameBase = tracedWaveName	endif		String linearParamsRef		if (calcVersion)		nameBase = nameBase + nameBaseSaveAppendStr		String paramsRef = tracing_calcParams_explicit2(tracingIndexRef, winSizeIs1XNot2X,!ParamIsDEfault(z) ? z : nan,nan,nan,"")		String img_loadPath = stringbykey("img_loadPath",note($tracedWaveName))		note/nocr $paramsRef, "img_ref:"+tracedWaveName+";img_loadPath:"+img_loadPath+";"				//make a linear version of the params ref; this will be different lengths for different cells if number of compartments differ		linearParamsRef = nameBase + "_L"		WAVE paramsWv = $paramsRef		Variable numParams = dimsize(paramsWv,0)		Variable numSegs = dimsize(paramsWv,1)		Make/O/D/N=(numParams*numSegs) $linearParamsRef/wave=linearParamsWv		Variable i		Variable segStartIndex		String segLbl		for (i=0;i<numSegs;i+=1)			segLbl = GetDimLabel(paramsWv, 1, i) + "_"			segStartIndex = i*numParams			linearParamsWv[segStartIndex,segStartIndex+numParams-1] = paramsWv [p-segStartIndex][i] 			dl_lblsToLbls(paramsRef,0,0,nan,linearParamsRef,0,segStartIndex,segLbl,1)		endfor				String linearParamsRef_T = linearParamsRef+"_T"		Duplicate/O $linearParamsRef, $linearParamsRef_T		MatrixTranspose $linearParamsRef_T				//make a version with added OS position		String linearParams_pOSRef = linearParamsRef+"_pOS"		Make/O/D/N=(numParams*(numSegs+1)) $(linearParams_pOSRef)/wave=linearParamsWv_pOS		Variable actSegNum		for (i=0;i<(numSegs+1);i+=1)			segStartIndex = i*numParams			actSegNum = i			if (i==1)				//i == 0, insert OS				segLbl = "os-s-1_"				linearParamsWv_pOS[segStartIndex,segStartIndex+numParams-1] = nan				dl_lblsToLbls(paramsRef,0,0,nan,linearParams_pOSRef,0,segStartIndex,segLbl,1)					continue						elseif (i>1)				actSegNum = i-1			endif						segLbl = GetDimLabel(paramsWv, 1, actSegNum) + "_"			linearParamsWv_pOS[segStartIndex,segStartIndex+numParams-1] = paramsWv [p-segStartIndex][actSegNum] 			dl_lblsToLbls(paramsRef,0,0,nan,linearParams_pOSRef,0,segStartIndex,segLbl,1)			endfor					String linearParams_pOSRef_T = linearParams_pOSRef+"_T"		Duplicate/O $linearParams_pOSRef, $linearParams_pOSRef_T		MatrixTranspose $linearParams_pOSRef_T 				WAVE linearTransposeWv = $linearParamsRef_T, linearTransposePOSWv = $linearParams_pOSRef_T				//prepare for saving to analysis stream		String paramsNote = note($paramsRef)		String streamStr = "trace"		String segmentList = replacestring(",",stringbykey("segmentList",paramsNote),";")		String listOfRefsToSaveInPath = tracedWaveName+";"+tracingIndexRef+";"+paramsRef+";"+segmentList+";"+combinedSegsRef+";"		if (strlen(oldNameToReplaceWithNameBase))			String oldList = listOfRefsToSaveInPath			listOfRefsToSaveInPath = wave_dupWithStrReplacedName(oldList, oldNameToReplaceWithNameBase, nameBase)			String oldParamsNote = paramsNote			paramsNote = replacestring(oldNameToReplaceWithNameBase,oldParamsNote,nameBase)			Print "params note updated for new wave names. next lines are old then new"			Print "oldParamsNote",oldParamsNote			print "newparamsNote",paramsNote		endif				if (savetostream)			fio_stream_saveToStream(streamStr,nameBase,paramsNote,streamTags,"",0,listOfRefsToSaveInPath, 0)		endif				if (dispResultsTable)			edit/k=1 $paramsRef.ld,$linearParamsRef.ld,$linearParams_pOSRef.ld			edit/k=1 linearTransposeWv.ld			edit/k=1 linearTransposePOSWv.ld		endif				Print "tracedWaveName",tracedWaveName,"tracingIndexRef",tracingIndexRef,"paramsRef",paramsRef,"linearParamsRef",linearParamsRef,"linearParamsRef_T",(tracingIndexRef+"_T"),"linearParams_pOSRef",linearParams_pOSRef,"linearParams_pOSRef_T",(linearParams_pOSRef+"_T")	else		tracing_calcParams_explicit(tracingIndexRef, winSizeIs1XNot2X)	endifendfunction tracing_showSegTable(dispWinN,[winN])	String dispWinN, winN		String tracedWaveName	if (!paramisDefault(winn))		tracedWaveName = tracing_getTracedWvNmFromWinN(winN)	else		tracedWaveName = tracing_getTracedWvNameFromWin()		//use top win	endif		tracing_showSegTable_ref(tracedWaveName)//0)	return 0endstatic constant k_doCcStats=1		//change this to zero if computation is slowing tracing updates//tracing function that concatenates segment params into combined params//relies on the accuracy of tracing_numParamColsfunction tracing_showSegTable_ref(tracedWaveRef)	String tracedWaveRef	String tracingIndexRef = tracing_getTracingIndexWaveRef(tracedWaveRef)	Variable tracing_numParamCols = 23	Variable segRefCol = 0			String combinedSegRef = tracing_getCombinedSegref(tracedWaveRef)		WAVE/T/Z tracingIndexWv = $tracingIndexRef		if (!WaveExists(tracingIndexWv))		return 0	endif		tracing_updateCombinedSegRef(tracedWaveRef)		String dispWinN = tracing_getCombinedSegRefTableN(combinedSegRef)	if (wintype(dispWinN) == 0)		table_clear(dispWinN)		edit/k=1/N=$dispWinN		dispWinN = S_name		AppendToTable/W=$dispWinN $combinedSegRef.ld		endif	note/nocr $combinedSegRef,"display_table_name:"+dispWinN+";"	//might only be necessary when window first created		//calculate some additional stats that are helpful for display	Variable numCcPnts=dimsize($combinedSegRef,0)	if (k_doCcStats && (numCcPnts>1))		WAVE ccWv=$combinedSegRef		Variable origCcCols=dimsize(ccWv,1)		//depends on original segment wave layout		Variable newCols = 3		Variable distDeltaInd = origCcCols		//distDelta is euclidian distance since last point		Variable distInd=origCcCols + 1			//dist is total euclidian distance since first point		redimension/n=(-1,origCcCols+newCols) ccWv		setdimlabel 1,distDeltaInd,deltaDist,ccWv			setdimlabel 1,	distInd,totalDist,ccWv		Variable xInd = finddimlabel(ccWv,1,"xPixLoc")		Variable yInd = finddimlabel(ccWv,1,"yPixLoc")		Variable zInd = finddimlabel(ccWv,1,"zPixLoc")				ccWv[0][distDeltaInd]=0;ccWv[0][distInd]=0;		ccWv[1,][distDeltaInd]=sqrt( (ccWv[p][xInd]-ccWv[p-1][xInd])^2 + (ccWv[p][yInd]-ccWv[p-1][yInd])^2 + (ccWv[p][zInd]-ccWv[p-1][zInd])^2 )		ccWv[1,][distInd]=ccWv[p][distDeltaInd]+ccWv[p-1][distInd]			Variable segNumInd = origCcCols + 2		setdimlabel 1,	segNumInd,segNum,ccWv		ccWv[][segNumInd]=str2num(replacestring("c",stringfromlist(1,getdimlabel(ccWv,0,p),"_"),""))	endif//	Modifytable/W=$dispWinN topleftcell  = (dimsize($combinedSegRef,0)-5,0)endfunction/S tracing_updateCombinedSegRef(tracedWaveRef)	String tracedWaveRef	String tracingIndexRef = tracing_getTracingIndexWaveRef(tracedWaveRef)	Variable tracing_numParamCols = 23	Variable segRefCol = 0			String combinedSegRef = tracing_getCombinedSegref(tracedWaveRef)		WAVE/T/Z tracingIndexWv = $tracingIndexRef		if (!WaveExists(tracingIndexWv))		return ""	endif		Variable i,segLen; string segList = "", segRef	for (i=0;i<dimsize(tracingIndexWv,0);i+=1)		segRef = tracingIndexWv[i][segrefCol]		if (WaveExists($segref))			segLen = dimsize($segref,0)				//currently have an error that is causing wrong indexing here, so just going to always redo for now			//if (!strlen(GetDimLabel($segRef, 0, 0)) || !strlen(GetDimLabel($segRef, 0, segLen-1)))		//incomplete row dim labels, assign..this check could be more extensive				dl_lblByInd(segRef,0,segRef+"_",1)			//endif						if (!strlen(GetDimLabel($segRef, 1, 0)))		//no column dim labels, assign				tracing_setSegColumnsLbls(segref)			endif					segList += tracingIndexWv[i][segrefCol] + ";"		endif	endfor	concatenate/O/NP=0/DL segList, $combinedSegRef	setscale/p x,0,1,"",$combinedSegRef	return combinedSegRefendfunction tracing_setSegColumnsLbls(segref)	String segRef		if (!waveexists($segRef))		return 0	endif		SetDimLabel 1,0,xPixLoc,$segRef	SetDimLabel 1,1,yPixLoc,$segRef	SetDimLabel 1,2,xPixNearest,$segRef	SetDimLabel 1,3,yPixNearest,$segRef	SetDimLabel 1,4,zPixLoc,$segRef	SetDimLabel 1,5,radiusPnts,$segRef	SetDimLabel 1,6,radiusPix,$segRefend//two output waves: segment params and total params (all segments)//for each param: numpnts, displacement x, y, z, total; dist x,y,z, total; radius mean, min, max//REPLACED BY tracing_calcParams_explicit2function tracing_calcParams_explicit(tracingIndexRef, winSizeIs1XNot2X)	String tracingIndexRef	Double winSizeIs1XNot2X				Double micronsPerPixel_2X = 100/1050	Double micronsPerPixel_1x = 100/510	Double micronsPerPixel_lsm510_40x = 0.1124711	Double micronsPerZStep = 1		Double micronsPerPixel_used	switch (winSizeIs1XNot2X)		case 0:			micronsPerPixel_used = micronsPerPixel_2x			break		case 1:			micronsPerPixel_used = micronsPerPixel_1X			break		case 2:			micronsPerPixel_used = micronsPerPixel_lsm510_40x			break		default:			micronsPerPixel_used = micronsPerPixel_used			break	endswitch		Print "micronsPerPixel_used", micronsPerPixel_used		//micronsPerPixel_used = winSizeIs1XNot2X ? micronsPerPixel_1x : micronsPerPixel_2X		Variable numParams = 12		//actual numParams is doubled to account for results in pixel units as well as in microns		WAVE/T tracingIndex = $tracingIndexRef		String segmentParamsOutRef = tracing_getTracedWvNFromIndRef(tracingIndexRef) + "_pS"		//params for segments	String totalParamsOutRef = tracing_getTracedWvNFromIndRef(tracingIndexRef) + "_pT"	//params for total		Print "storing results in ", segmentParamsOutRef, totalParamsOutRef, ". Use header:", tracing_getParamsHeader() 	Print "To display copy: Edit/K=1 ", tracing_getParamsHeader(), ", ", totalParamsOutRef, ", ", segmentParamsOutRef		Variable i, numSegs = DimSize(tracingIndex,0)		Make/D/O/N=(numSegs, numParams*2) $segmentParamsOutRef; WAVE/D segParamsOut = $segmentParamsOutRef	Make/D/O/N=(numParams*2) $totalParamsOutRef; WAVE/D totalParamsOut = $totalParamsOutRef		totalParamsOut = 0		//instantiate so that each segment result can be added during loop	String currSegRef	Variable x_dist_pix, x_disp_pix, y_dist_pix, y_disp_pix, z_dist_pix, z_disp_pix	Variable r_mean_pix, r_stdev_pix, r_min_pix, r_max_pix	Variable total_disp_pix, total_dist_pix	Variable x_dist_micron, x_disp_micron, y_dist_micron, y_disp_micron, z_dist_micron, z_disp_micron	Variable r_mean_micron, r_stdev_micron, r_min_micron, r_max_micron	Variable total_disp_micron, total_dist_micron	for (i=0;i<numSegs;i+=1)		currSegRef = tracingIndex[i][0]		if (DimSize($currSegRef,0) < 2)	//sometimes segs might be empty or have only one point									//e.g. if they were started but not filled (such as when deleted)			continue			//skipping these as they contribute no length		endif				Duplicate/O/R=[][0] $currSegRef, currVals_x_pix, currVals_x_micron			//for x (this segment)		Duplicate/O/R=[][1] $currSegRef, currVals_y_pix, currVals_y_micron			Duplicate/O/R=[][4] $currSegRef, currVals_z_pix, currVals_z_micron		Duplicate/O/R=[][6] $currSegRef, currVals_rad_pix, currVals_rad_micron			//for radius				currVals_x_micron = currVals_x_pix * micronsPerPixel_used		currVals_y_micron = currVals_y_pix * micronsPerPixel_used		currVals_z_micron = currVals_z_pix * micronsPerZStep		currVals_rad_micron = currVals_rad_pix * micronsPerPixel_used				//calculations for pixel units		x_disp_pix = wavemax(currVals_x_pix) - wavemin(currVals_x_pix)		x_dist_pix = wave_getTotalDist_1D("currVals_x_pix")		y_disp_pix = wavemax(currVals_y_pix) - wavemin(currVals_y_pix)		y_dist_pix = wave_getTotalDist_1D("currVals_y_pix")			z_disp_pix = wavemax(currVals_z_pix) - wavemin(currVals_z_pix)		z_dist_pix = wave_getTotalDist_1D("currVals_z_pix")				total_disp_pix = sqrt(x_disp_pix^2 + y_disp_pix^2 + z_disp_pix^2)		//for this segment		total_dist_pix = wave_getTotalDist_3D("currVals_x_pix","currVals_y_pix","currVals_z_pix")				Wavestats/Q currVals_rad_pix		r_mean_pix = V_avg		r_stdev_pix = V_sdev		r_min_pix = V_min		r_max_pix = V_max				//calculation for micron units		x_disp_micron = wavemax(currVals_x_micron) - wavemin(currVals_x_micron)		x_dist_micron = wave_getTotalDist_1D("currVals_x_micron")		y_disp_micron = wavemax(currVals_y_micron) - wavemin(currVals_y_micron)		y_dist_micron = wave_getTotalDist_1D("currVals_y_micron")			z_disp_micron = wavemax(currVals_z_micron) - wavemin(currVals_z_micron)		z_dist_micron = wave_getTotalDist_1D("currVals_z_micron")				total_disp_micron = sqrt(x_disp_micron^2 + y_disp_micron^2 + z_disp_micron^2)		//for this segment		total_dist_micron = wave_getTotalDist_3D("currVals_x_micron","currVals_y_micron","currVals_z_micron")				Wavestats/Q currVals_rad_micron		r_mean_micron = V_avg		r_stdev_micron = V_sdev		r_min_micron = V_min		r_max_micron = V_max				//store results (pixels)		segParamsOut[i][0] = x_dist_pix		segParamsOut[i][1] = x_disp_pix		segParamsOut[i][2] = y_dist_pix		segParamsOut[i][3] = y_disp_pix		segParamsOut[i][4] = z_dist_pix		segParamsOut[i][5] = z_disp_pix		segParamsOut[i][6] = total_disp_pix		segParamsOut[i][7] = total_dist_pix		segParamsOut[i][8] = r_mean_pix	//for this segment		segParamsOut[i][9] = r_stdev_pix		segParamsOut[i][10] = r_min_pix		segParamsOut[i][11] = r_max_pix				//store results (microns)				segParamsOut[i][numParams+0] = x_dist_micron		segParamsOut[i][numParams+1] = x_disp_micron		segParamsOut[i][numParams+2] = y_dist_micron		segParamsOut[i][numParams+3] = y_disp_micron		segParamsOut[i][numParams+4] = z_dist_micron		segParamsOut[i][numParams+5] = z_disp_micron		segParamsOut[i][numParams+6] = total_disp_micron		segParamsOut[i][numParams+7] = total_dist_micron		segParamsOut[i][numParams+8] = r_mean_micron	//for this segment		segParamsOut[i][numParams+9] = r_stdev_micron		segParamsOut[i][numParams+10] = r_min_micron		segParamsOut[i][numParams+11] = r_max_micron								totalParamsOut += segParamsOut[i][p]	//add this to total sum				endforend//two output waves: segment params and total params (all segments)//for each param: numpnts, displacement x, y, z, total; dist x,y,z, total; radius mean, min, max function/S tracing_calcParams_explicit2(tracingIndexRef, winSizeIs1XNot2X,zStepDepth,somaPip_ccPnt,pedPip_ccPnt_fromEnd,forceBaseName,[out_micronsPerPixel])	String tracingIndexRef	Double winSizeIs1XNot2X		//0 for 2x, 1 for 1x, 2 for one 510 value, otherwise enter the value, if near an integer number be wary of rounding	Double zStepDepth		//pass NaN to use default of 1	String forceBaseName	//blank to autogenerate (usual, but this is helpful for long tracing wave names)		//pass NaN for these if what is wanted is segment parameters; if somaPip_ccPnt is a real number this will 	//calculate the parameters for the combined param only	Variable somaPip_ccPnt		//pnts from start at which soma pipette was placed e.g. 0 for on inner segment end	Variable pedPip_ccPnt_fromEnd		//pnts from end at which ped pipette was placed e.g. 0 for on terminal end	Variable &out_micronsPerPixel		//optionally pass to return micronsPerPixel_used here	//	Variable micronsPerPixel_2x_numer = 100		//more accurate for saving than the resultant fraction//	Variable micronsPerPixel_2x_denom = 1050//	Variable micronsPerPixel_2X = micronsPerPixel_2x_numer/micronsPerPixel_2x_denom//	Variable micronsPerPixel_1x_numer = 100//	Variable micronsPerPixel_1x_denom = 510//	Variable micronsPerPixel_1x = micronsPerPixel_1x_numer/micronsPerPixel_1x_denom//	Variable micronsPerPixel_used = winSizeIs1XNot2X ? micronsPerPixel_1x : micronsPerPixel_2X		Double micronsPerPixel_2X = 100/1050	Double micronsPerPixel_1x = 100/510	Double micronsPerPixel_lsm510_40x = 0.1124711	Double micronsPerZStep = numtype(zStepDepth) ? 1 : zStepDepth		Double micronsPerPixel_used	if (winSizeIs1XNot2X==0)		micronsPerPixel_used = micronsPerPixel_2x	elseif (winSizeIs1XNot2X==1)		micronsPerPixel_used = micronsPerPixel_1X	elseif (winSizeIs1XNot2X==2)		micronsPerPixel_used = micronsPerPixel_lsm510_40x	else		micronsPerPixel_used = winSizeIs1XNot2X		endif		Print "micronsPerPixel_used", micronsPerPixel_used,"micronsPerZStep",micronsPerZStep		if (!Paramisdefault(out_micronsPerPixel))		out_micronsPerPixel = micronsPerPixel_used	endif		Variable calcSegParams = numtype(somaPip_ccPnt) != 0			Variable numParams = 12		//actual numParams is doubled to account for results in pixel units as well as in microns		WAVE/T tracingIndex = $tracingIndexRef	String tracedWaveRef = tracing_getTracedWvNFromIndRef(tracingIndexRef)	String combinedSegsRef = tracing_getCombinedSegref(tracedWaveRef)	String paramsOutRef	String baseName 	if (strlen(forceBaseName) > 0)		baseName = forceBaseName	else		baseName =tracedWaveRef	endif	Variable i,c,numSegs,numSegsInCalc=0,outNumCols	if (calcSegParams)		paramsOutRef = baseName + "_pTr"	//params for tracing		numSegs = DimSize(tracingIndex,0)		outNumCols = numSegs+1	else		paramsOutRef = baseName + "_pcTr"	//params combined for tracing			numSegs = 2		outNumCols = numSegs	endif		Print "storing results in paramsOutRef", paramsOutRef		Make/D/O/N=(numParams*2,outNumCols) $paramsOutRef; WAVE/D paramsWv = $paramsOutRef		//one column for totals, then one column for each segment	paramsWv = 0	//instantiate so that each segment result can be added during loop		String currSegRef, segNameStr	Variable x_dist_pix, x_disp_pix, y_dist_pix, y_disp_pix, z_dist_pix, z_disp_pix	Variable r_mean_pix, r_stdev_pix, r_min_pix, r_max_pix	Variable total_disp_pix, total_dist_pix	Variable x_dist_micron, x_disp_micron, y_dist_micron, y_disp_micron, z_dist_micron, z_disp_micron	Variable r_mean_micron, r_stdev_micron, r_min_micron, r_max_micron	Variable total_disp_micron, total_dist_micron	Variable segAnalysisStartP,segAnalysisEndP		SetDimLabel 1,0,paramTotals,paramsWv 	//label totals column	String segList = ""		for (i=0;i<numSegs;i+=1)		if (calcSegParams)			currSegRef = tracingIndex[i][0]; segList += currSegRef + ";"			segNameStr = tracingIndex[i][1]						c = i + 1		//c = paramWv column num. first column reserved for totals			segAnalysisStartP = 0			segAnalysisEndP = dimsize($currSegRef,0) - 1		//include up and including last point		else			currSegRef = combinedSegsRef; segList += currSegRef + ";"						c = i		//c = paramWv column num			if (i==0)		//first do the entire thing				segNameStr = "total_"				segAnalysisStartP = 0				segAnalysisEndP = dimsize($currSegRef,0) - 1		//include up and including last point							else			//then do just between pipettes				segNameStr = "inPips_"				segAnalysisStartP = somaPip_ccPnt				segAnalysisEndP = dimsize($currSegRef,0) - 1 - pedPip_ccPnt_fromEnd 			endif		endif				if (DimSize($currSegRef,0) < 2)	//sometimes segs might be empty or have only one point									//e.g. if they were started but not filled (such as when deleted)			continue			//skipping these as they contribute no length		endif		numSegsInCalc += 1		if (calcSegParams)			SetDimLabel 1,c,$(segNameStr+"-s"+num2str(i)),paramsWv		//label segment column 		else			SetDimLabel 1,c,$segNameStr,paramsWv		//label segment column 		endif				Duplicate/O/R=[segAnalysisStartP,segAnalysisEndP][0] $currSegRef, currVals_x_pix, currVals_x_micron	//xPixLoc			//for x (this segment)		Duplicate/O/R=[segAnalysisStartP,segAnalysisEndP][1] $currSegRef, currVals_y_pix, currVals_y_micron	//yPixLoc		Duplicate/O/R=[segAnalysisStartP,segAnalysisEndP][4] $currSegRef, currVals_z_pix, currVals_z_micron	//zPixLoc		Duplicate/O/R=[segAnalysisStartP,segAnalysisEndP][6] $currSegRef, currVals_rad_pix, currVals_rad_micron	//radiusPix			//for radius				currVals_x_micron = currVals_x_pix * micronsPerPixel_used		currVals_y_micron = currVals_y_pix * micronsPerPixel_used		currVals_z_micron = currVals_z_pix * micronsPerZStep		currVals_rad_micron = currVals_rad_pix * micronsPerPixel_used				//calculations for pixel units		x_disp_pix = wavemax(currVals_x_pix) - wavemin(currVals_x_pix)		x_dist_pix = wave_getTotalDist_1D("currVals_x_pix")		y_disp_pix = wavemax(currVals_y_pix) - wavemin(currVals_y_pix)		y_dist_pix = wave_getTotalDist_1D("currVals_y_pix")			z_disp_pix = wavemax(currVals_z_pix) - wavemin(currVals_z_pix)		z_dist_pix = wave_getTotalDist_1D("currVals_z_pix")				total_disp_pix = sqrt(x_disp_pix^2 + y_disp_pix^2 + z_disp_pix^2)		//for this segment		total_dist_pix = wave_getTotalDist_3D("currVals_x_pix","currVals_y_pix","currVals_z_pix")				Wavestats/Q currVals_rad_pix		r_mean_pix = V_avg		r_stdev_pix = V_sdev		r_min_pix = V_min		r_max_pix = V_max				//calculation for micron units		x_disp_micron = wavemax(currVals_x_micron) - wavemin(currVals_x_micron)		x_dist_micron = wave_getTotalDist_1D("currVals_x_micron")		y_disp_micron = wavemax(currVals_y_micron) - wavemin(currVals_y_micron)		y_dist_micron = wave_getTotalDist_1D("currVals_y_micron")			z_disp_micron = wavemax(currVals_z_micron) - wavemin(currVals_z_micron)		z_dist_micron = wave_getTotalDist_1D("currVals_z_micron")				total_disp_micron = sqrt(x_disp_micron^2 + y_disp_micron^2 + z_disp_micron^2)		//for this segment		total_dist_micron = wave_getTotalDist_3D("currVals_x_micron","currVals_y_micron","currVals_z_micron")				Wavestats/Q currVals_rad_micron		r_mean_micron = V_avg		r_stdev_micron = V_sdev		r_min_micron = V_min		r_max_micron = V_max				//store results (pixels)		paramsWv[0][c] = x_dist_pix		paramsWv[1][c] = x_disp_pix		paramsWv[2][c] = y_dist_pix		paramsWv[3][c] = y_disp_pix		paramsWv[4][c] = z_dist_pix		paramsWv[5][c] = z_disp_pix		paramsWv[6][c] = total_disp_pix		paramsWv[7][c] = total_dist_pix		paramsWv[8][c] = r_mean_pix	//for this segment		paramsWv[9][c] = r_stdev_pix		paramsWv[10][c] = r_min_pix		paramsWv[11][c] = r_max_pix				//store results (microns)				paramsWv[numParams+0][c] = x_dist_micron		paramsWv[numParams+1][c] = x_disp_micron		paramsWv[numParams+2][c] = y_dist_micron		paramsWv[numParams+3][c] = y_disp_micron		paramsWv[numParams+4][c] = z_dist_micron		paramsWv[numParams+5][c] = z_disp_micron		paramsWv[numParams+6][c] = total_disp_micron		paramsWv[numParams+7][c] = total_dist_micron		paramsWv[numParams+8][c] = r_mean_micron	//for this segment		paramsWv[numParams+9][c] = r_stdev_micron		paramsWv[numParams+10][c] = r_min_micron		paramsWv[numParams+11][c] = r_max_micron				if (i==0)		//during one iteration label rows		//store results (pixels)		SetDimLabel 0,0,x_dist_pix,paramsWv		SetDimLabel 0,1,x_disp_pix,paramsWv		SetDimLabel 0,2,y_dist_pix,paramsWv		SetDimLabel 0,3,y_disp_pix,paramsWv		SetDimLabel 0,4,z_dist_pix,paramsWv		SetDimLabel 0,5,z_disp_pix,paramsWv		SetDimLabel 0,6,total_disp_pix,paramsWv		SetDimLabel 0,7,total_dist_pix,paramsWv		SetDimLabel 0,8,r_mean_pix,paramsWv	//for this segment		SetDimLabel 0,9,r_stdev_pix,paramsWv		SetDimLabel 0,10,r_min_pix,paramsWv		SetDimLabel 0,11,r_max_pix,paramsWv				//store results (microns)				SetDimLabel 0,numParams+0,x_dist_micron,paramsWv		SetDimLabel 0,numParams+1,x_disp_micron,paramsWv		SetDimLabel 0,numParams+2,y_dist_micron,paramsWv		SetDimLabel 0,numParams+3,y_disp_micron,paramsWv		SetDimLabel 0,numParams+4,z_dist_micron,paramsWv		SetDimLabel 0,numParams+5,z_disp_micron,paramsWv		SetDimLabel 0,numParams+6,total_disp_micron,paramsWv		SetDimLabel 0,numParams+7,total_dist_micron,paramsWv		SetDimLabel 0,numParams+8,r_mean_micron,paramsWv	//for this segment		SetDimLabel 0,numParams+9,r_stdev_micron,paramsWv		SetDimLabel 0,numParams+10,r_min_micron,paramsWv		SetDimLabel 0,numParams+11,r_max_micron,paramsWv				endif								if (calcSegParams)			paramsWv[][0] += paramsWv[p][c]	//add this to total sum			endif	endfor		note/nocr paramsWv, "indexRef:"+tracingIndexRef+";winSizeIs1XNot2X:"+num2str(winSizeIs1XNot2X)+";segmentList:"+Replacestring(";",segList,",")+";"	note/nocr paramsWv, "micronsPerPixel_used:"+num2str(micronsPerPixel_used)+";"	note/nocr paramsWv, "micronsPerZStep:"+num2str(micronsPerZStep)+";numSegs:"+num2str(numSegs)+";numSegsInCalc:"+num2str(numSegsInCalc)+";"	note/nocr paramsWv, "tracedWaveRef:"+tracedWaveRef+";combinedSegRef:"+tracing_getCombinedSegref(tracedWaveRef)+";"	note/nocr paramswv, "baseName:"+baseName+";forceBaseName:"+forcebaseName+";"		return paramsOutRefendfunction img_edgeDetection3D(imgWv,outRef,thresholdMethod)	WAVE/D imgWv; String outRef;variable thresholdMethod //see imageThreshold..1,2,4,5 are valid		Variable ro=dimsize(imgWv,0),co=dimsize(imgWv,1)		MAke/O/D/N=(ro,co) edgetemp	Duplicate/O imgWv, $outREf/wave=out		Variable i	for (i=0;i<dimsize(imgWv,2);i+=1)		edgetemp = imgWv[p][q][i]		ImageEdgeDetection/M=(thresholdMethod) Kirsch edgetemp		if (i==0)			WAVE/D M_imageEdges		endif		out[][][i] = M_imageEdges[p][q][0]		endfor		killwaves/Z M_imageEdges,edgetemp 	endfunction/S tracing_getParamsHeader()	String paramsRef = "tracing_paramsHeader"		Variable numParams = 12	//only counting first half, in pixel units. Actual amount is double to include radius units		Make/O/T/N=(numParams*2) $paramsRef	WAVE/T temp = $paramsRef		temp[0] = "x_dist"	temp[1] = "x_disp"	temp[2] = "y_dist"	temp[3] = "y_disp"	temp[4] = "z_dist"	temp[5] = "z_disp"	temp[6] = "total_disp"	temp[7] = "total_dist"	temp[8] = "r_mean"	temp[9] = "r_stdev"	temp[10] = "r_min"	temp[11] = "r_max"		temp[0,numParams] = temp[p] + "_pix"	temp[numParams,] = temp[p-numParams] + "_micron"		return paramsRefendfunction wave_getTotalDist_1D(ref)	String ref		WAVE temp = $ref		Variable i, total=0	for (i=1;i<DimSize(temp,0);i+=1)		total += abs(temp[i] - temp[i-1])	endfor		return total	endfunction wave_getTotalDist_3D(ref0,ref1,ref2,[endRow,xyzInds,sumByPntOutRef])	String ref0, ref1, ref2	//refs to (1D) waves with x,y,z and z point locations, one row for each point, rows matched between xyz waves	Variable endRow	//optionally pass an end row	Wave xyzInds		//optionally pass xyz ind wave and then only ref0 is used at x=ref0[xyzInds[0]],y=ref0[xyzInds[1]],z=ref0[xyzInds[2]]	STring sumByPntOutRef		WAVE temp0 = $ref0	Variable i,rows=DimSize(temp0,0),storeSum=0	Double totalDist=0,currDist	if (!paramIsDefault(sumByPntOutRef) && (strlen(sumByPntOutRef)>0))		make/o/d/n=(rows) $sumByPntOutRef/wave=out		out[0]=0		storeSum=1	endif	if (ParamIsDefault(endRow))		endRow=rows	endif		if (PAramIsDefault(xyzInds))		WAVE temp1 = $ref1; WAVE temp2=$ref2		for (i=1;i<rows;i+=1)			if (i>endRow)				break			endif			currDist=sqrt(     ((temp0[i] - temp0[i-1])^2) + ((temp1[i] - temp1[i-1])^2) + ((temp2[i] - temp2[i-1])^2)     )			totalDist += currDist			if (storeSum)				out[i]=totalDist			endif					endfor	else		Variable xCol=xyzInds[0],yCol=xyzInds[1],zCol=xyzInds[2]		for (i=1;i<rows;i+=1)			if (i>endRow)				break			endif			currDist=sqrt(     ((temp0[i] - temp0[i-1])^2) + ((temp1[i] - temp1[i-1])^2) + ((temp2[i] - temp2[i-1])^2)     )			totalDist += currDist			if (storeSum)				out[i]=totalDist			endif			endfor	endif		return totalDist	endfunction/S win_getUserdata([winN, winSelector])	String winN;Variable  winSelector		//latter only matters if winN is NOT passed; used by winname to select top window		if (ParamIsDefault(winSelector))		winSelector = 1		//graphs by default	endif			if (ParamIsDefault(winN))		winN = winname(0, winSelector)	endif		getwindow $winN, userdata		return S_valueend//does not support userdata subfieldsfunction/S win_setUserdata(userdata, addNotOverwrite, [winN, winSelector])	String userdata; Variable addNotOverwrite		//pass 1 to add to pre-existing userdata rather than overwrite	String winN;Variable  winSelector		//latter only matters if winN is NOT passed; used by winname to select top window		if (ParamIsDefault(winSelector))		winSelector = 1		//graphs by default	endif			if (ParamIsDefault(winN))		winN = winname(0, winSelector)	endif		if (addNotOverWrite)		setwindow $winN, userdata	+= userdata	else		setwindow $winN, userdata	= userdata	endifend//negative values for float, positive values for integerfunction wave_getBitDepth(ref)	String ref	//	Variable isComplex = WaveType($ref) & 2^0	Variable waveTypeVal = WaveType($ref)		Variable i 	for (i=1;i<8;i+=1)		if (i==6)		//checks for unsigned, skip			i=7		//jump to 7		endif		if (waveTypeVal & 2^i)		//stop where bit is set			break		endif	endfor		switch (i)		//switch based on what bit is set to		case 1:			return -32		//float 32		case 2: 			return -64		//double (float 64)		case 3:			return 8			//8 bit integer		case 4:			return 16		case 5:			return 32		case 7: 			return 64	endswitch	end//returns non zer for complex wavefunction wave_isComplex(ref)	String ref		return (WaveType($ref) & 2^0) > 0end//returns non-zero if a wave is unsigned (range is zero to 2^numbits - 1)function wave_isUnsigned(ref)	String ref		return (WaveType($ref) & 2^6) > 0endfunction fit_getDimFlashFit_xyData(inRef, outCoefRef, outFitRef, len_out_x, xsampling_out)	String inRef, outCoefRef, outFitRef	Variable len_out_x, xsampling_out		//specify a new sampling rate for outFitRef so it can be in 1D wave format		//initial guesses, may need modification	Make/O/D coefWave = {0.25,0.03,.08,1,0}		WAVE in = $inRef		Duplicate/O/R=[][0] in, xVals; Redimension/N=(-1) xVals	Duplicate/O/R=[][1] in, yVals; Redimension/N=(-1) yVals		if (strlen(outCoefRef) > 0)		note/NOCR coefWave, "fitToWave:"+inRef+";"		Duplicate/O coefWave, $outCoefRef	endif	if (strlen(outfitRef) > 0)		Make/O/D/N=(len_out_x/xsampling_out)  $outFitRef		WAVE fit = $outFitRef		SetScale/P x, 0, xsampling_out, "s", fit						fit = fit_angueyraDimFlash(coefwave, x)		String noteStr		wfprintf noteStr, "%f", coefwave		Note fit, "coefs:"+noteStr+";"	endifend//as in fit_getDimFlashFit but no range specificationfunction fit_getDimFlashFit_all(inRef, outCoefRef, outFitRef)	String inRef, outCoefRef, outFitRef	Double fitStartX, fitEndX		//initial guesses, may need modification	Make/O/D coefWave = {4.5e-14,0.018,.05,.3,0}  //{1.5e-12,0.04,.08,.5,0}//	{0.25,0.03,.08,1,0}	//coef wave w: {a,r_tau, f_tau, osc_tau, phi}		WAVE in = $inRef		funcfit fit_angueyraDimFlash, coefWave, in		if (strlen(outCoefRef) > 0)		note/NOCR coefWave, "fitToWave:"+inRef+";"		Duplicate/O coefWave, $outCoefRef	endif	if (strlen(outfitRef) > 0)		Duplicate/O/R=(fitStartX, fitEndX) in, $outFitRef/WAVE=fit					fit = fit_angueyraDimFlash(coefwave, x)		String noteStr		wfprintf noteStr, "%f", coefwave		Note fit, "coefs:"+noteStr+";"	endif		Print "fit_getDimFlashFit() coefs {a,r_tau, f_tau, osc_tau, phi}:", coefWaveendfunction fit_getDimFlashFit(inRef, coefRef, outFitRef,fitStartX, fitEndX)	String inRef, coefRef, outFitRef	Double fitStartX, fitEndX		//initial guesses, may need modification	WAVE/D/Z coefWave = $coefRef		//check if initial guesses input in coefref	if (!waveexists(coefWave) || numtype(sum(coefwave)) )		Make/O/D $coefref/wave=coefwave		coefwave =  {1.5e-12,0.04,.08,.5,0}//	{0.25,0.03,.08,1,0}	//coef wave w: {a,r_tau, f_tau, osc_tau, phi}	endif		WAVE in = $inRef	Variable/G x0 = fitStartX		//needed for fit function	funcfit/Q fit_angueyraDimFlash, coefWave, in(fitStartX, fitEndX)		if (strlen(coefRef) > 0)		note/NOCR/k coefWave, "fitToWave:"+inRef+";"	endif	if (strlen(outfitRef) > 0)		Duplicate/O/R=(fitStartX, fitEndX) in, $outFitRef/WAVE=fit					fit = fit_angueyraDimFlash(coefwave, x)		String noteStr		wfprintf noteStr, "%f", coefwave		Note fit, "coefs:"+noteStr+";"	endif		Print "fit_getDimFlashFit() coefs {a,r_tau, f_tau, osc_tau, phi}:", coefWaveendfunction fit_getConeDimFlashFit_g(wv,baseSubStartX,baseSubEndX,startX,endX,ampGuess,riseTauGuess,fallTauGuess,oscTauGuess,phiGuess,userGuidedFit,outCoefsRef,outFitRef,appendToGraphStr,[expTitle])	WAVE wv	String  outCoefsRef, outFitRef,appendToGraphStr	Double baseSubStartX,baseSubEndX,startX, endX	Double ampGuess,riseTauGuess,fallTauGuess,oscTauGuess,phiGuess	//good guesses {0.25,0.03,.08,1,0}	//coef wave w: {a,r_tau, f_tau, osc_tau, phi}	Variable userGuidedFit		//pass to have the user assist in setting up initial guesses -- 	String expTitle				//optionally pass a title for the window so user knows what's going on. good when wv is a free wave	Make/O/D $outCoefsRef/wave=coefwave	coefwave =  {ampGuess,riseTauGuess,fallTauGuess,oscTauGuess,phiGuess}//	{0.25,0.03,.08,1,0}	//coef wave w: {a,r_tau, f_tau, osc_tau, phi}		Double baselineVal=mean(wv,baseSubStartX,baseSubEndX)	Duplicate/o/d/r=(startx,endx) wv,fit_getConeDimFlashFit_g_temp,fit_getConeDimFlashFit_ftemp;fit_getConeDimFlashFit_g_temp-=baselineVal	String dispName=nameofwave(wv)			Variable/G x0 = startX		//needed for fit function		if (userGuidedFit)		fit_getUserFit_main(coefwave,fit_getConeDimFlashFit_g_temp,x0,startx,endx,"fit_angueyraDimFlash",dispName)	else		Variable V_FitError		FuncFit/NTHR=0/W=2/N=1/Q=1 fit_angueyraDimFlash, coefwave,fit_getConeDimFlashFit_g_temp(startX,endX)		if (V_FitError > 0)			Print "fit_getConeDimFlashFit_g() fit had error V_FitError=",V_fitError,"seeking user guidance (starts from original guesses)"			coefwave =  {ampGuess,riseTauGuess,fallTauGuess,oscTauGuess,phiGuess}			fit_getUserFit_main(coefwave,fit_getConeDimFlashFit_g_temp,x0,startx,endx,"fit_angueyraDimFlash",dispName)		endif	endif		if (!ParamIsDefault(expTitle))		note/NOCR/k coefWave,"expTitle:"+expTitle+";"	elseif (wavetype(wv,2)!=2)		//not a free wave 		note/NOCR/k coefWave, "fitToWave:"+nameofwave(wv)+";"	endif	if (strlen(outfitRef) > 0)		Duplicate/O/R=(startX, endX) fit_getConeDimFlashFit_g_temp, $outFitRef/WAVE=fit					fit = fit_angueyraDimFlash(coefwave, x)		String noteStr		wfprintf noteStr, "%f", coefwave		Note fit, "coefs:"+noteStr+";"				if (strlen(appendToGraphStr) && wintype(appendToGraphStr))			appendtograph/w=$appendToGraphStr $outFitRef			modifygraph/w=$appendToGraphStr offset($outFitRef)={0,baselineVal}		endif	endif		return baselineVal	endfunction expFit_exhaustive(specWv,toFitWv,startx,endx,maxTau,weightWvRef,outBestCoefsRef,[ampSpecWv,xwvref])	WAVE/D toFitWv	WAVE/D specWv		//specifications: one row for each coef; columns are 0:numTests 1:linear/log 2:minVal 3:maxVal . if numTests == 0 or 1 the coef is held at minVal	Variable startx,endx	String weightWvRef		//constraints text wave optional, for use with curvefit / fitfunc /C flag as in  /C=$constraintsWvRef .. wave must exist to be used!	String outBestCoefsRef	Double maxTau		//pass a real number to limit max tau or NaN not to do so	WAVE/D ampSpecWv		//optionlly pass a 4 point wave. [0] a set total amp for amp component guesses (baseline sutracted) [1] fixed amp index [2] whether to make the amplitude a constraint for all amp indices [3] multiplier for amp limit for constraint							//the sum of all amp components in initial guess will equal ampSpecWv[0] by subtracting an equal amount fromall amp compnents excpt the fixed amp guess at index ampSpecWv[1]							//example: {1e12,5,1,1.1}	says limit the sum of guess amplitudes to 1e12 by subtracting any overage from all but ampl component 5. Also pass a fit constraint that limits the total amplitude to 1.1*1e12							//another option is to pass NaN for [1] the fixed amp index. No amplitude guess subtracion will be performed but the amplitude constraint will still be applied							//example {1e12,NaN,1,1.} says pass a fit constraint all amplitudes <= 1.1*1.1		String xwvref	//optionally pass an xWave for non-uniform dt		Variable hasxWv=!paramIsDefault(xwvref) && strlen(xwvref)>0	String passedXWvRef	if (hasXWv)		WAVE xwv=$xwvref	endif						Variable numThreadRunsPerUpdate = 25		//some prep for fitting  - weight wv not implemented yet	Variable hasWeightWv= (strlen(weightWvRef) > 0) && WAveExists($weightWvRef)	if (hasWeightWv)		WAVE/D weightWv=$weightWvRef	endif	Variable hasAmpSpecWv = !ParamIsDefault(ampSpecWv)	if (hasAmpSpecWv)		if (dimsize(ampSpecWv,0) != 4)			print "expFit_exhaustive() ampSpecWv passed but not lengh of 4, ignoring"			hasAmpSpecWv=0		endif	endif		//calculate starting guesses based on specWv		Variable numCoefs = dimsize(specWv,0)	Variable i,usesLog,numTests,numTestedCoefs=0	Double range,minVal,maxVal,stepVal,base	duplicate/o/r=[][0] specWv, numTestsForEachCoef	redimension/n=(-1) numTestsForEachCoef	duplicate/o numTestsForEachCoef, denominators	denominators[numCoefs-1] = 1	for (i=numCoefs-2;i>=0;i-=1)		denominators[i] = denominators[i+1]*numTestsForEachCoef[i+1]	endfor	Variable maxNumTests = wavemax(numTestsForEachCoef)	Variable totalNumTests = 1	make/o/d/n=(numCoefs,maxNumTests) testValues		for (i=0;i<numCoefs;i+=1)		numTests = numTestsForEachCoef[i]		minVal = specWv[i][2]		if (numTests < 2)			//not varied			specWv[i][0] = 1		//make sure no zeros or ther business			testValues[i][0] = minVal			testValues[i][1,] = nan			continue		endif		numTestedCoefs += 1		totalNumTests *= numTests			//number of test cases is multiplicative, e.g. test 2 variables 3 ways, need 3x3 = 9 tests, 3 variables 2 ways is 2x1x3x2 = 12 tests				usesLog = specWv[i][1]		maxVal = specWv[i][3]		range = maxVal - minVal		if (usesLog)		//log exploration			base = (maxVal/minVal)^(1/(numTests-1))			testValues[i][] = (q<numTests) ? (minVal*base^q) : NaN		else					//linear exploration			stepVal = range / (numTests - 1)			testValues[i][] = (q<numTests) ? (minVal+stepVal*q) : NaN		endif	endfor		make/o/n=(numCoefs,totalNumTests) pos	make/o/n=(numCoefs,totalNumTests)/d testCoefs		Variable denominator,j,ii,offset,currPos	for (j=0;j<totalNumTests;j+=1)		offset=0		for (i=0;i<numCoefs;i+=1)			numTests = numTestsForEachCoef[i]			denominator = denominators[i]			currPos = floor( (j-offset) / denominator )			pos[i][j] = currPos			offset+=denominator*currPos		endfor	endfor	testCoefs = testValues[p][pos[p][q]]			//make amplitude hit target if requested	//unlike other parts of code, this is exp specific	if (hasAmpSpecWv && (numtype(ampSpecWv[1]) == 0) )		//ignored if no index is given for the fixed (constInd) amplitude component		Double targetAmp =  ampSpecWv[0],sumAll,subAmp		Variable constInd = ampSpecWv[1]		Variable constAmpNum = floor ( (constInd-1)/2 )		Variable numAmps = floor ( (numCoefs-1)/2 )		Variable numSubAmps = numAmps - 1		make/o/free/n=(numAmps) ampInds,subInds		ampInds = 1+2*p; subInds=ampInds		DeletePoints/M=0 constAmpNum, 1, subInds		make/o/d/n=(totalNumTests)/free subVals				for (i=0;i<totalNumTests;i+=1)			sumAll = 0			for (j=0;j<numAmps;j+=1)				sumAll += testCoefs[ampInds[j]][i]			endfor			Double diff = sumAll-targetAmp			if (diff > 0)				subAmp = diff/numSubAmps				for (j=0;j<numAmps;j+=1)					testCoefs[ampInds[j]][i]-=subAmp				endfor							endif		endfor	endif			//finally, run fits from starting guesses		String minErrStr,threadTestCoefsRef	Double minErr=inf,V_FitError,V_FitQuitReason,V_FitNumIters	Variable numFitInfoParams=4	Variable aFitCompletedWithoutError=0,lastBestFitColumn=nan	make/o/d/n=(numCoefs+numCoefs+numFitInfoParams,totalNumTests) fitInfo	fitInfo=nan	make/o/d/n=(numFitInfoParams) fitInfoTemp	fitInfo[0,numCoefs-1][] = testCoefs[p][q]	dl_lblByInd("fitInfo",0,"start_c",1,num=numCoefs)	dl_lblByInd("fitInfo",0,"final_c",1,startPos=numCoefs,num=numCoefs,countFromStartPos=1)	ii=2*numCoefs-1;	ii+=1;SetDimLabel 0,ii,V_chisq,fitInfo	ii+=1;SetDimLabel 0,ii,V_FitError,fitInfo	ii+=1;SetDimLabel 0,ii,V_FitQuitReason,fitInfo	ii+=1;SetDimLabel 0,ii,V_FitNumIters,fitInfo		//generate constaints	Double maxAmp		//ignored by constraints generating function if NaN	if (hasAmpSpecWv)		maxAmp = ampSpecWv[2] ? ampSpecWv[0] * ampSpecWv[3] : NaN	else		maxAmp = NaN	endif		Variable fitStartP,fitEndP	if (hasxwv)		findlevel/p/edge=1/q xwv,startX		fitStartP=V_levelx		findlevel/p/edge=1/q xwv,endX		fitEndP=V_levelx-1				else		fitStartP=x2pnt(toFitWv,startX)		fitEndP=x2pnt(toFitWv,endX)	endif	analysis_expFit_getConstraintsMats(toFitWv,numCoefs,fitStartP,fitEndP,maxAmp,maxTau,0,"cMatTemp","dVecTemp",xwvref=xwvref)	WAVE cMat = $"cMatTemp"	WAVE dVec = $"dVecTemp"		//prepare for multithreadng 	Variable nthreads=threadprocessorcount	Variable tgID=ThreadGroupCreate(nthreads)	Variable thread,test,jj,threadStatus	Print "expFit_exhaustive() beginning fits, tgID",tgID,"totalNumTests",totalNumTests,"status updates every",numThreadRunsPerUpdate*nthreads,"tests"	String heldStr="1" + text_getrepeatedstr("0",numCoefs)	for (j=0;j<totalNumTests;j+=nthreads)		for (jj=0;jj<nthreads;jj+=1)			test = j+jj			if ( test >=totalNumTests)				break			endif						threadTestCoefsRef="testCoefs_thread"+num2str(jj)			duplicate/o/r=[][test] testCoefs,$threadTestCoefsRef; redimension/n=(-1) $threadTestCoefsRef			if (hasWeightWv)				if (hasXwv)					ThreadStart tgID,jj,expFit_exhaustive_tsDriver_weighted_X($threadTestCoefsRef,toFitWv,fitStartP,fitEndP,cMat,dVec,heldStr,fitInfo,numCoefs,test,weightWv,xwv)				else					ThreadStart tgID,jj,expFit_exhaustive_tsDriver_weighted($threadTestCoefsRef,toFitWv,startX,endX,cMat,dVec,heldStr,fitInfo,numCoefs,test,weightWv)				endif			else				if (hasXWv)					ThreadStart tgID,jj,expFit_exhaustive_tsDriver_unweighted_X($threadTestCoefsRef,toFitWv,fitStartP,fitEndP,cMat,dVec,heldStr,fitInfo,numCoefs,test,xWv)				else					ThreadStart tgID,jj,expFit_exhaustive_tsDriver_unweighted($threadTestCoefsRef,toFitWv,startX,endX,cMat,dVec,heldStr,fitInfo,numCoefs,test)				endif			endif		endfor				// Wait for the two curve fits to finish.		threadStatus = ThreadGroupWait(tgID, inf)		if (threadStatus)			print "There was a problem with a thread. Aborting! j",j,"test",test			break;		endif				if ( (j>0) && (mod(j,nthreads*numThreadRunsPerUpdate)==0) )			print "competed thread run",j,"test num",test		endif		endfor		Variable releaseOutput=threadgrouprelease(tgID)		//find best fit coefs	Variable V_chisq_row=FindDimLabel(fitInfo, 0, "V_chisq" )		//NaN out any perfect fits.. there is a chance you could have a perfect for for a noiseless exponential		//in practice it seems like zeros are returned with V_fitError and V_fitQuitReason are both 3, that could be a better criteria that allows perfect fits	fitInfo[V_chisq_row][] = (fitInfo[p][q] == 0) ? Nan : fitInfo[p][q]	wavestats/rmd=[V_chisq_row][]/Q fitInfo	Variable numGoodFits = dimsize(fitInfo,1) - V_numNans	Variable minTest=nan	Double minChiSq=nan	if (numGoodFits>=1)		minTest=V_minColLoc		minChiSq=fitInfo[V_chisq_row][minTest]	endif	print/d "numGoodFits",numGoodFits,"minTest",minTest,"minChiSq",minChiSq	Duplicate/o/r=[numCoefs,2*numCoefs-1][minTest] fitInfo,$outBestCoefsRef/wave=out	redimension/n=(-1) out			return minChiSq		//return v_chiSq for best of all fits//aFitCompletedWithoutError	endThreadsafe function expFit_exhaustive_tsDriver_unweighted(coefWv,fitWv,startX,endX,cMat,dVec,heldStr,fitInfoWv,numCoefs,col)	WAVE/D coefWv,fitWv,fitInfoWv	WAVE/D cMat,dVec	Variable startX,endX,numCoefs,col	String heldStr		Variable V_FitError = 0,V_FitQuitReason,V_FitNumIters	Variable/G x0=startX	FuncFit/W=2/N=1/Q=1/H=heldStr myExp,coefWv,fitWv(startX,endX)/C={cMat,dVec}	analysis_sortExpCoefWave(coefWv)	Variable infoStart=2*numCoefs		fitInfoWv[numCoefs,infoStart-1][col]=coefWv[p-numCoefs]	fitInfoWv[infoStart+0][col]=V_chisq	fitInfoWv[infoStart+1][col]=V_FitError	fitInfoWv[infoStart+2][col]=V_FitQuitReason	fitInfoWv[infoStart+3][col]=V_FitNumIters		return v_chisqendThreadsafe function expFit_exhaustive_tsDriver_weighted(coefWv,fitWv,startX,endX,cMat,dVec,heldStr,fitInfoWv,numCoefs,col,weightWv)	WAVE/D coefWv,fitWv,fitInfoWv	WAVE/D cMat,dVec	Variable startX,endX,numCoefs,col	WAVE/D weightWv	String heldStr		Variable V_FitError = 0,V_FitQuitReason,V_FitNumIters	Variable/G x0=startX	FuncFit/W=2/N=1/Q=1/H=heldStr myExp,coefWv,fitWv(startX,endX)/C={cMat,dVec}/W=weightWv(startX,endX)	analysis_sortExpCoefWave(coefWv)	Variable infoStart=2*numCoefs		fitInfoWv[numCoefs,infoStart-1][col]=coefWv[p-numCoefs]	fitInfoWv[infoStart+0][col]=V_chisq	fitInfoWv[infoStart+1][col]=V_FitError	fitInfoWv[infoStart+2][col]=V_FitQuitReason	fitInfoWv[infoStart+3][col]=V_FitNumIters		return v_chisqendThreadsafe function expFit_exhaustive_tsDriver_unweighted_X(coefWv,fitWv,startP,endP,cMat,dVec,heldStr,fitInfoWv,numCoefs,col,xWv)	WAVE/D coefWv,fitWv,fitInfoWv,xWv	WAVE/D cMat,dVec	Variable startP,endP	Variable numCoefs,col	String heldStr		Variable V_FitError = 0,V_FitQuitReason,V_FitNumIters	Variable/G x0=xWv[startP]	FuncFit/W=2/N=1/Q=1/H=heldStr myExp,coefWv,fitWv[startP,endP]/C={cMat,dVec}/X=xWv[startP,endP]	analysis_sortExpCoefWave(coefWv)	Variable infoStart=2*numCoefs		fitInfoWv[numCoefs,infoStart-1][col]=coefWv[p-numCoefs]	fitInfoWv[infoStart+0][col]=V_chisq	fitInfoWv[infoStart+1][col]=V_FitError	fitInfoWv[infoStart+2][col]=V_FitQuitReason	fitInfoWv[infoStart+3][col]=V_FitNumIters		return v_chisqendThreadsafe function expFit_exhaustive_tsDriver_weighted_X(coefWv,fitWv,startP,endP,cMat,dVec,heldStr,fitInfoWv,numCoefs,col,weightWv,xWv)	WAVE/D coefWv,fitWv,fitInfoWv,xWv	WAVE/D cMat,dVec	Variable startP,endP	Variable numCoefs,col	WAVE/D weightWv	String heldStr		Variable V_FitError = 0,V_FitQuitReason,V_FitNumIters	Variable/G x0=xWv[startP]	FuncFit/W=2/N=1/Q=1/H=heldStr myExp,coefWv,fitWv[startP,endP]/C={cMat,dVec}/W=weightWv[startP,endP]/X=xWv[startP,endP]	analysis_sortExpCoefWave(coefWv)	Variable infoStart=2*numCoefs		fitInfoWv[numCoefs,infoStart-1][col]=coefWv[p-numCoefs]	fitInfoWv[infoStart+0][col]=V_chisq	fitInfoWv[infoStart+1][col]=V_FitError	fitInfoWv[infoStart+2][col]=V_FitQuitReason	fitInfoWv[infoStart+3][col]=V_FitNumIters		return v_chisqend//elegant in place shuffle from igor exchange forums by s.r.chinn https://www.wavemetrics.com/code-snippet/random-place-shuffle-input-waves-elementsfunction wave_shuffle(wv)	wave wv		variable N	=	numpnts(wv)	variable i, j, emax, temp	for(i = N; i>1; i-=1)		emax = i / 2		j =  floor(emax + enoise(emax))		//	random index// 		emax + enoise(emax) ranges in random value from 0 to 2*emax = i		temp		= wv[j]		wv[j]		= wv[i-1]		wv[i-1]	= temp	endforendendfunction wave_multiplyRange(wv,startP,endP)	WAVE wv; Variable startP,endP		//inclusive!		Variable pnts = dimsize(wv,0)	if (startP >= pnts) 		return 0	endif		endP = min(pnts-1,endP)		Variable i	Double out = 1	for (i=startP;i<=endP;i+=1)		out*=wv[i]	endfor		return outendfunction/WAVE stats_getLogTestVals(minVal,maxVal,numTests,outRef)	Double minVal,maxVal	Variable numTests	String outRef		if (strlen(outRef)>0)		make/o/d/n=(numTests) $outref/wave=out	else		make/free/o/d/n=(numTests) out	endif		Double base = (maxVal/minVal)^(1/(numTests-1))	out = minVal*base^p		return outend						function fit_getUserFit_main(coefWave,toFitWv,x0Val,startx,endx,fitNameStr,dispName,[weightWv,constraintsWvRef])	WAVE/D coefwave,toFitWv,weightWv	Variable x0Val,startx,endx	String fitNamestr	String dispName		//pass a name for this fit, e.g., the name of the original data wave. this will be displayed	String constraintsWvRef		//constraints text wave optional, for use with curvefit / fitfunc /C flag as in  /C=$constraintsWvRef .. wave must exist to be used!		variable/g fit_getUserFit_running = 1		String weightWvRef	if (ParamISDefault(weightWv))		weightWvRef=""	else		weightWvRef=nameofwave(weightWv)	endif		String constraintsRefPAssed = ""	if (!PAramIsDefault(constraintsWvRef))		constraintsRefPAssed = constraintsWvRef	endif		String wins=fit_getUserFit(coefwave,toFitWv,x0Val,startx,endx,fitNameStr,0,1,dispName,weightWvRef,constraintsRefPAssed)	String winN=stringfromlist(0,wins),editWinN=stringfromlist(1,wins)	dowindow/f $winN;dowindow/f $editWinN	showinfo/w=$winN;doupdate;	pauseforuser $editWinN, $winN	print "fit_getUserFit_main completed!"	killwindow/z $winN;killwindow/z $editWinN	variable/g fit_getUserFit_running = 0endfunction/s fit_getUserFit(coefwave,toFitWv,x0Val,startx,endx,fitNameStr,doFit,firstCall,dispName,weightWvRef,constraintsWvRef)	WAVE/D coefwave,toFitWv	Variable x0Val,startx,endx	String fitNamestr	Variable doFit		//otherwise only updates residuals etc.	Variable firstCall	//pass to instantiate necessary items, only first call	String dispName		//pass a name for this fit, e.g., the name of the original data wave. this will be displayed -- ignored for updateOnly	String weightWvRef		//pass a weight wave e.g. standard errors or "" for no weighting	String constraintsWvRef	//string of form "/C=whatever" as it would be for a /C flag. Fitting will use a macro in this case		//attempt to avoid re-entrant curve fitting-- do not call funcfit when a fit is already going	NVAR/Z fitInProgress	if (!Nvar_exists(fitInProgress))		Variable/G fitInProgress = 0	elseif (fitInProgress)		return ""	endif		String winN="fit_getUserFit_win"	String fitHolderWvN=winN+"fit"	String resWvN=winN+"res"	String resCoefsRef=winN+"resC"	String resFitRef=winN+"resF"	String editWinN=winN+"edit"	String msgWvRef=winN+"msg"	String coefWvCopy=winN+"coefs"	String origCoefWvBackup=winN+"coefsB"		Variable hasWeightWv= (strlen(weightWvRef) > 0) && WAveExists($weightWvRef)	if (hasWeightWv)		WAVE weightWv=$weightWvRef	endif	Variable hasConstraintsWv= (strlen(constraintsWvRef) > 0) && WAveExists($constraintsWvRef)	if (hasConstraintsWv)		WAVE/T constraintsWv=$constraintsWvRef	endif		Variable numMsgRows=12			if (firstCall)			//waves for fit		duplicate/o coefwave, $origCoefWvBackup		make/o/t/n=(max(numMsgRows,dimsize(coefwave,0)),2) $msgWvRef/wave=msgWv		dl_lblsToLbls(nameofwave(coefwave),0,0,inf,msgWvRef,0,0,"",0)	//allow user to pass labels that informs		duplicate/o coefwave,$coefWvCopy/wave=coefWvCopyWv		duplicate/o/r=(startx,endx) toFitWv,$fitHolderWvN/wave=fitHolderWv				//waves for residuals		duplicate/o coefwave, $resCoefsRef/wave=resCoefs		duplicate/o fitHolderWv,$resWvN/wave=reswv,$resFitRef/wave=resFit				//global variables		Variable/G x0=x0Val				//displays		killwindow/Z $winN;	display/k=1/n=$winN		appendtograph/w=$winN/c=(0,0,0) toFitWv/tn=toFit		appendtograph/w=$winN fitHolderWv		appendtograph/w=$winN/l=left2/c=(0,0,0) reswv		appendtograph/w=$winN/l=left2 resFit		modifygraph/w=$winN freepos=0,lblpos=50,axisenab(left)={0,0.49},axisenab(left2)={0.51,1}		setaxis/w=$winN bottom, startx,endx;label left, "FIT \U";label left2,"RES \U"				if (hasWeightWv)  //useful to show when SD/SEM, not if some other artbitrary weight, so usually commenting this out			//errorbars/w=$winN toFit,SHADE={0,0,(39321,1,31457),(0,0,0)},wave=(weightWv,weightWv)//wave=(weightWv[x2pnt(weightWv,startx),x2pnt(weightWv,endX)],weightWv[x2pnt(weightWv,startx),x2pnt(weightWv,endX)])			//appendtograph/w=$winN/l=left2/c=(39321,1,31457) weightwv		//show weight		endif				String x0Str,startxstr,endxstr		sprintf x0Str, "%0.20f",x0Val;sprintf startxstr, "%0.20f",startx;sprintf endxstr, "%0.20f",endx			String fit_getUserFit_info="coefwave:"+nameofwave(coefwave)+";toFitWv:"+nameofwave(toFitWv)+";fitHolderWv:"+fitHolderWvN+";fitNameStr:"+fitNameStr+";weightWvRef:"+weightWvRef+";"		fit_getUserFit_info+="x0Str:"+x0Str+";startxstr:"+startxstr+";endxstr:"+endxstr+";winN:"+winN+";resWvN:"+resWvN+";editWinN:"+editWinN+";coefWvCopy:"+coefWvCopy+";"		fit_getUSerFit_info+="origCoefWvBackup:"+origCoefWvBackup+";dispName:"+dispName+";msgWvRef:"+msgWvRef+";constraintsWvRef:"+constraintsWvRef+";"		setwindow $winN,userdata(fit_getUserFit_info)=fit_getUserFit_info					edit/k=1/n=$editWinN coefwave.ld,resCoefs.ld,msgWv.ld		setwindow $editWinN,userdata(fit_getUserFit_info)=fit_getUserFit_info		setwindow $editWinN,hook(fit_getUserFit_hook)=fit_getUserFit_hook			else		//declare things		WAVE/T msgWv=$msgWvRef		wave/D coefWvCopyWv=$coefWvCopy		WAVE/D fitHolderWv=$fitHolderWvN				WAVE/D resCoefs = $resCoefsRef		WAVE/D reswv = $resWvN		WAVE/D resFit = $resFitRef	endif			Variable isExp = stringmatch(fitNameStr,"myExp")	FUNCREF fits_protoFunc f = $fitNameStr	Variable mainFitErr,resFitErr,mainFitQuitReason,resFitQuitReason,V_fitError,V_FitQuitReason			//fitting main wave	if (doFit)		print "fit_getUserFit() entering main fit"//		print "FuncFit f,coefwave,toFitWv(startX,endX)/W=weightWv(startX,endX);fitInProgress=0"		print "coefwave",nameofwave(coefwave),"toFitWv",nameofwave(toFitWv),"startX",startx,"endX",endx,"weightWv",nameofwave(weightWv)		print "USAGE: SHIFT -> FIT; CTRL -> REPLOT; SHIFT+CTRL -> RESTORE ORIGINAL"		V_fitError=0		if (hasWeightWv)			if (hasConstraintsWv)				fitInProgress=1;FuncFit f,coefwave,toFitWv(startX,endX)/W=weightWv(startX,endX)/C=constraintsWv;fitInProgress=0			else				fitInProgress=1;FuncFit f,coefwave,toFitWv(startX,endX)/W=weightWv(startX,endX);fitInProgress=0			endif		else			if (hasConstraintsWv)				fitInProgress=1;FuncFit f,coefwave,toFitWv(startX,endX)/C=constraintsWv;fitInProgress=0			else				fitInProgress=1;FuncFit f,coefwave,toFitWv(startX,endX);fitInProgress=0			endif		endif		print "leaving main fit"		mainFitErr=V_fitError		mainFitQuitReason=V_FitQuitReason		if (V_fitError)			String errors="error;Singular matrix;Out of memory;Function returned NaN or INF;Fit function requested stop;Reentrant curve fitting;"			string errorStr=""			Variable i,maxNumBits = itemsinlist(errors)			for (i=0;i<maxNumBits;i+=1)				if ( (V_fitError & 2^i) > 0)					errorStr+=stringfromlist(i,errors)+";"				endif			endfor			print "fit_getUserFit() failed V_FitError!",mainFitErr,"REASONS:",errorStr		endif	endif		//calculate fit and residuals	fitHolderWv=f(coefWave,x)	reswv=fitHolderWv(x)-toFitWv(x)	doupdate;		if (doFit)		print "entering second fit"		V_fitError=0		//fit residuals even just for updates--for some types of fits (e.g., exponentials) may be informative		if (hasWeightWv)			if (isExp)				fitInProgress=1;Curvefit exp_XOffset , kwCwave=resCoefs,reswv(startX,endX)/W=weightWv(startX,endX);fitInProgress=0			else				fitInProgress=1;FuncFit f, resCoefs,reswv(startX,endX)/W=weightWv(startX,endX);fitInProgress=0			endif			//funcfit/n=1/q {{$fitNameStr,resCoefs}},reswv(startX,endX)/W=weightWv(startX,endX)		else			if (isExp)				fitInProgress=1;Curvefit exp_XOffset , kwCwave=resCoefs,reswv(startX,endX)/W=weightWv(startX,endX);fitInProgress=0			else				fitInProgress=1;FuncFit f, resCoefs,reswv(startX,endX);fitInProgress=0			endif			//funcfit/n=1/q {{$fitNameStr,resCoefs}},reswv(startX,endX)		endif		print "leaving second fit"		resFitErr=V_fitError		resFitQuitReason=V_FitQuitReason		if (resFitErr)			print "fit_getUserFit() failed to fit residual wave V_FitError!",resFitErr		endif		endif		resFit=f(resCoefs,x)	doupdate		//messages to user	Variable prevN_main=str2num(stringfromlist(1,msgWv[1][0]	,"_"))	Variable prevN_res=str2num(stringfromlist(1,msgWv[6][0],"_"))	Variable prevUpN_main=str2num(stringfromlist(1,msgWv[4][0]	,"_"))	Variable prevUpN_res=str2num(stringfromlist(1,msgWv[9][0]	,"_"))	if (numtype(prevN_main) > 0)		prevN_main=-1	endif	if (numtype(prevN_res) > 0)		prevN_res=-1	endif				//related to main fit	if (firstCall)		msgWv[0][0]="Target:"+dispName		msgWv[1,3][0]=""		msgWv[6,8][0]=""		prevN_main=-1		prevN_res=-1		prevUpN_main=-1		prevUpN_res=-1	elseif (doFit)		msgWv[1][0]="Fitted_"+num2str(prevN_main+1)		msgWv[2][0]="FitErr:"+num2str(mainFitErr)		msgWv[3][0]="FitQuit:"+num2str(mainFitQuitReason)		msgWv[6][0]="FittedRes_"+num2str(prevN_res+1)		msgWv[7][0]="FitErr:"+num2str(resFitErr)		msgWv[8][0]="FitQuit:"+num2str(resFitQuitReason)	endif		//always an update for now	msgWv[4][0]="Updated_"+num2str(prevUpN_main+1)	msgWv[5][0]=""	msgWv[9][0]="Upd.Res_"+num2str(prevUpN_res+1)	msgWv[10][0]=""		doupdate;			return winN+";"+editWinN+";"endfunction fit_getUserFit_hook(s)	STRUCT WMWinHookStruct &s		if (s.eventcode != 5)		//mouse up		return 0	endif			String info=getuserdata(s.winname,"","fit_getUserFit_info")	String coefwave=stringbykey("coefwave",info)	String coefWvCopy=stringbykey("coefWvCopy",info)	String origCoefWvBackup=stringbykey("origCoefWvBackup",info)	String toFitWv=stringbykey("toFitWv",info)	String x0str=stringbykey("x0str",info)	String startxstr=stringbykey("startxstr",info)	String endxstr=stringbykey("endxstr",info)	String fitNameStr=stringbykey("fitNameStr",info)	String weightWvRef=stringbykey("weightWvRef",info)	String constraintsWvRef=stringbykey("constraintsWvRef",info)	Variable x0Val=str2num(x0str)	Variable startx=str2num(startxstr)	variable endx=str2num(endxstr)		Variable ctrlClick= (s.eventMod & 2^3) != 0 	Variable shiftClick = (s.eventMod & 2^1) != 0		Variable doFit	if ( !ctrlClick && !shiftClick)			// neither, do nothing (ignore regular clicks)		Print "click ignored"		return 0		elseif (ctrlClick && shiftClick)		//both, restore original guesses, update but no fit		Print "restored original and updating"		duplicate/o $origCoefWvBackup,$coefwave		doFit=0	elseif (shiftClick)		//do fit and update		print "fitting and updating"		doFit=1	else		//ctrl click -- update only		print "updating only"		doFit=0	endif		fit_getUserFit($coefwave,$toFitWv,x0Val,startx,endx,fitNameStr,doFit,0,"",weightWvRef,constraintsWvRef)end//coef wave w: {a,r_tau, f_tau, osc_tau, phi}function fit_angueyraDimFlash(w,x) : FitFunc	Wave/d w;Double x		NVAR x0		return x<x0 ? 0 : tCurve_riekeDimFlash_c0(x-x0, w[0], w[1], w[2]) * tCurve_riekeDimFlash_c1(x-x0, w[3], w[4])end		//undershootfunction tCurve_riekeDimFlash_c1(t, osc_tau, phi)	Variable t, osc_tau, phi		return cos((2*pi*t/osc_tau) + phi)end//initial rising and falling phasefunction tCurve_riekeDimFlash_c0(t, a, r_tau, f_tau)	Variable t, a, r_tau, f_tau		return a* ( ((t/r_tau)^4)/(1+(t/r_tau)^4) ) * exp(-t/f_tau)endfunction text_getTWaveListFromStrList(list,outRef)	String list,outRef		variable i,num=itemsinlist(list)	make/o/t/n=(num) $outref/wave=out	out=stringfromlist(p,list)endfunction/S text_getStrListFromTWave(tWave, includeDimLabels,[skipBlanks])	WAVE/T tWave	Variable includeDimLabels		//when passed, output will be keyword-string paired	Variable skipBlanks		Variable noBlanks = !paramIsDefault(skipBlanks) && skipBlanks		Variable i; String out = "",str	for (i=0;i<dimsize(twave,0);i+=1)		str=tWave[i]		if (noBlanks && (strlen(str) < 1) )			continue		endif			if (!includeDimLabels)			out += tWave[i] + ";"		else			out += GetDimLabel(tWave, 0, i) + ":" + tWave[i] + ";"		endif	endfor		return outendfunction/S text_getStrListFromWave(wv, includeDimLabels)	Wave wv	Variable includeDimLabels		//when passed, output will be keyword-string paired		Variable wType = wavetype(wv,1)		if (wType==1) //numeric, so convert to text wave		Make/O/T/N=(dimsize(wv,0))/free text_getStrListFromWave_temp		text_getStrListFromWave_temp = num2str(wv[p])		dl_lblsToLbls("",0,0,nan,"text_getStrListFromWave_temp",0,0,"",0,forceFromWv=wv,forceToWv=text_getStrListFromWave_temp)		String out = text_getStrListFromTWave(text_getStrListFromWave_temp,includeDimLabels)		killwaves text_getStrListFromWave_temp		return out	elseif (wtype > 1)	//probably some sort of text wave		return text_getStrListFromTWave(wv,includeDimLabels)	else		return ""	endifendfunction/S text_getStrListFromTWaveCol(tWave,col,dimLabelOptions)	WAVE/T tWave	Variable col	Variable dimLabelOptions		//when passed as 1, output will be keyword-string paired, pass 2 for just dim labels		Variable i; String out = ""	for (i=0;i<dimsize(twave,0);i+=1)		if (dimLabelOptions==0)			out += tWave[i][col] + ";"		elseif (dimLabelOptions==1)			out += GetDimLabel(tWave, 0, i) + ":" + tWave[i][col] + ";"		else		//2 or something			out += GetDimLabel(tWave, 0, i) + ";"		endif	endfor		return outendfunction/S text_getStrListFromTWaveRow(tWave,row,includeDimLabels)	WAVE/T tWave	Variable row	Variable includeDimLabels		//when passed, output will be keyword-string paired		Variable i; String out = ""	for (i=0;i<dimsize(twave,1);i+=1)		if (!includeDimLabels)			out += tWave[row][i] + ";"		else			out += GetDimLabel(tWave, 1, i) + ":" + tWave[row][i] + ";"		endif	endfor		return outendfunction disp_appendWaveListToTable(listOrWvList, newG, [suffix])	String listOrWvList; String suffix	Variable newG		//pass true for new graph		Variable i; String ref	if (ParamIsDefault(suffix))		suffix = ""	endif		if (newG)		Edit/K=1	endif		if (WaveExists($listOrWvList))		//presumed list wave		WAVE/T w = $listOrWvList		for (i=0;i<DimSize(w,0);i+=1)			appendtotable $(w[i] + suffix)		endfor	else		for (i=0;ItemsInList(listOrWvList);i+=1)			appendtotable $(StringFromList(i, listOrWvList) + suffix)		endfor			endifendfunction disp_appendWaveOrListToGraph(refOrList, colsNotRows, colIndex, [suffix])	String refOrList; String suffix	Variable colsNotRows, colIndex		//ignored for wave list		if (ParamIsDefault(suffix))		suffix = ""	endif		Variable isList = StringMatch(refOrList,"*;*")	Variable i	if (isList)		for (i=0;i<ItemsInList(refOrList);i+=1)			appendToGraph $(StringFromList(i,refOrList) + suffix)		endfor		else		WAVE/T w = $refOrList		if (colsNotRows)			for (i=0;i<DimSize(w,1);i+=1)				appendToGraph $(w[colIndex][i] + suffix)			endfor		else			for (i=0;i<DimSize(w,0);i+=1)				appendToGraph $(w[i][colIndex] + suffix)			endfor			endif	endifendfunction tWave_norm(refsWv, colNum, useMin)	WAVE/T refsWv; Variable colNum, useMin	Variable i, normFactor		for (i=0;i<DimSize(refsWv,0);i+=1)		WAVE/D temp = $refsWv[i][colNum]		if (useMin)			normFactor = wavemin(temp)		else			normFactor = wavemax(temp)		endif		temp /= normFactor	endforendfunction flash_normFlash(refsWv, colNum,flashIncrWv)	WAVE/T refsWv; WAVE/D flashIncrWv; Variable colNum	Variable i	for (i=0;i<DimSize(refsWv,0);i+=1)		WAVE/D temp = $refsWv[i][colNum]		temp /= flashIncrWv[i]	endforendfunction/S wave_listDup(list, [suffix, startX, endX,subWv])	String list, suffix	Variable startX,endX	WAVE subWv		//optionally pass a wave to subtract from the others		variable doMath = !ParamIsDefault(subWv)		Variable overwriteSelf = 0	if (ParamIsDefault(suffix))		overwriteSelf = 1	endif		if (ParamIsDefault(startX))		startX = DimOffset($StringFromList(0,list),0)	endif	if (ParamIsDefault(endX))		endX = DimOffset($StringFromList(0,list),0) + (DimDelta($StringFromList(0,list),0)) * (DimSize($StringFromList(0,list),0)-1)	endif		Variable i; String inRef, outRef; String outList = ""	for (i=0;i<ItemsInList(list);i+=1)		inRef = StringFromList(i,list)		outRef = inRef + suffix		outList += outRef + ";"		if (overwriteSelf)			Duplicate/O/R=(startX, endX) $inRef, temp_dupList			Duplicate/O temp_dupList, $outRef		else			if (doMath)				Duplicate/O/R=(startX, endX) $inRef, $outRef/wave=out				out -= subWv			else				Duplicate/O/R=(startX, endX) $inRef, $outRef			endif		endif	endfor		killwaves/Z temp_dupList	return outListendfunction disp_colorTraces(matchStr,colorTabN,[opac,scaleWv,logColors])	String matchStr, colorTabN	Variable opac	//0-1	WAVE scaleWv		//pass a min and a max value for a color scale -- should correspond to first and last wave's values 			Variable logColors		//pass for log scaling, requires scaleWv		String traceList = ListMatch(tracenamelist("",";",1), matchStr)	Variable numTraces = ItemsInList(traceList)		Colortab2wave $colorTabN	WAVE M_colors		Variable maxNumColors = DimSize(M_colors,0)	Variable doLogColors=!ParamIsDefault(scaleWv) && !ParamIsDefault(logcolors) && logColors	Variable colorStepSize = (maxNumColors-1)/(numTraces-1)		//maxNumColors-1 because last index is N-1 for N colors	Print "numTraces",numTraces, "maxNumColors",maxNumColors, "colorStepSize",colorStepSize		Variable i, cInd	if (ParamIsDefault(opac))		for (i=0;i<numTraces;i+=1)			cInd = floor(i*colorStepSize)			modifygraph rgb($StringFromList(i, traceLisT)) = (M_colors[cInd][0],M_colors[cInd][1],M_colors[cInd][2])		endfor	else		Variable alpha = opac*(-1+2^16)		for (i=0;i<numTraces;i+=1)			cInd = floor(i*colorStepSize)			modifygraph rgb($StringFromList(i, traceLisT)) = (M_colors[cInd][0],M_colors[cInd][1],M_colors[cInd][2],alpha)		endfor		endif		if (!ParamIsDefault(scaleWv))		ColorScale/C/N=text0/F=0/A=MC frame=0.00, ctab={scaleWv[0],scaleWv[1],CyanMagenta,0},log=(doLogColors)	endif	end	//max  numCoefs = 4001function/S list_filterFIR(list,cutOff,reject,numCoefs,suffix)	String list; Variable cutoff, reject, numCoefs; String suffix		Variable i; String inRef, outRef, out = ""	for (i=0;i<ItemsInList(list);i+=1)		inRef = StringFromList(i,list)		outRef = inRef + suffix		Duplicate/O $inRef, $outRef		FilterFIR/LO={cutOff, reject, numCoefs} $outRef		out += outRef + ";"	endfor		return outend//function/S wn_testBridges(stimRef, bridgeRef, secondRef, r_pipetteBestGuess, r_stepSize, r_numSteps)//	String stimRef, bridgeRef, secondRef//	Variable r_pipetteBestGuess			//best guess = ideally from correcting a tuning trace//	Variable r_stepSize												// size of steps +/- to go//	Variable r_numSteps									//how many positive and negative steps to take (3 = 7 steps total, best gues always middle//	//	String appendStr = "WNB"//	String refsAppendStr = "_R"//	String paramsAppendStr = "_P"//	String nameStartStr = bridgeRef + appendStr//	String resistancesSaveStr = nameStartStr + "O"//	String refsStartStr = bridgeRef + refsAppendStr//	String paramsStartStr = bridgeRef + paramsAppendStr//	String diffRefsStr = bridgeRef + appendStr + "_D"//	String foldDiffRefsStr = bridgeRef + appendStr + "_F"//	String diffRefsListStr = bridgeRef + appendStr + "_Dl"//	String foldDiffRefsListStr = bridgeRef + appendStr + "_Fl"//	String/G outListRaw = ""//	//	String secondRefAppendStr = "WNC"//	String ped_refsNameStr = secondRef + secondRefAppendStr + refsAppendStr//	String ped_paramsNameStr = secondRef + secondRefAppendStr + paramsAppendStr//	//	Variable numResistances = 1 + 2*r_numSteps//	Make/O/D/N=(numResistances) $resistancesSaveStr//	WAVE/D resistances_temp = $resistancesSaveStr//	resistances_temp[] = r_pipetteBestGuess + ((p-r_numSteps)*r_stepSize)//	//	////	Double range = r_pipetteMax - r_pipetteMin////	Double binSize = range/(numResistances-1)////	resistances_temp[] = r_pipetteMin + p*range////	////	Variable slope = range/numResistances////	Variable bestGuessBinNum = round((r_pipetteBestGuess - r_pipetteMin)/slope)////	resistances_temp[bestGuessBinNum] = r_pipetteBestGuess//	//	Variable baselineStartX=0, baselineEndX=0.5//	//	Variable filterLenX = 1			//sets size of bins therefore also filter length (in current implementation)//	Variable numNonlinearityBins = 30		//how finely to segment the non-linearity (pairwise plot of predicted and actual voltage response at soma and ped)//	Variable binSpacingX = 0.5		//sets spacing between START of bins averaged to calculate filter, so for 1s bins, 0.5s spaces means 50% overlap//	String windowFuncStr = ""//	Variable winStartX=10//	Variable winSizeX=35 //	//	wn_myCorr3(stimRef, secondRef, ped_refsNameStr, ped_paramsNameStr, filterLenX, binSpacingX, winStartX, winSizeX, numNonlinearityBins, windowFuncStr)	//	wn_myCorr3Params_v2(ped_refsNameStr)	//wn_myCorr3Params(ped_refsNameStr)	//	//	WAVE/D stim = $stimRef; Variable stimBaseline = mean(stim, baselineStartX, baselineEndX)//	//	Variable i; String nStr, currBridgeCorrSaveRef//	for (i=0;i<numResistances;i+=1)//		nStr = num2str(i)//		currBridgeCorrSaveRef = nameStartStr + nStr//		Duplicate/O $bridgeRef, $currBridgeCorrSaveRef//		WAVE/D temp = $currBridgeCorrSaveRef//		temp -= (stim-stimBaseline)*resistances_temp[i]//		wn_myCorr3(stimRef, currBridgeCorrSaveRef, refsStartStr+nStr, paramsStartStr+nStr, filterLenX, binSpacingX, winStartX, winSizeX, numNonlinearityBins, windowFuncStr)	//		wn_myCorr3CalcDiffs(0,refsStartStr+nStr, ped_refsNameStr)		//MAY NEED UPDATING SINCE NAMES NOW AUTO GENERATED//		outListRaw += currBridgeCorrSaveRef + ";"//	endfor//	//	Print "nameStartStr",nameStartStr,"resistancesSaveStr",resistancesSaveStr,"refsStartStr",refsStartStr,"paramsStartStr",paramsStartStr//	Print "diffRefsStr",diffRefsStr, "foldDiffRefsStr", "diffRefsListStr",diffRefsListStr,"foldDiffRefsListStr",foldDiffRefsListStr//	Print "ped_refsNameStr",ped_refsNameStr,"ped_paramsNameStr",ped_paramsNameStr//	//	////	return outListRaw//end//only supports append to left axis at presentfunction disp_appendTracesToGraph(newClearOrAdd,waves,delimStr,[gName,suffix,leftAxN,color,reload,bottomAxN])	Variable newClearOrAdd	String waves, delimStr, gName,leftAxN,bottomAxN	String suffix	//optional suffix to append to the name in the waves list in order to give the name of the waves to be plotted'	String color		//optionally pass a string of 3 or 4 colors 	Variable reload	//1 to reload, 2 to reload even if exists		if (!ParamIsDefault(reload))		if (reload==1)			da_fd_loadWavesFromWaveName(waves,1)		elseif (reload==2)			da_fd_loadWavesFromWaveName(waves,0)		endif	endif		if (ParamIsDefault(gName))		gName=""		newClearOrAdd = 2	endif		switch (newClearOrAdd)		case 1:			if (strlen(gName) == 0)				gName = winname(0,1)		//top graph			endif			if (winType(gName) > 0)				vis_clearGraph(gName)			else				Display/K=1/N=$gName				gName = S_name			endif			break		case 2:		//if win exists do nothing			if (strlen(gName) == 0)				gName = winname(0,1)		//top graph			endif			if (winType(gName) == 0)				Display/K=1/N=$gName				gName = S_name			endif			break			default:			if (strlen(gName) == 0)				gName = "Graph"			elseif (winType(gName) > 0)				killwindowsbyname(gName)			endif						Display/K=1/N=$gName			gName = S_name	endswitch			Variable hasColor = -1	if (!paramIsDefault(color))		Variable colorLen = itemsinlist(color)		if (colorLen >= 3)			make/o/u/i/n=(colorLen)/free cw			cw = str2num(stringfromlist(p,color))		endif	endif		if (ParamIsDefault(leftAxN))		leftAxN = "left"	endif		if (ParamIsDefault(bottomAxN))		bottomAxN = "bottom"	endif		if (strlen(delimStr) < 1)		delimStr = ";"	endif		if (ParamIsDefault(suffix))		suffix = ""	endif		Variable i	for (i=0;i<ItemsInList(waves,delimStr);i+=1)		if (colorLen == 4)			appendtograph/L=$leftAxN/B=$bottomAxN/W=$gName/c=(cw[0],cw[1],cw[2],cw[3]) $(StringFromList(i,waves, delimStr) + suffix)		elseif (colorLen == 3)			appendtograph/L=$leftAxN/B=$bottomAxN/W=$gName/c=(cw[0],cw[1],cw[2]) $(StringFromList(i,waves, delimStr) + suffix)		else			appendtograph/L=$leftAxN/B=$bottomAxN/W=$gName $(StringFromList(i,waves, delimStr) + suffix)		endif	endforendfunction disp_removeTraces(matchStr, [gName])	String matchStr, gName		if ( ParamIsDefault(gName))		gName = winname(0,1)	endif			String list = wavelist(matchStr,";","WIN:"+gName)		Variable i	for (i=0;i<ItemsInList(list);i+=1)		RemoveFromGraph/W=$gName $StringFromList(i,list)	endfor	endfunction disp_appendXYTracesToGraph(yTraceList, xTraceList, yColOrRow, xColOrRow, dataAcrossCols, delimStr, [gName])	String yTraceList, xTraceList, delimStr, gName; Variable  yColOrRow, xColOrRow, dataAcrossCols		if (Strlen(xTraceList) < 1)		xTraceList = yTraceList	endif		if (strlen(delimStr) < 1)		delimStr = ";"	endif		if ( ParamIsDefault(gName))		gName = ""	endif		Variable i	if (!dataAcrossCols)		//data is in rows (down columns)		for (i=0;i<ItemsInList(yTraceList,delimStr);i+=1)			appendtograph/W=$gName $StringFromList(i,yTraceList, delimStr)[][yColOrRow] vs  $StringFromList(i,xTraceList, delimStr)[][xColOrRow] 		endfor	else		for (i=0;i<ItemsInList(yTraceList,delimStr);i+=1)			appendtograph/W=$gName $StringFromList(i,yTraceList, delimStr)[yColOrRow][] vs  $StringFromList(i,xTraceList, delimStr)[xColOrRow][] 		endfor		endifendfunction/S wave_bridgeBalance_g(r_pipette, cmdBaselineStartX, cmdBaselineEndX, cmdRefs, respRefs, suffix)	Variable cmdBaselineStartX, cmdBaselineEndX		//baseline used as zero cmd	Variable r_pipette	String cmdRefs, respRefs, suffix		//order of cmd and resp lists should be paired. results saved as respRef + suffix		Variable i, cmdBaseline; String currRef, outRef, outRefsList = ""	for (i=0;i<ItemsInList(cmdRefs);i+=1)		Duplicate/O $StringFromList(i, cmdRefs), cmdTemp		currRef = StringFromList(i, respRefs)		outRef =  currRef + suffix		outRefsList += outRef + ";"		Duplicate/O $currRef, $outRef/WAVE=currWv		cmdBaseline = mean(cmdTemp, cmdBaselineStartX, cmdBaselineEndX)		currWv -= (cmdTemp-cmdBaseline)*r_pipette	endfor		Print "outRefsList = " + outRefsList	return outRefsListend//function wn_bridgeTest(r_pipette0, r_pipette1, origRef_stim, origRef_resp, respRef_bridge, displayFilter [winStartX, winSizeX, outRefs, outParams,bridgeCorrectionOnly])//	String origRef_stim, origRef_resp, respRef_bridge//	Variable displayFilter		//displayResult will make window with filter//	Variable r_pipette0			//pipette resistance (usually judged from zeroeth point on filter//	Variable r_pipette1//	Variable winSizeX, winStartX//	String &outRefs, &outParams		//pass to have listRef and paramsWaveRef stored in these strings//	Variable bridgeCorrectionOnly	//optionally pass as true to stop after bridge correction is performed//	//	Variable filterLenX = 1			//sets size of bins therefore also filter length (in current implementation)//	Variable numNonlinearityBins = 30		//how finely to segment the non-linearity (pairwise plot of predicted and actual voltage response at soma and ped)//	Variable binSpacingX = 0.5		//sets spacing between START of bins averaged to calculate filter, so for 1s bins, 0.5s spaces means 50% overlap//	String windowFuncStr = ""////	if (ParamIsDefault(winStartX))//		winStartX=10//	endif//	if (ParamIsDefault(winSizeX))//		winSizeX=35 //	endif//	//	String outRefs_bridge = respRef_bridge + "_R", outParams_bridge = respRef_bridge + "_P"//	Print/D "outRefs_bridge",outRefs_bridge,"outParams_bridge",outParams_bridge,"Starting wn_bridgeTest. r_pipette0=", r_pipette0//	//	Variable baselineStartX=0, baselineEndX=0.5//	//	if (!stringmatch(origRef_resp,respRef_bridge))//		Duplicate/O $origRef_resp, $respRef_bridge//	else			//perform bridge correction on input wave. MODIFIES ORIGINAL//		respRef_bridge = origRef_resp//	endif//	//	WAVE/D out = $respRef_bridge//	WAVE/D stim = $origRef_stim//	//	Variable stimBaseline = mean(stim, baselineStartX, baselineEndX)//	//	Variable corr_r_pipette0 = !numtype(r_pipette0) && (r_pipette0 != 0)		//r_pipette0 must be real number and non-zero//	if (corr_r_pipette0)//		out -= (stim-stimBaseline)*r_pipette0 			//subtract pipette voltage drop: Vpipette = deltaI * rpipette	//	endif//	Variable corr_r_pipette1 = !numtype(r_pipette1) && (r_pipette1 != 0)		//r_pipette1 must be real number and non-zero//	if (corr_r_pipette1)//		out[1,] -= (stim[p-1]-stimBaseline)*r_pipette1		//subtract pipette voltage drop for one point forward in time	//	endif	////	if (!ParamIsDefault(bridgeCorrectionOnly) && bridgeCorrectionOnly)//		return 0//	endif////	//run corr at soma//	wn_myCorr3(origRef_stim, respRef_bridge, outRefs_bridge, outParams_bridge, filterLenX, binSpacingX, winStartX, winSizeX, numNonlinearityBins, windowFuncStr)//	//run params at soma//	wn_myCorr3Params_v2(outRefs_bridge)	//wn_myCorr3Params(outRefs_bridge)	//	//	if (displayFilter)//		Display/k=1 $(respRef_bridge+"wnf")//	endif//	//	if (!paramIsDefault(outRefs))//		outRefs = outRefs_bridge//	endif//	if (!paramIsDefault(outParams))//		outParams = outParams_bridge//	endif//	//end//wn_bridgeTest()function wn_autoBridge(numBridgeCorrPnts,origRef_stim,origRef_resp,respRef_bridge,displayFilter,bridgeInfoWvRef,compRegStartX,compRegLenX,reloadWaves,[winStartX,winSizeX,outRefs,outParams,bridgeCorrectionOnly])	String origRef_stim, origRef_resp, respRef_bridge	Variable displayFilter		//displayResult will make window with filter	Variable numBridgeCorrPnts			//1 or more to perform correction. 1 == instantaneous filter value 0, 2 == instantenous and next value 0, 3 == ...	String bridgeInfoWvRef		//reference into which to store values used for bridge correction	Variable winSizeX, winStartX	String &outRefs, &outParams		//pass to have listRef and paramsWaveRef stored in these strings	Variable bridgeCorrectionOnly	//optionally pass as true to stop after bridge correction is performed	Variable reloadWaves	//do reload beforehand (Requires access to original abf files in indexed locations in filePanel	Variable compRegStartX,compRegLenX		//region to test model on.. see wn_mycorr3() for more detail		Variable filterLenX = 5		//classically 1	//sets size of bins therefore also filter length (in current implementation)	Variable numNonlinearityBins = 30		//how finely to segment the non-linearity (pairwise plot of predicted and actual voltage response at soma and ped)	Variable binSpacingX = 0.75 //classically 0.5		//sets spacing between START of bins averaged to calculate filter, so for 1s bins, 0.5s spaces means 50% overlap	String windowFuncStr = ""	if (ParamIsDefault(winStartX))		winStartX=10	endif	if (ParamIsDefault(winSizeX))		winSizeX=35 	endif	Variable winEndX = winStartX + winSizeX		if (reloadWaves)		da_fd_loadWavesFromWaveName(origRef_stim+";"+origRef_resp+";",0)	endif		//dc baseline for bridge correction	Variable baselineStartX=0, baselineEndX=0.5		String outRefs_bridge = respRef_bridge + "_R", outParams_bridge = respRef_bridge + "_P"		if (!stringmatch(origRef_resp,respRef_bridge))		Duplicate/O $origRef_resp, $respRef_bridge	else			//perform bridge correction on input wave. MODIFIES ORIGINAL		respRef_bridge = origRef_resp	endif		if (numBridgeCorrPnts > 0)			//get cross-correlation of stim and resp to determine bridge values		Variable windowingUsed = strlen(windowFuncStr) > 0		WAVE/D stimWave = $origRef_stim		Duplicate/O/D/R=(winStartX, winEndX) stimWave, stimWaveNoDC		Variable stimMean = mean(stimWave)		stimWaveNoDC -= stimMean		WAVE/D respWave = $origRef_resp		Duplicate/O/D/R=(winStartX, winEndX) respWave, respWaveNoDC		Variable respMean = mean(respWave)		respWaveNoDC -= respMean		SetScale/P x, 0,DimDelta(stimWave,0), stimWaveNoDC, respWave, respWaveNoDc				avgFilterAndConvolve("stimWaveNoDC", "respWaveNoDC", "filter_TD", "filter_FD", "respPredicted", windowingUsed, 0, filterLenX, binSpacingX, subEachRep = 1, baseSubOutput =1)			WAVE filter_TD		//generated by avgFilterAndConvolve				//determine bridge correction values from first points in cross-correlation		Make/O/D/N=(numBridgeCorrPnts) bridgeInfo_temp		bridgeInfo_temp = filter_TD[p];				WAVE/D out = $respRef_bridge		//save bridge corrected wave here				//perform bridge correction			//find a baseline for changes -- any value will do since there's dc subtraction						wn_autobridge_subtract(out,stimWave,bridgeInfo_temp,baselineStartX,baselineEndX)						endif	if (!ParamIsDefault(bridgeCorrectionOnly) && bridgeCorrectionOnly)		return 0	endif	//run corr	wn_myCorr3(origRef_stim,respRef_bridge,outRefs_bridge,outParams_bridge,filterLenX,binSpacingX,winStartX,winSizeX,compRegStartX,compRegLenX,numNonlinearityBins,windowFuncStr)	//if bridge save requested, add bridge ref to refs list and store	if (strlen(bridgeInfoWvRef) > 0)		dl_lblByInd("bridgeInfo_temp",0,"R_vals",1)		Duplicate/O bridgeInfo_temp, $bridgeInfoWvRef		WAVE/T outRefsWv = $outRefs_bridge 		Variable addIndex = dimsizE(outRefsWv,0)		Redimension/N=(addIndex+1) outRefsWv		dl_assignAndLbl_T(outRefsWv, addIndex, bridgeInfoWvRef, "bridgeInfoWvRef")	endif	//run params	wn_myCorr3Params_v2(outRefs_bridge)	//wn_myCorr3Params(outRefs_bridge)			if (displayFilter)		Display/k=1 $(respRef_bridge+"wnf")	endif		if (!paramIsDefault(outRefs))		outRefs = outRefs_bridge	endif	if (!paramIsDefault(outParams))		outParams = outParams_bridge	endif	//	killwaves/Z bridgeInfo_temp	end//wn_autoBridge()function wn_autoBridge_subtract_list(respList,stimList,bridgeInfoWv,stim_baselineStartX,stim_baselineEndX)	String respList, stimList		//ordered list  .. if fewer stims than resps, the last stim is used for all remaining responses	Wave/D bridgeInfoWv	Variable stim_baselineStartX,stim_baselineEndX		//could modify function to take a list of start and end times if they differ across the set		if (itemsinlist(stimList) < 1)		Print "wn_autoBridge_subtract_list(): no stimulus passed! aborting."		return 0	endif		variable i, num = itemsinlist(respList)	Variable numStim = itemsinlist(stimList)	String respRef,stimRef	for (i=0;i<num;i+=1)		respREf = stringfromlist(i,respList)		if (i<numStim)	//if i > numStim			stimRef = stringfromlist(i,stimList)		endif		wn_autoBridge_subtract($respRef,$stimRef,bridgeInfoWv,stim_baselineStartX,stim_baselineEndX)	endforend//run wn_main() or wn_mainc() to calculate bridgeInfoWv, the filter coefficients for the pipette, basically//differs from the bridge balance for a voltage step, which is basically function wn_autoBridge_subtract(respWv,stimWv,bridgeInfoWv,stim_baselineStartX,stim_baselineEndX)	WAVE/D respWv,stimWv		//response adn stimulus waves	WAVE/D bridgeInfoWv			//bridge balance values (resistance values)	Double stim_baselineStartX,stim_baselineEndX		//baseline measurement region		Double stimBaseline = mean(stimWv, stim_baselineStartX, stim_baselineEndX)			Variable i	//subtract bridge values	for (i=0;i<dimsize(bridgeInfoWv,0);i+=1)		respWv[i,inf] -= (stimWv[p-i]-stimBaseline)*bridgeInfoWv[i]		//note:i==0 is instantaneous, i==1 is one point into filter, i==2 two points, etc.	endfor		endfunction/S wn_main(stimRef,somaRef,pedRef,fromPed,numBridgeCorrPnts,compRegStartX,compRegLenX,standInStimRef,[winStartX,winSizeX,suppressDisplay,noReloads])	String stimRef	//stimulus input	Variable fromPed	//pass true if stimulus was input at ped	String somaRef, pedRef		//stim and response, pass empty strings if not recorded at one site	Variable winStartX, winSizeX		//optionally specify	Variable numBridgeCorrPnts		//2 is default for 20 kHz, pass 0 to skip bridge balance	String standInStimRef		//substitute a stim when it wasnt recorded.. or pass "" to use actual stim	Variable suppressDisplay	Variable compRegStartX,compRegLenX		//region to test model on, see wn_mycorr3() for details	Variable noReloads		Variable attemptKillOfSavedWvs = 0	//pass true to kill those waves that have been saved and can be killed (e.g., those not being displayed)	Variable reloadWaves=ParamIsDefault(noReloads) || !noReloads	//very good to do this if using bridge balance!			Variable numBridgeCorrPnts_stimSite=numBridgeCorrPnts, numBridgeCorrPnts_nonStimSite=numBridgeCorrPnts			Variable hasStandInStim = strlen(standInStimRef) > 0		String passedStimRef = SelectString(hasStandInStim , stimRef, standInStimRef)		//default window sizes		if (ParamIsDefault(winStartX))		winStartX=10	endif	if (ParamIsDefault(winSizeX))		winSizeX=35 	endif		if (numtype(compRegStartX))		compRegStartX = winStartX + winSizeX	endif	if (numtype(compRegLenX))		compRegLenX=5	endif		String stimulatedSiteRef="",nonStimulatedSiteRef=""	Variable respAt_S = strlen(somaRef) > 0, respAt_P = strlen(pedRef) > 0, respAt_nonStimSite=0,respAt_stimSite=0	if (fromPed)		stimulatedSiteRef = pedRef		nonStimulatedSiteRef = somaRef		respAt_stimSite = respAt_P		//should always be true?		respAt_nonStimSite = respAt_S		else		//fromSoma		stimulatedSiteRef = somaRef		nonStimulatedSiteRef = pedRef		respAt_stimSite = respAt_S		//should always be true?		respAt_nonStimSite = respAt_P	endif 		//auto name bridge-corrected refs (append "B" is current default)	String analysisRef_stimSite="", analysisRef_nonStimSite=""		//holds stimulus used for analysis, after bridge correction if performed	String bridgeInfoWvRef_stimSite="" , bridgeInfoWvref_nonStimSite=""		//holds reference to values for bridge correction, if performed 	if (numBridgeCorrPnts_stimSite && respAt_stimSite)				analysisRef_stimSite = stimulatedSiteRef + "B"	//appending B avoids altering original ref		bridgeInfoWvRef_stimSite = analysisRef_stimSite + "BRRR"	else		analysisRef_stimSite = stimulatedSiteRef		//no new name if not performing correction	endif	if (numBridgeCorrPnts_nonStimSite && respAt_nonStimSite)			analysisRef_nonStimSite = nonStimulatedSiteRef + "B"	//appending B avoids altering original ref		bridgeInfoWvref_nonStimSite = analysisRef_nonStimSite + "BRRR"	else		analysisRef_nonStimSite = nonStimulatedSiteRef		//no new name if not performing correction	endif		String refsListWv_main="", refsListWv_sec=""		//reference to text wave containing names of waves generated in analysis	String paramsRef_main="", paramsRef_sec=""			//reference to params wave generated in analysis															//stored for main (Stimulated site) and secondary (nonStimulated site)																String diffsParamRef="",fDiffsParamRef="",diffsRefList="",fDiffsRefList=""		//overwritten with auto generated names in call to wn_myCorr3CalcDiffs																String refsListWv_S="", refsListWv_P=""	String paramsRef_S="", paramsRef_P=""		Variable respSites		String refsList_main_str="", refsList_sec_str="", diffRefsList_Str="", fDiffRefsList_str=""	//for saving. note: some end up totally blank for single site analysis	String refsList_soma_str="", refsList_ped_str=""	//same as refsList_main_str,refsList_sec_str but organized by position not site of stim	if (respAt_S && respAt_P)		respSites = 3		//3 dual site				//analyze main site of stimulus		wn_autoBridge(numBridgeCorrPnts_stimSite,passedStimRef,stimulatedSiteRef,stimulatedSiteRef,0,bridgeInfoWvRef_stimSite,compRegStartX,compRegLenX,reloadWaves,winStartX=winStartX,winSizeX=winSizeX,outRefs=refsListWv_main,outParams=paramsRef_main)				//analyze secondary site of stimulus		wn_autoBridge(numBridgeCorrPnts_nonStimSite,passedStimRef,nonStimulatedSiteRef,nonStimulatedSiteRef,0,bridgeInfoWvRef_nonStimSite,compRegStartX,compRegLenX,reloadWaves,winStartX=winStartX,winSizeX=winSizeX,outRefs=refsListWv_sec,outParams=paramsRef_sec)				//differnce calculation on resultant waves (always main - secondary, doesnt matter whether from soma or ped)		wn_myCorr3CalcDiffs(fromPed,refsListWv_main,refsListWv_sec,diffsParamRef=diffsParamRef,fDiffsParamRef=fDiffsParamRef,diffsRefList=diffsRefList,fDiffsRefList=fDiffsRefList)				//for saving primary and secondary site reps in easy access form		refsList_main_str = text_getStrListFromTWave($refsListWv_main,1);refsList_main_str=replacestring(":",refsList_main_str,"_fMainR:")	//change keys to distinguish them		refsList_sec_str = text_getStrListFromTWave($refsListWv_sec,1);refsList_sec_str=replacestring(":",refsList_sec_str,"_fSecR:")		diffRefsList_Str = text_getStrListFromTWave($diffsRefList,1);diffRefsList_Str=replacestring(":",diffRefsList_Str,"_diffR:")		fDiffRefsList_str = text_getStrListFromTWave($fDiffsRefList,1);fDiffRefsList_str=replacestring(":",fDiffRefsList_str,"_fDiffR:")			//a little book keeping		if (fromPed)			refsListWv_S=refsListWv_sec; refsListWv_P=refsListWv_main			paramsRef_S=paramsRef_sec; paramsRef_P=paramsRef_main						refsList_soma_str = refsList_sec_str			refsList_ped_str = refsList_main_str		else			refsListWv_S=refsListWv_main; refsListWv_P=refsListWv_sec			paramsRef_S=paramsRef_main; paramsRef_P=paramsRef_sec							refsList_soma_str = refsList_main_str			refsList_ped_str = refsList_sec_str			endif					if (ParamIsDefault(suppressDisplay) || !suppressDisplay)			wn_disp_pair_g(fromPed, refsListWv_s, refsListWv_p, diffsRefList, fDiffsRefList) //display results		endif			elseif (respAt_S)			respSites = 1		//1 soma only				wn_autoBridge(numBridgeCorrPnts_stimSite,passedStimRef,stimulatedSiteRef,stimulatedSiteRef,0,bridgeInfoWvRef_stimSite,compRegStartX,compRegLenX,reloadWaves,winStartX=winStartX,winSizeX=winSizeX,outRefs=refsListWv_S,outParams=paramsRef_S)				//bridgeRef is not specific to soma; trying to leave open the unlikely possibility that white nosie was injected at one site but only monitored at other				refsList_soma_str = text_getStrListFromTWave($refsListWv_S,1);refsList_soma_str=replacestring(":",refsList_soma_str,"_fMainR:")		refsList_main_str = refsList_soma_str				if (ParamIsDefault(suppressDisplay) || !suppressDisplay)				wn_disp_pair_g(0, refsListWv_s, "", "", "") //display results		endif			elseif (respAt_P)		respSites = 2		//2 ped only				wn_autoBridge(numBridgeCorrPnts_stimSite,passedStimRef,stimulatedSiteRef,stimulatedSiteRef,0,bridgeInfoWvRef_stimSite,compRegStartX,compRegLenX,reloadWaves,winStartX=winStartX,winSizeX=winSizeX,outRefs=refsListWv_P,outParams=paramsRef_P)				refsList_ped_str = text_getStrListFromTWave($refsListWv_P,1);refsList_ped_str=replacestring(":",refsList_soma_str,"_fMainR:")		refsList_main_str = refsList_ped_str				if (ParamIsDefault(suppressDisplay) || !suppressDisplay)			wn_disp_pair_g(fromPed, "", refsListWv_P, "", "")	//display results		endif			else			//neither has reference -- shouldn't happen		respSites = 0		return ""			endif		//handle saving results	String saveInfoStr = ""	saveInfoStr = ReplaceNumberByKey("winStartX", saveInfoStr, winStartX)	saveInfoStr = ReplaceNumberByKey("winSizeX", saveInfoStr, winSizeX)	saveInfoStr = ReplaceNumberByKey("fromPed", saveInfoStr, fromPed)		saveInfoStr = ReplaceNumberByKey("respSites", saveInfoStr, respSites)		saveInfoStr = ReplaceNumberByKey("respAt_stimSite", saveInfoStr, respAt_stimSite)		saveInfoStr = ReplaceNumberByKey("respAt_nonStimSite", saveInfoStr, respAt_nonStimSite)				//bridge info	saveInfoStr = ReplaceNumberByKey("numBridgeCorrPnts_stimSite", saveInfoStr, numBridgeCorrPnts_stimSite)	saveInfoStr = ReplaceNumberByKey("numBridgeCorrPnts_nonStimSite", saveInfoStr, numBridgeCorrPnts_stimSite)			saveInfoStr = ReplaceStringByKey("bridgeInfoWvRef_stimSite", saveInfoStr, bridgeInfoWvRef_stimSite); 	saveInfoStr = ReplaceStringByKey("bridgeInfoWvRef_nonStimSite", saveInfoStr, bridgeInfoWvRef_nonStimSite)		saveInfoStr = ReplaceStringByKey("stimRef", saveInfoStr, stimRef)	saveInfoStr = ReplaceStringByKey("somaRef", saveInfoStr, somaRef)	saveInfoStr = ReplaceStringByKey("pedRef", saveInfoStr, pedRef)	saveInfoStr = ReplaceStringByKey("hasStandInStim", saveInfoStr, num2str(hasStandInStim))	saveInfoStr = ReplaceStringByKey("standInStimRef", saveInfoStr, standInStimRef)		saveInfoStr = ReplaceStringByKey("stimulatedSiteRef", saveInfoStr, stimulatedSiteRef)	saveInfoStr = ReplaceStringByKey("nonStimulatedSiteRef", saveInfoStr, nonStimulatedSiteRef)		//refs list and params list -- both from soma/ped or primary/sec		//single site	saveInfoStr = ReplaceStringByKey("refsListWv_S", saveInfoStr, refsListWv_S);	saveInfoStr = ReplaceStringByKey("refsListWv_P", saveInfoStr, refsListWv_P);	saveInfoStr = ReplaceStringByKey("paramsRef_S", saveInfoStr, paramsRef_S);	saveInfoStr = ReplaceStringByKey("paramsRef_P", saveInfoStr, paramsRef_P);	saveInfoStr = ReplaceStringByKey("refsListWv_fMainR", saveInfoStr, refsListWv_main)	saveInfoStr = ReplaceStringByKey("refsListWv_fSecR", saveInfoStr, refsListWv_sec);	saveInfoStr = ReplaceStringByKey("paramsRef_fMainR", saveInfoStr, paramsRef_main)	saveInfoStr = ReplaceStringByKey("paramsRef_fSecR", saveInfoStr, paramsRef_sec)		//difference refs	saveInfoStr = ReplaceStringByKey("diffsParamRef", saveInfoStr, diffsParamRef)	saveInfoStr = ReplaceStringByKey("fDiffsParamRef", saveInfoStr, fDiffsParamRef)	saveInfoStr = ReplaceStringByKey("diffsRefList", saveInfoStr, diffsRefList); 	saveInfoStr = ReplaceStringByKey("fDiffsRefList", saveInfoStr, fDiffsRefList);		//refs themselves		refsList_main_str="", refsList_sec_str="", diffRefsList_Str="", fDiffRefsList_str	saveInfoStr += refsList_main_str + refsList_sec_str + diffRefsList_Str + fDiffRefsList_str	saveInfoStr = fio_keyedRefsList_addInfo(saveInfoStr)		//adds some info like experiment name		return saveInfoStrend//check an igor symbolic path and create one if need befunction fio_pathCheckAndCreateINB(pathStr, forcePathReset, [full_path])	String pathStr		//name of symbolic path as string	Variable forcePathReset		//pass true to force user prompt to map new path into symbolic path with name pathStr	String &full_path	//optinally pass to save full path into this string		PathInfo/S $pathStr	if (!V_flag || forcePathReset)		Newpath/O $pathStr		if (V_flag)	//V_flag = 1 if setting a new path failed			print "fio_pathCheckAndCreateINB for pathStr="+pathStr+" failed on user prompt to select path"			return 0			endif		PathInfo/S $pathStr	endif		if (!ParamIsdefault(full_path))		full_path = S_path		//S_path created by pathInfo	endif		return 1		//no V_flag from pathinfo, so path is goodendfunction fio_renameFiles(copyNotRename, folderMatchStr, extStr,  fnameMatchStr, replaceThisString, withThisStr)	String folderMatchStr //match str for subfolders to look at , e.g. "*" for all subfolders in selected path (user is prompted for path)	String extStr			//e.g. ".abf", (requires ".")	String fnameMatchStr //match str for files to look at (only files of extension extStr will be considered in any case)	String  replaceThisString, withThisStr //how to rename files	Variable copyNotRename		//0 to change name of original file, 1 to generate a copy under new name, leaving original untouched		NewPath/O temp; PathInfo temp	//start new path, select parent directory	String parentPathStr = S_path	String currPathStr	String foldersList = indexeddir(temp,-1,0)		//gets semi colon delim list of all subfolders	String currFolder, currFileList, currFile, newName		Variable j, i	for (i=0;i<ItemsInList(foldersList);i+=1)		currFolder = StringFromList(i, foldersList)		if (stringmatch(currFolder, folderMatchStr))			currPathStr = parentPathStr + currFolder			NewPath/O temp2, currPathStr			currFileList =  indexedfile(temp2,-1,extStr)			for (j=0;j<itemsInList(currFileList);j+=1)				currFile = StringFromList(j, currFileList)				if (stringmatch(currFile, fNameMatchStr))					newName = ReplaceString(replaceThisString, currFile, withThisStr)					Print "oldname", currFile, "newName",newName					if (copyNotRename)						CopyFile/P=temp2 currFile as newName					else						MoveFile/P=temp2 currFile as newName					endif				endif			endfor		endif	endforend//renameFiles//pulseWv is usually a command wave, e.g., light monitor or current clamp commandfunction analysis_pulseTiming(pulseWv, threshold, usePositiveGoing, outTimingRef, startX, endX,[pulseInfoRef])	Wave pulseWv	Double threshold	Variable usePositiveGoing	String outTimingRef		// x timings, adjust algorithm to use point values	Variable startX, endX //pass -inf and inf for entire wave	String pulseInfoRef		//optionally pass a ref to store pulse info in with pulseStats.. only calculated if passed		Variable edgeParam = usePositiveGoing ? 1 : 2		//edge = 1 for positive-going, 2 for negative going	Variable baseline=mean(pulseWv,0,0.001)		//first ms used to calculate baseline and threshold is presumed a deviation from that	threshold = baseline + threshold		FindLevels/R=(startX, endX)/DEST=$outTimingRef/EDGE=(edgeParam)/Q pulseWv, threshold		if ( !ParamIsDefault(pulseInfoRef) && (strlen(pulseInfoRef) > 0) )		//search for information on pulse ending		Variable numPulseParams=3		duplicate/o $outTimingRef, $pulseInfoRef/wave=pulseInfo		redimension/n=(-1,1+numPulseParams) pulseInfo				Variable preNextPadding=0.005		//really just cant run into preceding or following waves		Variable winStartX,winEndX,i,j		Variable pulseStartX,nextPulseStartX		Variable minEdgeWidthP=5		//used to decide when to look for pulse ON level and as minEdgeWidth parameter for pulseStats		Variable searchStartPadding=minEdgeWidthP*dimdelta(pulseWv,0)		//set minimum width to -- if interested in a pusle shorter than that, change		variable numPulses=dimsize(pulseInfo,0)		Double avgPulseWidth=0,pulseWidth		edgeParam=usePositiveGoing ? 2 : 1	//now looking in reverse dir				for (i=0;i<numPulses;i+=1)			pulseStartX=pulseInfo[i][0]			winStartX=pulseStartX+searchStartPadding			if (i==numPulses-1)		//last pulse				winEndX=endX			else				nextPulseStartX=pulseInfo[i+1][0]				winEndX=nextPulseStartX-preNextPadding			endif						FindLevel/EDGE=(edgeParam)/Q/R=(winStartX,winEndX) pulseWv, threshold						//PulseStats/F=(pulseThresholdProp)/L=(onLevel, offLevel)/M=(minEdgeWidthX)/Q /R=(winStartX,winEndX) pulseWv		//also worked, but this seems slightly more robust and this way the whole function just uses the one command			pulsewidth = v_levelx - pulseStartX					j=1;pulseInfo[i][j]=v_levelx		//important param			j+=1;pulseInfo[i][j]=v_flag			j+=1;pulseInfo[i][j]=pulsewidth									avgPulseWidth+=pulsewidth		endfor				SetDimLabel 1,0,pulseStartX,pulseInfo		SetDimLabel 1,1,pulseEndX,pulseInfo		SetDimLabel 1,2,pulseEndX_flag,pulseInfo		SetDimLabel 1,3,pulseWidth,pulseInfo				avgPulseWidth/=numPulses				return avgPulseWidth		endif		return V_flag //generated by findLevelsend//based on timings in timingWv (from FindLevels/analysis_pulsetiming() ) overlays responses in respWv, each offset to pulse startfunction analysis_disp_pulseResponses(timingWv, respWvRefList, prePulseWinSizeX, postPulseWinSizeX, pulseDCSubLength, winN)	WAVE timingWv	String respWvRefList		//list of wave(s) with responses, e.g., sweep replicates	Double prePulseWinSizeX		//length of time preceding each pulse to show	Double postPulseWinSizeX		//length of time following each pulse to show	Double pulseDCSubLength			//pass non-zero to subtract dc from each pulse response (goes from pulseStart to pulseStart + pulseDCSubLength	String winN		if (!strlen(winN))		winN = NameOfWave(timingWv)	endif		if (!wintype(winN))		display/k=1/N=$winN		winN = S_name	endif		String traceNameBase	Double currZeroTime		Variable respWvNum, pulseNum	Double currPulseTime, currStartP, currEndP, dcVal=0	String currRespRef, currTraceName	for (respWvNum=0;respWvNum<ItemsInList(respWvRefList);respWvNum+=1)		currRespRef = StringFromList(respWvNum, respWvRefList)		WAVE currRespWv = $currRespRef		traceNameBase = currRespRef + "_"		for (pulseNum=0;pulseNum<DimSize(timingWv,0);pulseNum+=1)			currTraceName = traceNameBase + num2str(pulseNum)						currPulseTime = timingWv[pulseNum]			currStartP = x2pnt(currRespWv, currPulseTime-prePulseWinSizeX)			currEndP = x2pnt(currRespWv, currPulseTime+postPulseWinSizeX)						if (pulseDCSubLength != 0)				dcVal = mean(currRespWv,currPulseTime, currPulseTime + pulseDCSubLength)			endif						appendtograph/W=$winN currRespWv[currStartP, currEndP]/TN=$currTraceName			modifygraph/W=$winN offset($currTraceName) = {-currPulseTime,dcVal}		endfor	endforend//pulseStartTimeWv is generated by FindLevels, packed into my analysis_pulseTiming() functionfunction analysis_pulseTimedAvg_old(wvsToAvg, pulseStartTimeWv, prePulseAvgDur, avgLenX, subDC, outRef)	String wvsToAvg		//semi colon delimited list of waves to avg	WAVE pulseStartTimeWv	String outRef	Variable prePulseAvgDur		//duration to avg before sweep, will be set to zero	Variable avgLenX	//lengh to average (position will be pulseStartX - prePulseAvgDur to pulseStartX - prePulseAvgDur + avgLenX	Variable subDC		//pass non-zero to subDC		String currRef = StringFromList(0, wvsToAvg)		Duplicate/O/R=(0,avgLenX) $currRef, $outRef/WAVE=out	out = 0		Variable i,j, count=0, currPulseStartX, currAvgStartX, currMean=0, overallMean = 0		for (i=0;i<ItemsInList(wvsToAvg);i+=1)		currRef = StringFromList(i, wvsToAvg)		WAVE currWv = $currRef		for (j=0;j<DimSize(pulseStartTimeWv,0);j+=1)			currPulseStartX = pulseStartTimeWv[j]			currAvgStartX = currPulseStartX - prePulseAvgDur			if (subDC)				currMean = mean(currWv, currAvgStartX, currPulseStartX)			endif			out += currWv(x+currAvgStartX) - currMean		//add to avg after baseline subtracting			overallMean += currMean			count +=1			endfor	endfor	out /= count	overallMean /= count		String noteStr =  "PULSE-TRIGGERED_AVG_COUNT:" + num2str(count) + ";" + "PULSE-TRIGGERED_AVG_BaselineMean:" + num2str(overallMean) + ";"		note/NOCR out, noteStr		SetScale/P x, -prePulseAvgDur, DimDelta(out,0), out		Print "noteStr",noteStrend//goal is to iterate through all selected files and generate pulse triggered average from each, regardless of whether waves have been loadedfunction/S analysis_fd_pulseTimedAvgs(respChStr,pulseChStr,pulseThreshold,pulseTimeFromRisingPhase,pulseSearchStartX,pulseSearchEndX,prePulseAvgDur,avgLenX,dcSubStartX,dcSubLenX)	String respChStr,pulseChStr	Double pulseThreshold,pulseSearchStartX,pulseSearchEndX,prePulseAvgDur,avgLenX,dcSubStartX,dcSubLenX	Variable pulseTimeFromRisingPhase		WAVE/T sweepsDispList	WAVE fileSelListByNums	String currChanStrList, outRefsList = "", selSweepsList, fPath, respREf, pulseRef, respRefList = "", pulseRefList = ""	Variable isPreloaded; String sweepsToDeleteList = ""		//tracks sweeps that were loaded by this function	Variable file_iter, i, fNum, sweepsDisp_row = 0,currNumSweeps, currSweep	Variable respChNum, pulseChNum	for (file_iter=0;file_iter<DimSize(sweepsDispList,0);file_iter+=1)		fNum = fileSelListByNums[file_iter]		currChanStrList = fd_getChanNameList(fNum, 0)		respChNum = WhichListItem(respChStr, currChanStrList,";",0,0)		pulseChNum = WhichListItem(pulseChStr, currChanStrList,";",0,0)				if ( (respChNum > -1) && (pulseChNum > -1) )			selSweepsList = fd_getSelSweepsListByNums(fNum)			for (i=0;i<ITemsInList(selSweepsList);i+=1)				currSweep = str2num(stringfromlist(i,selSweepsList))				respRef = fd_loadSweep(fNum, respChNum, currSweep, 0, isPreloaded = isPreloaded)		//loads sweeps if not already loaded				if (strlen(respRef) > 1)					respRefList += respRef + ";"				endif				if (!isPreLoaded)					sweepsToDeleteList += respRef + ";"				endif				pulseRef = fd_loadSweep(fNum, pulseChNum, currSweep, 0, isPreloaded = isPreloaded)				if (strlen(pulseRef) > 1)					pulseRefList += pulseRef + ";"				endif				if (!isPreLoaded)					sweepsToDeleteList += pulseRef + ";"				endif							endfor			print "i",i,"respRef", respRef, "pulseRef", pulseRef						if (strlen(respRefList) > 0)				outRefsList += analysis_pulseTimedAvg(respRefList, pulseRefList, "", pulseThreshold, pulseTimeFromRisingPhase, pulseSearchStartX, pulseSearchEndX, prePulseAvgDur, avgLenX, dcSubStartX, dcSubLenX) + ";"			endif		endif					endfor		killWavesByName(sweepsToDeleteList)		return outRefsListend	function/S analysis_pulseTimedAvg_win(respMatchStr, pulseMatchStr, outRef, pulseThreshold, pulseTimeFromRisingPhase, pulseSearchStartX, pulseSearchEndX, prePulseAvgDur, avgLenX, dcSubStartX, dcSubLenX)	String respMatchStr, pulseMatchStr		//paired list of responses and pulses (pulses are for example light monitors or current clamp impulses	String outRef		//ref in which avg will be stored	Double pulseThreshold		//minimum deflection of pulse, see analysis_pulseTiming and FindLevels for details	Variable pulseTimeFromRisingPhase	//use positive-going portion of pulse? 	Double pulseSearchStartX, pulseSearchEndX	//beginning and end of region analyzed for presence of pulses	Double prePulseAvgDur	//how much time before pulse should be included in output average?	Double avgLenX			//length of average (start of average is pulseTime - prePulseAvgDur and end of average is pulseTime - prePulseAvgDur + avgLenX	Double dcSubStartX, dcSubLenX			//pass to subtract the mean of a length of time relative to each pulse before adding to average. NaN for no subtraction, -/+inf for default of from start of average to start of pulse	String currPulseRef		String responsesList = wavelist(respMatchStr,";","WIN:")	String pulsesList = wavelist(pulseMatchStr,";","WIN:")		return analysis_pulseTimedAvg(responsesList, pulsesList, outRef, pulseThreshold, pulseTimeFromRisingPhase, pulseSearchStartX, pulseSearchEndX, prePulseAvgDur, avgLenX, dcSubStartX, dcSubLenX)end//uses analysis_pulseTiming() and analysis_pulseTimedAvg() to make a pulse-timed average for multiple sweeps, where pulse timing may differfunction/S analysis_pulseTimedAvg(responsesList,pulsesList,outRef,pulseThreshold,pulseTimeFromRisingPhase,pulseSearchStartX,pulseSearchEndX,prePulseAvgDur,avgLenX,dcSubStartX,dcSubLenX,[LP_IIR_Freq_order,LP_FIR_info])	String responsesList, pulsesList		//paired list of responses and pulses (pulses are for example light monitors or current clamp impulses	String outRef		//ref in which avg will be stored	Double pulseThreshold		//minimum deflection of pulse, see analysis_pulseTiming and FindLevels for details	Variable pulseTimeFromRisingPhase	//use positive-going portion of pulse? 	Double pulseSearchStartX, pulseSearchEndX	//beginning and end of region analyzed for presence of pulses	Double prePulseAvgDur	//how much time before pulse should be included in output average?	Double avgLenX			//length of average (start of average is pulseTime - prePulseAvgDur and end of average is pulseTime - prePulseAvgDur + avgLenX	Double dcSubStartX		//pass NaN for no subtraction. +/- inf for this and dcSubLenX to get default, which is from start of average (determined by prePulseAvgDur to start of pulse. Otherwise this is time relative to pulse to start average used for sum	Double dcSubLenX			//pass NaN for no subtraction. if +/- inf, this is set to prePulseAvgDur so that baseline mean averaging is from prePulseDur to pulse time												//e.g. pass dcSubStartX = -0.1 to start subtraction 100 ms before pulse	String LP_FIR_info				//optionally pass cut off (hz), reject (hz),numCoefs for FIR filtering. Preferred to IIR because no phase change. ALL RESPONSES MUST HAVE SAME SAMPLING	String LP_IIR_Freq_order		//optionally pass a cut off frequency and order for an IIR low pass filter.. string list item 0 = freq, 1 = filter order 		String currPulseRef, currRespRef = StringFromList(0, responsesList)	String pulseTimingTempRef = "analysis_pulseTimedAvg_temp"		Variable numResps = ItemsInList(responsesList)	String pulseTimeList	= ""		//list of timing of pulses for each pulseWv in pulsesList	String baselineAvgList = ""		//list of baseline values for each pulse response		String exRef=StringFromList(0, responsesList)	if (strlen(outRef) < 1)		//auto-generate name		outRef = getWaveNameBySweeps(exRef, StringFromList(numResps-1, responsesList))	endif		Duplicate/O/R=(0,avgLenX) $currRespRef, $outRef/WAVE=out	//average saved here	out = 0		Variable i,j, count=0	Double currPulseStartX, currAvgStartX, currDCSubStartX, currDCSubEndX, currMean=0, overallMean = 0	Double lpf_freq,lpf_order,lpf_srateAdjustedFreq	String pulseTimeStr,baselineAvgStr	Make/O/D/N=0 coefs		//prepare for filtering whether FIR or IIR is requested		Variable sfreq_hz,fir_endOfBand_hz,fir_startOfRejection_hz,numCoefs,fir_endOfBand,fir_startOfRejection	if (!ParamIsDefault(LP_FIR_info))		fir_endOfBand_hz=str2num(stringfromlist(0,LP_FIR_info))		fir_startOfRejection_hz=str2num(stringfromlist(1,LP_FIR_info))		numCoefs=str2num(stringfromlist(2,LP_FIR_info))		sfreq_hz=1/dimdelta($exRef,0)		fir_endOfBand=fir_endOfBand_hz/sfreq_hz		fir_startOfRejection=fir_startOfRejection_hz/sfreq_hz		make/o/d/n=0 fir_coefs_temp		FilterFIR/LO={fir_endOfBand,fir_startOfRejection,numCoefs}/coef fir_coefs_temp		//generate coefs		print "fir_coefs_temp",fir_coefs_temp	endif			if (!ParamIsDefault(LP_IIR_Freq_order))		lpf_freq = str2num(stringfromlist(0,LP_IIR_Freq_order))		lpf_order = str2num(stringfromlist(1,LP_IIR_Freq_order))	endif		for (i=0;i<numResps;i+=1)		currPulseRef = StringFromList(i, pulsesList)		currRespRef = StringFromList(i, responsesList)				if (!ParamIsDefault(LP_FIR_info))			Duplicate/O $currRespRef, $"analysis_pulseTimedAvg_LP_temp"/WAVE=currRespWv			lpf_srateAdjustedFreq = lpf_freq/(1/dimdelta(currRespWv,0))			//convert cut off freq to proportion of real sampling freq (=1/dimdelta)			FilterfIR/coef=fir_coefs_temp currRespWv					elseif (!ParamIsDefault(LP_IIR_Freq_order))			Duplicate/O $currRespRef, $"analysis_pulseTimedAvg_LP_temp"/WAVE=currRespWv			lpf_srateAdjustedFreq = lpf_freq/(1/dimdelta(currRespWv,0))			//convert cut off freq to proportion of real sampling freq (=1/dimdelta)			FilterIIR/CASC/LO=(lpf_srateAdjustedFreq)/ORD=(lpf_order)/COEF coefs, currRespWv		else			WAVE currRespWv = $currRespRef		endif		//get current pulse timings		Double avgPulseWidth=analysis_pulseTiming($currPulseRef, pulseThreshold, pulseTimeFromRisingPhase, pulseTimingTempRef, pulseSearchStartX, pulseSearchEndX,pulseInfoRef="pulseTA_pulseInfoTemp")	//analysis_pulseTimedAvg_pulseInfo only created to get avg width, not stored		WAVE currPulseTiming = $pulseTimingTempRef		for (j=0;j<DimSize(currPulseTiming,0);j+=1)			currPulseStartX = currPulseTiming[j]			currAvgStartX = currPulseStartX - prePulseAvgDur			if ( (numtype(dcSubStartX) != 2) && (numtype(dcSubLenX) != 2) )		//no dc sub if either input is NaN. +/- inf OK				currDCSubStartX = numtype(currDCSubStartX) == 1 ? currAvgStartX : currPulseStartX + dcSubStartX		//is dcSubStartX inf/-inf? Then set to start of avg, otherwise set to pulseTime - dcSubStartX				currDCSubEndX = numtype(currDCSubEndX) == 1 ? currPulseStartX : currDCSubStartX + dcSubLenX		//is dcSubStartX inf/-inf? Then set to start of avg, otherwise set to currDCSubStartX + dcSubLenX				//Print "i",i,"j",j,"currPulseStartX",currPulseStartX,"currDCSubStartX",currDCSubStartX,"currDCSubEndX",currDCSubEndX				currMean = mean(currRespWv, currDCSubStartX, currDCSubEndX)			endif			out += currRespWv(x+currAvgStartX) - currMean		//add to avg after baseline subtracting, currMean = 0 if 			overallMean += currMean			count +=1							sprintf pulseTimeStr, "%f",currPulseStartX			sprintf baselineAvgStr, "%0.20e",currMean						pulseTimeList+=pulseTimeStr+","			baselineAvgList+=baselineAvgStr+","		endfor		pulseTimeList+="|"		baselineAvgList+="|"	endfor	out /= count	overallMean /= count		//pulseThreshold,pulseTimeFromRisingPhase,pulseSearchStartX,pulseSearchEndX,prePulseAvgDur,avgLenX,dcSubStartX,dcSubLenX,[LP_IIR_Freq_order])	String noteStr =  "pulseTA_COUNT:" + num2str(count) + ";" + "pulseTA_BaselineMean:" + num2str(overallMean) + ";"	noteStr+="pulseTA_PULSELIST:"+sc2c(pulsesList,1)	noteStr+="pulseTA_RESPLIST:"+sc2c(responsesList,1)	noteStr+="pulseTA_pulseSearchStartX:"+num2str(pulseSearchStartX)+";"	noteStr+="pulseTA_pulseSearchEndX:"+num2str(pulseSearchEndX)+";"	noteStr+="pulseTA_prePulseAvgDur:"+num2str(prePulseAvgDur)+";"	noteStr+="pulseTA_avgLenX:"+num2str(avgLenX)+";"	noteStr+="pulseTA_dcSubStartX:"+num2str(dcSubStartX)+";"	noteStr+="pulseTA_dcSubLenX:"+num2str(dcSubLenX)+";"	noteStr+="pulseTA_pulseTimes:"+pulseTimeList+";"	noteStr+="pulseTA_baselineAvgs:"+baselineAvgList+";"		String avgPulseWidthStr	sprintf avgPulseWidthStr, "%0.20f", avgPulseWidth	noteStr+="pulseTA_avgPulseWidth:"+avgPulseWidthStr+";"		if (!Paramisdefault(LP_FIR_info))		noteStr+="pulseTA_LP_FIR_info:"+LP_FIR_info+";"	else		noteStr+="pulseTA_LP_FIR_info:;"	endif	if (!Paramisdefault(LP_IIR_Freq_order))		noteStr+="pulseTA_LP_IIR_Freq_order:"+LP_IIR_Freq_order+";"	else		noteStr+="pulseTA_LP_IIR_Freq_order:;"	endif	note/NOCR out, noteStr		SetScale/P x, -prePulseAvgDur, DimDelta(out,0), out		Print "analysis_pulseTimedAvg(): outRef",outRef,"noteStr",noteStr		killwaves/Z $"analysis_pulseTimedAvg_LP_temp"	return outRefend//uses analysis_pulseTiming() and analysis_pulseTimedAvg() to make a pulse-timed average for multiple sweeps, where pulse timing may differfunction/S analysis_pulseTimedAvg_L(responsesList,pulsesList,out_avg,out_reps,pulseThreshold,pulseTimeFromRisingPhase,pulseSearchStartXList,pulseSearchEndXList,prePulseAvgDur,avgLenX,dcSubStartX,dcSubLenX,[LP_IIR_Freq_order,LP_FIR_info,loadWvOptions,outAppendStr,killAfter,forcePulseTiming,weights,outliers,forcePulseTimingStr,weightStr])	String responsesList,pulsesList		//paired list of responses and pulses (pulses are for example light monitors or current clamp impulses	String out_avg		//ref in which avg will be stored (columns contain different row stats, avg, sd sem etc)	String out_reps		//all excised, baseline subtracted reps	Double pulseThreshold		//minimum deflection of pulse, see analysis_pulseTiming and FindLevels for details	Variable pulseTimeFromRisingPhase	//use positive-going portion of pulse? 	String pulseSearchStartXList, pulseSearchEndXList	//beginning and end of region analyzed for presence of pulses	Double prePulseAvgDur	//how much time before pulse should be included in output average?	Double avgLenX			//length of average (start of average is pulseTime - prePulseAvgDur and end of average is pulseTime - prePulseAvgDur + avgLenX	Double dcSubStartX		//pass NaN for no subtraction. +/- inf for this and dcSubLenX to get default, which is from start of average (determined by prePulseAvgDur to start of pulse. Otherwise this is time relative to pulse to start average used for sum	Double dcSubLenX			//pass NaN for no subtraction. if +/- inf, this is set to prePulseAvgDur so that baseline mean averaging is from prePulseDur to pulse time												//e.g. pass dcSubStartX = -0.1 to start subtraction 100 ms before pulse	String LP_FIR_info				//optionally pass cut off (hz), reject (hz),numCoefs for FIR filtering. Preferred to IIR because no phase change. ALL RESPONSES MUST HAVE SAME SAMPLING	String LP_IIR_Freq_order		//optionally pass a cut off frequency and order for an IIR low pass filter.. string list item 0 = freq, 1 = filter order 	Variable loadWvOptions			//optionally pass to control wave reloading. bitwise bit0: allow reloading, bit1:force reloading (bits 1 ignored if bit 0 not set)	Variable killAfter				//optionally pass (and pass true) to kill waves after	string outAppendStr				//optionally pass a string to append to names..useful when autonaming but trying to analyze different parts of the same file	Wave forcePulseTiming			//optionally pass would-be pulse times in a wave	WAVE/D weights						//optioally apply weights .. for each pulse g	String outliers					//optionally pass a list of pulse indices to ignore (ordered sequentially from 0 to N-1). EAsiest to call the function once on all the data then pick columns from out_reps to remove	String forcePulseTimingStr	//optionally instead of forcePulseTiming wv and pulseList, forcePulseTimingStr can be specify ranges of indices in responsesList that get one set of pulse time strings			//for example: "0~3:0.0734415;4~inf:0.173448,0.473451,0.773454,1.073457,;" gives resonses 0~3 have forcePulseTiming={0.173448} and >=4 have {0.173448,0.473451,0.773454,1.073457}			//as a special case, forcePulseTimingStr without a key and just a list of comma-delimited times will set these pulse times for all responses, so it's nearly redundent with forcePulseTiming in that case but accepts a string input instead			//string handling is by text_strByIndFromKeyRange()	String weightStr					//optionally instead of weights wave pass a string of the same formatting rules as forcePulseTimingStr		if (!paramisdefault(forcePulseTiming))		WAVE/D currPulseTiming = forcePulseTiming	endif		Variable hasWeights = !ParamIsDefault(weights) || !paramIsDefault(weightStr)	String currPulseRef, currRespRef = StringFromList(0, responsesList)	String pulseTimingTempRef = "analysis_pulseTimedAvg_temp"		Variable numResps = ItemsInList(responsesList)	String pulseTimeList	= ""		//list of timing of pulses for each pulseWv in pulsesList	String baselineAvgList = ""		//list of baseline values for each pulse response		Variable attemptWvReload=!ParamIsDefault(loadWvOptions) && (loadWvOptions & 2^0)	Variable forceReload=0,reload	String loadedWvs=""	if (attemptWvReload)		forceReload = (loadWvOptions & 2^1) > 0				reload = forceReload || !Wavesexist(responsesList+pulsesList)		if (reload)			if (igor_is64())				fd_loadAbfFrom32DuringExecution(responsesList+pulsesList,1,1,justRequestedWvs=1)				else				da_fd_loadWavesFromWaveName(responsesList+pulsesList,!forceReload,out_loadedWvList=loadedWvs,atRecSampling=1)			endif		endif	endif		String exRef=StringFromList(0, responsesList)	if (strlen(out_avg) < 1)		//auto-generate names		out_avg = getWaveNameBySweeps(exRef, StringFromList(numResps-1, responsesList))+"A"	endif	if (strlen(out_reps) < 1)		//auto-generate names		out_reps = getWaveNameBySweeps(exRef, StringFromList(numResps-1, responsesList))+"R"	endif			if (!ParamIsDefault(outAppendStr) && (strlen(outAppendStr) > 0) )		out_avg+=outAppendStr		out_reps+=outAppendStr	endif		Duplicate/O/R=(0,avgLenX) $currRespRef, $out_reps/WAVE=reps	//average saved here	reps = nan		Variable i,j, count=0,pulseSearchStartX,pulseSearchEndX	String pulseSearchStartXStr,pulseSearchEndXStr	Double currPulseStartX, currAvgStartX, currDCSubStartX, currDCSubEndX, currMean=0, overallMean = 0	Double lpf_freq,lpf_order,lpf_srateAdjustedFreq	Double delta=dimdelta($exRef,0)	String pulseTimeStr,baselineAvgStr	Make/O/D/N=0 coefs		//prepare for filtering whether FIR or IIR is requested		Variable sfreq_hz,fir_endOfBand_hz,fir_startOfRejection_hz,numCoefs,fir_endOfBand,fir_startOfRejection	if (!ParamIsDefault(LP_FIR_info) && (strlen(LP_FIR_info) > 0))		fir_endOfBand_hz=str2num(stringfromlist(0,LP_FIR_info))		fir_startOfRejection_hz=str2num(stringfromlist(1,LP_FIR_info))		numCoefs=str2num(stringfromlist(2,LP_FIR_info))		sfreq_hz=1/delta		fir_endOfBand=fir_endOfBand_hz/sfreq_hz		fir_startOfRejection=fir_startOfRejection_hz/sfreq_hz		make/o/d/n=0 fir_coefs_temp		FilterFIR/LO={fir_endOfBand,fir_startOfRejection,numCoefs}/coef fir_coefs_temp		//generate coefs	endif			if (!ParamIsDefault(LP_IIR_Freq_order) && (Strlen(LP_IIR_Freq_order) > 0))		lpf_freq = str2num(stringfromlist(0,LP_IIR_Freq_order))		lpf_order = str2num(stringfromlist(1,LP_IIR_Freq_order))	endif		//condition vaiables to fit dimdelta, avoid roundin errors avgLenX dcSubStartX dcSubLenX	prePulseAvgDur = delta*floor(prepulseAvgDur/delta) 	avgLenX = delta*floor(avgLenX/delta)	dcSubStartX = delta*floor(dcSubStartX/delta)	dcSubLenX = delta*floor(dcSubLenX/delta)		String currPulseStr,currWeightStr	for (i=0;i<numResps;i+=1)		currRespRef = StringFromList(i, responsesList)				//set up for searching for pulses (doesnt matter what happens here if forcing pulse timing)		currPulseRef = StringFromList(i, pulsesList)		pulseSearchStartXStr=stringfromlist(i,pulseSearchStartXList)		if ( (i==0) || (strlen(pulseSearchStartXStr) > 0))			pulseSearchStartX = str2num(pulseSearchStartXStr)		endif		pulseSearchEndXStr=stringfromlist(i,pulseSearchEndXList)		if ( (i==0) || (strlen(pulseSearchEndXStr) > 0))			pulseSearchEndX = str2num(pulseSearchEndXStr)		endif								//do low pass filtering if requested -- seems better to do this on the whole wave rather than excised portions, in orde to reduce edge effects		if (!ParamIsDefault(LP_FIR_info) && (strlen(LP_FIR_info) > 0))			Duplicate/O $currRespRef, $"analysis_pulseTimedAvg_LP_temp"/WAVE=currRespWv			lpf_srateAdjustedFreq = lpf_freq/(1/dimdelta(currRespWv,0))			//convert cut off freq to proportion of real sampling freq (=1/dimdelta)			FilterfIR/coef=fir_coefs_temp currRespWv					elseif (!ParamIsDefault(LP_IIR_Freq_order) && (Strlen(LP_IIR_Freq_order) > 0))			Duplicate/O $currRespRef, $"analysis_pulseTimedAvg_LP_temp"/WAVE=currRespWv			lpf_srateAdjustedFreq = lpf_freq/(1/dimdelta(currRespWv,0))			//convert cut off freq to proportion of real sampling freq (=1/dimdelta)			FilterIIR/CASC/LO=(lpf_srateAdjustedFreq)/ORD=(lpf_order)/COEF coefs, currRespWv		else			WAVE currRespWv = $currRespRef		endif				//get current pulse timings		if (!ParamIsDefault(forcePulseTimingStr))		//supercedes all other pulse options			currPulseStr = text_strByIndFromKeyRange(i,forcePulseTimingStr)			make/o/d/n=(itemsinlist(currPulseStr,",")) currPulseTiming			currPulseTiming = str2num(stringfromlist(p,currPulseStr,","))		else		//either forcePulseTiming in which case do nothing or forcePulseTiming is deafult in which case find pulse timing for pulse responses			if (ParamIsDefault(forcePulseTiming))				Double avgPulseWidth=analysis_pulseTiming($currPulseRef, pulseThreshold, pulseTimeFromRisingPhase, pulseTimingTempRef, pulseSearchStartX, pulseSearchEndX,pulseInfoRef="pulseTA_pulseInfoTemp")	//analysis_pulseTimedAvg_pulseInfo only created to get avg width, not stored				WAVE/D currPulseTiming = $pulseTimingTempRef			endif		endif		Variable numPulses=DimSize(currPulseTiming,0)				//set up weights wave if necessary (in case of weightStr being passed)		if (hasWeights && !ParamIsDefault(weightStr))			currWeightStr = text_strByIndFromKeyRange(i,weightStr)						make/o/d/n=(itemsinlist(currWeightStr,",")) weights			weights = str2num(stringfromlist(p,currWeightStr,","))		endif				for (j=0;j<numPulses;j+=1)			currPulseStartX = currPulseTiming[j]			currAvgStartX = currPulseStartX - prePulseAvgDur			if ( (numtype(dcSubStartX) != 2) && (numtype(dcSubLenX) != 2) )		//no dc sub if either input is NaN. +/- inf OK				currDCSubStartX = numtype(currDCSubStartX) == 1 ? currAvgStartX : currPulseStartX + dcSubStartX		//is dcSubStartX inf/-inf? Then set to start of avg, otherwise set to pulseTime - dcSubStartX				currDCSubEndX = numtype(currDCSubEndX) == 1 ? currPulseStartX : currDCSubStartX + dcSubLenX		//is dcSubStartX inf/-inf? Then set to start of avg, otherwise set to currDCSubStartX + dcSubLenX				//Print "i",i,"j",j,"currPulseStartX",currPulseStartX,"currDCSubStartX",currDCSubStartX,"currDCSubEndX",currDCSubEndX				currMean = mean(currRespWv, currDCSubStartX, currDCSubEndX)			endif			//out += currRespWv(x+currAvgStartX) - currMean		//add to avg after baseline subtracting, currMean = 0 if 			overallMean += currMean			count +=1				redimension/n=(-1,count) reps			//print dimsize(reps,0),dimdelta(reps,0),dimoffset(reps,0),dimoffset(reps,0)+dimsize(reps,0)*dimdelta(reps,0)			//print dimsize(currRespWv,0),dimdelta(currRespWv,0),dimoffset(currRespWv,0),dimoffset(currRespWv,0)+dimsize(currRespWv,0)*dimdelta(currRespWv,0)			//print "currAvgStartX",currAvgStartX			if (hasWeights)				reps[][count-1]=(currRespWv(x+currAvgStartX) - currMean)*weights[j]			else				reps[][count-1]=currRespWv(x+currAvgStartX) - currMean				endif					sprintf pulseTimeStr, "%f",currPulseStartX			sprintf baselineAvgStr, "%0.20e",currMean			SetDimLabel 1,count-1,$(nameofwave(currRespWv)+"_r"+num2str(j)),reps						pulseTimeList+=pulseTimeStr+","			baselineAvgList+=baselineAvgStr+","		endfor		pulseTimeList+="|"		baselineAvgList+="|"	endfor	overallMean /= count		setscale/p x,-prePulseAvgDur,dimdelta(reps,0),"s",reps		//remove outliers if needed	string outliersNoteStr=""	if (!PAramIsDefault(outliers))			//go from highest column to lowest column in sorted list to avoid changing indices during deletion		String list = sortlist(text_removeStringListDuplicates(outliers,";"),";",2)		Variable numOutliers=itemsinlist(list),ind		for (i=numOutliers-1;i>=0;i-=1)			ind=str2num(stringfromlist(i,list))			print ind			deletepoints/m=1 ind,1,reps		endfor	endif		//AVERAGE ACROSS COLUMNS	wave_colStats(reps,0,inf,0,inf,out_avg)		String noteStr =  "pulseTA_COUNT:" + num2str(count) + ";" + "pulseTA_BaselineMean:" + num2str(overallMean) + ";"	noteStr+="pulseTA_PULSELIST:"+sc2c(pulsesList,1)	noteStr+="pulseTA_RESPLIST:"+sc2c(responsesList,1)	noteStr+="pulseTA_pulseSearchStartX:"+num2str(pulseSearchStartX)+";"	noteStr+="pulseTA_pulseSearchEndX:"+num2str(pulseSearchEndX)+";"	noteStr+="pulseTA_prePulseAvgDur:"+num2str(prePulseAvgDur)+";"	noteStr+="pulseTA_avgLenX:"+num2str(avgLenX)+";"	noteStr+="pulseTA_dcSubStartX:"+num2str(dcSubStartX)+";"	noteStr+="pulseTA_dcSubLenX:"+num2str(dcSubLenX)+";"	noteStr+="pulseTA_pulseTimes:"+pulseTimeList+";"	noteStr+="pulseTA_baselineAvgs:"+baselineAvgList+";"	noteStr+="pulseTA_out_avg:"+out_avg+";"	noteStr+="pulseTA_out_reps:"+out_reps+";"	noteStr+="pulseTA_pulseThreshold:"+num2str(pulseThreshold)+";"	noteStr+="pulseTA_pulseTimeFromRisingPhase:"+num2str(pulseTimeFromRisingPhase)+";"	noteStr+="pulseTA_pulseSearchStartXList:"+pulseSearchStartXList+";"	noteStr+="pulseTA_pulseSearchEndXList:"+sc2c(pulseSearchEndXList,1)	noteStr+="pulseTA_pulseTimeFromRisingPhase:"+num2str(pulseTimeFromRisingPhase)+";"	noteStr+="pulseTA_LP_FIR_info:"+selectstring(ParamIsDefault(LP_FIR_info),LP_FIR_info,"")+";"	noteStr+="pulseTA_LP_IIR_Freq_order:"+selectstring(ParamIsDefault(LP_IIR_Freq_order),LP_IIR_Freq_order,"")+";"			//save optional variables	noteStr+="pulseTA_outliers:"+outliersNoteStr+";"	if (!paramIsDefault(loadWvOptions))		noteStr+="pulseTA_loadWvOptions:"+num2str(loadWvOptions)+";"	endif	if (!paramIsDefault(killAfter))		noteStr+="pulseTA_killAfter:"+num2str(killAfter)+";"	endif	if (!paramIsDefault(outAppendStr))		noteStr+="pulseTA_outAppendStr:"+outAppendStr+";"	endif	if (!paramIsDefault(forcePulseTiming))		noteStr+="pulseTA_forcePulseTiming:"+wave_print(forcePulseTiming,",")+";"	endif	if (!paramIsDefault(weights))		noteStr+="pulseTA_weights:"+wave_print(weights,",")+";"	endif		if (!paramIsDefault(forcePulseTimingStr))		noteStr+="pulseTA_forcePulseTimingStr:"+replacestring(";",forcePulseTimingStr,"|")+";"	endif	if (!paramIsDefault(weightStr))		noteStr+="pulseTA_weightStr:"+replacestring(";",weightStr,"|")+";"	endif		String avgPulseWidthStr	sprintf avgPulseWidthStr, "%0.20f", avgPulseWidth	noteStr+="pulseTA_avgPulseWidth:"+avgPulseWidthStr+";"		note/NOCR reps, noteStr	note/nocr $out_avg,noteStr			Print "analysis_pulseTimedAvg(): out_avg",out_avg,"out_reps",out_reps		if (killAfter)		killwavesbyname(responsesList+pulsesList)	endif		return out_avgend//expects keyRangedList to be a strin like "0~4:ahab;5~7:blah;12:what;" returns the value after the colon for the first key range that contains ind (inclusively)//ignores keys that are "nan" "inf" without "~"//inf used with "~" is taken as a number//nan or empty string used before "~" is taken to be -inf, nan or empty string used after "~" is taken to be inf//as a special case, if the first key is an empty string the first item is returned, e.g. ,":what;" returns "what" as does ":what;1~3:blah"//as another special case, if just one item is passed and that item lacks a key, the item is always returned, so "what" returns "what"function/S text_strByIndFromKeyRange(ind,keyRangedList)	Variable ind	String keyRangedList		//handle the first special case: only one item is passed and it lacks a key	Variable numItems=itemsinlist(keyRangedList)	if ( (numItems==1) && !stringmatch(keyRangedList,"*:*"))		return keyRangedList	endif		variable i,minVal,maxVal,isRange,val	STring keyAndItem,key,minStr,maxStr	for (i=0;i<numItems;i+=1)		keyAndItem = stringfromlist(i,keyRangedList)		key = stringfromlist(0,keyAndItem,":")				//handle second special case, just return first item if first key is blank		if ( (i==0) && (strlen(key) < 1) )			return stringfromlist(1,keyAndItem,":")		endif				isRange = stringmatch(key,"*~*")		if (isRange)			minStr = stringfromlist(0,key,"~")			maxStr = stringfromlist(1,key,"~")			minVal = str2num(minStr)			maxVal = str2num(maxStR)			if (numtype(minVal) == 2)		//nan, as would be if minStr == NaN or blank				minVal = -inf			//then convert to - inf			endif			if (numtype(maxVal) == 2)				maxVal = inf		//as for minVal but for max convert to inf			endif			if ( (ind >= minVal) && (ind <= maxVal) )				return stringfromlist(1,keyAndItem,":")			endif		else			val = str2num(key)			if (ind == val)				return stringfromlist(1,keyAndItem,":")			endif		endif	endfor		return ""end//print a wave as a string to a very high precision, delimifunction/S wave_print(wv,delim)	WAVE/Z wv	string delim		if (!waveexists(wv))		return ""	endif		String out="",temp	Variable i,num=numpnts(wv)	for (i=0;i<num;i+=1)		sprintf temp,"%33.33f",wv[i]			out+=temp+delim	endfor		return out	end//based on timings in timingWv (from FindLevels/analysis_pulsetiming() ) overlays responses in respWv, each offset to pulse startfunction analysis_pulseTimedAvg_disp(analysis_pulseTimedAvg_outRef,winN)	String analysis_pulseTimedAvg_outRef,winN		if (!wintype(winN))		display/k=1/N=$winN		winN = S_name	endif		String traceNameBase	Double currZeroTime		String notestr=note($analysis_pulseTimedAvg_outRef)	String respWvRefList=c2sc(stringbykey("pulseTA_RESPLIST",noteStr))	String allPulseTimes=stringbykey("pulseTA_pulseTimes",noteStr),pulseTimes,pulseTimeStr	String allBaselineAvgs=stringbykey("pulseTA_baselineAvgs",noteStr),baselineAvgs,baselineAvgStr	Variable prePulseWinSizeX = numberbykey("pulseTA_prePulseAvgDur",noteStr)	Variable postPulseWinSizeX = numberbykey("pulseTA_avgLenX",noteStr)		Variable numResps=ItemsInList(respWvRefList)	Variable respWvNum, pulseNum,numPulses	Double currPulseTime, currStartP, currEndP, dcVal=0	String currRespRef, currTraceName	for (respWvNum=0;respWvNum<numResps;respWvNum+=1)		currRespRef = StringFromList(respWvNum, respWvRefList)		WAVE currRespWv = $currRespRef		traceNameBase = currRespRef + "_"		pulseTimes=c2sc(stringfromlist(respWvNum,allPulseTimes,"|"))		baselineAvgs=c2sc(stringfromlist(respWvNum,allBaselineAvgs,"|"))		numPulses=itemsinlist(pulseTimes)		for (pulseNum=0;pulseNum<numPulses;pulseNum+=1)			pulseTimeStr=stringfromlist(pulseNum,pulseTimes)			baselineAvgStr=stringfromlist(pulseNum,baselineAvgs)			currPulseTime=str2num(pulseTimeStr)			dcVal=str2num(baselineAvgStr)			currTraceName = traceNameBase + num2str(pulseNum)						currStartP = x2pnt(currRespWv, currPulseTime-prePulseWinSizeX)			currEndP = x2pnt(currRespWv, currPulseTime+postPulseWinSizeX)			appendtograph/W=$winN/c=(-1+2^16,0,0,0.4*2^16) currRespWv[currStartP, currEndP]/TN=$currTraceName			modifygraph/W=$winN offset($currTraceName) = {-currPulseTime,-dcVal}		endfor	endfor		appendtograph/w=$winN/c=(0,0,0) $analysis_pulseTimedAvg_outRefendfunction fd_setWinHook()	Setwindow $winname(0,1) hook(fd_winHook) = fd_winHookendfunction fd_winHook(s)		//set to all fd displays (general puropse)	STRUCT WMWinHookStruct &s		winHook_printName(s)endofunction winHook_printName(s)	STRUCT WMWinHookStruct &s		if (  (s.eventCode == 7)	&& ( (s.eventMod & 2^1) == 0)	)		//cursor moved && shift not down		SVAR/Z winHook_printName_traces		if (!Svar_Exists(winHook_printName_traces))			String/G winHook_printName_traces=""		endif		if (strlen(winHook_printName_traces) < 1)			winHook_printName_traces=""		endif		winHook_printName_traces+=s.tracename+";"		//Print "traceName",s.traceName,"added to winHook_printName_traces"		return 0	endif		return 0endfunction wave_sub(ref0, ref1, ref_out)	String ref0, ref1	String ref_out // pass "" for auto name		WAVE w0 = $ref0	WAVE w1 = $ref1		if (strlen(ref_out) < 1)		text_getInfoFromWaveName_S(ref0, 0, saveRefForAllInfo = "ref0_info")		text_getInfoFromWaveName_S(ref0, 0, saveRefForAllInfo = "ref1_info")		WAVE/T ref0_info, ref1_info		//created above		String chStr0 = ReplaceString("D",ref0_info[3],"")		//remove D from AD#		String chStr1 = ReplaceString("D",ref1_info[3],"")		//remove D from AD#			ref_out = ref0_info[0] + "_" + ref0_info[1] + ref0_info[2] + chStr0 +  "m" + ref1_info[1] + ref1_info[2] + chStr1		Print "subtraction outref: " + ref_out	endif		Duplicate/O w0, $ref_out/WAVE=out	out = w0 - w1	String noteStr = "MATH:SUBTRACTION;" + "INREF:" + ref0 + ";SUBREF:" + ref1 + ";OUTREF:" + ref_out + ";"		end	//fft_power is better than these first pass-attemptsfunction fft_getScaledFFT(wvRef_td, outRef_fd, coefsParsevalOrPhase, removeDC, normToInputLen)	String wvRef_td, outRef_fd	Variable coefsParsevalOrPhase		//0 and 1 give magnitude of fourier transform, 0 is scaled as for fourier transform coefficients, 1 to obey Parseval's theorum. 2 gives phase	Variable removeDC			//pass to have mean of wave subtracted	Variable normToInputLen	//pass to divide output by number of points in input, thus sum of squares across FFT output will equal (average) variance of input (sample).		String refToFFT	if (removeDC)		Duplicate $wvRef_td, wv_nodc_scaledFFT_temp		Variable m = mean(wv_nodc_scaledFFT_temp)		wv_nodc_scaledFFT_temp -= m		refToFFT = nameofwave(wv_nodc_scaledFFT_temp)	else		refToFFT = wvRef_td	endif			fft/dest=fft_temp $refToFFT 	Variable len_td = DimSize($refToFFT,0)		Duplicate/O fft_temp, $outRef_fd/WAVE=out	Redimension/R out		//output will be real		if (coefsParsevalOrPhase < 2)		//magnitude of some sort		out = fft_magForRealInput(fft_temp[p], p, len_td, coefsParsevalOrPhase)	else			//phase		out = imag(r2polar(fft_temp))			//convert to polar, then take the imaginary portion		out[0] = out[1]		//recommended by igor help files, since DC cannot have a phase anyway		Unwrap 2*pi, out		//avoids jumps when extending beyond 360 range	endif			if (normToInputLen)		out /= len_td	endif		//clean up temp waves	KillWAves/Z fft_temp	if (WaveExists(wv_nodc_scaledFFT_temp))		killwaves/z wv_nodc_scaledFFT_temp	endifend function fft_magForRealInput(z, index, len_input, fourierCoeffsOrMatchParseval)	Variable z		//value at frequency in index -- see next	Variable index	//index is index in array, e.g. z = arr[index]	Variable len_input	//number of points in (real) fft input wave	Variable fourierCoeffsOrMatchParseval 	//zero for standard, Igor help file recommended scaling, which gives each point a value as it would be for coefficients in a continuous fourier transform									//one to give each point a value  that will allow the FFT to obey Perseval's theorem, so the overall variance in input and output are equal		Variable mult	//the fft of real waves is one-sided, but most values actually have an equal negative frequency that was not calculated	//and so they should be multipled. The only exception is zero and nyquist frequency (see Fourier Transform help file)		if ( (index == 0) || (index == -2 +  len_input/2) )	//-2 +  len_input/2 is one less than the length of the fft output for a real wave input, so this checks of the input z value has the index of either zero or the nyquist frequency		mult = 1		else		mult = 2	endif		if (!fourierCoeffsOrMatchParseval)		mult /= len_input	endif			return real(r2polar(mult*z))		//convert to polar, then take the real portionend//for discussion about normalization see http://www.igorexchange.com/node/1018 and ctrl + F for Parseval//as of IGor 8, /pars flag makes this easier//NOTE AUTOATMICALLY REMOVING DC BY AVG SUBTRACTIONfunction fft_power(refs,outAvgAndStats,outReps,startX,endX,pntsInSeg,segLenX,overlapProportion,winf,[wv1Dor2D])	String refs						//wvs of same length (or at least containing range startx,endx) to obtain an average power spectrum from	String outAvgAndStats					//place to store resultant power spectra and stats (e.g., variance across bins)	String outReps			//place to store the power spectra of individual bins	.. not stored if "" is passed	Variable startX,endX			//analysis range	Variable pntsInSeg		//length of each bin/segment or NaN to use segLenX	Variable segLenX					//ignored unless points in segment is nan, then pointsInSeg is calculated from this	Variable overlapProportion	//proportion of overlap between bins/segments	String winf 		//see fft for options. a good choice might be "bartlett"	WAVE wv1Dor2D		//override with one or more columns to generate avg from		Variable i,num;	//get N and reference the first wave/col	if (paramIsdefault(wv1dor2d))		num=itemsinlist(refs)		WAVE wv=$stringfromlist(0,refs)	else		num=dimsize(wv1dor2d,1)		WAVE wv=wv1dor2d		refs=nameofwave(wv)	endif		if (numtype(pntsInSeg) != 0)		Variable delta=dimdelta(wv,0)		pntsInSeg = segLenX / delta	endif			if (mod(pntsInSeg,2) != 0)		pntsInSeg -= 1	endif		if (numtype(endX))		endX=pnt2x(wv,dimsize(wv,0)-1)	endif		if (num==0)		num=1		//one column wave likely	endif	Variable overlapPnts=ceil(pntsInSeg*overlapProportion)	Variable startPnt=x2pnt(wv,startx)	Variable endPnt=x2pnt(wv,endX)	Variable finalPnts,finalSegLenX	String ref;	Variable currStartPnt,currEndPnt,currBinCount,totalBinCount=0	for (i=0;i<num;i+=1)		if (ParamIsDefault(wv1dor2d))			ref=stringfromlist(i,refs)			WAVE wv=$ref		else			duplicate/o/free/r=[][i] wv1dor2d,wv			ref="rep"		endif		currBinCount=0		for (currStartPnt=startPnt;(currStartPnt+pntsInSeg-1)<endPnt;currStartPnt+=overlapPnts)			currEndPnt=currStartPnt+pntsInSeg-1			duplicate/o/r=[currStartPnt,currEndPnt]/free wv,tempwv			//print "i",i,"currStartPnt",currStartPnt,"currEndPnt",currEndPnt,"end-start",currEndPnt-currStartPnt,"pnts",dimsize(tempwv,0)			if (strlen(winf) < 1)		//no window function: 				DSPPeriodogram/PARS/Q/nodc=1 tempwv			else						//window function				DSPPeriodogram/PARS/Q/nodc=1/Win=$winf tempwv			endif 						if (totalBinCount==0)				Wave W_Periodogram				duplicate/o/free W_Periodogram,repsTemp				finalPnts=dimsize(tempwv,0)				finalSegLenX=finalPnts*delta			else				concatenate/dl/np=1 {W_Periodogram},repsTemp				setdimlabel 1,i,$(ref+"_"+num2str(currBinCount)),repsTemp					endif				currBinCount+=1		endfor				totalBinCount+=1		endfor  	if  (dimsize(repsTemp,0) <= 1) 		duplicate/o repsTemp,$outAvgAndStats 	else		wave_colStats(repsTemp,0,inf,0,inf,outAvgAndStats)	endif		segLenX = pntsInSeg*delta	String nss="power_fft_"	String noteStr=nss+"inRefs:"+replacestring(";",refs,",")+";"+nss+"outAvgAndStats:"+outAvgAndStats+";"+nss+"outReps:"+outReps+";"+nss+"startX"+num2str(startX)+";"	noteStr+=nss+"endX:"+num2str(endX)+";"+nss+"pntsInSeg:"+num2str(pntsInSeg)+";"+nss+"segLenX:"+num2str(segLenX)+";"+nss+"overlapProportion:"+num2str(overlapProportion)+";"	noteStr+=nss+"winF"+winF+";"+nss+"finalPnts:"+num2str(finalPnts)+";"+nss+"finalSegLenX:"+num2str(finalSegLenX)+";"		if (strlen(outReps) > 0)		duplicate/o repsTemp,$outReps		note/nocr $outReps,noteStr	endif	note/nocr $outAvgAndStats,noteStr		print "fft_power() noteStr",noteStr				return pntsInSegEnd//function wavestatsTest(wv)//	wave wv//	//	wavestats/R=[10,100] wv//end////function wavestatsTest2(wv)//	wave wv//	variable startP = 10//	variable endP = 100//	wavestats/R=[startP,endP] wv//end////function dspperiodogramTest(wv)//	wave wv//	variable startP = 10//	variable endP = 100//	DSPPeriodogram/R=[startP,endP] wv //DSPPeriodogram/R=(startP,endP) wv  --this line causes the same error and again doesn't do so for wavestats//end////function dspperiodogramTest2(wv)//	wave wv//	variable startP = 10//	variable endP = 100//	DSPPeriodogram/R=[(startP),(endP)] wv//end	function/S analysis_multiExpFits(wv, vCmd_t0,winSizeX, positiveGoing, maxNumExps, outRefBase)	WAVE wv	Variable positiveGoing		//direction of cap transient	Variable vCmd_t0, winSizeX	Variable maxNumExps	String outRefBase		//base name for coef wave refs		Variable ampPadding = 0.500*10^-12			//amount by which any exponential fit component peak may be greater than the actual found peak	Variable foldDiffTauSampleInterval = 0				//how much slower tau must be than sampling, e.g. 2 = tau must be twice as slow as the sample interval. seems to strangly affect some waves whose result when this is zero is within the bounds	String ampConstraintStr		//amp must be negative (see below, changed to positive for positive-going steps	Make/O/T tauConstraints = {"K2 > " + num2str(foldDiffTauSampleInterval*DimDelta(wv,0))} 	//tau must be positive (left) and slower than twice the sampling interval (right)	Make/O/T/N=1 ampConstraints	if (positiveGoing)		//positive-going step		ampConstraints[0] =  "K1 > 0"	//constain amplitude to be positive	else		ampConstraints[0] =  "K1 < 0" //constrain to be negative for negative going steps	endif	//find baseline	Variable baselineWinSize = 0.001	Variable baseCurrent = mean(wv, vCmd_t0-baselineWinSize, vCmd_t0)	//find peak of the capacity transient. Want to start fit at this peak, even if it's after t0, because we don't want to fit to values that are lower than and precede the peak	WaveStats/Q/R=(vCmd_t0, vCmd_t0 + winSizeX) wv	Variable peakLoc, peakVal	if (positiveGoing)		//positive going, so peak is a maximum		peakLoc = V_maxloc		peakVal = V_max - baseCurrent	else		peakLoc = V_minloc		//Might have to NVAR in V_minloc and V_maxloc, but not today...		peakVal = V_min - baseCurrent			//at step, all current flowing through access resistance, giving capactive transient. Subtract baseline to get delta for this capacitive current		endif			Variable fitStartX = peakLoc	Variable fitEndX = peakLoc + winSizeX	Variable fitStartP = x2pnt(wv, fitStartX)	Variable fitEndP = x2pnt(wv, fitEndX)		Make/O/D/N=1 coefWave //2 points added to each coef wave before each iteration	Variable/G x0 = fitStartX	Variable V_FitError	Make/O/D/N=(maxNumExps) fitErrorTrackerTemp		//tracks whether each fit generated an error	String out_coefWvList = ""	String coefWaveRefBaseName = outRefBase + "_eC"		VAriable i,j; String currSaveName, currNoteStr	Variable init_amplitude	for (i=0;i<maxNumExps;i+=1)		//update constraints wave		if (i==0)			Concatenate /NP/O/T  {ampConstraints, tauConstraints}, fitConstraintsWave		// /O makes sure fitconstraints is killed not added to		else			Duplicate/O/T ampConstraints, ampConstraintsTemp; ampConstraintsTemp = ReplaceString("K1", ampConstraintsTemp[p], "K" + num2str(1+2*i))			Duplicate/O/T tauConstraints, tauConstraintsTemp; tauConstraintsTemp = ReplaceString("K2", tauConstraintsTemp[p], "K" + num2str(1+2*i + 1))			Concatenate /NP/T  {ampConstraintsTemp, tauConstraintsTemp}, fitConstraintsWave		endif				//update coef wave		Redimension/N=(DimSize(coefWave,0) + 2) coefWave		debug_checkRTErrState(msg="analysis_multiExpFits() BEFORE curve fit on iteration " + num2str(i))		if (i==0)			CurveFit/NTHR=0/W=2/N=1/Q=1 exp_XOffset, kwCWave=coefWave, wv[fitStartP, fitendP] /C=fitConstraintsWave			print "coefs", i, coefwave, x0			init_amplitude = coefwave[1]		//take this initial amplitude as initial guess		elseif(i==1)			CurveFit/NTHR=0/W=2/N=1/Q=1 dblExp_XOffset, kwCWave=coefWave, wv[fitStartP, fitendP] /C=fitConstraintsWave			print "coefs", i, coefwave, x0		else			//use custom fit function for 3 or more exponentials, first generating initial guesses based on Igor's initial findings			coefWave[1+2*i] = coefwave[1 + (2*(i-1)) + 1] /2 //amplitude guess: initial fit amplitude divided across number of potential components			coefwave[1 + (2*(i-1)) + 1] = coefwave[1 + (2*(i-1)) + 1] /2			coefWave[1+2*i + 1] = coefwave[1 + (2*(i-1)) + 1]/2		//tau			print "coefs", i, coefwave, x0			FuncFit/NTHR=0/W=2/N=1/Q=1 myExp, coefWave, wv[fitStartP, fitendP]/C=fitConstraintsWave		endif		debug_checkRTErrState(msg="analysis_multiExpFits() AFTER curve fit on iteration " + num2str(i))		fitErrorTrackerTemp[i] = V_FitError						analysis_sortExpCoefWave(coefWave)		//place components in order of fastest to slowest taus				//for saving waves		String startX_hpp, endX_hpp, x0_hpp		//hpp for high precision print		sprintf startX_hpp, "%.20f", fitStartX		//20 is just more precision than possibly needed		sprintf endX_hpp, "%.20f", fitEndX		//20 is just more precision than possibly needed		sprintf x0_hpp, "%.20f", x0		//20 is just more precision than possibly needed		currNoteStr =  "fitWinStartX:" + startX_hpp + ";fitWinEndX:" + endX_hpp + ";DATAWAVE:" + nameofwave(wv) + ";FIT_x0:" + x0_hpp + ";"		currNoteStr += "fitConstraints:"		for (j=0;j<DimSize(fitConstraintsWave,0);j+=1)			currNoteStr += num2str(j) + "," + fitConstraintsWave[j] + "|"		endfor		currNoteStr += ";"		//ends keyed pair for fitConstraints		Note coefWave, currNoteStr;	Print "currNoteStr",currNoteStr		currSaveName = coefWaveRefBaseName + num2str(i)		out_coefWvList += currSaveName + ";"		Duplicate/O coefWave, $currSaveName			endfor		return out_coefWvListend //analysis_multiExpFits()function/S analysis_makeExpFits(coefWaveList, outRefBase, addToTopGraph, addRealToTopGraph)	String coefWaveList	//semi colon delim list of coef wave refs	String outRefBase	//basis for saving	Variable addToTopGraph, addRealToTopGraph		Variable i, numFits = ItemsInList(coefWaveList)	String currCoefRef, currOutRef, outList = ""		for (i=0;i<numFits;i+=1)		currCoefRef = StringFromList(i, coefwaveList)		currOutRef = currCoefRef + "EF" + num2str(i)		outList += currOutRef + ";"		analysis_makeExpFit($currCoefRef, currOutRef,-1, addToTopGraph, addRealToTopGraph && (i==0),"",0)	endfor	endfunction analysis_plotExpFitAndComps(coefWave, outRef)	WAVE coefWave	String outRef		Variable i, numExps = floor( (DimSize(coefWave,0) - 1) / 2)  		Variable C_int = str2num(stringbykey("C_int",note(coefWave)))	Variable dv = str2num(stringbykey("deltaVoltage",note(coefWave)))		display/k=1	//plot overall fit	analysis_makeExpFit(coefWave, outRef, -1, 1, 1, "plotExpFitComps_infoTemp",dv)	WAVE info_overall = $"plotExpFitComps_infoTemp"		//created by analysis_makeExpFit()	WAVE info_compartmental = $"plotExpFitComps_infoTempECP"	//created by analysis_makeExpFit()		String currAmp, currTau, currCap, c_int_str	String totalAccess, totalMem, cap_compsum	sprintf totalAccess, "%.3e", info_overall[1]	sprintf totalMem, "%.3e", info_overall[2]	sprintf cap_compsum, "%.3e", info_overall[3]	sprintf c_int_str, "%.3e", c_int		String text = "Ra:" + totalAccess + ". Rm:" + totalMem + ". C_int:" + c_int_str + ". Csum:" + cap_compsum + "\r"		//holds textbox output	for (i=0;i<numExps;i+=1)		analysis_makeExpFit(coefWave, outRef + "c" + num2str(i), i, 1, 0, "",NaN)		sprintf currAmp, "%.3e", info_compartmental[0][i]				sprintf currTau, "%.3e", info_compartmental[1][i]		sprintf currCap, "%.3e", info_compartmental[3][i]		text += "A" + num2str(i) + ":" + currAmp + ". T" + num2str(i) + ":" + currTau + ". C" + num2str(i) + ":" + currCap + "\r"	endfor				SetDrawEnv xcoord= abs,ycoord= abs;DelayUpdate	DrawText 100,100,text	end	//for use with analysis_multiExpFitsfunction analysis_makeExpFit(coefWave, outRef, componentNum, addToTopGraph, addRealToTopGraph, infoRef,dv)	WAVE coefWave	String outRef		//name of ref to save fit 	Variable componentNum		//-1 for entire fit, 0 or greater for a different component	Variable addToTopGraph, addRealToTopGraph	String infoRef	//pass non-empty to get analysis on exponential (not component specific)	Variable dv //only needed with infoRef		//get fit info from wave note	String noteStr = note(coefWave)	String origWvRef = StringByKey("DATAWAVE",noteStr); WAVE origWv = $origWvRef	Variable/G x0 = str2num(StringByKey("FIT_x0",noteStr))		//has to be set global for myExp fit function	Variable fitStartX = str2num(StringByKey("fitWinStartX",noteStr))	Variable fitEndX = str2num(StringByKey("fitWinEndX",noteStr))		if (!WaveExists(origWv))		Print origWvRef, WaveExists($origWvRef), !waveexists($origWvRef)		Print "in analysis_makeExpFit() original wave", origWvRef, "could not be found. aborting"		return 0	endif		Duplicate/O/R=(fitStartX, fitEndX) $origWvRef, $outRef/WAVE=out		if (componentNum < 0)		out = myExp(coefWave,x)	else		Double y0 = coefwave[0]		Double amp = coefWave[1+2*componentNum]		Double tau = coefWave[1+2*componentNum+1]		out = myExp({y0,amp,tau},x)		Print "y0",y0,"amp",amp,"tau",tau	endif		if (addToTopGraph)		appendtoGraph/C=(0,0,0) out	endif		if (addRealToTopGraph)		appendtograph $origWvRef		Setaxis bottom, fitStartX, fitEndX; setaxis/A=2 left	endif		if (strlen(infoRef))		String compartmentParamsSaveRef = infoRef + "ECP"		analysis_expFitCellParams(coefWave, dv, fitStartX, infoRef, compartmentParamsSaveRef)		Print "analysis_makeExpFit() is returning fit and compartment refs:", infoRef, compartmentParamsSaveRef 	endifendfunction analysis_fTest_exp(origWv, simpleFitCoefs, complexFitCoefs, paramsOutRef)	WAVE origWv, simpleFitCoefs, complexFitCoefs	String paramsOutRef		//save outputs		String noteStr = note(simpleFitCoefs)	String origWvRef = StringByKey("DATAWAVE",noteStr); WAVE origWv = $origWvRef		analysis_makeExpFit(simpleFitCoefs, "simpleFitWv",-1,0,0,"",0); WAVE simpleFitWv	analysis_makeExpFit(complexFitCoefs, "complexFitWv",-1,0,0,"",0); WAVE complexFitWv		analysis_ftest(origWv, simpleFitWv, complexFitWv, DimSize(simpleFitCoefs,0), DimSize(complexFitCoefs,0),paramsOutReF)endfunction analysis_ftest(origWv, simpleFitWv, complexFitWv, numCoefs_simple, numCoefs_complex, paramsOutRef)	WAVE origWv, simpleFitWv, complexFitWv	Variable numCoefs_simple, numCoefs_complex	String paramsOutRef		//save outputs		Variable fit_lenP = DimSize(simpleFitWv,0)	Variable startX = DimOffset(simpleFitWv,0)	Variable endX = startX + (fit_lenP-1)*DimDelta(simpleFitWv,0)	Duplicate/O/R=(startX,endX) origWv, origWv_fitPortion	matrixop/O sse_simple = sumsqr(simpleFitWv - origWv_fitPortion)		//find sum squared errors	matrixop/O sse_complex = sumsqr(complexFitWv - origWv_fitPortion)		Variable improvement = sse_complex[0] < sse_simple[0]		double f_numer1 = (sse_simple[0] - sse_complex[0])	Double f_numer2 = (numCoefs_complex - numCoefs_simple)	Double f_numer = (sse_simple[0] - sse_complex[0]) / (numCoefs_complex - numCoefs_simple)	Double f_denom = sse_complex[0] / (fit_lenP-numCoefs_complex)	Double f_stat = f_numer/f_denom		Double f_pval = 1 - StatsFCDF(f_stat, numCoefs_complex - numCoefs_simple, fit_lenP-numCoefs_complex) 		Variable numParams = 12	Make/O/D/N=(numParams) $paramsOutRef/WAVE=out	out[0] = f_pval	out[1] = f_stat	out[2] = f_numer	out[3] = f_denom	out[4] = sse_simple[0]	out[5] = sse_complex[0]	out[6] = sse_complex[0] < sse_simple[0]		//is error of more complex less than error of simple?	out[7] = fit_lenP	out[8] = numCoefs_simple	out[9] = numCoefs_complex	out[10] = startX	out[11] = endX		String noteStr = "origRef:" + nameofwave(origWv) +";" + "simpleFitRef:" + nameofwave(simpleFitWv) +";" + "complexFitRef:" + nameofwave(complexFitWv) +";"	Note out, noteStrendfunction graph_autoLegend(matchStr)	String matchStr		String winN = winname(0,1)		Variable i, r, g ,b	String traces = graph_getWaveList(winN, matchStr, "temp", 1, returnTNList=1)	String text = ""	String colorStr, currTrace	for (i=0;i<ItemsInList(traces);i+=1)		currTrace = StringFromList(i,traces)		colorStr = StringByKey("rgb(x)",TraceInfo(winN, currTrace, 0), "=")	//	sscanf colorStr, "(%i,%i,%i)", r,g,b		text += "\\K" + colorStr + currTrace + "\r"	endfor			SetDrawEnv xcoord= abs,ycoord= abs;DelayUpdate	DrawText/W=$winN 100,100,textend//never completed?function analysis_cellParams_S4SA(respRef,breakInTraceRef, subbedSaveRef, cmdRef, overallFitParamsOutRef, paramsOutRef)	String respRef, breakInTraceRef, cmdRef, overallFitParamsOutRef, paramsOutRef	String subbedSaveRef		Double vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step	analysis_cellParams_S_vCmd(cmdRef,  vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step)		analysis_cellParams_s4(respRef,breakInTraceRef, subbedSaveRef,  vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step, overallFitParamsOutRef, paramsOutRef)	end//never completed?function analysis_cellParams_s4(respRef,breakInTraceRef, subbedSaveRef, vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step, overallFitParamsOutRef, paramsOutRef)	String respRef; 		//response to get cell params from	Variable vCmd_t0, vCmd_t1, vCmd_baseline, vCmd_step		//cmd info (use analysis_fastCellParamsTC to input as array	String breakInTraceRef		//(optional) pass "" if none	String subbedSaveRef		//only used if breakInTraceRef is passed	String paramsOutRef		//must be pre-allocated, data will be overwritten. 	String overallFitParamsOutRef		//pass where to store overall fit params output	if (strlen(breakInTraceRef) > 0)		//do sub		Duplicate/O $respRef, $subbedSaveRef/wave=currentResp		WAVE waveToSub = $breakInTraceRef		currentResp -= waveToSub	else		WAVE currentResp = $respRef	endif			Variable fTestPvalThreshold = 0.05	Variable numExpsToAttemptToFit = 4	Variable baselineLenX = 0.01	Variable baselineBuffer = 0.0002	Variable baselineEndX = vCmd_t0 - baselineBuffer	Variable baselineStartX = baselineEndX - baselineLenX	Variable ssWinLenX = baselineLenX	Variable ssWinDelay = 0.05	Variable ssWinStartX = vCmd_t0 + ssWinDelay	Variable ssWinEndX = ssWinStartX + ssWinLenX						Variable stepLength = vCmd_t1 - vCmd_t0		//calcualte step duration to assure that fit window falls within step only  (see fit win size limit below for the use of this)	Variable fitWinSize = .01	Variable deltaVoltage = vCmd_step - vCmd_baseline	Variable baseCurrent = mean(currentResp, baselineStartX,baselineEndX)		Variable ssCurrent = mean(currentResp, ssWinStartX,ssWinEndX)	Variable deltaSSCurrent = ssCurrent - baseCurrent	Variable ssRin = deltaVoltage / deltaSSCurrent							//find peak of the capacity transient. Want to start fit at this peak, even if it's after t0, because we don't want to fit to values that are lower than and precede the peak	variable isNegativeStep = vCmd_step < vCmd_baseline	WaveStats/Q/R=(vCmd_t0, ssWinStartX) currentResp	Variable peakLoc, peakVal	if (isNegativeStep)	//so look for minimum		peakLoc = V_minloc		//Might have to NVAR in V_minloc and V_maxloc, but not today...		peakVal = V_min - baseCurrent			//at step, all current flowing through access resistance, giving capactive transient. Subtract baseline to get delta for this capacitive current	else		peakLoc = V_maxloc		peakVal = V_max - baseCurrent	endif			//model-less access resistance: peak of capacity transient	Variable accessR_noModel = deltaVoltage/peakVal			//only a rough estimate, especially if the peak is incorrectly found (e.g. before going whole cell)	Variable memR_noModel = ( deltaVoltage - (accessR_noModel*ssCurrent) ) / ssCurrent		//model-less capacitance: integral of capacity transient	analysis_capTransIntegration_S2(NameOfWave(currentResp), "cpS4_capParamsTemp",  vCmd_t0, vCmd_baseline, vCmd_step, fitWinSize)	WAVE cpS4_CapParamsTemp; 	Double Q_int = cpS4_CapParamsTemp[0]; String q_int_str; sprintf q_int_str, "%.60f", Q_int	Double C_int = cpS4_CapParamsTemp[1]; String C_int_str; sprintf C_int_str, "%.60f", C_int	String deltaVoltage_str; sprintf deltaVoltage_str, "%.60f", deltaVoltage			//curve fitting for exponentla component parameters	Variable fitStartX = peakLoc	Variable fitEndX = peakLoc + fitWinSize	Variable fitStartP = x2pnt(currentResp, fitStartX)	Variable fitEndP = x2pnt(currentResp, fitEndX)			String coefWvList = analysis_multiExpFits(currentResp, vCmd_t0,fitWinSize, !isNegativeStep, numExpsToAttemptToFit, respRef)		//note capacity transient info in coef wave notes	Variable i	for (i=0;i<ItemsInList(coefWvList);i+=1)		String currNote = note($stringfromlist(i, coefWvList))		currNote += "Q_int:"+q_int_str+";" + "C_int:"+C_int_str+";"+"deltaVoltage:"+deltaVoltage_str+";"		Note/NOCR/K $stringfromlist(i, coefWvList), currNote	endfor		//f-test: which multi-exponential models are statistically justified?	variable numFTestParams = 12 + 2		//f test results are appended to overall model output, and then two additional parameters are calculated and added	Variable origOverallOutputSize	Variable currModelJustified = 1, lastJustifiedModel = 0, sse_reduced, pValBelowCrit; String simpleFitCoefRef, currFitCoefsRef	String currFitComponentParamsRef, fitComponentParamsList = ""		//will track list of fit component params as they are generated. list stored in note for overall fit params	for (i=0;i<ItemsInList(coefWvList);i+=1)		//iterate through coefWvList, one for each model, check if each multi-exponential model is justified over next most simple model		currFitCoefsRef = StringFromList(i,coefWvList)				//handle saving fit component params		currFitComponentParamsRef = currFitCoefsRef +"P"		//for exponential component params		fitComponentParamsList += currFitComponentParamsRef + ","				//run analysis on fit		analysis_expFitCellParams($currFitCoefsRef,deltaVoltage, fitStartX, "cpS4_fitOverallParamsTemp", currFitComponentParamsRef)		WAVE currOverallFitParamsOut = $"cpS4_fitOverallParamsTemp"		//load overall results		origOverallOutputSize = DimSize(currOverallFitParamsOut,0)			//save results and check f test if needed		if (i==0)			//use overall fit params wave as seed for output fit params wave from all fits			Duplicate/O currOverallFitParamsOut, $overallFitParamsOutRef/WAVE=overallFitParamsOut		//add kill later						Print "i==0 start. overallFitParamsOut len = ", dimsize(currOverallFitParamsOut,0)			Redimension/N=(origOverallOutputSize + numFTestParams) overallFitParamsOut		//redimension by so that f test results may be added (or not, for simplest fit model)			overallFitParamsOut[origOverallOutputSize,] = NaN		//make that stuff blank			duplicate/o overallFitParamsOut, firstround		else			//check f test						//check f test			simpleFitCoefRef = StringFromList(i-1,coefWvList)			analysis_fTest_exp(currentResp, $simpleFitCoefRef, $currFitCoefsRef, "cpS4_fTestParamsTemp")			WAVE fTestParamsWv = $"cpS4_fTestParamsTemp";  						//check criteria for justification			currModelJustified = fTestParamsWv[6] && (fTestParamsWv[0] < fTestPvalThreshold)			if ( currModelJustified )		//is error of more complex model less than error of simple model AND pval below criteria?				lastJustifiedModel = i			endif						Concatenate/NP=0 {fTestParamsWv}, currOverallFitParamsOut						//make room for newly calculated parameters			Redimension/N=(DimSize(currOverallFitParamsOut,0) + 2) currOverallFitParamsOut			currOverallFitParamsOut[DimSize(currOverallFitParamsOut,0)-2] = currModelJustified			currOverallFitParamsOut[DimSize(currOverallFitParamsOut,0)-1] = lastJustifiedModel						//append overall fit params wave as new column in overallFitParamsOut			Concatenate/NP=1 {currOverallFitParamsOut}, overallFitParamsOut			//add kill later		endif									endfor		Note overallFitParamsOut, "coefWvList:" + ReplaceString(";",coefWvList,",") + ";COMPONENTPARAMSLIST:" + fitComponentParamsList + ";"		//list is comma delimited		//save parameters	Variable initialNumParams = 35	Make/O/D/N=(initialNumParams) $paramsOutRef/WAVE=out		out[0] = vCmd_t0	out[1] = vCmd_t1	out[2] = vCmd_baseline	out[3] = vCmd_step	out[4] = isNegativeStep	out[5] = fTestPvalThreshold	out[6] = numExpsToAttemptToFit	out[7] = baselineLenX	out[8] = baselineBuffer	out[9] = baselineEndX	out[10] = baselineStartX	out[11] = baselineStartX	out[12] = ssWinLenX	out[13] = ssWinDelay	out[14] = ssWinStartX	out[15] = ssWinEndX	out[16] = stepLength	out[17] = fitWinSize	out[18] = deltaVoltage	out[19] = baseCurrent	out[20] = ssCurrent	out[21] = deltaSSCurrent	out[22] = ssRin	out[23] = peakLoc	out[24] = peakVal	out[25] = accessR_noModel	out[26] = memR_noModel	out[27] = Q_int	out[28] = C_int	out[29] = fitStartX	out[30] = fitEndX	out[31] = fitStartP	out[32] = fitEndP	out[33] = numFTestParams	out[34] = lastJustifiedModel		Print "coef waves = ", coefWvList	end	//analysis_cellparams_s4function/S analysis_getHeaderS4(paramType)	Variable paramType		//0 for output params, 1 for overall fit params, 2 for fit component params		String outRef	Variable initialNumParams	switch (paramType)		case 0: 					outRef = "s4_paramsHeader"			initialNumParams = 35			Make/O/T/N=(initialNumParams) $outRef/WAVE=out						out[0] = "vCmd_t0"			out[1] = "vCmd_t1"			out[2] = "vCmd_baseline"			out[3] = "vCmd_step"			out[4] = "isNegativeStep"			out[5] = "fTestPvalThreshold"			out[6] = "numExpsToAttemptToFit"			out[7] = "baselineLenX"			out[8] = "baselineBuffer"			out[9] = "baselineEndX"			out[10] = "baselineStartX"			out[11] = "baselineStartX"			out[12] = "ssWinLenX"			out[13] = "ssWinDelay"			out[14] = "ssWinStartX"			out[15] = "ssWinEndX"			out[16] = "stepLength"			out[17] = "fitWinSize"			out[18] = "deltaVoltage"			out[19] = "baseCurrent"			out[20] = "ssCurrent"			out[21] = "deltaSSCurrent"			out[22] = "ssRin"			out[23] = "peakLoc"			out[24] = "peakVal"			out[25] = "accessR_noModel"			out[26] = "memR_noModel"			out[27] = "Q_int"			out[28] = "C_int"			out[29] = "fitStartX"			out[30] = "fitEndX"			out[31] = "fitStartP"			out[32] = "fitEndP"			out[33] = "numFTestParams"			out[34] = "lastJustifiedModel"				break;		case 1:			outRef = "s4_overallFitHeader"			initialNumParams = 21			Make/O/T/N=(initialNumParams) $outRef/WAVE=out						//from analysis_expFitCellParams, overallParamsOut[]...			out[0] = "i_peak"			out[1] = "accessR"			out[2] = "memR"			out[3] = "total_qCap"			out[4] = "total_mCap"			out[5] = "numExps"			out[6] = "dimsize(coefwave,0)"				//from analysis_ftest			out[7] = "f_pval"			out[8] = "f_stat"			out[9] = "f_numer"			out[10] = "f_denom"			out[11] = "sse_simple[0]"			out[12] = "sse_complex[0]"			out[13] = "sse_complex[0] < sse_simple[0]"		//is error of more complex less than error of simple?			out[14] = "fit_lenP"			out[15] = "numCoefs_simple"			out[16] = "numCoefs_complex"			out[17] = "startX"			out[18] = "endX"			//from s4 function itself (see for loop)			out[19] = "currModelJustified"			out[20] = "lastJustifiedModel"			break		case 2:			outRef = "s4_componentParamsHeader"			Variable  numComponentParams = 5			Make/O/T/N=(numComponentParams) $outRef/wave=out			out[0] = "c_amp_"			out[1] = "c_tau"				out[2] = "c_q" 						out[3] = "c_qCap" 					out[4] = "c_mCap"		break	endswitch		return outRef		end//never completed?function analysis_expFitCellParams(coefWave, deltaVoltage, fitStartX, overallParamsSaveRef, compartmentParamsSaveRef)	WAVE coefWave; Double deltaVoltage,fitStartX	String overallParamsSaveRef, compartmentParamsSaveRef		Variable i, numExps = floor( (DimSize(coefWave,0) - 1) / 2)  		Variable numOverallParams = 7			Variable numcompartmentParams = 5	Make/O/D/N=(numOverallParams) $overallParamsSaveRef/WAVE=overallParamsOut	Make/O/D/N=(numcompartmentParams, numExps) $compartmentParamsSaveRef/WAVE=compartmentParamsOut		//one row for each param, one column for each exp component			Double i_ss = coefWave[0]		//steady state current (equiv. y0, an offset)	Double i_peak = myExp(coefWave,fitStartX)	Double accessR = deltaVoltage/i_peak	Double memR = ( deltaVoltage - (accessR*i_ss) ) / i_ss	Double c_tau, c_amp, c_q, c_mCap, c_qCap		//current parameters for each component	Double total_mCap=0, total_qCap =0	for (i=0;i<numExps;i+=1)				c_amp = coefWave[1+(2*i)]; compartmentParamsOut[0][i] = c_amp			//component amplitude		c_tau = coefWave[1+(2*i) + 1]	; compartmentParamsOut[1][i] = c_tau		//component tau		c_q = c_amp * c_tau; compartmentParamsOut[2][i] = c_q						//component charge		c_qCap = c_q / deltaVoltage; compartmentParamsOut[3][i] = c_qCap			//component capacitance (assuming it sees all voltage, which it doesn't if multi-exponential!). From Geiger and Jonas (2000)		c_mCap = c_tau * ( (1/accessR) + (1/memR) ); compartmentParamsOut[4][i] = c_mCap			//probably even more meaningless way to measure capacitance for each component. good if numExps = 1				total_qCap += c_qCap		total_mCap += c_mCap	endfor		overallParamsOut[0] = i_peak	overallParamsOut[1] = accessR	overallParamsOut[2] = memR	overallParamsOut[3] = total_qCap	overallParamsOut[4] = total_mCap	overallParamsOut[5] = numExps	overallParamsOut[6] = dimsize(coefwave,0)end//quick way to get matching waves on top graphfunction/S wlist(matchStr)	String matchStr		return wavelist(matchStr,";","WIN:")	end//perform a wave operation and document it in the wave notefunction/S wave_operation_g(operateThisRef, onThisRef, saveRef, operation)	String operateThisRef		//wave to apply in operation, e.g. a wave to subtract	String onThisRef				//wave to apply operation to, e.g. subtract operateThisRef from onThisRef	String saveRef				//ref to save as output, if blank or == onThisRef, overwrites onThisRef. if == operateThisRef, overwrites that, but operation order is not affected (e.g. operateThisRef will not be the wave subtracted FROM)	Variable operation			//see switch statement below for options		WAVE operateThisWv = $operateThisRef	WAVE onThisWv = $onThisRef		if (strlen(saveRef) < 1)		saveRef = onThisRef	endif		if ( stringmatch(saveRef,operateThisRef) || stringmatch(saveRef,onThisRef) )		WAVE outWv = $saveRef		//wave already exists as one of the inputs, no need for duplication	else		Duplicate/O onThisWv, $saveRef/WAVE=outWv	endif		String operationStr	switch (operation)		case 1:	//subtraction			operationStr = "subtraction"			outWv = onThisWv - operateThisWv			break		case 2:	//mult			operationStr = "multiplication"			outWv = onThisWv * operateThisWv			break		case 3:	//div			operationStr = "division"			outWv = onThisWv / operateThisWv			break		case 4:	//power			operationStr = "power"			outWv = onThisWv^operateThisWv			break		case 5:	//mod			operationStr = "modulus"			outWv = mod(onThisWv,operateThisWv)			break		default: //addition: leave 0 unspecified so as to route that here			operationStr = "addition"			outWv = onThisWv + operateThisWv	endswitch				note/nocr outWv, "ORIGREF:" +onThisRef + ";OPERATEDBYREF:"+operateThisRef + ";OPERATIONSTR:"+operationStr + ";"		return saveRefend	function fd_subAChannel_g(fNum, sNum,operateThisChanNum, onThisChanNum, operation)	Variable fNum, sNum		//file number in file panel, sweepNum from sweepsList (NOT sweepsDispList)	Variable operateThisChanNum	//channel num to perform operation with	Variable onThisChanNum //channel num on which operation is performed (e.g. subtraction occurs from this)	//result is fromThisChan = fromThisChan (operation, e.g. -) subThisChanNum	Variable operation //see switch below for options		String outRef = fd_getWaveLoadName(fNum, sNum, onThisChanNum)	String operationRef = fd_getWaveLoadName(fNum, sNum, operateThisChanNum)		Print "outRef", outRef, "operationRef", operationRef		WAVE outWv = $outRef, operationWv = $operationRef	switch (operation)		case 0:		//addition			outWv += operationWv			break		case 1:			outWv -= operationWv			break	endswitch	end//subtract a channel from another channel for a selection of files in file directory (only operates on sweeps selected for loading)//uses fd_subAChannel_g(...); see this for parameter descriptionsfunction fd_subAchannel_fileSel(operateThisChanNum, onThisChanNum, operation)	Variable operateThisChanNum, onThisChanNum, operation	//see fd_subAChannel_g()		WAVE fileSelListByNums		Variable i,j, currFNum, currSNum; string selSweepsList	for (i=0;i<DimSize(fileSelListByNums,0);i+=1)		currFNum = fileSelListByNums[i]		selSweepsList = fd_getSelSweepsListByNums(currFNum)		for (j=0;j<ItemsInList(selSweepsList);j+=1)			currSNum = str2num(StringFromList(j, selSweepsList))			fd_subAChannel_g(currFNum, currSNum,operateThisChanNum, onThisChanNum, operation)		endfor	endforend//returns semi-colon delimited list of indices (aka sweep nums) of selected sweeps from sweepsTracker, through which user selects which sweeps to loadfunction/S fd_getSelSweepsListByNums(fNum)	Variable fNum		WAVE/T sweepsTracker		//associated with fileDirectory stuff, tracks which sweeps should be loaded for each file	String sweepsSelList = sweepsTracker[fNum]		//semi-colon delim, 0 or 1 for unload or load each sweep	return text_whichListItems("1",sweepsSelList,";")	//takes semi-colon 0 or 1 and returns indices for all 1s,endfunction/S fd_getSelFileInfo(infoStr)	String infoStr		//pass a column num or column name		Variable in_num = str2num(infoStr)		Variable fileInfoWaveCol	if (!numtype(in_num))		//returns true for real number, which occurs when infoStr was a number		fileInfoWaveCol = in_num	else		fileInfoWaveCol = findInHeader(infoStr, "fileInfoWaveColumnTitles")	endif		WAVE fileSelListByNums; WAVE/T fileInfoWave		if ( (fileInfoWaveCol < 0) || fileInfoWaveCol > DimSize(fileInfoWave,1) )		return ""	endif			Variable i; String out = ""	for (i=0;i<DimSize(fileSelListByNums,0);i+=1)		out += fileInfoWave[fileSelListByNums[i]][fileInfoWaveCol] + ";"	endfor		return out	endfunction/S text_whichListItems(itemStr, listStr, listSepStr)	String itemStr, listStr, listSepStr		Variable nextIndex	Variable currStartIndex = 0	String out = ""	do		nextIndex = WhichListItem(itemStr, listStr  , listSepStr  , currStartIndex)			//returns -1 if no instances found		if (nextIndex > -1)			out += num2str(nextIndex) + ";"		else			break		endif		currStartIndex = nextIndex  + 1		//next round start from one past most recently found index	while (1)			//break ends loop		return outend	//acts like the stringmatch function but takes a list of matchStrs instead of a single onefunction text_stringmatch_list(str,matchStrList)	String str, matchStrList		variable i	for (i=0;i<itemsinlist(matchStrList);i+=1)		if (stringmatch(str,stringfromlist(i,matchStrList)))			return 1		endif	endfor		return 0endfunction/S text_findMissingListItems(templateList,testList,useAsMatchStrs)	String templateList		//list with required items	String testList			//list that needs these items, any that are in the template and absent here are returned	Variable useAsMatchStrs	//0 for default which is to search for each item in templateList in testList									//1 to check whether there is a match in testList for each item in templateList		variable i,numRequired=itemsinlist(templateList)	String item,out="",matches	for (i=0;i<numRequired;i+=1)		item=stringfromlist(i,templateList)		if (useAsMatchStrs)			matches = listmatch(testList,item)			if (itemsinlist(matches) < 1)				out+=item+";"			endif		else			if (WhichListItem(item,testList) < 0)				out+=item+";"			endif		endif	endfor	return outend		function/S disp_subWaves(subTheseWaves_matchStr,fromTheseWaves_matchStr, baseName, axName, doAppend)	String subTheseWaves_matchStr,fromTheseWaves_matchStr	String baseName //output wave refs are basename_# for each subtraction result	String axName	//axisName for result	Variable doAppend		//pass 0 to skip appending, in which case axName isn't used		String waveListSelectorStr = "WIN:"	//top win	String subTheseWavesList = wavelist(subTheseWaves_matchStr,";",waveListSelectorStr)		String fromTheseWavesList = wavelist(fromTheseWaves_matchStr,";",waveListSelectorStr)			Variable i; String subThisRef, fromThisRef, outList = "", outRef	for (i=0;i<Min( ItemsInList(subTheseWavesList),ItemsInList(fromTheseWavesList) );i+=1)		subThisRef = stringfromlist(i,subTheseWavesList)		fromThisRef = stringfromlist(i,fromTheseWavesList)		WAVE subThisWave = $subThisRef		WAVE fromThisWave = $fromThisRef		outRef = baseName + "_" + num2str(i)		Duplicate/O fromThisWave, $outRef/WAVE=out		out -= subThisWave		note/nocr out, "ORIGREF:" +subThisRef + ";SUBBEDBYREF:"+fromThisRef		outList += outRef + ";"		if (doAppend)			appendtograph/L=$axName out		endif	endfor		print "subbed wave output list", outList	return outList	endfunction/S disp_operateWaves(operateTheseWaves_matchStr,onTheseWaves_matchStr, baseName,operation, axName, doAppend)	String operateTheseWaves_matchStr,onTheseWaves_matchStr	String baseName //output wave refs are basename_# for each subtraction result	String axName	//axisName for result	Variable doAppend		//pass 0 to skip appending, in which case axName isn't used	Variable operation		//see wave_operation_g() for details		String waveListSelectorStr = "WIN:"	//top win	String operateTheseWavesList = wavelist(operateTheseWaves_matchStr,";",waveListSelectorStr)		String onTheseWavesList = wavelist(onTheseWaves_matchStr,";",waveListSelectorStr)			Variable i; String operateThisRef, onThisRef, outList = "", outRef	for (i=0;i<Min( ItemsInList(operateTheseWavesList),ItemsInList(onTheseWavesList) );i+=1)		operateThisRef = stringfromlist(i,operateTheseWavesList)		onThisRef = stringfromlist(i,onTheseWavesList)		outRef = baseName + "_" + num2str(i)		outList += outRef + ";"		wave_operation_g(operateThisRef, onThisRef, outRef, operation)		if (doAppend)			appendtograph/L=$axName $outRef		endif	endfor		print "operatebed wave output list", outList	return outList	endfunction sin_pearsonAnalysis(indWv,startRow,numRows)	Variable startRow,numRows	WAVE/T indWv//sin_refs_main0		//need this in exp 			//also need a symbolic path with literal name sin pointing to the "sin" folder in the "analysis" folder, where all the data is stored		Variable numNLBins=15				Variable i,rows=dimsize(indWv,0),numSinFreqs,j,k,ii	Double pearsonR	String combinedParamRef_S,combinedParamRef_P	String combinedParamRef_pred_S,combinedParamRef_pred_P	String realResps_nodc_S,realResps_nodc_P  //wn_predRespFamNODC_S 	String wn_predFam_S,wn_predFam_P	String outAvgsList_predResp_S,outAvgsList_predResp_P	String basename,list,realRespCombParamsRef_S,outAvgsList_resp_S,outAvgsList_resp_P,loadList=""	string outPearsonParams,realResp,predResp,outNL,outNls_raw_S,outNls_raw_P,outNLs_sinAvg_S,outNLs_sinAvg_P	Variable nlStartX,nlEndX,numParams,resps_S,resps_P,pred_S,pred_P	for (i=startRow;i<(startRow+numRows);i+=1)		if (i >= rows)			break		endif		//load needed waves -- overwrites those in the pxp!		basename = getdimlabel(indWv,0,i)		list=indWv[i]		combinedParamRef_S=stringbykey("combinedParamRef_S",list);loadList+=combinedParamRef_S+";"		//params for real responses at S		combinedParamRef_P=stringbykey("combinedParamRef_P",list);loadList+=combinedParamRef_P+";"		//and ped		combinedParamRef_pred_S=stringbykey("combinedParamRef_pred_S",list);loadList+=combinedParamRef_pred_S+";"		//params for predicted resposnes at S		combinedParamRef_pred_P=stringbykey("combinedParamRef_pred_P",list);loadList+=combinedParamRef_pred_P+";"		//params for predicted responses at P		realResps_nodc_S=c2sc(stringbykey("wn_predRespFamNODC_S",list));loadList+=realResps_nodc_S+";"		//odd/inaccurate key name for the raw baseline subtracted responses		realResps_nodc_P=c2sc(stringbykey("wn_predRespFamNODC_P",list));loadList+=realResps_nodc_P+";"				outAvgsList_resp_S=c2sc(stringbykey("outAvgsList_resp_S",list));loadList+=outAvgsList_resp_S+";"		//sine wave averages for raw data at S		outAvgsList_resp_P=c2sc(stringbykey("outAvgsList_resp_P",list));loadList+=outAvgsList_resp_P+";"		//sine wave averages for raw data at P		wn_predFam_S=c2sc(stringbykey("wn_predFam_S",list));loadList+=wn_predFam_S+";"		//full predicted responses at S		wn_predFam_P=c2sc(stringbykey("wn_predFam_P",list));loadList+=wn_predFam_P+";"		//and ped		outAvgsList_predResp_S=c2sc(stringbykey("outAvgsList_predResp_S",list));loadList+=outAvgsList_predResp_S+";"		//sine wave averages for predicted responses at S		outAvgsList_predResp_P=c2sc(stringbykey("outAvgsList_predResp_P",list));loadList+=outAvgsList_predResp_P+";"		//sine wave averages for predicted responses at P		fio_ibwLoad(loadList,"sin",1)			WAVE/Z combParams_S=$combinedParamRef_S		WAVE/Z combParams_P=$combinedParamRef_P		WAVE/Z combParamsPred_S=$combinedParamRef_pred_S		WAVE/Z combParamsPred_P=$combinedParamRef_pred_P		resps_S=waveexists(combParams_S);resps_P=waveexists(combParams_P);pred_S=waveexists(combParamsPred_S);pred_P=waveexists(combParamsPred_P)		if (resps_S)			wAVE ex=$combinedParamRef_S		else			wAVE ex=$combinedParamRef_P		endif		numSinFreqs=dimsize(ex,1)		numParams=dimsize(ex,0)		nlStartX=numberbykey("nlStartX",list)		nlEndX=numberbykey("nlEndX",list)				if ( (strlen(stringfromlist(0,wn_predFam_S)) < 1) && (strlen(stringfromlist(0,wn_predFam_S)) < 1) )			Print "i",i,"basename",basename,"no pred fam at soma or ped found, skipping"			continue		else			print "i",i,"basename",basename,"combinedParamRef_S",combinedParamRef_S,"combinedParamRef_P",combinedParamRef_P,"combinedParamRef_pred_S",combinedParamRef_pred_S,"combinedParamRef_pred_P",combinedParamRef_pred_P		endif				String assignList=selectstring(resps_S,"",combinedParamRef_S+";")+selectstring(resps_P,"",combinedParamRef_P+";")+selectstring(pred_S,"",combinedParamRef_pred_S+";")+selectstring(pred_P,"",combinedParamRef_pred_P+";")		Variable gain = numberbykey("gain",list); gain = numtype(gain) ? 0 : gain		Variable holding = numberbykey("holding",list); holding = numtype(holding) ? 0 : holding		Variable block = numberbykey("block",list); block = numtype(block) ? 0 : block		print dl_assign_list(assignList,nan,nan,"rawPredPearson",1)	//filed in later, create row now		print dl_assign_list(assignList,nan,nan,"sinAvgPredPearson",1)	//same		print dl_assign_list(assignList,nan,gain,"gain",1)		//fill and create rows now		print dl_assign_list(assignList,nan,holding,"holding",1)		print dl_assign_list(assignList,nan,block,"block",1)				outNls_raw_S="";outNls_raw_P="";outNls_sinAvg_S="";outNls_sinAvg_P=""		//iterate every frequency and calculate a pearson val and a nonlinearity for each wave 		for (j=0;j<numSinFreqs;j+=1)			if (pred_S)				//soma raw first				realResp=stringfromlist(j,realResps_nodc_S)				predResp=stringfromlist(j,wn_predFam_S)				outNL=predResp+"_rnl"		//raw nonlinearity				outNls_raw_S+=outNL+";"				pearsonR = analyzeNL(realResp,predResp,outNL,numNLBins,0,baselineSub=1,startX=nlStartX,endX=nlEndX,noprint=(j>0))						combParams_S[%rawPredPearson][j]=pearsonR				combParamsPred_S[%rawPredPearson][j]=pearsonR				//soma sin avg next				realResp=stringfromlist(j,outAvgsList_resp_S)				predResp=stringfromlist(j,outAvgsList_predResp_S)				outNL=predResp+"_anl"		//avg nonlinearity				outNls_sinAvg_S+=outNL+";"				pearsonR = analyzeNL(realResp,predResp,outNL,numNLBins,0,baselineSub=1,noprint=(j>0))				combParams_S[%sinAvgPredPearson][j]=pearsonR							combParamsPred_S[%sinAvgPredPearson][j]=pearsonR				endif						if (pred_P)				//ped raw first				realResp=stringfromlist(j,realResps_nodc_P)				predResp=stringfromlist(j,wn_predFam_P)				outNL=predResp+"_rnl"		//raw nonlinearity				outNls_raw_P+=outNL+";"				pearsonR = analyzeNL(realResp,predResp,outNL,numNLBins,0,baselineSub=1,startX=nlStartX,endX=nlEndX,noprint=(j>0))						combParams_P[%rawPredPearson][j]=pearsonR				combParamsPred_P[%rawPredPearson][j]=pearsonR				//ped sin avg next				realResp=stringfromlist(j,outAvgsList_resp_P)				predResp=stringfromlist(j,outAvgsList_predResp_P)				outNL=predResp+"_anl"		//avg nonlinearity				outNls_sinAvg_P+=outNL+";"				pearsonR = analyzeNL(realResp,predResp,outNL,numNLBins,0,baselineSub=1,noprint=(j>0))				combParams_P[%sinAvgPredPearson][j]=pearsonR							combParamsPred_P[%sinAvgPredPearson][j]=pearsonR						endif		endfor		//store results		list=selectstring(pred_S,list,replacestringbykey("outNls_raw_S",list,sc2c(outNls_raw_S,1)))		list=selectstring(pred_S,list,replacestringbykey("outNls_sinAvg_S",list,sc2c(outNls_sinAvg_S,1)))		list=selectstring(pred_P,list,replacestringbykey("outNls_raw_P",list,sc2c(outNls_raw_P,1)))		list=selectstring(pred_P,list,replacestringbykey("outNls_sinAvg_P",list,sc2c(outNls_sinAvg_P,1)))		indWv[i]=list	endforendfunction/S fio_ibwLoad_multipleSubfolders(refs,subfolders,rootPathStr,nonExistentOnly)	String refs	//refs to load from each subfolder, matched by semi-colon delimited index. Mutliple refs for the same subfolder can be requested as a comma-delimited refs					//Assumes each (comma and semi colon delimited) item in refs specifies a file name <Stringfromlist(stringfromlist(0,refs,";"),0,",")+".ibw">. can be multiple fo	String subfolders	//for each ref, name of the subfolder to look in	String rootPathStr	//string name of Igor symbolic path to root .. user is prompted if it does not exist	Variable nonExistentOnly		Variable numSubfolders=itemsinlist(subfolders)	if (numSubFolders < 1)		print "fio_ibwLoad_multipleSubfolders() passed subfolder list is empty, aborting"		return ""	endif		pathinfo $rootPathStr	if (!V_flag)		newpath/o/q/m=("select a path to the root folder for subfolder ibw loading with fio_ibwLoad_multipleSubfolders()") $rootPathStr		if (V_flag)			print "fio_ibwLoad_multipleSubfolders() root folder path not set, aborting" 		endif		return ""	endif			String currRefs,subFolder	String allSubFolderFullPaths=indexeddir($rootPathStr,-1,1),subfolderPath	String allSubFolderNames=indexeddir($rootPathStr,-1,0)		Variable i,sfIndex; string missingSubfolders="",loadedWvs=""	for (i=0;i<numSubfolders;i+=1)		subFolder=stringfromlist(i,subFolders)		sfIndex = whichlistitem(subFolder,allSubFolderNames)		if (sfIndex < 0)			missingSubfolders += subfolder +";"			continue		endif		currRefs=c2sc(stringfromlist(i,refs))		if (itemsinlist(currRefs) <1)			print "for subFolder",subFolder,"list item",i,"no files to load listed! skipping"			continue		endif		subfolderPath=stringfromlist(sfIndex,allSubFolderFullPaths)		newpath/o/q/z fio_ibwLoad_multipleSubfolders_temp,subfolderPath		loadedWvs+=fio_ibwLoad(currRefs,"fio_ibwLoad_multipleSubfolders_temp",nonExistentOnly)	endfor	killpath/Z fio_ibwLoad_multipleSubfolders_temp	return loadedWvsendfunction/S fio_ibwLoad(refs,pathStr,nonExistentOnly)	String refs	String pathStr		//string name of Igor symbolic path to file	Variable nonExistentOnly		//avoid blanks	refs = replacestring(";;",refs,";")	Variable i,numRefs=itemsinlist(refs)	String loadName,ref	Variable loaded=0	String loadedWvs="",likelyFailed=""	for (i=0;i<numRefs;i+=1)		ref = stringfromlist(i,refs)		if (strlen(ref) < 1)			continue		endif				if (nonExistentOnly && waveexists($ref))			continue		endif		loadName=ref+".ibw"		loadwave/o/p=$pathStr/q/h loadName		loaded+=V_flag		loadedWvs+=s_wavenames				if (!v_flag)			likelyFailed+=ref+";"		endif	endfor		if (itemsinlist(likelyFailed))		print "fio_ibwLoad failures:",likelyFailed	endif	return loadedWvsendfunction sin_mainc(respChaNum_S,respChanNum_P,stimChanNum,stimFromPed,wn_refs_S,bridgeTypeStr_S,wn_refs_P,bridgeTypeStr_P,doDisplay,streamTags_inclHoldingAndGain,noStreaming)	Variable respChaNum_S,respChanNum_P,stimChanNum	String wn_refs_S,wn_refs_P	Variable stimFromPed	//stim from soma = 0 stim from ped = 1	Variable doDisplay	String streamTags_inclHoldingAndGain	//might be "holding:-30;blockers:1;"	String bridgeTypeStr_S, bridgeTypeStr_P	//how tp perform bridge: if "", gets bridge from wn_refs. if "NONE" then no bridge corr performed. 														//otherwise, assumes bridgeTypeStr_S/P is a reference to pipette resistances as for V(I) bridge correction	Variable noStreaming		//pass 1 for no saving to analysis stream		String matchStr_S="", matchStr_P="", matchStr_stim=""	if (!numtype(respChaNum_S))		matchStr_S = "*AD"+num2str(respChaNum_S)	endif	if (!numtype(respChanNum_P))		matchStr_P = "*AD"+num2str(respChanNum_P)	endif	if (!numtype(stimChanNum))		matchStr_stim = "*AD"+num2str(stimChanNum)	endif		sin_main(matchStr_S,matchStr_P,matchStr_stim,stimFromPed,wn_refs_S,bridgeTypeStr_S,wn_refs_P,bridgeTypeStr_P,doDisplay,streamTags_inclHoldingAndGain,noStreaming)endfunction sin_main(respFamily_S,respFamily_P,stimFamily,stimFromPed,wn_refs_S,bridgeTypeStr_S,wn_refs_P,bridgeTypeStr_P,doDisplay,streamTags_inclHoldingAndGain,noStreaming,[startX_endX_list,killAfter])	String respFamily_S,respFamily_P,stimFamily	String wn_refs_S,wn_refs_P		//refs to wn refs list wave.. used for comparison of real and predicted response, as well as for bridge correction info depending on bridgeTypeStr	Variable stimFromPed	//stim from soma = 0 stim from ped = 1	Variable doDisplay	String streamTags_inclHoldingAndGain	//might be "holding:-30;blockers:1;"	String bridgeTypeStr_S, bridgeTypeStr_P	//how tp perform bridge: if "", gets bridge from wn_refs. if "NONE" then no bridge corr performed. 														//otherwise, assumes bridgeTypeStr_S/P is a reference to pipette resistances as for V(I) bridge correction	Variable killAfter		//optionally pass to kill outputs after. mainly kills sin reps	Variable noStreaming		//pass 1 for no saving to analysis stream	String startX_endX_list			//optionally pass to handle multiple sin stim in the same sweep with different startx endx points .. DOES NOT SUPPORT PREDICTIONS		Variable hasStartXEndX_list = 0	String startX_endX_list_used = ""	if (!ParamIsDefault(startX_endX_list))		hasStartXEndX_list = 1		startX_endX_list_used = startX_endX_list	endif																Variable startX = 3, endX = 11, numSkipCycles=2,numPreCycles=.5,numPostCycles=.5,doPlot=0,saveReps=1	Variable bridge_bsx = 0,bridge_bex=.5		variable respAt_S = itemsinlist(respFamily_S)>0	variable respAt_P = itemsinlist(respFamily_P)>0	Variable respAtBoth = respAt_S && respAt_P	Variable predAt_S = respAt_S && (strlen(wn_refs_S) > 0)	Variable predAt_P = respAt_P && (strlen(wn_refs_P) > 0)	Variable predAtBoth = predAt_S && predAt_P	String nameBase = text_getInfoFromWaveName_S(stringfromlist(0,respFamily_S), 9)		//use up to file num	String listRef_S = "", listRef_P = ""	String wn_pred_refsWv_s = "", wn_pred_refsWv_p = ""		//holds ref to text wave generated by wn_genAndTestPredictions	String pred_sinAvg_listRefs_S="", pred_sinAvg_listRefs_P	=""	//holds ref to text wave generated by running analysis_sinAvg_list on wn_pred_refsWv_s/wn_pred_refsWv_p	String pred_diffParams_S="",pred_fDiffParams_S="",pred_diffParams_P="",pred_fDiffParams_P=""				//holds ref to diff and fold diff params waves for predictions at each site (Relative to actual results)	String sp_diffParams = "", sp_fDiffParams=""		//diff params between soma and ped	String sp_pred_diffParams = "", sp_pred_fDiffParams=""	//diff params between soma and ped predictions		String streamInfoStr = ""		//filled in later -- keyword list pairs of info for this analysis	String streamSaveRefs = ""	//refs to save	String sinListRefsToSave = "",predListRefsToSave=""		//text waves containing refs that need saving	String wnf_S = "", wnf_P = ""	String bridgeRef_S="", bridgeRef_P=""	Variable bridgeFromVInotWN_S, bridgeFromVInotWN_P		//tracks which type of bridge balance was performed. see bridgeTypeStr_S description above for more info		streamInfoStr += "hasStartXEndX_list:"+num2str(hasStartXEndX_list)+";startX_endX_list_used:"+ReplaceString(";",startX_endX_list_used,"|")+";"			//soma	if (respAt_S)		//handle bridge		if (!strlen(bridgeTypeStr_S))		//bridge from wn			bridgeFromVInotWN_S = 0			WAVE/T wn_refsWv_S = $wn_refs_s			bridgeRef_S = wn_refsWV_S[%bridgeInfoWvRef]		elseif (stringmatch(bridgeTypeStr_S,"NONE"))			bridgeFromVInotWN_S = -1			bridgeRef_S = ""		else			bridgeFromVInotWN_S = 1			bridgeRef_S = bridgeTypeStr_S		endif			listRef_S = nameBase + "srs"		//sin refs soma				if (hasStartXEndX_list)			analysis_sinAvg_list_mx(stimFamily,respFamily_S,startX_endX_list_used,numSkipCycles,numPreCycles,numPostCycles,saveReps,listRef_S,doPlot,bridge_bsx,bridge_bex,bridgeRef_S,bridgeFromVInotWN_S)		else			analysis_sinAvg_list(stimFamily,respFamily_S,startX,endX,numSkipCycles,numPreCycles,numPostCycles,saveReps,listRef_S,doPlot,bridge_bsx,bridge_bex,bridgeRef_S,bridgeFromVInotWN_S)		endif				if (predAt_S)			WAVE/T wn_refsWV_S = $wn_refs_S			wnf_S = wn_refsWV_S[%filter_TDSN]			wn_pred_refsWv_s = wn_genAndTestPredictions(wnf_S,stimFamily,respFamily_S,nameBase+"S_","",startX,endX,startX,endX,0)			WAVE/T pred_refs_S = $wn_pred_refsWv_s			pred_sinAvg_listRefs_S = nameBase + "srps"		//sin refs predicted at soma			pred_diffParams_S = nameBase + "spds"				//sin refs predicted real diffs at soma			pred_fDiffParams_S = nameBase + "spfs"				//sin refs predicted real fold diffs at soma			analysis_sinAvg_list(stimFamily,pred_refs_S[%predFamily],startX,endX,numSkipCycles,numPreCycles,numPostCycles,0,pred_sinAvg_listRefs_S,doPlot,NaN,NaN,"",-1)			analysis_sinAvg_getParamDiffs($listRef_S,$pred_sinAvg_listRefs_S,pred_diffParams_S,pred_fDiffParams_S)		endif	endif		//ped	if (respAt_P)		//handle bridge		if (!strlen(bridgeTypeStr_P))		//bridge from wn			bridgeFromVInotWN_P = 0			WAVE/T wn_refsWv_P = $wn_refs_P			bridgeRef_P = wn_refsWV_P[%bridgeInfoWvRef]		elseif (stringmatch(bridgeTypeStr_P,"NONE"))			bridgeFromVInotWN_P = -1			bridgeRef_P = ""		else			bridgeFromVInotWN_P = 1			bridgeRef_P = bridgeTypeStr_P		endif						listRef_P = nameBase + "srp"		//sin refs ped				if (hasStartXEndX_list)			analysis_sinAvg_list_mx(stimFamily,respFamily_P,startX_endX_list_used,numSkipCycles,numPreCycles,numPostCycles,saveReps,listRef_P,doPlot,bridge_bsx,bridge_bex,bridgeRef_P,bridgeFromVInotWN_P)		else			analysis_sinAvg_list(stimFamily,respFamily_P,startX,endX,numSkipCycles,numPreCycles,numPostCycles,saveReps,listRef_P,doPlot,bridge_bsx,bridge_bex,bridgeRef_P,bridgeFromVInotWN_P)		endif				if (predAt_P)			WAVE/T wn_refsWV_P = $wn_refs_P			wnf_P = wn_refsWV_P[%filter_TDSN]			wn_pred_refsWv_P = wn_genAndTestPredictions(wnf_P,stimFamily,respFamily_P,nameBase+"P_","",startX,endX,startX,endX,0)			WAVE/T pred_refs_P = $wn_pred_refsWv_P			pred_sinAvg_listRefs_P = nameBase + "srpp"		//sin refs predicted at ped			pred_diffParams_P = nameBase + "spdp"				//sin refs predicted real diffs at ped			pred_fDiffParams_P = nameBase + "spfp"				//sin refs predicted real fold diffs at ped			analysis_sinAvg_list(stimFamily,pred_refs_P[%predFamily],startX,endX,numSkipCycles,numPreCycles,numPostCycles,0,pred_sinAvg_listRefs_P,doPlot,NaN,NaN,"",-1)			analysis_sinAvg_getParamDiffs($listRef_P,$pred_sinAvg_listRefs_P,pred_diffParams_P,pred_fDiffParams_P)		endif	endif			//calculate soma ped param diffs if needed	if (respAtBoth)		sp_diffParams = nameBase + "sspd"		//sin soma ped diffs		sp_fDiffParams = nameBase + "ssfd"		//sin soma ped fold diffs		analysis_sinAvg_getParamDiffs($listRef_S,$listRef_P,sp_diffParams,sp_fDiffParams)		if (predAtBoth)			sp_pred_diffParams = nameBase + "spbd"		//sin pred at both diff			sp_pred_fDiffParams= nameBase + "spbf"		//sin pred at both fold diff			analysis_sinAvg_getParamDiffs($pred_sinAvg_listRefs_S,$pred_sinAvg_listRefs_P,sp_pred_diffParams,sp_pred_fDiffParams)		endif	endif		//handle streamed info		//text waves	streamSaveRefs +=listRef_S+";"	streamSaveRefs +=listRef_P+";"		//store waves catalogued in these  -- does not store reps!		//at soma	if (respAt_S)		WAVE/T listWv_S = $listRef_S		String outAvgsList_stim_S = listWv_S[%outAvgsList_stim]		streamSaveRefs += outAvgsList_stim_S + ";"		streamInfoStr += "outAvgsList_stim_S:"+sc2c(outAvgsList_stim_S,1)		String outAvgsList_resp_S = listWv_S[%outAvgsList_resp]		streamSaveRefs += outAvgsList_resp_S + ";"		streamInfoStr += "outAvgsList_resp_S:"+sc2c(outAvgsList_resp_S,1)		String combinedParamRef_S = listWv_S[%combinedParamRef]		streamSaveRefs += combinedParamRef_S + ";"		streamInfoStr += "combinedParamRef_S:"+sc2c(combinedParamRef_S,1)	else		streamInfoStr += "outAvgsList_stim_S:;"		streamInfoStr += "outAvgsList_resp_S:;"		streamInfoStr += "combinedParamRef_S:;"	endif			//at ped	if (respAt_P)		WAVE/T listWv_P = $listRef_P		String outAvgsList_stim_P = listWv_P[%outAvgsList_stim]		streamSaveRefs += outAvgsList_stim_P + ";"		streamInfoStr += "outAvgsList_stim_P:"+sc2c(outAvgsList_stim_P,1)		String outAvgsList_resp_P = listWv_P[%outAvgsList_resp]		streamSaveRefs += outAvgsList_resp_P + ";"		streamInfoStr += "outAvgsList_resp_P:"+sc2c(outAvgsList_resp_P,1)		String combinedParamRef_P = listWv_P[%combinedParamRef]		streamSaveRefs += combinedParamRef_P + ";"		streamInfoStr += "combinedParamRef_P:"+sc2c(combinedParamRef_P,1)	else		streamInfoStr += "outAvgsList_stim_P:;"		streamInfoStr += "outAvgsList_resp_P:;"		streamInfoStr += "combinedParamRef_P:;"	endif			//pred at soma	if (predAt_S)				//save sin average responses		WAVE/T predListWv_S = $pred_sinAvg_listRefs_S		String outAvgsList_predStim_S = predListWv_S[%outAvgsList_stim]		streamSaveRefs += outAvgsList_predStim_S + ";"		streamInfoStr += "outAvgsList_predStim_S:"+sc2c(outAvgsList_predStim_S,1)		String outAvgsList_predResp_S = predListWv_S[%outAvgsList_resp]		streamSaveRefs += outAvgsList_predResp_S + ";"		streamInfoStr += "outAvgsList_predResp_S:"+sc2c(outAvgsList_predResp_S,1)		String combinedParamRef_pred_S = predListWv_S[%combinedParamRef]		streamSaveRefs += combinedParamRef_pred_S + ";"		streamInfoStr += "combinedParamRef_pred_S:"+sc2c(combinedParamRef_pred_S,1)								//save wn prediction information		WAVE/T wn_pred_rWv_s = $wn_pred_refsWv_s		String wn_predStimFam_S = wn_pred_rWv_s[%stimFamily]		//save stim family? not sure it's needed but just in case		streamSaveRefs += wn_predStimFam_S  + ";"		streamInfoStr += "wn_predStimFam_S:"+sc2c(wn_predStimFam_S,1)		String wn_predRespFam_S = wn_pred_rWv_s[%respFamily]		//save predicted response family		streamSaveRefs += wn_predRespFam_S + ";"		streamInfoStr += "wn_predRespFam_S:"+sc2c(wn_predRespFam_S,1)		String wn_predStimFamNODC_S = wn_pred_rWv_s[%stimNoDCFamily]		//save NODC stim family		streamSaveRefs += wn_predStimFamNODC_S + ";"		streamInfoStr += "wn_predStimFamNODC_S:"+sc2c(wn_predStimFamNODC_S,1)		String wn_predRespFamNODC_S = wn_pred_rWv_s[%respNoDCFamily]		//save predicted NODC response family		streamSaveRefs += wn_predRespFamNODC_S + ";"		streamInfoStr += "wn_predRespFamNODC_S:"+sc2c(wn_predRespFamNODC_S,1)		String wn_predFam_S = wn_pred_rWv_s[%predFamily]		//save predicted NODC response family		streamSaveRefs += wn_predFam_S + ";"		streamInfoStr += "wn_predFam_S:"+sc2c(wn_predFam_S,1)			String wn_predPairCompFamily_S = wn_pred_rWv_s[%pairCompFamily]		//save predicted NODC response family		streamSaveRefs += wn_predPairCompFamily_S + ";"		streamInfoStr += "wn_predPairCompFamily_S:"+sc2c(wn_predPairCompFamily_S,1)			String wn_predParamWvRef_S = wn_pred_rWv_s[%paramsWvRef]		//save predicted NODC response family		streamSaveRefs += wn_predParamWvRef_S		streamInfoStr += "wn_predParamWvRef_S:"+sc2c(wn_predParamWvRef_S,1)	else		streamInfoStr += "outAvgsList_predStim_S:;"		streamInfoStr += "outAvgsList_predResp_S:;"		streamInfoStr += "combinedParamRef_pred_S:;"					streamInfoStr += "wn_predStimFam_S:;"		streamInfoStr += "wn_predRespFam_S:;"		streamInfoStr += "wn_predStimFamNODC_S:;"		streamInfoStr += "wn_predRespFamNODC_S:;"		streamInfoStr += "wn_predFam_S:;"		streamInfoStr += "wn_predPairCompFamily_S:;"		streamInfoStr += "wn_predParamWvRef_S:;"	endif		if (predAt_P)				//save sin average responses		WAVE/T predListWv_P = $pred_sinAvg_listRefs_P		String outAvgsList_predStim_P = predListWv_P[%outAvgsList_stim]		streamSaveRefs += outAvgsList_predStim_P + ";"		streamInfoStr += "outAvgsList_predStim_P:"+sc2c(outAvgsList_predStim_P,1)		String outAvgsList_predResp_P = predListWv_P[%outAvgsList_resp]		streamSaveRefs += outAvgsList_predResp_P + ";"		streamInfoStr += "outAvgsList_predResp_P:"+sc2c(outAvgsList_predResp_P,1)		String combinedParamRef_pred_P = predListWv_P[%combinedParamRef]		streamSaveRefs += combinedParamRef_pred_P + ";"		streamInfoStr += "combinedParamRef_pred_P:"+sc2c(combinedParamRef_pred_P,1)								//save wn prediction information		WAVE/T wn_pred_rWv_P = $wn_pred_refsWv_P					String wn_predStimFam_P = wn_pred_rWv_P[%stimFamily]		//save stim family? not sure it's needed but just in case		streamSaveRefs += wn_predStimFam_P + ";"		streamInfoStr += "wn_predStimFam_P:"+sc2c(wn_predStimFam_P,1)		String wn_predRespFam_P = wn_pred_rWv_P[%respFamily]		//save predicted response family		streamSaveRefs += wn_predRespFam_P + ";"		streamInfoStr += "wn_predRespFam_P:"+sc2c(wn_predRespFam_P,1)		String wn_predStimFamNODC_P = wn_pred_rWv_P[%stimNoDCFamily]		//save NODC stim family		streamSaveRefs += wn_predStimFamNODC_P + ";"		streamInfoStr += "wn_predStimFamNODC_P:"+sc2c(wn_predStimFamNODC_P,1)		String wn_predRespFamNODC_P = wn_pred_rWv_P[%respNoDCFamily]		//save predicted NODC response family		streamSaveRefs += wn_predRespFamNODC_P + ";"		streamInfoStr += "wn_predRespFamNODC_P:"+sc2c(wn_predRespFamNODC_P,1)		String wn_predFam_P = wn_pred_rWv_P[%predFamily]		//save predicted NODC response family		streamSaveRefs += wn_predFam_P + ";"		streamInfoStr += "wn_predFam_P:"+sc2c(wn_predFam_P,1)			String wn_predPairCompFamily_P = wn_pred_rWv_P[%pairCompFamily]		//save predicted NODC response family		streamSaveRefs += wn_predPairCompFamily_P + ";"		streamInfoStr += "wn_predPairCompFamily_P:"+sc2c(wn_predPairCompFamily_P,1)			String wn_predParamWvRef_P = wn_pred_rWv_P[%paramsWvRef]		//save predicted NODC response family		streamSaveRefs += wn_predParamWvRef_P + ";"		streamInfoStr += "wn_predParamWvRef_P:"+sc2c(wn_predParamWvRef_P,1)	else		streamInfoStr += "outAvgsList_predStim_P:;"		streamInfoStr += "outAvgsList_predResp_P:;"		streamInfoStr += "combinedParamRef_pred_P:;"					streamInfoStr += "wn_predStimFam_P:;"		streamInfoStr += "wn_predRespFam_P:;"		streamInfoStr += "wn_predStimFamNODC_P:;"		streamInfoStr += "wn_predRespFamNODC_P:;"		streamInfoStr += "wn_predFam_P:;"		streamInfoStr += "wn_predPairCompFamily_P:;"		streamInfoStr += "wn_predParamWvRef_P:;"	endif		streamSaveRefs +=pred_sinAvg_listRefs_S+";"	streamSaveRefs +=pred_sinAvg_listRefs_P+";"	streamSaveRefs +=wn_pred_refsWv_S+";"	streamSaveRefs +=wn_pred_refsWv_P+";"		//params waves not catalogued in those text waves	streamSaveRefs +=pred_diffParams_S+";"	streamSaveRefs +=pred_fDiffParams_S+";"	streamSaveRefs +=pred_diffParams_P+";"	streamSaveRefs +=pred_fDiffParams_P+";"	streamSaveRefs +=sp_diffParams+";"	streamSaveRefs +=sp_fDiffParams+";"	streamSaveRefs +=sp_pred_diffParams+";"	streamSaveRefs +=sp_pred_fDiffParams+";"		streamSaveRefs +=wn_refs_S+";"	streamSaveRefs +=wn_refs_P+";"		streamSaveRefs +=wnF_S+";"	streamSaveRefs +=wnF_P+";"	streamSaveRefs +=bridgeTypeStr_S+";"	streamSaveRefs +=bridgeTypeStr_P+";"	streamSaveRefs +=bridgeRef_S+";"	streamSaveRefs +=bridgeRef_P+";"			//write a function to give back a list  based on specific rows -- not sure this is working so its now redundent with above	streamSaveRefs += text_listWvsToStrList(sinListRefsToSave,"0,1,5","","")		//save rows are avgs stim, avg resp, combined params ref	streamSaveRefs += text_listWvsToStrList(predListRefsToSave,"4,5,6","","")		//save rows are predFamily,pairCompFamily,paramsWvRef			streamInfoStr+="startX:"+num2str(startX)+";"	streamInfoStr+="endX:"+num2str(endX)+";"	streamInfoStr+="numSkipCycles:"+num2str(numSkipCycles)+";"	streamInfoStr+="numPreCycles:"+num2str(numPreCycles)+";"	streamInfoStr+="numPostCycles:"+num2str(numPostCycles)+";"	streamInfoStr+="saveReps:"+num2str(saveReps)+";"	streamInfoStr+="stimFromPed:"+num2str(stimFromPed)+";"	streamInfoStr+="respAt_S:"+num2str(respAt_S)+";"	streamInfoStr+="respAt_P:"+num2str(respAt_P)+";"		streamInfoStr+="respAtBoth:"+num2str(respAtBoth)+";"	streamInfoStr+="predAt_S:"+num2str(predAt_S)+";"	streamInfoStr+="predAt_P:"+num2str(predAt_P)+";"		streamInfoStr+="respFamily_S:"+replacestring(";",respFamily_S,",")+";"	streamInfoStr+="respFamily_P:"+replacestring(";",respFamily_P,",")+";"	streamInfoStr+="stimFamily:"+replacestring(";",stimFamily,",")+";"		streamInfoStr+="nameBase:"+nameBase+";"	streamInfoStr+="wn_refs_S:"+wn_refs_S+";"	streamInfoStr+="wn_refs_P:"+wn_refs_P+";"		streamInfoStr+="wnf_S:"+wnf_S+";"	streamInfoStr+="wnf_P:"+wnf_P+";"		streamInfoStr+="bridgeTypeStr_S:"+bridgeTypeStr_S+";"	streamInfoStr+="bridgeTypeStr_P:"+bridgeTypeStr_P+";"	streamInfoStr+="wnf_P:"+wnf_P+";"	streamInfoStr+="wnf_P:"+wnf_P+";"			streamInfoStr+="listRef_S:"+listRef_S+";"	streamInfoStr+="listRef_P:"+listRef_P+";"	streamInfoStr+="wn_pred_refsWv_s:"+wn_pred_refsWv_s+";"	streamInfoStr+="wn_pred_refsWv_p:"+wn_pred_refsWv_p+";"	streamInfoStr+="pred_sinAvg_listRefs_S:"+pred_sinAvg_listRefs_S+";"	streamInfoStr+="pred_sinAvg_listRefs_P:"+pred_sinAvg_listRefs_P+";"		streamInfoStr+="pred_diffParams_S:"+pred_diffParams_S+";"	streamInfoStr+="pred_fDiffParams_S:"+pred_fDiffParams_S+";"	streamInfoStr+="pred_diffParams_P:"+pred_diffParams_P+";"	streamInfoStr+="pred_fDiffParams_P:"+pred_fDiffParams_P+";"	streamInfoStr+="sp_diffParams:"+sp_diffParams+";"	streamInfoStr+="sp_fDiffParams:"+sp_fDiffParams+";"	streamInfoStr+="sp_pred_diffParams:"+sp_pred_diffParams+";"	streamInfoStr+="sp_pred_fDiffParams:"+sp_pred_fDiffParams+";"		streamInfoStr+="streamTags_inclHoldingAndGain:"+replacestring(";",streamTags_inclHoldingAndGain,"|")+";"		streamInfoStr+="bridgeRef_S:"+bridgeRef_S+";"	streamInfoStr+="bridgeRef_P:"+bridgeRef_P+";"	streamInfoStr+="bridgeFromVInotWN_S:"+num2str(bridgeFromVInotWN_S)+";"	streamInfoStr+="bridgeFromVInotWN_P:"+num2str(bridgeFromVInotWN_P)+";"		if (!noStreaming)		fio_stream_saveToStream("sin",nameBase,streamInfoStr,streamTags_inclHoldingAndGain,"",0,streamSaveRefs, 0)	endif		if (doDisplay)				//display results		if (respAtBoth)		//plot both and calc param wave diffs				//cycles plot			analysis_sinAvg_listDisp($listRef_S, 0, 1, 1, 0, 1)		//analysis_sinAvg_listDisp(listWv, newOrAdd, appendReps, appendExampleStim, colorSet, subMean, [addDC])			analysis_sinAvg_listDisp($listRef_P, 1, 1, 1, 1, 1)			if (predAt_S)				analysis_sinAvg_listDisp($pred_sinAvg_listRefs_S,1,0,1,2,1)			endif			if (predAt_P)				analysis_sinAvg_listDisp($pred_sinAvg_listRefs_P,1,0,1,3,1)			endif									//summary params plot			analysis_sinAvg_summaryDisp(listRef_S,0,0,0,nameBase + "sinsum")			analysis_sinAvg_summaryDisp(listRef_P,0,1,1,"")			if (predAt_S)				analysis_sinAvg_summaryDisp(pred_sinAvg_listRefs_S,0,1,2,"")			endif			if (predAt_P)				analysis_sinAvg_summaryDisp(pred_sinAvg_listRefs_P,0,1,3,"")			endif									//summary diffs plot						analysis_sinAvg_summaryDisp(sp_diffParams,2,0,0,nameBase + "sinsumD")			if (predAT_S && predAt_P)				analysis_sinAvg_summaryDisp(sp_pred_diffParams,2,1,1,"")			endif		elseif (respAt_S)				//cycles plot			analysis_sinAvg_listDisp($listRef_S, 0, 1, 1, 0, 1)			if (predAt_S)				analysis_sinAvg_listDisp($pred_sinAvg_listRefs_S,1,0,1,2,1)			endif				//summary params plot			analysis_sinAvg_summaryDisp(listRef_S,0,0,0,nameBase + "sinsum")			if (predAt_S)				analysis_sinAvg_summaryDisp(pred_sinAvg_listRefs_S,0,1,2,"")			endif			else		//resp at ped only				//cycles plot			analysis_sinAvg_listDisp($listRef_P, 0, 1, 1, 0, 1)			if (predAt_P)				analysis_sinAvg_listDisp($pred_sinAvg_listRefs_P,1,0,1,2,1)			endif				//summary params plot			analysis_sinAvg_summaryDisp(listRef_P,0,0,0,nameBase + "sinsum")			if (predAt_P)				analysis_sinAvg_summaryDisp(pred_sinAvg_listRefs_P,0,1,2,"")			endif		endif	endif		if (!ParamIsDefault(killAfter) && killAfter)//		String killList="",ref//		STring refLists = listRef_S+";"+listRef_P+";"//		variable i,j//		for (i=0;i<itemsinlist(refLists);i+=1)//			ref = stringfromlist(i,refLists)//			WAVE/T refWv = $ref//			for (j=0;j<dimsize(refWv,0);j+=1)//				killList += refWv[j] + ";"//			endfor//		endfor	//		//		killwavesbyname(killList)		killwavesbyname(nameBase + "*")	endifend//have one set of sine waves that are long single sweeps with 5 freqs. using this function to match the length fo the parameter waves to my 7 param single sweep onesfunction/s sin_main_matchLong5ToNorm7(long5list)	string long5list		Variable i,num=itemsinlist(long5list)		string inref,appendstr="_sc",outref,outlist=""	for (i=0;i<num;i+=1)		inref = stringfromlist(i,long5list)		outref = inref + appendstr		outlist+=outref + ";"		duplicate/o $inref,$outref/wave=out		•insertpoints/m=1 1,1,out		//make room for 1 hz column		•out[][1] = nan		•insertpoints/m=1 3,2,out		//2.5 and 5 hz column		•out[][3,4] = nan		•insertpoints/m=1 6,1,out		//15 hz column		•out[][6] = nan		•insertpoints/m=1 1000,1,out		//adds  90 hz past lastmost column		•out[][9] = nan	endfor	return outlistendfunction sin_main_update_all()	WAVE/T sin_refs_main0	String skipList = "2;28;33;6"		//28 is VI bridge have to fix that one separately skipped for now	variable i	for (i=0;i<dimsize(sin_refs_main0,0);i+=1)		if (WhichListItem(num2str(i), skipList) < 0)			fio_stream_loadStreamList("sin",noDisp=1)			sin_main_update(sin_refs_main0,i,0,0)			endif	endfor	endfunction sin_main_update(refsListWv,row,doDisplay,noStreaming)	WAVE/T refsListWv;variable row,doDisplay,noStreaming		Variable killAfter = 1		STring info = refsListwv[row]	STring respFamily_S = c2sc(stringbykey("respFamily_S",info))	STring respFamily_P = c2sc(stringbykey("respFamily_P",info))	STring stimFamily = c2sc(stringbykey("stimFamily",info))	STring wn_refs_S = stringbykey("wn_refs_S",info)	STring wn_refs_P = stringbykey("wn_refs_P",info)	Variable stimFromPed = str2num(stringbykey("stimFromPed",info))	Variable respAt_S = str2num(stringbykey("respAt_S",info))	Variable respAt_P = str2num(stringbykey("respAt_P",info))		STring bridgeTypeStr_S = stringbykey("bridgeTypeStr_S",info)	STring bridgeTypeStr_P = stringbykey("bridgeTypeStr_P",info)	STring streamTags_inclHoldingAndGain = replacestring("|",stringbykey("streamTags_inclHoldingAndGain",info),";")		fio_stream_loadIBF(NameOfWave(refsListWv),wn_refs_S+";"+wn_refs_P+";")		//check what if any bridge ref has to be loaded	String bridgeRef_S,bridgeRef_P	if (respAt_S)		//handle bridge		if (!strlen(bridgeTypeStr_S))		//bridge from wn			WAVE/T wn_refsWv_S = $wn_refs_s			bridgeRef_S = wn_refsWV_S[%bridgeInfoWvRef]			fio_stream_loadIBF(NameOfWave(refsListWv),bridgeRef_S)		elseif (stringmatch(bridgeTypeStr_S,"NONE"))			bridgeRef_S = ""		else			bridgeRef_S = bridgeTypeStr_S			fio_stream_loadIBF(NameOfWave(refsListWv),bridgeRef_S)		endif				if (Strlen(wn_refs_S))			WAVE/T wn_refWv_S = $wn_refs_S			String wnf_S = wn_refWv_S[%filter_TDSN]			fio_stream_loadIBF(NameOfWave(refsListWv),wnf_S)		endif	endif		if (respAt_P)		//handle bridge		if (!strlen(bridgeTypeStr_P))		//bridge from wn			WAVE/T wn_refsWv_P = $wn_refs_P			bridgeRef_P = wn_refsWV_P[%bridgeInfoWvRef]			fio_stream_loadIBF(NameOfWave(refsListWv),bridgeRef_P)		elseif (stringmatch(bridgeTypeStr_P,"NONE"))			bridgeRef_P = ""		else			bridgeRef_P = bridgeTypeStr_P			fio_stream_loadIBF(NameOfWave(refsListWv),bridgeRef_P)		endif				if (Strlen(wn_refs_P))			WAVE/T wn_refWv_P = $wn_refs_P			String wnf_P = wn_refWv_P[%filter_TDSN]			fio_stream_loadIBF(NameOfWave(refsListWv),wnf_P)		endif	endif		da_fd_loadWavesFromWaveName(respFamily_S,1)	da_fd_loadWavesFromWaveName(respFamily_P,1)	da_fd_loadWavesFromWaveName(stimFamily,1)		Print "streamTags_inclHoldingAndGain",streamTags_inclHoldingAndGain	Print "sin_main_inUpdate(): respFamily_S=",respFamily_S	Print "sin_main_inUpdate(): respFamily_P=",respFamily_P	Print "sin_main_inUpdate(): stimFamily=",stimFamily		sin_main(respFamily_S,respFamily_P,stimFamily,stimFromPed,wn_refs_S,bridgeTypeStr_S,wn_refs_P,bridgeTypeStr_P,doDisplay,streamTags_inclHoldingAndGain,noStreaming,killAfter=killAfter)end		//for updates from experiment where results were originally generatedfunction sin_main_inUpdate(row,bridgeTypeStr_S,bridgeTypeStr_P,streamTags_inclHoldingAndGain)	variable row	String bridgeTypeStr_S,bridgeTypeStr_P,streamTags_inclHoldingAndGain		Variable doDisplay = 0	Variable noStreaming = 0		WAVE/T sin_refs_main0	STring info = sin_refs_main0[row]	STring respFamily_S = c2sc(stringbykey("respFamily_S",info))	STring respFamily_P = c2sc(stringbykey("respFamily_P",info))	STring stimFamily = c2sc(stringbykey("stimFamily",info))	STring wn_refs_S = c2sc(stringbykey("wn_refs_S",info))	STring wn_refs_P = c2sc(stringbykey("wn_refs_P",info))	Variable stimFromPed = str2num(stringbykey("stimFromPed",info))//	Variable fromPed = str2num(stringbykey("fromPed",info))	Print "sin_main_inUpdate(): respFamily_S=",respFamily_S	Print "sin_main_inUpdate(): respFamily_P=",respFamily_P	Print "sin_main_inUpdate(): stimFamily=",stimFamily		da_fd_loadWavesFromWaveName(respFamily_S,1)	da_fd_loadWavesFromWaveName(respFamily_P,1)	da_fd_loadWavesFromWaveName(stimFamily,1)		if (!numtype(stimFromPed))		Print "sin_main_inUpdate(): missing stimFromPed"	endif		sin_main(respFamily_S,respFamily_P,stimFamily,stimFromPed,wn_refs_S,bridgeTypeStr_S,wn_refs_P,bridgeTypeStr_P,doDisplay,streamTags_inclHoldingAndGain,noStreaming)		end//(respMatchStr_S,respMatchStr_P,stimMatchStr,stimFromPed,wn_refs_S,bridgeTypeStr_S,wn_refs_P,bridgeTypeStr_P,doDisplay,streamTags_inclHoldingAndGain,noStreaming,[startX_endX_list])function/S text_listWvsToStrList(tListWvList,selRowsStr,out_listDelimStr,out_subListDelimStr)	String tListWvList		//one column text waves (or text waves where first column has strings of interest	String selRowsStr	String out_listDelimStr, out_subListDelimStr	//pass "" for both for text waves containing lists, as those are already delimited		Variable j,i,numWvs = ItemsInList(tListWvList), numSelRows = ItemsInList(selRowsStr), selRow	String out = "",str	for (i=0;i<numWvs;i+=1)		str = stringfromlist(i,tListWvList)		if (strlen(str) && waveexists($str))			WAVE/T wv = $str			if (strlen(selRowsStr))				for (j=0;j<numSelRows;j+=1)					selRow = str2num(stringfromlist(j,selRowsStr))					out += wv[selRow] + out_subListDelimStr				endfor			else				for (j=0;j<dimsize(wv,0);j+=1)					out += wv[j] + out_subListDelimStr				endfor					endif			out += out_listDelimStr		endif	endfor		return out	endfunction analysis_sinAvg_getParamDiffs(listWv_initial,listWv_final,out_paramDiffsRef,out_paramFDiffsRef)	wave/T listWv_initial	//list refs as generated by analysis_sinAvg_list()	wave/T listWv_final		//output is diffs = final - initial. fDiffs = final / initial	String out_paramDiffsRef,out_paramFDiffsRef		//refs into which output should be stored		WAVE/D params_initial = $listWv_initial[%combinedParamRef]	WAVE/D params_final = $listWv_final[%combinedParamRef]		Duplicate/O params_initial, $out_paramDiffsRef/wave=diffs,$out_paramFDiffsRef/wave=fDiffs	diffs = params_final - params_initial	fDiffs = params_final / params_initial		String noteStr = "listWv_initial:"+nameofwave(listWv_initial)+";listWv_final:"+nameofwave(listWv_final)+";"		note/nocr diffs,noteStr	note/nocr fDiffs,noteStrend		//current default is to plot responses onlyfunction analysis_sinAvg_listDisp(listWv,newOrAdd,appendReps,appendExampleStim,colorSet,subMean[addDC,normAmp])	WAVE/T listWv		//text wave ref input, as generated by analysis_sinAvg_list and stored by that function in outListRef	//format is 0=stimAvgRefs, 1=respAvgRefs, 2=stimAvgReps (comma between reps), 3=respAvgRefs (comma between reps)	Variable newOrAdd		//0 for new window, generates axes. 1 for adding to pre-existing window, assumes matched stimulus and so only adds responses	Variable appendReps						//pass true to append example reps, if listed in liStWv	Variable appendExampleStim		//must pass same value consistently if appending traces to same graph	Variable colorSet					//0 for first set, 1 for second (usually soma, terminal)	Variable subMean			//pass to subtract the mean from all traces	Variable addDC			//pass any value for handling of predictions with a dc offset to add back	Variable normAmp			//only works for parameters dispParams=0 and subMean=1 and addDC not passed  = 0		Variable dispParams = 0		//add parameter indicators			Variable excludedProprtionPre = 0.25	//proportion of total, so if showing 2 cyces, 25% is half a cycle	Variable excludedProprtionPost = 0.125	//0.125 for showing a quarter cycle extra post (current settings could show a quarter post)	Variable cycleProprtionShownAsTime = 0.25		Variable vertAxScaleSetting = 0 	//0 for normal autoscale, 1 for rounded values	variable sampleStimSize = .1		//if appended, how much of graph example stim will take up	variable colorMin = 0	variable colorMax = -1 + 2^16	Variable r_colorBlue = 1	Variable gb_colorBlue = 52428	Variable r_green=26205, g_green=52428,b_green=1	Variable r_avg, g_avg, b_avg, r_rep, g_rep, b_rep, opac_avg, opac_rep	Variable lstyle_avg, lsize_avg	Variable repOpacMult = 1/5	//display options  FINISH COLOR SCHEMES	switch (colorSet)		case 1:		//usually for terminal (red)			r_avg=colorMax; g_avg=colorMin; b_avg=colorMin; opac_avg=colorMax			r_rep=colorMax; g_rep=colorMax/3; b_rep=colorMax/3; opac_rep=colorMax*repOpacMult			lstyle_avg = 0; lsize_avg = 1			break		case 2:		//somatic predictions			r_avg=r_colorBlue; g_avg=gb_colorBlue; b_avg=gb_colorBlue; opac_avg=colorMax*0.7			r_rep=colorMax/3; g_rep=colorMax/3; b_rep=colorMax/3; opac_rep=colorMax*repOpacMult				lstyle_avg = 7; lsize_avg = 1.5				break		case 3:		//terminal predictions			r_avg=r_green; g_avg=g_green; b_avg=b_green; opac_avg=colorMax*0.7			r_rep=colorMax/3; g_rep=colorMax/3; b_rep=colorMax/3; opac_rep=colorMax*repOpacMult			lstyle_avg = 7; lsize_avg = 1.5				break		default:			r_avg=colorMin; g_avg=colorMin; b_avg=colorMin; opac_avg=colorMax			r_rep=colorMax/3; g_rep=colorMax/3; b_rep=colorMax/3; opac_rep=colorMax*repOpacMult			lstyle_avg = 0; lsize_avg = 1	endswitch			Variable avgNum, repNum, numAvgs = ItemsInList(listWv[%outAvgsList_stim]), numReps	String winN, currAvgWvN, currRepsList, currRepWvN,currVertAxN,currHorAxN	if (!newOrAdd)		//set up window		winN = StringFromList(0,listWv[%outAvgsList_resp])		//resp is basis for window name		Display/k=1/N=$winN ;doupdate		winN = S_name		modifygraph/W=$winN height=72*9.5, width=72*3.5	else		winN = winname(0,1)			//uses top graph	endif			//determine size of each plot	Variable spaceBetweenAxes = .015	Variable plotStart = appendExampleStim ? sampleStimSize + spaceBetweenAxes : 0	Variable plotEnd = 1	Variable plotWinSize = abs(plotEnd - plotStart)	Variable totalSpaceBetween = spaceBetweenAxes*(numAvgs-1)		//one less space than axes	Variable totalSpaceForAxes = plotWinSize - totalSpaceBetween	Variable totalSpaceForEachAxis = totalSpaceForAxes / numAvgs	Variable currAxStart, currAxEnd	Variable cycleLen_x, propCycleLen_x; string freq_hz_str	Double range	Double dcVal	Double ymean //for offset	String paramRef, tn_temp ; Variable min1Loc_index, min1val_index	for (avgNum=0;avgNum<numAvgs;avgNum+=1)		currAxStart = plotStart + avgNum*(totalSpaceForEachAxis+spaceBetweenAxes)		currAxEnd = currAxStart + totalSpaceForEachAxis		currVertAxN = "L_resp_" + num2str(avgNum)		currHorAxN = "B_" + num2str(avgNum)		currAvgWvN = StringFromList(avgNum,listWv[%outAvgsList_resp])		fio_ibwLoad(currAvgWvN,"sin",1)		appendToGraph/W=$winN/L=$currVertAxN/B=$currHorAxN/C=(r_avg, g_avg, b_avg, opac_avg) $currAvgWvN		if (subMean)			ymean = mean($currAvgWvN)			if (!ParamIsDefault(normAmp) && normAmp)				double yRange = wavemax($currAvgWvN)-wavemin($currAvgWvN)				modifygraph/W=$winN muloffset($currAvgWvN) = {0,1/yRange}, offset($currAvgWvN) = {0,-ymean/yRange}			else				modifygraph/W=$winN offset($currAvgWvN) = {0,-ymean}			endif		endif		ModifyGraph/W=$winN axisEnab($currVertAxN) = {currAxStart, currAxEnd}, nolabel($currHorAxN)=2, tick($currHorAxN) = 3		ModifyGraph/W=$winN lsize($currAvgWvN)=lsize_avg	,lstyle($currAvgWvN)=lstyle_avg		Setaxis/W=$winN/A/N=(vertAxScaleSetting) $currVertAxN;		//scale axis to appropriate scaling		Setaxis/W=$winN/A $currHorAxN; doupdate;GetAxis/Q/W=$winN $currHorAxN; range = V_max - V_min		Setaxis/W=$winN $currHorAxN, V_min+excludedProprtionPre*range, V_max-excludedProprtionPost*range		//find quarterCyceLen_x and flip move label to a good position		cycleLen_x = str2num(stringbykey("cycleLen_X",note($currAvgWvN)))		propCycleLen_x = cycleLen_x*cycleProprtionShownAsTime		sprintf freq_hz_str, "%.2f", 1/ cycleLen_x		//print frequency in Hz out to two decimal places		Label/W=$winN $currVertAxN, num2str(propCycleLen_x*1000) + "\\u#2 ms ( " + freq_hz_str + " Hz)"		ModifyGraph/W=$winN lblPos($currVertAxN)=-10,lblLatPos($currVertAxN)=35,lblRot($currVertAxN)=-90		//check if has reps, append if so		currRepsList = StringFromList(avgNum, listWv[%outRepsList_resp])		numReps = ItemsInList(currRepsList,",")			//append min max half demarcations//		paramRef = stringbykey("sinAvgParamRef",note($currAvgWvN)); WAVE paramTemp = $paramRef//		fio_ibwLoad(paramRef,"sin",1)//		Redimension/N=(-1,2) paramTemp; paramTemp[][1] = paramTemp[p][0]		//seems to me must make a second column in order to plot row vs row unfortunately				//handle dc offsets in predictions		//do not set dcVal to baseline subtraction val if addDC wasn't passed (default) or if mean is being subtracted from other traces		if (subMean && ParamIsDefault(addDC))		//not adding dc back, so subtract dc for quartile points			dcVal = -yMean		elseif (ParamIsDefault(addDC))		//addDC isn't passed, and neither is subMean			dcVal = 0		elseif (subMean)				//submean is passed, and so is addDC; subMean takes precedence			dcVal = -yMean		else //don't submean, do add DC			dcVal = str2num(stringbykey("resp_baseSub_VAL",note($currAvgWvN)))			modifygraph/W=$winN offset($currAvgWvN) = {0,dcVal}		endif						//	dcVal = (ParamIsDefault(addDC) || subMean) ? 0 : str2num(stringbykey("resp_baseSub_VAL",note($currAvgWvN)))		if (dispParams)				appendSineParam2(winN, currVertAxN, currHorAxN, paramRef, "firstPeriod_minVal","firstPeriod_minLoc", currAvgWvN + "Pd1", r_avg, g_avg, b_avg, opac_avg, dcVal)	//first min			appendSineParam2(winN, currVertAxN, currHorAxN, paramRef, "firstPeriod_maxVal","firstPeriod_maxLoc", currAvgWvN + "Pu1", r_avg, g_avg, b_avg, opac_avg, dcVal)	//first max		appendSineParam2(winN, currVertAxN, currHorAxN, paramRef, "firstPeriod_halfVal","firstHalfVal_loc", currAvgWvN + "Pi1", r_avg, g_avg, b_avg, opac_avg, dcVal)	//first halfway			appendSineParam2(winN, currVertAxN, currHorAxN, paramRef, "secondPeriod_minVal","secondPeriod_minLoc", currAvgWvN + "Pd2", r_avg, g_avg, b_avg, opac_avg, dcVal)	//second min			appendSineParam2(winN, currVertAxN, currHorAxN, paramRef, "secondPeriod_maxVal","secondPeriod_maxLoc", currAvgWvN + "Pu2", r_avg, g_avg, b_avg, opac_avg, dcVal)	//second max		appendSineParam2(winN, currVertAxN, currHorAxN, paramRef, "secondPeriod_halfVal","secondHalfVal_loc", currAvgWvN + "Pi2", r_avg, g_avg, b_avg, opac_avg, dcVal)	//second halfway			appendSineParam2(winN, currVertAxN, currHorAxN, paramRef, "interim_halfVal","interimHalfVal_loc", currAvgWvN + "Pi", r_avg, g_avg, b_avg, opac_avg, dcVal)	//interim halfway							endif				if (numReps && appendReps)			for (repNum=0;repNum<numReps;repNum+=1)				currRepWvN = StringFromList(repNum, currRepsList,",")				fio_ibwLoad(currRepWvN,"sin",1)				appendtograph/L=$currVertAxN/B=$currHorAxN/C=(r_rep, g_rep, b_rep, opac_rep) $currRepWvN				if (subMean)					ymean = mean($currRepWvN)					modifygraph/W=$winN offset($currRepWvN) = {0,-ymean}				endif			endfor			ReorderTraces _front_,{$currAvgWvN}		//brings to front. if using igor 6 might work to change to ReorderTraces {$currRepWvN}, {$currAvgWvN}		endif			endfor		if (!newOrAdd && appendExampleStim)		Variable preferredStimIndex = numAvgs > 2 ? 3 : numAvgs-1		String exStimRef = StringFromList(preferredStimIndex,listWv[%outAvgsList_stim])		fio_ibwLoad(exStimRef,"sin",1)		String noteStr = note($exStimRef)		appendtograph/W=$winN/L=$"L_stim"/B=$"B_stim"/C=(0,0,0) $exStimRef		Modifygraph axisEnab($"L_stim") = {0,sampleStimSize}, nolabel($"L_stim")=2, tick($"L_stim") = 3,nolabel($"B_stim")=2, tick($"B_stim") = 3		Setaxis/W=$winN/A $"B_stim"; doupdate;GetAxis/Q/W=$winN $"B_stim"; range = V_max - V_min		Setaxis/W=$winN $"B_stim", V_min+excludedProprtionPre*range, V_max-excludedProprtionPost*range		String numPreCycles = StringByKey("numPreCycles",noteStr)		String numPostCycles = StringByKey("numPostCycles",noteStr)		if (strlen(numPreCycles) > 0)			//make a guide wave for axis scaling			string guideWaveN = text_makeStrPresentable(winN + "guide")			Make/O/N=2 $guideWaveN/WAVE=guideWv			guideWv = wavemin($exStimRef)		//so that guide wave does not affect scaling of left axis			setScale/P x, -str2num(numPreCycles), 1 + (str2num(numPreCycles) + str2num(numPostCycles)), guideWv			appendtograph/W=$winN/L=$"L_stim"/B=$"B_guide" guideWv/TN=guideWv			Setaxis/W=$winN/A $"B_guide"; doupdate;GetAxis/Q/W=$winN $"B_guide"; range = V_max - V_min			Setaxis/W=$winN $"B_guide", V_min+excludedProprtionPre*range, V_max-excludedProprtionPost*range			modifygraph hidetrace(guideWv) = 2		//2 for still affecting scaling without being shown			ModifyGraph nticks(B_guide)=2,minor(B_guide)=1		//fewer ticks but add minor ticks (keeps nums and guide marks from confusing						//draw guide lines 			SetDrawEnv xcoord= B_guide,dash= 3;delayupdate;DrawLine 0.25,1,0.25,0		//line at 0.25			SetDrawEnv xcoord= B_guide,dash= 3;delayupdate;DrawLine 0.5,1,0.5,0				//line at .5			SetDrawEnv xcoord= B_guide,dash= 3;delayupdate;DrawLine .75,1,.75,0				//line at .75			SetDrawEnv xcoord= B_guide,dash= 3;delayupdate;DrawLine 1,1,1,0				//line at 1		endif	endif		if (!newOrAdd)		modifygraph/W=$winN freepos=0,lblpos=52,fsize=6	endif		doupdate;modifygraph/W=$winN height=0,width=0		//makes width and height GUI adjustable againend//must have added second column to paramWv for this to workfunction appendSineParam2(winN, vertN, horN, paramRef, yParamStr, xParamStr, tn, r, g, b, opac, dcVal)	String winN, vertN, horN, paramRef	String yParamStr, xParamStr, tn	Variable r, g, b, opac	double dcVal	Variable yIndex = FindDimLabel($paramRef, 0, yParamStr) 	Variable xIndex = FindDimLabel($paramRef, 0, xParamStr)	appendtograph/W=$winN/L=$vertN/B=$horN/C=(r, g, b, opac) $paramRef[yIndex][]/TN=$tn vs $paramRef[xIndex][]	//	appendtograph/W=$winN/L=$vertN/B=$horN/C=(r, g, b, opac) $paramRef[%yParamStr][]/TN=$tn vs $paramRef[%xParamStr][]	modifygraph/W=$winN mode($tn)=3,marker($tn)=8, msize($tn)=2.5, offset($tn) = {0,dcVal}end	function/S analysis_sinAvg_summaryDisp(listWvOrCombinedParamsRef,isCombinedListRef,appendToTopWin,colorSet,winN,[startCol,endCol,UTN,UMN])	String listWvOrCombinedParamsRef		//listWv as generated by analysis_sinAvg_list() or combinedListRef (helpful when passing difference params refs)	Variable isCombinedListRef		//specify which type of reference was input to listWvOrCombinedParamsRef. if listWvOrCombinedParamsRef is a diff ref and want to use original values for xAx (e.g. frequency), input value of 2	Variable colorSet			//0 for is, 1 for terminal, 2 for Is predictions, 3 for terminal predictions	Variable appendToTopWin		//0 for new window, 1 for append to top win	String winN	Variable startCol,endCol		//columns to plot, defaults to all .. handled by local vars StartC and endC	Variable UTN					//unique trace names needed for each input wave	Variable UMN					//force unique marker number for all traces			String xAxRef 	if (isCombinedListRef)		WAVE/D yAxWv = $listWvOrCombinedParamsRef		if (isCombinedListRef == 2)		//combined params wv is a difference wave, use x axis from original params because stimulus parameters will be zero in difference wave			WAVE/T listWv_init = $stringbykey("listWv_initial",note(yAxWv))			WAVE/D xAxWv = $listWv_init[%combinedParamRef]		else			WAVE/D xAxWv = $listWvOrCombinedParamsRef		endif	else		WAVE/T listWv = $listWvOrCombinedParamsRef		WAVE/D yAxWv = $listWv[%combinedParamRef]		WAVE/D xAxWv = $listWv[%combinedParamRef]	endif		//get a unique basis for the trace names, considering that one might append data from more than one paramWv to the same graph	String traceNameBase	if (ParamIsDefault(UTN) || numtype(UTN))		traceNameBase = "T"+nameofwave(yAxWv)[strlen("G16110201"),inf]	else		traceNameBase = "T"+nameofwave(yAxWv)[0,strlen("G16110201_0000")]	endif	variable startC = 	(ParamIsDefault(startCol) || numtype(startCol)) ? 0 : startCol	variable endC = 	(ParamIsDefault(endCol) || numtype(endCol)) ? dimsize(xAxWv,1) : min(endCol,min(dimsize(yAxWv,1),dimsize(xAxWv,1))	)	String yxLogPairsList = ""				//phase_rad_diff			yxLogPairsList += "phase_rad_diff_v1,Ph lag (rad.\\U),0,freq_Hz_stim,Frequency (Hz),0;"			yxLogPairsList += "impedence,Imp,0,freq_Hz_stim,Frequency (Hz),0;"		yxLogPairsList += "W_coef_resp_1,Amp (V),0,freq_Hz_stim,Frequency (Hz),0;"		//		yxLogPairsList += "phase_rad_stim_v1,Ph stim (rad.),0,freq_Hz_stim,Frequency (Hz),0;"//		yxLogPairsList += "phase_rad_resp_v1,Ph resp (rad.),0,freq_Hz_stim,Frequency (Hz),0;"//		yxLogPairsList += "phase_s_stim_v1,Ph stim (s),0,freq_Hz_stim,Frequency (Hz),0;"//		yxLogPairsList += "phase_s_resp_v1,Ph resp (s),0,freq_Hz_stim,Frequency (Hz),0;"//		yxLogPairsList += "phase_s_diff_v1,Ph lag (s),0,freq_Hz_stim,Frequency (Hz),0;"//		yxLogPairsList += "period_rad_diff,Period Diff (rad),0,freq_Hz_stim,Frequency (Hz),0;"//		yxLogPairsList += "W_coef_stim_3,Ph stim (rad.),0,freq_Hz_stim,Frequency (Hz),0;"//		yxLogPairsList += "W_coef_resp_3,Ph resp (rad.),0,freq_Hz_stim,Frequency (Hz),0;"//		yxLogPairsList += "phase_rad_diff,Ph lag (rad.),0,freq_Hz_stim,Frequency (Hz),0;"//		yxLogPairsList += "phase_s_stim,Ph stim (s),0,freq_Hz_stim,Frequency (Hz),0;"//		yxLogPairsList += "phase_s_resp,Ph resp (s),0,freq_Hz_stim,Frequency (Hz),0;"//		yxLogPairsList += "phase_s_diff,Ph lag (s),0,freq_Hz_stim,Frequency (Hz),0;"//		yxLogPairsList += "W_coef_resp_1,Amp (V),0,freq_Hz_stim,Frequency (Hz),0;"		variable colorMin = 0	variable colorMax = -1 + 2^16	Variable r_colorBlue = 1	Variable gb_colorBlue = 52428	Variable r_green=26205, g_green=52428,b_green=1	Variable r_avg, g_avg, b_avg, r_rep, g_rep, b_rep, opac_avg, opac_rep	Variable lstyle_avg, lsize_avg	Variable repOpacMult = 1/5, marker	//display options  FINISH COLOR SCHEMES	switch (colorSet)		case 1:		//usually for terminal (red)			r_avg=colorMax; g_avg=colorMin; b_avg=colorMin; opac_avg=colorMax*0.3			lstyle_avg = 0; lsize_avg = 1; marker=18			break		case 2:		//somatic predictions			r_avg=r_colorBlue; g_avg=gb_colorBlue; b_avg=gb_colorBlue; opac_avg=colorMax*.8			lstyle_avg = 7; lsize_avg = 1	; marker=8			break		case 3:		//terminal predictions			r_avg=r_green; g_avg=g_green; b_avg=b_green; opac_avg=colorMax*.8			lstyle_avg = 7; lsize_avg = 1	; marker=42			break		default:			//for soma			r_avg=colorMin; g_avg=colorMin; b_avg=colorMin; opac_avg=colorMax*.3			lstyle_avg = 0; lsize_avg = 1; marker=19	endswitch			if (appendToTopWin)		if (strlen(WinN) < 1)			winN = winname(0,1)		endif	else		if (strlen(winN) < 1)			display/k=1		else			display/k=1/N=$winN		endif		winN = S_name	endif	Variable overrideMarker = (ParamIsDefault(UMN) || numtype(UMN)) ? 0 : UMN	marker = overrideMarker ? overrideMarker : marker	Variable numAxes = ItemsInList(yxLogPairsList)	Variable axSpacing = 0.015	Variable totalAxSpacing = axSpacing * (numAxes-1)	Variable totalAxRoom = 1 - totalAxSpacing	Variable roomPerAx = totalAxRoom/numAxes	Variable tn_rep,i,y_doLog,x_doLog,axStart,axEnd,yIndex,xIndex; string pair,yParam, xParam	String yAx, xAx,yLbl,xLbl, tn	for (i=0;i<numAxes;i+=1)		axStart = i*roomPerAx + i*axSpacing		axEnd = axStart + roomPerAx		pair = stringfromlist(i,yxLogPairsList)		yParam = stringfromlist(0,pair,","); yAx = "L_" + yParam		yIndex = FindDimLabel(yAxWv, 0, yParam)		xParam = stringfromlist(3,pair,","); xAx = "B_" + xParam		xIndex = FindDimLabel(yAxWv, 0, xParam)		yLbl = stringfromlist(1,pair,",")		xLbl = stringfromlist(4,pair,",")		y_doLog = str2num(stringfromlist(2,pair,","))		x_doLog = str2num(stringfromlist(5,pair,","))		tn = (traceNameBase + yParam + "_"+num2str(y_doLog) + "v" + xParam)[0,31]		//truncate to 31 characters		appendtograph/W=$winN/L=$yAx/B=$xAx/c=(r_avg,g_avg,b_avg,opac_avg)  yAxWv[yIndex][startC,endC]/TN=$tn vs xAxWv[xIndex][startC,endC]		modifygraph/W=$winN axisenab($yAx)={axStart,axEnd},log($yAx)=y_doLog,log($xAx)=x_doLog,mode($tn)=4,marker($tn)=marker,lstyle($tn)=lstyle_avg		Label/W=$winN $yAx, yLbl		Label/W=$winN $xAx, xLbl	endfor	modifygraph/W=$winN freepos=0,lblpos=50,fsize=8	SetAxis/A/N=1/W=$winN		// y average name conflict		return winNend//uses analysis_sinAvg_g to run through a list of sine wave stimulus-response pairs and get average cycle//names are auto generated as ref + "_sin"; reps are ref + "_sin" + "_rep#"function/S analysis_sinAvg_list(stimList,respList,startX,endX,numSkipCycles,numPreCycles,numPostCycles,saveReps,outListRef,doPlot,bridge_bsx,bridge_bex,bridgeValsRef,bridgeType)	String stimList, respList		//semi-colon delim. list of stimulus and response pairs, paired by order'	Variable startX, endX		//start and end values for sine wave stim (NOT region that will be averaged, see below)	Variable numSkipCycles		//num cycles not to include in average	Variable numPreCycles		//num preceding cycles to include in average--0 would have average start at the beginning of the cycle, 0.5 would be a half a cycle	Variable numPostCycles		//num cycles following the cycle to include in average--0 would have average end at one cycle		Variable saveReps			//pass to save individual replicates	String outListRef			//optionally pass to save refs as text wave: semi colon between list inputs, 0=stimAvgRefs, 1=respAvgRefs, 2=stimAvgReps (comma between reps), 3=respAvgRefs (comma between reps)	Variable doPlot				//pass to plot each rep. requires outListRef	Variable bridgeType			//format of bridge reistance values: -1 for for no bridge balance, 0 for format generated by wn, 1 for VI format	String bridgeValsRef		//reference to bridge bals, "" ok for bridgeType == -1	Variable bridge_bsx,bridge_bex	//baseline start x and baseline end x for bridge balance zero mean		Variable combineParamRefs = 2			//if true, makes paramRefs into one 2-d wave rows as params cols as reps. numCols = itemsInList(stimList). save name based on first stim/response wave in list												//saves this in addition to individual params wave. have to go in and kill those seperately..maybe necessary for plotting?	String refAppendStr = "si"	String outAvgsList_stim = "",outRepsList_resp = "", outRepsList_stim = "", outAvgsList_resp = "", returnedRepsList		analysis_bridge_applyToList(respList,stimList,bridgeValsRef,NaN,bridgeType,bridge_bsx,bridge_bex,1,0)			//reloads waves from file before analysis. NaN sets # bridge rVals via size of rValsRef		Variable i	String stimRef, respRef, stimRef_out, respRef_out, currRepsList, paramsRefList = "", paramsRef = "", combinedParamRef = ""	for (i=0;i<ItemsInList(stimList);i+=1)		stimRef = StringFromList(i, stimLisT); stimRef_out = stimRef + refAppendStr; outAvgsList_stim += stimRef_out + ";"		respREf = stringfromlist(i, respList); respREf_out = respREf + refAppendStr; outAvgsList_resp += respREf_out + ";"		//run sinAvg, deal with reps as needed		paramsRef = ""		returnedRepsList=analysis_sinAvg_g(stimRef,respREf,stimRef_out,respREf_out,startX,endX,numSkipCycles,numPreCycles,numPostCycles,saveReps,out_paramsRef=paramsRef)		paramsRefList += paramsRef + ";"		if (combineParamRefs)			if (i==0)				combinedParamRef = paramsRef + "c"				Duplicate/O $paramsRef, $combinedParamRef/wave=combinedParamWv				Redimension/N=(-1,1) combinedParamWv				Print "analysis_sinAvg_list(): combinedParamRef",combinedParamRef,"outListRef",outListRef			else				WAVE/D currParamsWv = $paramsRef				Redimension/N=(-1,i+1) combinedParamWv				combinedParamWv[][i] = currParamsWv[p]			endif			SetDimLabel 1,i,$paramsRef,combinedParamWv		endif		//store reps as comma delimited, semi colon delimited between list inputs		if (saveReps)			outRepsList_stim += ReplaceString(";",StringFromList(0,returnedRepsList,","),",") + ";" 		//output from analysis_sinAvg_g() is stimReps, respReps (if saved)			outRepsList_resp += ReplaceString(";",StringFromList(1,returnedRepsList,","),",") + ";" 		endif		endfor		if (strlen(outListRef) > 0)		Make/O/T/N=6 $outListRef/WAVE=out		dl_assignAndLbl_T(out, 0, outAvgsList_stim, "outAvgsList_stim")		dl_assignAndLbl_T(out, 1, outAvgsList_resp, "outAvgsList_resp")		dl_assignAndLbl_T(out, 2, outRepsList_stim, "outRepsList_stim")		dl_assignAndLbl_T(out, 3, outRepsList_resp, "outRepsList_resp")		dl_assignAndLbl_T(out, 4, paramsRefList, "paramsRefList")		dl_assignAndLbl_T(out, 5, combinedParamRef, "combinedParamRef")				if (doPlot)			switch (doPlot)				case 1:		//no dc sub									analysis_sinAvg_listDisp($outListRef,0,1,1,0,0)					break				case 2:		//dc sub					analysis_sinAvg_listDisp($outListRef,0,1,1,0,1)					break				case 3:		//dc sub but add back mean..same for all refs					analysis_sinAvg_listDisp($outListRef,0,1,1,0,1,addDC=1)					break							endswitch			endif		endif		return outAvgsList_stimend//uses analysis_sinAvg_g to run through a list of sine wave stimulus-response pairs and get average cycle//names are auto generated as ref + "_sin"; reps are ref + "_sin" + "_rep#"//_mx variant: multiple startX and endX inputfunction/S analysis_sinAvg_list_mx(stimList,respList,startX_endX_list,numSkipCycles,numPreCycles,numPostCycles,saveReps,outListRef,doPlot,bridge_bsx,bridge_bex,bridgeValsRef,bridgeType)	String stimList, respList		//semi-colon delim. list of stimulus and response pairs, paired by order'	String startX_endX_list	//startX,endX times (as comma pairs in semi-colon delim list) for each stim/resp pair .. more than one pair is performed on same stim/resp at different points	Variable numSkipCycles		//num cycles not to include in average	Variable numPreCycles		//num preceding cycles to include in average--0 would have average start at the beginning of the cycle, 0.5 would be a half a cycle	Variable numPostCycles		//num cycles following the cycle to include in average--0 would have average end at one cycle		Variable saveReps			//pass to save individual replicates	String outListRef			//optionally pass to save refs as text wave: semi colon between list inputs, 0=stimAvgRefs, 1=respAvgRefs, 2=stimAvgReps (comma between reps), 3=respAvgRefs (comma between reps)	Variable doPlot				//pass to plot each rep. requires outListRef	Variable bridgeType			//format of bridge reistance values: -1 for for no bridge balance, 0 for format generated by wn, 1 for VI format	String bridgeValsRef		//reference to bridge bals, "" ok for bridgeType == -1	Variable bridge_bsx,bridge_bex	//baseline start x and baseline end x for bridge balance zero mean		Variable startX, endX		//start and end values for sine wave stim (NOT region that will be averaged, see below)			Variable combineParamRefs = 2			//if true, makes paramRefs into one 2-d wave rows as params cols as reps. numCols = itemsInList(stimList). save name based on first stim/response wave in list												//saves this in addition to individual params wave. have to go in and kill those seperately..maybe necessary for plotting?	String refAppendStr = "si_"	String paramRefAPpendStr = "sap_"	String outAvgsList_stim = "",outRepsList_resp = "", outRepsList_stim = "", outAvgsList_resp = "", returnedRepsList		analysis_bridge_applyToList(respList,stimList,bridgeValsRef,NaN,bridgeType,bridge_bsx,bridge_bex,1,0)			//reloads waves from file before analysis. NaN sets # bridge rVals via size of rValsRef		Variable i,j,numStartXEndXPairs,sinAvgCount = 0 	String startX_endX	String stimRef, respRef, stimRef_out, respRef_out, currRepsList, paramsRefList = "", paramsRef = "", combinedParamRef = ""	for (i=0;i<ItemsInList(stimList);i+=1)		stimRef = StringFromList(i, stimLisT); 		respREf = stringfromlist(i, respList);		startX_endX = Stringfromlist(i,startX_endX_list)		numStartXEndXPairs = floor(itemsinlist(startX_endX,",")/2); Print "numStartXEndXPairs",numStartXEndXPairs		for (j=0;j<numStartXEndXPairs;j+=1)			//assign name to output (unique to this stim/ref AND startx/endx pair) and get startx,endX vals			paramsRef = respRef + paramRefAPpendStr + num2str(j) +"_"; paramsRefList += paramsRef + ";"			stimRef_out = stimRef + refAppendStr + num2str(j); outAvgsList_stim += stimRef_out + ";"			respREf_out = respREf + refAppendStr + num2str(j); outAvgsList_resp += respREf_out + ";"						startX = str2num(stringfromlist(2*j,startX_endX,","))			endX = str2num(stringfromlist(2*j + 1,startX_endX,","))			//run sinAvg			returnedRepsList=analysis_sinAvg_g(stimRef,respREf,stimRef_out,respREf_out,startX,endX,numSkipCycles,numPreCycles,numPostCycles,saveReps,out_paramsRef=paramsRef)			if (combineParamRefs)				if (sinAvgCount==0)					combinedParamRef = respRef + "sapc"					Duplicate/O $paramsRef, $combinedParamRef/wave=combinedParamWv					Redimension/N=(-1,1) combinedParamWv					Print "analysis_sinAvg_list(): combinedParamRef",combinedParamRef,"outListRef",outListRef				else					WAVE/D currParamsWv = $paramsRef					Redimension/N=(-1,sinAvgCount+1) combinedParamWv					combinedParamWv[][sinAvgCount] = currParamsWv[p]				endif				SetDimLabel 1,sinAvgCount,$paramsRef,combinedParamWv			endif							//store reps as comma delimited, semi colon delimited between list inputs			if (saveReps)				outRepsList_stim += ReplaceString(";",StringFromList(0,returnedRepsList,","),",") + ";" 		//output from analysis_sinAvg_g() is stimReps, respReps (if saved)				outRepsList_resp += ReplaceString(";",StringFromList(1,returnedRepsList,","),",") + ";" 			endif			sinAvgCount += 1		endfor		endfor		if (strlen(outListRef) > 0)		Make/O/T/N=6 $outListRef/WAVE=out		dl_assignAndLbl_T(out, 0, outAvgsList_stim, "outAvgsList_stim")		dl_assignAndLbl_T(out, 1, outAvgsList_resp, "outAvgsList_resp")		dl_assignAndLbl_T(out, 2, outRepsList_stim, "outRepsList_stim")		dl_assignAndLbl_T(out, 3, outRepsList_resp, "outRepsList_resp")		dl_assignAndLbl_T(out, 4, paramsRefList, "paramsRefList")		dl_assignAndLbl_T(out, 5, combinedParamRef, "combinedParamRef")				if (doPlot)			switch (doPlot)				case 1:		//no dc sub									analysis_sinAvg_listDisp($outListRef,0,1,1,0,0)					break				case 2:		//dc sub					analysis_sinAvg_listDisp($outListRef,0,1,1,0,1)					break				case 3:		//dc sub but add back mean..same for all refs					analysis_sinAvg_listDisp($outListRef,0,1,1,0,1,addDC=1)					break							endswitch			endif		endif		return outAvgsList_stimend//if save reps is passed, appends _rep# to outRef_stim and outRef_resp for saving reps; returns refs as semi-colon delim list, with comma seperating stimulus and response lists function/S analysis_sinAvg_g(stimRef, respRef, outRef_stim, outRef_resp, startX, endX, numSkipCycles, numPreCycles, numPostCycles, saveReps, [out_paramsRef])	String stimRef		//stim wave (ideally a sine wave, at minimum a cyclic wave)	String respRef	// response	String outRef_stim, outRef_resp		//must pass	Variable startX, endX		//start and end values for sine wave stim (NOT region that will be averaged, see below)	Variable numSkipCycles		//num cycles not to include in average	Variable numPreCycles		//num preceding cycles to include in average--0 would have average start at the beginning of the cycle, 0.5 would be a half a cycle	Variable numPostCycles		//num cycles following the cycle to include in average--0 would have average end at one cycle	Variable saveReps			//pass to save individual replicates. 0 for none, 1 for response only, 2 for all	String &out_paramsRef		//pass to get name of paramsRef or to overwrite auto name (strlen > 0)		Variable maxNumSaveReps = 25		//limit to number of individual reps that will be saved. if more reps than this, evenly spaced sample will be taken		WAVE stim = $stimRef	WAVE resp = $respRef		String paramRef = respRef + "sap"		//stores parameter info about the avg wave, e.g. for displaying quartile points	if (!ParamIsDefault(out_paramsRef))		if	(numtype(strlen(out_paramsRef)) || (strlen(out_paramsRef)<1))		//passed uninstantiated or without length, return paramRef to this			out_paramsRef = paramRef		else	//passed with a length, set paramRef to this			Print "assigning paramRef (automated name choice overwritten)"			paramRef = out_paramsRef		endif	endif			//estimate midpoint value of sine wave, use to estimate # cycles	Variable estMidvalue = mean(stim, startX, endX)	FindLevels/B=10/EDGE=1/Q/R=(startX,endX) stim, estMidValue		Variable estNumPntsPerCycle  = (endX-startX)/dimdelta(stim,0)/V_LevelsFound	//total num pnts in fit region divided by estimated num cycles in region = estimated points per cycle		//fit stimulus as a sin wave	Make/O/D W_coef	CurveFit/B=(estNumPntsPerCycle)/NTHR=0/N=1/Q/W=2 sin stim(startX, endX)	Variable freq_Hz = W_coef[2] / 2 / pi	Variable period_s = 1 / freq_Hz	Variable phase_s = W_coef[3] / W_coef[2] //phase offset in seconds			//determine output parameters, such as length of saved cycles, start of averaging	Variable actNumCycles = (endX - startX) * freq_Hz	Variable sampledCycleStepSize = actNumCycles / maxNumSaveReps 	Variable saveRepSubset = sampledCycleStepSize > 1	Variable startCycle = numSkipCycles 	Variable cycleLen_X = (1+numPreCycles+numPostCycles) * period_s		//# periods in each average * period length	Variable cycleLen_P = cycleLen_X / dimDelta(resp,0)	Variable timeFromPrecedingCycle = numPreCycles*period_s	Variable numCyclesBeforeStart = floor(startX / period_s)			//number of cycles before start of analysis .. something related to the way fit coefs come out I think?	Variable firstCycleStart = (numCyclesBeforeStart+1) * period_s - phase_s	duplicate/O/R=(0,cycleLen_X) resp, $outRef_resp/WAVE=resp_mean; SetScale/P x, 0, dimdelta(resp,0), resp_mean		//make sure portion starts at zero	duplicate/O/R=(0,cycleLen_X) stim, $outRef_stim/WAVE=stim_mean; SetScale/P x, 0, dimdelta(stim,0), stim_mean		resp_mean = 0; stim_mean = 0;	if (saveReps)		Duplicate/O resp_mean, resp_temp		Duplicate/O stim_mean, stim_temp	endif		String noteAddStr = "SINSTIMREF:" + stimRef + ";SINRESPREF:" + respREf + ";"		//note to append in case of saveReps	noteAddStr += "cycleLen_X:"+num2str(cycleLen_X) + ";cycleLen_P:"+num2str(cycleLen_P) + ";numPreCycles:"+num2str(numPreCycles) + ";numPostCycles:"+num2str(numPostCycles) + ";"	noteAddStr += "sinAvgParamRef:" + paramRef + ";"		Variable currCycleNum, cycleStartX, portionToAvgStartX	Variable count = 0, repCount = 0, nextSavedRep = 0		//always save first rep	String currRef_stim, currRef_resp, currRef_clamp, outList_stim = "", outList_resp = ""	for (currCycleNum = startCycle; currCycleNum < actNumCycles - 2 - numPostCycles; currCycleNum+=1)		cycleStartX = firstCycleStart + (currCycleNum*period_s)		portionToAvgStartX = cycleStartX - timeFromPrecedingCycle		resp_mean[0, ] += resp(x+portionToAvgStartX)		stim_mean[0, ] += stim(x+portionToAvgStartX)		if (saveReps)			if ( !saveRepSubset || ( (repCount < maxNumSaveReps) && (count == nextSavedRep ) ) )							//save response				currRef_resp = outRef_resp + "_" +num2str(count)				outList_resp += currRef_resp + ";"				resp_Temp[0,] = resp(x+portionToAvgStartX)				duplicate/O resp_temp, $currRef_resp				Note/NOCR $currRef_resp, noteAddStr				//save stimulus				currRef_stim = outRef_stim + "_" +num2str(count)				outList_stim += currRef_stim + ";"				stim_temp[0,] = stim(x+portionToAvgStartX)				duplicate/O stim_temp, $currRef_stim				Note/NOCR $currRef_stim, noteAddStr				repCount += 1				nextSavedRep = ceil(repCount*sampledCycleStepSize)		//iterate nextSavedRep	(ignored for !saveRepSubset or beyond maxNumSaveReps, due to if				endif		endif		count += 1			endfor //analysis_sinAvg_g	resp_mean /= count; stim_mean /= count		String noteStr = ""	Variable numPArams = 27	Make/O/D/N=(numParams) analysisParams		//information about the analysis that took place	dl_assignAndLbl(analysisParams, 0, startX, "startX")	dl_assignAndLbl(analysisParams, 1, endX, "endX")	dl_assignAndLbl(analysisParams, 2, numSkipCycles, "numSkipCycles")	dl_assignAndLbl(analysisParams, 3, numPreCycles, "numPreCycles")	dl_assignAndLbl(analysisParams, 4, numPostCycles, "numPostCycles")	dl_assignAndLbl(analysisParams, 5, saveReps, "saveReps")	dl_assignAndLbl(analysisParams, 6, maxNumSaveReps, "maxNumSaveReps")	dl_assignAndLbl(analysisParams, 7, estMidvalue, "estMidvalue")	dl_assignAndLbl(analysisParams, 8, estNumPntsPerCycle, "estNumPntsPerCycle")	dl_assignAndLbl(analysisParams, 9, W_coef[0], "in_W_coef_0")	dl_assignAndLbl(analysisParams, 10, W_coef[1], "in_W_coef_1")	dl_assignAndLbl(analysisParams, 11, W_coef[2], "in_W_coef_2")	dl_assignAndLbl(analysisParams, 12, W_coef[3], "in_W_coef_3")	dl_assignAndLbl(analysisParams, 13, freq_Hz, "freq_Hz")	dl_assignAndLbl(analysisParams, 14, period_s, "period_s")	dl_assignAndLbl(analysisParams, 15, phase_s, "phase_s")	dl_assignAndLbl(analysisParams, 16, actNumCycles, "actNumCycles")	dl_assignAndLbl(analysisParams, 17, sampledCycleStepSize, "sampledCycleStepSize")	dl_assignAndLbl(analysisParams, 18, saveRepSubset, "saveRepSubset")	dl_assignAndLbl(analysisParams, 19, startCycle, "startCycle")	dl_assignAndLbl(analysisParams, 20, cycleLen_X, "cycleLen_X")	dl_assignAndLbl(analysisParams, 21, cycleLen_P, "cycleLen_P")	dl_assignAndLbl(analysisParams, 22, timeFromPrecedingCycle, "timeFromPrecedingCycle")	dl_assignAndLbl(analysisParams, 23, numCyclesBeforeStart, "numCyclesBeforeStart")	dl_assignAndLbl(analysisParams, 24, firstCycleStart, "firstCycleStart")	dl_assignAndLbl(analysisParams, 25, count, "count")	dl_assignAndLbl(analysisParams, 26, repCount, "repCount")		noteAddStr += "AVGCOUNT:" + num2str(count) + ";STIMREPSLIST:"+Replacestring(";",outList_stim,",")+";RESPREPSLIST:"+Replacestring(";",outList_resp,",")+";"	Note/NOCR resp_mean, noteAddStr; Note/NOCR stim_mean, noteAddStr; 	Note/NOCR resp_mean, noteAddStr; Note/NOCR stim_mean, noteAddStr; Note/NOCR stim_mean, noteAddStr; 			analysis_sinAvg_getParams2(stim_mean, resp_mean, analysisParams, paramRef,0)			return outList_stim + "," + outList_respend		//parameterizes average sin responsefunction analysis_sinAvg_getParams2(stimWv, respWv, analysisParamsWv, paramOutRef, addNote)	WAVE stimWv, respWv,analysisParamsWv; String paramOutRef	Variable addNote		//pass to add note with paramRef to input waves		Variable sRate = dimdelta(stimWv,0)	Variable cycleLen_x_stimIn = analysisParamsWv[%cycleLen_X]	Variable period_s_stimIn = analysisParamsWv[%period_s]	Variable cycleLen_P = cycleLen_x_stimIn / sRate	Variable period_P_stimIn = period_s_stimIn / sRate		//generate fits	Make/O/D W_coef		CurveFit/B=(period_P_stimIn)/NTHR=0/N=1/Q/W=2 sin stimWv	Duplicate/O W_coef, W_coef_stim; print "stimRef",nameofwave(stimWv),W_coef_stim//,W_coef_stim[3]-2*pi,W_coef_stim[3]+2*pi	CurveFit/B=(period_P_stimIn)/NTHR=0/N=1/Q/W=2 sin respWv	Duplicate/O W_coef, W_coef_resp; print "respRef",nameofwave(respWv),W_coef_resp		//phase can equivalently be +/- 2*pi. 	Double phase_rad_stim_v1 = w_coef_stim[3], phase_rad_resp_v1 = w_coef_resp[3]		Variable stim_phase_flipped = 0, resp_phase_flipped = 0	if ( phase_rad_resp_v1 < 0 )		//flip phase of response 		phase_rad_resp_v1 += 2*pi		resp_phase_flipped = 1	endif	if ( phase_rad_stim_v1 < 0 )		//flip phase of stim		phase_rad_stim_v1 += 2*pi		stim_phase_flipped = 1	endif		Double phase_rad_diff_v1 = phase_rad_resp_v1 - phase_rad_stim_v1	Double phase_s_resp_v1 = phase_rad_resp_v1	/ W_coef_stim[2] 	Double phase_s_stim_v1 = phase_rad_stim_v1	/ W_coef_stim[2] 	Double phase_s_diff_v1 = phase_s_resp_v1 - phase_s_stim_v1	Double phase_sv1_diff_v1 = phase_rad_diff_v1 / W_coef_stim[2]			//calculate parameters		//frequency,period,phase	Double freq_Hz_stim = W_coef_stim[2] / 2 / pi	Double period_s_stim = 1 / freq_Hz_stim	Double phase_s_stim = W_coef_stim[3] / W_coef_stim[2] //phase offset in seconds	Double freq_Hz_resp = W_coef_resp[2] / 2 / pi	Double period_s_resp = 1 / freq_Hz_resp	Double phase_s_resp = W_coef_resp[3] / W_coef_resp[2] //phase offset in seconds		Double freq_hz_diff = freq_Hz_resp - freq_Hz_stim	Double period_s_diff = period_s_resp - period_s_stim	Double phase_s_diff = phase_s_resp - phase_s_stim		Double freq_rad_diff = W_coef_resp[2] - W_coef_stim[2]	Double period_rad_stim = 1/W_coef_stim[2]	double period_rad_resp = 1/W_coef_resp[2]	double period_rad_diff = period_rad_resp - period_rad_stim	double phase_rad_diff = W_coef_resp[3] - W_coef_stim[3]		//amplitude related	Double impedence = W_coef_resp[1]/W_coef_stim[1]	Double power_VxI = W_coef_resp[1]*W_coef_stim[1]				Double avgLen_x = dimsize(respWv,0) * dimdelta(respWv,0)	Double expectedNumCycles_resp = avgLen_x / period_s_resp	Double expectedNumCycles_stim = avgLen_x / period_s_stim		analysis_sinAvgMinMaxStats(respWv,"analysis_sinAvgMinMaxStatsRTemp",expectedNumCycles_resp,period_s_resp,"resp_")	WAVE/D analysis_sinAvgMinMaxStatsRTemp	analysis_sinAvgMinMaxStats(respWv,"analysis_sinAvgMinMaxStatsSTemp",expectedNumCycles_stim,period_s_stim,"stim_")	WAVE/D analysis_sinAvgMinMaxStatsSTemp	Variable numParams = 38	//store results	Make/O/D/N=(numParams) sinParamsTemp//$paramOutRef/wave=out	variable r=-1			r+=1;dl_assignAndLbl(sinParamsTemp, r, W_coef_stim[0], "W_coef_stim_0")	r+=1;dl_assignAndLbl(sinParamsTemp, r, W_coef_stim[1], "W_coef_stim_1")	r+=1;dl_assignAndLbl(sinParamsTemp, r, W_coef_stim[2], "W_coef_stim_2")	r+=1;dl_assignAndLbl(sinParamsTemp, r, W_coef_stim[3], "W_coef_stim_3")	r+=1;dl_assignAndLbl(sinParamsTemp, r, W_coef_resp[0], "W_coef_resp_0")	r+=1;dl_assignAndLbl(sinParamsTemp, r, W_coef_resp[1], "W_coef_resp_1")	r+=1;dl_assignAndLbl(sinParamsTemp, r, W_coef_resp[2], "W_coef_resp_2")	r+=1;dl_assignAndLbl(sinParamsTemp, r, W_coef_resp[3], "W_coef_resp_3")	//8	r+=1;dl_assignAndLbl(sinParamsTemp, r, cycleLen_P, "mean_cycleLen_P")	r+=1;dl_assignAndLbl(sinParamsTemp, r, freq_Hz_stim, "freq_Hz_stim")	r+=1;dl_assignAndLbl(sinParamsTemp, r, period_s_stim, "period_s_stim")	r+=1;dl_assignAndLbl(sinParamsTemp, r, phase_s_stim, "phase_s_stim")	r+=1;dl_assignAndLbl(sinParamsTemp, r, freq_Hz_resp, "freq_Hz_resp")	r+=1;dl_assignAndLbl(sinParamsTemp, r, period_s_resp, "period_s_resp")	r+=1;dl_assignAndLbl(sinParamsTemp, r, phase_s_resp, "phase_s_resp")	r+=1;dl_assignAndLbl(sinParamsTemp, r, freq_hz_diff, "freq_hz_diff")	r+=1;dl_assignAndLbl(sinParamsTemp, r, period_s_diff, "period_s_diff")	r+=1;dl_assignAndLbl(sinParamsTemp, r, phase_s_diff, "phase_s_diff")	//18	r+=1;dl_assignAndLbl(sinParamsTemp, r, phase_rad_stim_v1, "phase_rad_stim_v1")	r+=1;dl_assignAndLbl(sinParamsTemp, r, phase_rad_resp_v1, "phase_rad_resp_v1")	r+=1;dl_assignAndLbl(sinParamsTemp, r, phase_rad_diff_v1, "phase_rad_diff_v1")	//phase_sv1_diff_v1	r+=1;dl_assignAndLbl(sinParamsTemp, r, phase_s_resp_v1, "phase_s_resp_v1")	r+=1;dl_assignAndLbl(sinParamsTemp, r, phase_s_stim_v1, "phase_s_stim_v1")	r+=1;dl_assignAndLbl(sinParamsTemp, r, phase_s_diff_v1, "phase_s_diff_v1")	r+=1;dl_assignAndLbl(sinParamsTemp, r, stim_phase_flipped, "stim_phase_flipped")	r+=1;dl_assignAndLbl(sinParamsTemp, r, resp_phase_flipped, "resp_phase_flipped")	r+=1;dl_assignAndLbl(sinParamsTemp, r, nan, "placeholder0")//r+=1;dl_assignAndLbl(sinParamsTemp, r, phase_s_diff_v1, "phase_s_diff_v1")	r+=1;dl_assignAndLbl(sinParamsTemp, r, nan, "placeholder1")//r+=1;dl_assignAndLbl(sinParamsTemp, r, phase_s_diff_v1, "phase_s_diff_v1")	//28	r+=1;dl_assignAndLbl(sinParamsTemp, r, freq_rad_diff, "freq_rad_diff")	r+=1;dl_assignAndLbl(sinParamsTemp, r, period_rad_stim, "period_rad_stim")	r+=1;dl_assignAndLbl(sinParamsTemp, r, period_rad_resp, "period_rad_resp")	r+=1;dl_assignAndLbl(sinParamsTemp, r, period_rad_diff, "period_rad_diff")	r+=1;dl_assignAndLbl(sinParamsTemp, r, phase_rad_diff, "phase_rad_diff")	//33	r+=1;dl_assignAndLbl(sinParamsTemp, r, impedence, "impedence")	r+=1;dl_assignAndLbl(sinParamsTemp, r, power_VxI, "power_VxI")		//wave stats results	r+=1;dl_assignAndLbl(sinParamsTemp, r, avgLen_x, "avgLen_x")	r+=1;dl_assignAndLbl(sinParamsTemp, r, expectedNumCycles_stim, "expectedNumCycles_stim")	r+=1;dl_assignAndLbl(sinParamsTemp, r, expectedNumCycles_resp, "expectedNumCycles_resp")	//38			string inNote = note(analysisParamsWv)		concatenate/NP=0/DL/O/kill {analysisParamsWv,sinParamsTemp,analysis_sinAvgMinMaxStatsRTemp,analysis_sinAvgMinMaxStatsSTemp}, $paramOutRef	note/nocr $paramOutRef, inNote		if (addNote)		note/nocr stimWv, "sinAvgParamRef:" + paramOutRef + ";"		note/nocr respWv, "sinAvgParamRef:" + paramOutRef + ";"	endif		Print "analysis_sinAvg_getParams2() paramOutRef",paramOutRefend//analysis_sinAvg_getParams2()//resp throughout but could equally pass stimfunction analysis_sinAvgMinMaxStats(wv,outRef,expectedNumCycles,period_s_resp,dlPreAppendStr)	WAVE/D wv; string outRef	Double expectedNumCycles,period_s_resp	String dlPreAppendStr		//analyze first period	Double analysisReg1_start_x = 0	Double analysisReg1_end_x = period_s_resp	Variable firstPeriodComplete = expectedNumCycles >= 1	wavestats/Q/R=(analysisReg1_start_x, analysisReg1_end_x) wv	Double firstPeriod_maxVal = V_max	Double firstPeriod_maxLoc = V_maxLoc	Double firstPeriod_minVal = V_min	Double firstPeriod_minLoc = V_minLoc	Double firstPeriod_amp = V_max - V_min	Double firstPeriod_halfVal = firstPeriod_minVal + firstPeriod_amp / 2	FindLevel/Q/R=(firstPeriod_minLoc, firstPeriod_maxLoc) wv, firstPeriod_halfVal	Variable firstHalfValFind_flag = V_flag	Variable firstHalfValFind_rising = V_rising	Double firstHalfVal_loc = V_levelX	Double firstPeriod_minMaxLocDiff_abs = abs(firstPeriod_maxLoc-firstPeriod_minLoc)	Variable firstPeriod_rising = firstPeriod_minLoc < firstPeriod_maxLoc		//is minimum  before max?		//analyze second period	Double analysisReg2_start_x = period_s_resp	Double analysisReg2_end_x = period_s_resp*2	Variable secondPeriodComplete = expectedNumCycles >= 2	wavestats/Q/R=(analysisReg2_start_x, analysisReg2_end_x) wv	Double secondPeriod_maxVal = V_max	Double secondPeriod_maxLoc = V_maxLoc	Double secondPeriod_minVal = V_min	Double secondPeriod_minLoc = V_minLoc	Double secondPeriod_amp = V_max - V_min	Double secondPeriod_halfVal = secondPeriod_minVal + secondPeriod_amp / 2	FindLevel/Q/R=(secondPeriod_minLoc, secondPeriod_maxLoc) wv, secondPeriod_halfVal	Variable secondHalfValFind_flag = V_flag	Variable secondHalfValFind_rising = V_rising	Double secondHalfVal_loc = V_levelX	Double secondPeriod_minMaxLocDiff_abs = abs(secondPeriod_maxLoc-secondPeriod_minLoc)	Variable secondPeriod_rising = firstPeriod_minLoc < firstPeriod_maxLoc		//is minimum  before max?		//analyze intermediate half	Double interimSearchStart_x, interimSearchEnd_x, interim_amp, interim_halfVal	if (firstPeriod_rising)		//V_max is last, look for interim falling half		interimSearchStart_x = firstPeriod_maxLoc		interimSearchEnd_x = secondPeriod_minLoc		interim_amp = firstPeriod_maxVal - secondPeriod_minVal		interim_halfVal = secondPeriod_minVal + interim_amp / 2	else		//V_min is last, look for interim rising half		interimSearchStart_x = firstPeriod_minLoc		interimSearchEnd_x = secondPeriod_maxLoc			interim_amp = secondPeriod_maxVal - firstPeriod_minVal		interim_halfVal = firstPeriod_minVal + interim_amp / 2	endif	FindLevel/Q/R=(interimSearchStart_x, interimSearchEnd_x) wv, interim_halfVal	double interimHalfValFind_flag = V_flag	double interimHalfValFind_rising = V_rising	double interimHalfVal_loc = V_levelX		//other stats related to this analysis	double minMax_period = secondHalfVal_loc - firstHalfVal_loc		//phase is semi-arbitrary but will be correct relative to stimulus	double minMax_phase;Variable phaseFromRegion	Double risingPeriodAmp,fallingPeriodAmp	if (firstPeriod_rising)		minMax_phase = firstHalfVal_loc		phaseFromRegion = 0		risingPeriodAmp = firstPeriod_amp		fallingPeriodAmp = secondPeriod_amp	elseif(secondPeriod_rising)		minMax_phase = secondHalfVal_loc		phaseFromRegion = 1		risingPeriodAmp = secondPeriod_amp		fallingPeriodAmp = firstPeriod_amp	else		minMax_phase = nan		phaseFromRegion = nan		risingPeriodAmp = nan		fallingPeriodAmp = nan		endif		Variable numParams = 40	Make/O/D/N=(numParams) $outRef/wave=out	variable r=-1			r+=1;dl_assignAndLbl(out, r, analysisReg1_start_x, dlPreAppendStr + "analysisReg1_start_x")		r+=1;dl_assignAndLbl(out, r, analysisReg1_end_x, dlPreAppendStr + "analysisReg1_end_x")		r+=1;dl_assignAndLbl(out, r, firstPeriodComplete, dlPreAppendStr + "firstPeriodComplete")		r+=1;dl_assignAndLbl(out, r, firstPeriod_maxVal, dlPreAppendStr + "firstPeriod_maxVal")		r+=1;dl_assignAndLbl(out, r, firstPeriod_maxLoc, dlPreAppendStr + "firstPeriod_maxLoc")		r+=1;dl_assignAndLbl(out, r, firstPeriod_minVal, dlPreAppendStr + "firstPeriod_minVal")		r+=1;dl_assignAndLbl(out, r, firstPeriod_minLoc, dlPreAppendStr + "firstPeriod_minLoc")		r+=1;dl_assignAndLbl(out, r, firstPeriod_amp, dlPreAppendStr + "firstPeriod_amp")		r+=1;dl_assignAndLbl(out, r, firstPeriod_halfVal, dlPreAppendStr + "firstPeriod_halfVal")		r+=1;dl_assignAndLbl(out, r, firstHalfValFind_flag, dlPreAppendStr + "firstHalfValFind_flag")		r+=1;dl_assignAndLbl(out, r, firstHalfValFind_rising, dlPreAppendStr + "firstHalfValFind_rising")		r+=1;dl_assignAndLbl(out, r, firstHalfVal_loc, dlPreAppendStr + "firstHalfVal_loc")		r+=1;dl_assignAndLbl(out, r, firstPeriod_minMaxLocDiff_abs, dlPreAppendStr + "firstPeriod_minMaxLocDiff_abs")		r+=1;dl_assignAndLbl(out, r, firstPeriod_rising, dlPreAppendStr + "firstPeriod_rising")		r+=1;dl_assignAndLbl(out, r, analysisReg2_start_x, dlPreAppendStr + "analysisReg2_start_x")		r+=1;dl_assignAndLbl(out, r, analysisReg2_end_x, dlPreAppendStr + "analysisReg2_end_x")		r+=1;dl_assignAndLbl(out, r, secondPeriodComplete, dlPreAppendStr + "secondPeriodComplete")		r+=1;dl_assignAndLbl(out, r, secondPeriod_maxVal, dlPreAppendStr + "secondPeriod_maxVal")		r+=1;dl_assignAndLbl(out, r, secondPeriod_maxLoc, dlPreAppendStr + "secondPeriod_maxLoc")		r+=1;dl_assignAndLbl(out, r, secondPeriod_minVal, dlPreAppendStr + "secondPeriod_minVal")			r+=1;dl_assignAndLbl(out, r, secondPeriod_minLoc, dlPreAppendStr + "secondPeriod_minLoc")		r+=1;dl_assignAndLbl(out, r, secondPeriod_amp, dlPreAppendStr + "secondPeriod_amp")		r+=1;dl_assignAndLbl(out, r, secondPeriod_halfVal, dlPreAppendStr + "secondPeriod_halfVal")		r+=1;dl_assignAndLbl(out, r, secondHalfValFind_flag, dlPreAppendStr + "secondHalfValFind_flag")		r+=1;dl_assignAndLbl(out, r, secondHalfValFind_rising, dlPreAppendStr + "secondHalfValFind_rising")		r+=1;dl_assignAndLbl(out, r, secondHalfVal_loc, dlPreAppendStr + "secondHalfVal_loc")		r+=1;dl_assignAndLbl(out, r, secondPeriod_minMaxLocDiff_abs, dlPreAppendStr + "secondPeriod_minMaxLocDiff_abs")		r+=1;dl_assignAndLbl(out, r, secondPeriod_rising, dlPreAppendStr + "secondPeriod_rising")		r+=1;dl_assignAndLbl(out, r, interimSearchStart_x, dlPreAppendStr + "interimSearchStart_x")		r+=1;dl_assignAndLbl(out, r, interimSearchEnd_x, dlPreAppendStr + "interimSearchEnd_x")		r+=1;dl_assignAndLbl(out, r, interim_amp, dlPreAppendStr + "interim_amp")		r+=1;dl_assignAndLbl(out, r, interim_halfVal, dlPreAppendStr + "interim_halfVal")		r+=1;dl_assignAndLbl(out, r, interimHalfValFind_flag, dlPreAppendStr + "interimHalfValFind_flag")		r+=1;dl_assignAndLbl(out, r, interimHalfValFind_rising, dlPreAppendStr + "interimHalfValFind_rising")		r+=1;dl_assignAndLbl(out, r, interimHalfVal_loc, dlPreAppendStr + "interimHalfVal_loc")		r+=1;dl_assignAndLbl(out, r, minMax_period, dlPreAppendStr + "minMax_period")		r+=1;dl_assignAndLbl(out, r, minMax_phase, dlPreAppendStr + "minMax_phase")		r+=1;dl_assignAndLbl(out, r, phaseFromRegion, dlPreAppendStr + "phaseFromRegion")		r+=1;dl_assignAndLbl(out, r, risingPeriodAmp, dlPreAppendStr + "risingPeriodAmp")		r+=1;dl_assignAndLbl(out, r, fallingPeriodAmp, dlPreAppendStr + "fallingPeriodAmp")			end//get sin fit function as used by curve fittingfunction sinusoid(w,x)	Wave/D w; double x		return w[0]+w[1]*sin(w[2]*x+w[3])end	//sin avg for data with original current stimulus, voltage resp used as clamp, and current response to clampfunction/S analysis_sinAvg_stimClampResp(sinStimRef, clampStimRef, respRef, outRef_stim, outRef_clamp, outRef_resp, startX, endX, numSkipCycles, numPreCycles, numPostCycles, saveReps)	String sinStimRef		//original current sin wave	String clampStimRef //voltage response used as command	String respRef	//current response	String outRef_stim, outRef_clamp, outRef_resp		//must pass	Variable saveReps	Variable startX, endX		//start and end values for sine wave stim (NOT region that will be averaged, see below)	Variable numSkipCycles		//num cycles not to include in average	Variable numPreCycles		//num preceding cycles to include in average--0 would have average start at the beginning of the cycle	Variable numPostCycles		//num cycles following the cycle to include in average--0 would have average end at one cycle		WAVE stim = $sinStimRef	WAVE clamp = $clampStimRef	WAVE resp = $respRef		Variable estMidvalue = mean(stim, startX, endX)		FindLevels/B=10/EDGE=1/Q/R=(startX,endX) stim, estMidValue			Variable estNumPntsPerCycle  = (endX-startX)/dimdelta(stim,0)/V_LevelsFound	//total num pnts in fit region divided by estimated num cycles in region = estimated points per cycle		Print "estNumPntsPerCycle:", estNumPntsPerCycle, "as x:", estNumPntsPerCycle * dimdelta(stim,0)	Make/O/D W_coef		CurveFit/B=(estNumPntsPerCycle)/NTHR=0/N=1/Q/W=2 sin stim(startX, endX)	Print/D "W_coef", W_coef	Variable freq_Hz = W_coef[2] / 2 / pi	Variable period_s = 1/freq_Hz	Variable phase_s = W_coef[3] / W_coef[2] //phase offset in seconds		Print "freq_Hz",freq_Hz, "period_s", period_s, "phase_s", phase_s, "W_coef[3]", W_coef[3]		Variable actNumCycles = (endX - startX) * freq_Hz	Variable startCycle = numSkipCycles 	Variable cycleLen_X = (1+numPreCycles+numPostCycles) * period_s		//# periods in each average * period length	Variable cycleLen_P = cycleLen_X / dimDelta(resp,0)	Variable timeFromPrecedingCycle = numPreCycles*period_s	Variable numCyclesBeforeStart = floor(startX / period_s)	Variable firstCycleStart = (numCyclesBeforeStart+1) * period_s - phase_s		Print "actNumCycles", actNumCycles, "startCycle", startCycle, "cycleLen_X", cycleLen_X, "cycleLen_P", cycleLen_P,"timeFromPrecedingCycle", timeFromPrecedingCycle, "firstCycleStart:", firstCycleStart	Print "numCyclesBeforeStart", numCyclesBeforeStart	duplicate/O/R=(0,cycleLen_X) resp, $outRef_resp/WAVE=resp_mean; SetScale/P x, 0, dimdelta(resp,0), resp_mean		//make sure portion starts at zero	duplicate/O/R=(0,cycleLen_X) clamp, $outRef_clamp/WAVE=clamp_mean; SetScale/P x, 0, dimdelta(stim,0), clamp_mean		duplicate/O/R=(0,cycleLen_X) stim, $outRef_stim/WAVE=stim_mean; SetScale/P x, 0, dimdelta(stim,0), stim_mean		resp_mean = 0; stim_mean = 0; clamp_mean = 0	if (saveReps)		Duplicate/O resp_mean, resp_temp		Duplicate/O stim_mean, stim_temp		Duplicate/O clamp_mean, clamp_temp	endif		Print "avg win lenx:", dimsize(resp_mean,0) * dimdelta(resp_mean,0)		Variable currCycleNum, cycleStartX, portionToAvgStartX	Variable count = 0	String currRef_stim, currRef_resp, currRef_clamp, outList = ""	for (currCycleNum = startCycle; currCycleNum < actNumCycles - 2 - numPostCycles; currCycleNum+=1)		debug_checkRTErrState(msg="start COUNT:"+num2str(count))		cycleStartX = firstCycleStart + (currCycleNum*period_s)		portionToAvgStartX = cycleStartX - timeFromPrecedingCycle		debug_checkRTErrState(msg="aaaaCOUNT:"+num2str(count))		resp_mean[0, ] += resp(x+portionToAvgStartX)		debug_checkRTErrState(msg="bbbbCOUNT:"+num2str(count))		stim_mean[0, ] += stim(x+portionToAvgStartX)		clamp_mean[0,] += clamp(x+portionToAvgStartX)		debug_checkRTErrState(msg="bbbbddddddCOUNT:"+num2str(count))		if (saveReps)			currRef_stim = outRef_stim + "_" +num2str(count)			outList += currRef_stim + ";"			debug_checkRTErrState(msg="ccccCOUNT:"+num2str(count))			stim_temp[0,] = stim(x+portionToAvgStartX)			debug_checkRTErrState(msg="ddddCOUNT:"+num2str(count))			duplicate/O stim_temp, $currRef_stim						currRef_resp = outRef_resp + "_" +num2str(count)			resp_Temp[0,] = resp(x+portionToAvgStartX)			duplicate/O resp_temp, $currRef_resp					currRef_clamp = outRef_clamp + "_" + num2str(count)			clamp_temp[0,] = clamp(x+portionToAvgStartX)			duplicate/O clamp_temp, $currRef_clamp 			debug_checkRTErrState(msg="eeeeeeeCOUNT:"+num2str(count))		endif				count += 1	//	Print "count:", count, "portionToAvgStartX:", portionToAvgStartX, "cycleStartX:", cycleStartX, ". portionEndX:", portionToAvgStartX + dimsize(resp_mean,0) * dimdelta(resp_mean,0), portionToAvgStartX + dimsize(resp_temp,0) * dimdelta(resp_temp,0), portionToAvgStartX + dimsize(stim_temp,0) * dimdelta(stim_temp,0)		debug_checkRTErrState(msg="endCOUNT:"+num2str(count))	endfor 	resp_mean /= count	stim_mean /= count	clamp_mean/=count	Print "outList", outList	Print "COUNT = " + num2str(count) //	SetScale/P x, -timeFromPrecedingCycle , dimdelta(resp,0), resp_mean, stim_mean, clamp_mean//	SetScale/P x, -timeFromPrecedingCycle , dimdelta(stim,0), stim_mean	//	Duplicate/O resp_mean, $(outRef_resp + "_n")/WAVE=resp_n//	setscale/P x, -timeFromPrecedingCycle, 		return outListend	function dummy_a()		String list	Variable stimStart = 2.22816	Variable stimEnd = 12.20648			list = analysis_sinAvg_stimClampResp("G16073009_0010_1_AD1", "G16073009_0013_1_AD1", "G16073009_00131A0m00131A0", "stim_1", "clamp_1", "resp_1",stimSTart, stimEnd, 3, .5, .5,1)	list = analysis_sinAvg_stimClampResp("G16073009_0010_2_AD1", "G16073009_0013_2_AD1", "G16073009_00132A0m00132A0", "stim_2", "clamp_2", "resp_2",stimSTart, stimEnd, 3, .5, .5,1)	list = analysis_sinAvg_stimClampResp("G16073009_0010_3_AD1", "G16073009_0013_3_AD1", "G16073009_00133A0m00133A0", "stim_3", "clamp_3", "resp_3",stimSTart, stimEnd, 3, .5, .5,1)	list = analysis_sinAvg_stimClampResp("G16073009_0010_4_AD1", "G16073009_0013_4_AD1", "G16073009_00134A0m00134A0", "stim_4", "clamp_4", "resp_4",stimSTart, stimEnd, 3, .5, .5,1)	list = analysis_sinAvg_stimClampResp("G16073009_0010_5_AD1", "G16073009_0013_5_AD1", "G16073009_00135A0m00135A0", "stim_5", "clamp_5", "resp_5",stimSTart, stimEnd, 3, .5, .5,1)	list = analysis_sinAvg_stimClampResp("G16073009_0010_6_AD1", "G16073009_0013_6_AD1", "G16073009_00136A0m00136A0", "stim_6", "clamp_6", "resp_6",stimSTart, stimEnd, 3, .5, .5,1)	list = analysis_sinAvg_stimClampResp("G16073009_0010_7_AD1", "G16073009_0013_7_AD1", "G16073009_00137A0m00137A0", "stim_7", "clamp_7", "resp_7",stimSTart, stimEnd, 3, .5, .5,1)endfunction dummy_b()	WAVE resp_1, resp_2, resp_3, resp_4, resp_5, resp_6, resp_7	WAVE stim_1, stim_2, stim_3, stim_4, stim_5, stim_6, stim_7	WAVE clamp_1, clamp_2, clamp_3, clamp_4, clamp_5, clamp_6, clamp_7	display/B=b_1/L=resp resp_1; appendtograph/B=b_1/L=stim stim_1; appendtograph/B=b_1/L=clamp clamp_1	appendtograph/B=b_2/L=resp resp_2; appendtograph/B=b_2/L=stim stim_2; appendtograph/B=b_2/L=clamp clamp_2	appendtograph/B=b_3/L=resp resp_3; appendtograph/B=b_3/L=stim stim_3; appendtograph/B=b_3/L=clamp clamp_3	appendtograph/B=b_4/L=resp resp_4; appendtograph/B=b_4/L=stim stim_4; appendtograph/B=b_4/L=clamp clamp_4	appendtograph/B=b_5/L=resp resp_5; appendtograph/B=b_5/L=stim stim_5; appendtograph/B=b_5/L=clamp clamp_5	appendtograph/B=b_6/L=resp resp_6; appendtograph/B=b_6/L=stim stim_6; appendtograph/B=b_6/L=clamp clamp_6	appendtograph/B=b_7/L=resp resp_7; appendtograph/B=b_7/L=stim stim_7; appendtograph/B=b_7/L=clamp clamp_7endfunction disp_matchingWavesToFrontBack(matchStr, frontOrBack, useTNs, [excludeMatchStr])	string matchstr	Variable frontOrBack //0 for front, 1 for back	Variable useTNs		//pass to use trace names instead of wave names	String excludeMatchStr		//pass to exclude certain waves		String list	if (useTNs)		list = tracenamelist(winname(0,1), ";",1)		//top window	else		list = wavelist(matchStr, ";","WIN:")		//top window	endif		if (!ParamIsDefault(excludeMatchStr))		list = ListMatch(list, "!"+excludeMatchStr)	endif			variable i, count = 0	for (i=0;i<ItemsInList(list);i+=1)		if (frontOrBack)			reordertraces _back_, {$StringFromList(i,list)}		else			reordertraces _front_, {$StringFromList(i,list)}		endif		count +=1	endfor		Print "# waves moved forward or back = ", count	end//correct a white noise filterfunction wn_correctFilter(inRef, [appendstr])	String inRef	string appendstr		//optionally pass own append str		if (ParamIsDefault(appendStr) || (strlen(appendStr) < 1) )		appendStr = "_c"		//default append str	endif		variable rangeStart_p = 0, rangeEnd_p = 1		String outRef = inRef + appendStr		Duplicate/O $inRef, $outRef/WAVE=out		out[rangeStart_p,rangeEnd_p] = 0		note/nocr out, "wnCorrectionOrigRef:" + inRef + ";wnCorrectionRangeStart_p:" + num2str(rangeStart_p) + ";wnCorrectionRangeEnd_p:"+num2str(rangeEnd_p) + ";"	end//save waves on a graph to file and put graph recreation macro on clipboard (also returns it and prints it to command line)//macro will automatically map to the file to find the waves and recreate the graph, even in another igor procedurefunction/S fio_saveGraphWithWaves(overwritePath, [pathUsed, winN,skipSave,useUserFilesPath,makeRecreationExecutable])	variable overwritePath	String winN	String &pathUsed 	//pass to have this reference filled with the used path	Variable skipSave		//optionally skip saving and just get the macro string, which is useful if waves are already saved but graphs changed	Variable useUserFilesPath	//optionally pass to use userFilesPath	Variable makeRecreationExecutable	//optionally pass to make directly executable; strips recreation macro of function parts		String pathStr = "graphSavePath"	if (ParamIsDefault(useUserFilesPath) || !useUserFilesPath)		if (overwritePath)			NewPath/O/Q $pathStr		else		//use current graphSavePath, if possible, otherwise have user instantiate that path			PathInfo $pathStr			if (!V_flag)				NewPath/O/Q $pathStr			endif		endif				else		pathStr = "IgorUserFiles"	endif		if (ParamIsDefault(winN))		winN = winname(0,disp_getRecreatableWinSelector())	endif		string recreationStr =  winrecreation(winN,0)		Variable error = GETRTERRor(1)		//1 specifies to clear and continue, ignoring error	if (error)		Print "Error occured before/during fio_saveGraphWithWaves(). error =  " + GetErrMessage(error) 	endif		string wlist = wavelist("*",";","WIN:" + winN)		if (PAramIsDefault(skipSave) || !skipSave)		fio_saveWavesByName("*",pathStr,1, saveListStr = wList)		//save waves on graph as binary file	endif		PathInfo $pathStr		//makes sure S_path available for writing full path	string wLoadStr	Variable num = itemsinlist(wList)	if (num < 6)		//after this amount it becomes an unreasonably long single line command		sprintf wLoadStr, "\tfio_loadfiles(\"*\",\".ibw\",loadWvListStr=\"%s\",fullPathStr=\"%s\")\r", wList, S_path 	else		wLoadStr="\tString loadWvListStr=\"\"\r"		Variable i; string temp		for (i=0;i<num;i+=1)			wLoadStr+="\tloadWvListStr+=\""+stringfromlist(i,wList)+";\"\r"		endfor			sprintf temp,"\tfio_loadfiles(\"*\",\".ibw\",loadWvListStr=loadWvListStr,fullPathStr=\"%s\")\r",S_path		wLoadStr+=temp	endif			Variable firstLinePnts = strsearch(recreationStr, "\r", 1)	String firstLine = recreationStr[0,firstLinePnts]	String functionCmd=stringfromlist(1,firstLine," ")		recreationStr = firstLine + wLoadStr + recreationStr[firstLinePnts,inf] + " //"+functionCmd +"<--run this"		If (!ParamIsDefault(makeRecreationExecutable) && makeRecreationExecutable)		recreationStr = removelistitem(0,recreationStr,"\r")		String pauseUpdates = listmatch(recreationStr,"*PauseUpdate*","\r"),line		Variable numMatch=itemsinlist(pauseUpdates),j		for (j=0;j<numMatch;j+=1)			line=stringfromlist(j,pauseUpdates,"\r")			recreationStr = removefromlist(line,recreationStr,"\r")		endfor		recreationStr = ReplaceString("Display",recreationStr,"Display/N="+winN,1,1)		Variable len = itemsinlist(recreationStr,"\r")		recreationStr = removelistitem(len-1,recreationStr,"\r")		recreationStr = removelistitem(len-2,recreationStr,"\r")	endif		putscraptext recreationStr		//copy recreation macro text to clipboard		if (!ParamIsDefault(pathUsed))		pathUSed = pathStr	endif		return recreationStrendfunction/S fio_saveGraphsWithWaves(overwritePath,matchStr, numWins,[skipSave])	Variable numWins; String matchStr		Variable skipSave		//optionally skip saving and just get the macro string, which is useful if waves are already saved but graphs changed	Variable overwritePath		variable i	string pathUsed	String recreationStr = ""		string commentStr = "\r\r//// "		//holds window function call names so one can copy all of them and just run that line	string currWinN		string recretableWinList = disp_getRecreatableWinList(matchStr)	variable numWinsToSave = min(ItemsInList(recretableWinList), numWins)	variable doNewPath	variable doSkipSave=!ParamIsDefault(skipSave) && skipSave		for (i=0;i<numWinsToSave;i+=1)		currWinN = stringfromlist(i,recretableWinList)		doNewPath= (i==0) && overwritePath		recreationStr += fio_saveGraphWithWaves(doNewPath, winN = currWinN,skipSave=doSkipSave) + "\r\r"			commentStr += currWinN + "(); "	endfor		recreationStr += commentStr + "\r\r"		putscraptext recreationStr		//copy recreation macro text to clipboard		print "recreation string macro copied to clipboard"		return recreationStrend//from http://www.igorexchange.com/node/981 RGerkin author, now slightly modifiedFunction/S annote_WordWrapTB(textBoxName,wrapWidth[,windowName])	String textBoxName	Variable wrapWidth	String windowName 	if(ParamIsDefault(windowName))		windowName=WinName(0,5)	endif	Variable layout_=(WinType(windowName)==3)	if(!strlen(textBoxName))		String annotations=AnnotationList(windowName)		Variable i,textboxes		for(i=0;i<ItemsInList(annotations);i+=1)			String info=AnnotationInfo(windowName,textBoxName,1)			String type=StringByKey("TYPE",info)			if(StringMatch(type,"Textbox")) // Apply word wrapping to textboxes is graphs and layouts.  				textboxName=StringFromList(i,annotations)				if(layout_) // Layout					String layout_info=LayoutInfo(windowName,textboxName)					Variable selected=NumberByKey("SELECTED",layout_info)					if(!selected)						continue // Only apply word wrapping to selected textboxes in layouts.  					endif				endif				String result=annote_WordWrapTB(textboxName,wrapWidth,windowName=windowName)				textboxes+=1			endif		endfor		if(textboxes==0)			return ""		else			return result		endif	endif 	Variable currentLineNum = 0	// determine the dimensions of the textbox where this text will be placed.   	info=AnnotationInfo(windowName,textBoxName,1)	if(strlen(info))				string searchStr = "TEXT:"		variable searchStrLen = strlen(searchStr)		variable textStart = strsearch(info, "TEXT:",0) + searchStrLen		string textStr=info[textStart,inf]		String rect=StringByKey("RECT",info)		Variable left,top,right,bottom		sscanf rect,"%f,%f,%f,%f",left,top,right,bottom		Variable textHeight=bottom-top	else						// Textbox doesn't exist.		return ""					endif 	// Protect double carriage returns and carriage returns followed by tabs.  	textStr=ReplaceString("\r\r",textStr,"<|r>")	textStr=ReplaceString("\r\t",textStr,"<|t>")	// Kill old carriage returns.  	textStr=ReplaceString("\r",textStr,"")	// Bring back protected characters.  	textStr=ReplaceString("<|r>",textStr,"\r\r")	textStr=ReplaceString("<|t>",textStr,"\r\t") 	Make /o/T/n=0 outputTextWave	String returnTextStr=""	Variable firstLineNum=0 	// get the font information for the default font used in this panel	if(layout_)		DefaultGuiFont all	else		DefaultGuiFont/W=$(windowName) all	endif	String defaultFontName = S_name	Variable defaultTextFontSize = V_value	Variable defaultTextFontStyle = V_flag 	// now read information from title control to see if	// a non-default font size, style, or name is being used		Variable textFontSize=NaN, textFontStyle=NaN	String fontName, escapedFontName	sscanf textStr,"\Z%d",textfontSize	if (numtype(textFontSize) != 0)		// default font size is used		textFontSize = defaultTextFontSize		if (numtype(textFontSize) != 0)			textFontSize = 12		endif	endif	sscanf textStr,"\f%d",textfontStyle	if (numtype(textFontStyle) != 0)		// default font style is used		textFontStyle = defaultTextFontStyle		if (numtype(textFontStyle) != 0)			textFontStyle = 0		endif	endif			sscanf textStr,"\S'%[A-Za-z]'",fontName	if (cmpstr(fontName, "") == 0)	// no font name found		fontName = defaultFontName		if (cmpstr(fontName, "") == 0)		// will be true if S_name above is ""			fontName = GetDefaultFont(windowName)		endif	endif 	// Determine the height, in pixels, of a line of text	Variable lineHeight = FontSizeHeight(fontName, textFontSize, textFontStyle)	Variable maxNumLines = Inf//floor(textHeight / lineHeight) 	// search for spaces, check length of string up to that point + length of new text, and decide whether 	// to add the new word or add a line break	Variable sourceStringPos = 0	Variable nextSpacePos, nextCRPos, nextBreakPos	Variable currentTextWidth, newTextWidth	Variable breakIsCR = 0	String nextWordString = ""	String currentLineString = "" 	do		nextSpacePos = strsearch(textStr, " ", sourceStringPos)		nextSpacePos = nextSpacePos >= 0 ? nextSpacePos : inf		// set to inf if space is not found		nextCRPos = strsearch(textStr, "\r", sourceStringPos)		nextCRPos = nextCRPos >= 0 ? nextCRPos : inf		// set to inf if \r is not found		if (nextCRPos >= 0 && nextCRPos < nextSpacePos)			breakIsCR = 1		else			breakIsCR = 0		endif		nextBreakPos = min(nextSpacePos, nextCRPos) 		if (numtype(nextBreakPos) == 1)		// nextBreakPos == inf means there are no more spaces or \r			if (strlen(textStr) == sourceStringPos)	// at the end of the string				returnTextStr += currentLineString					break			else				nextWordString = textStr[sourceStringPos, inf]				sourceStringPos = strlen(textStr)			endif		else			nextWordString = textStr[sourceStringPos, nextBreakPos]		endif		currentTextWidth = FontSizeStringWidth(fontName, textFontSize, textFontStyle, currentLineString)		newTextWidth = FontSizeStringWidth(fontName, textFontSize, textFontStyle, nextWordString)		if ((currentTextWidth + newTextWidth + 5) <= wrapWidth)		// add this word		// leave 5px padding			currentLineString += nextWordString			if (numtype(nextBreakPos) == 1)				break			elseif (breakIsCR)				sourceStringPos = nextBreakPos + 1				returnTextStr += currentLineString				Redimension/N=(currentLineNum + 1) outputTextWave				outputTextWave[currentLineNum] = currentLineString				currentLineString = ""				currentLineNum += 1			else				sourceStringPos = nextBreakPos + 1			endif		else													// add a new line and then add this word			returnTextStr += currentLineString			returnTextStr += "\r"			Redimension/N=(currentLineNum + 1) outputTextWave			outputTextWave[currentLineNum] = currentLineString + "\r"			currentLineNum += 1			currentLineString = nextWordString			if (numtype(nextBreakPos) == 1)				break			else				sourceStringPos = nextBreakPos + 1			endif		endif	while(sourceStringPos < strlen(textStr) - 1)	returnTextStr += currentLineString		// add last part of string to return string	Redimension/N=(currentLineNum + 1) outputTextWave	outputTextWave[currentLineNum] = currentLineString + "\r" 	Variable n	String finalOutputString = ""	Variable numLinesToReturn = min(DimSize(outputTextWave, 0), maxNumLines + firstLineNum)	For (n=firstLineNum; n<numLinesToReturn; n+=1)		finalOutputString += outputTextWave[n]	EndFor	finalOutputString=RemoveEnding(finalOutputString,"\r") 	KillWaves /Z outputTextWave	Textbox /W=$windowName /C/N=$textboxName/A=LT finalOutputString	//gb: note added /A=LT to avoid large shifts in position	return finalOutputStringEndfunction disp_getRecreatableWinSelector()	return 2^0 + 2^1 + 2^2 + 2^6	//graphs,tables,layouts,panels .. maybe others are covered? not sure haven't triedend function disp_getRecreatableWinCount(matchStr)	String matchStr		return ItemsInList(disp_getRecreatableWinList(matchStr))endfunction/S disp_getRecreatableWinList(matchStr)	String matchStr		if (strlen(matchStr) < 1)		matchStr = "*"	endif		return WinList(matchStr, ";", "WIN:"+num2str(disp_getRecreatableWinSelector()))endfunction/S disp_getRecreatableWin(index)	variable index		return winname(index,disp_getRecreatableWinSelector())end//codes is bitwise: 1 for graphs, 2 tables, 4 for layouts, 16 for notebooks, 64 for panelsfunction/S disp_getAnnotationWin(win_name, index)	string &win_name; variable index		Variable selector = 2^0 + 2^2 + 2^4	+ 2^6	//graphs + layouts + notebooks + panels (skips tables)		if (!strlen(win_name))		win_name = winname(index,selector)		//top most layout	endif		return win_nameendfunction/S disp_getTextBox(win_name, win_index, tb_name, tb_index)	string &win_name, &tb_name; variable win_index, tb_index		win_name = disp_getAnnotationWin(win_name,win_index)		if (!strlen(tb_name))		tb_name = StringFromList(tb_index,AnnotationList(win_name))	endif		return tb_nameendfunction/S annote_getTextBoxText(win_name, win_index, tb_name, tb_index)	string win_name, tb_name; variable win_index, tb_index	//will use top layout and top-most tb by default	disp_getTextBox(win_name, win_index, tb_name, tb_index)			string info = AnnotationInfo(win_name, tb_name, 1)		string searchStr = "TEXT:"	variable searchStrLen = strlen(searchStr)		variable textStart = strsearch(info, "TEXT:",0) + searchStrLen		return info[textStart,inf]endfunction annote_setTextBoxTest(win_name, win_index, tb_name, tb_index, textStr)	String win_name, tb_name, textStr; variable win_index, tb_index	disp_getTextBox(win_name, win_index, tb_name, tb_index)		Textbox/W=$win_name/C/N=$tb_name textStrendfunction/S annote_wordWrap(wrapWidth, win_name, win_index, tb_name, tb_index)	String win_name, tb_name; variable win_index, tb_index	Variable wrapWidth	annote_WordWrapTB(tb_name,wrapWidth, windowName = win_name)endfunction annote_removeWrap(win_name, win_index, tb_name, tb_index)	string win_name, tb_name; variable win_index, tb_index		disp_getTextBox(win_name, win_index, tb_name, tb_index)		String currStr = annote_getTextBoxText(win_name, win_index, tb_name, tb_index)	String unformattedStr = ReplaceString("\r", currStr, " ")	unformattedStr = ReplaceString("  ", unformattedStr, " ")		annote_setTextBoxTest(win_name, win_index, tb_name, tb_index, unformattedStr)	end//point closest to startX and endX are included in resulting wave//NEEDS ALTERING TO MAINTAIN WAVE SCALINGfunction wave_trim(wv, startX, endX [backupRef])	WAVE wv	Double startX, endX	string backupRef		//optionally pass to copy original wave in case something goes wrong!		if (!ParamIsDefault(backupRef))		Duplicate/O wv, $backupREf	endif			variable firstXVal = pnt2x(wv,0)	startX = max(firstXVal, startX)		//makes sure x val used isn't below the first x val in the wave		variable startP = x2pnt(wv,startX)		double actualStartX = pnt2x(wv,startP)	//assure that x timing won't shift (as it would if startX requested isnt an exact value)		variable lastPoint = x2pnt(wv,endX)		DeletePoints lastPoint + 1, inf, wv	//delete tail end first so last point doesnt change after the shift by deleting early points	DeletePoints 0, startP, wv 	//delete number of points = startP, so the new first cell is startP		double delta = DimDelta(wv, 0)		//change x scaling to account for shift due to deleting early points	Setscale/P  x, actualStartX, delta, wv	endfunction wave_trimWavesOnGraph(matchStr, winN, maxNumPlots, startX, endX)	String winN, matchStr	Variable maxNumPlots, startX,endX		maxNumPlots = maxNumPlots < 1 ? inf : maxNumPlots		if (strlen(winN) < 1)		winN = winname(0,1)	endif			if (strlen(matchStr) < 1)		matchStr = "*"	endif		string list = wavelist(matchStr, ";", "WIN:" + winN)		Variable i; maxNumPlots = min(ItemsInList(list), maxNumPlots)	for (i=0;i<maxNumPlots;i+=1)		wave_trim($StringFromList(i,list),startX, endX)	endfor	end	function/S spectraSuite_xy2xcalc(ywave, xwave)	WAVE/D ywave, xwave		Variable decimalPlace = 100		String yWaveRef = NameOfWave(ywave)	String outRef = yWaveRef[0,strlen(yWaveRef)-3]		double startVal =  xwave[0]	double range = xwave[DimSize(xwave,0)-1] - startVal + 1	double numpoints = range * decimalPlace		Make/O/N=(numpoints)/D $outRef/wave=out	Setscale/P x, startVal, 1/decimalPlace, out		out = NaN		//all values in between measurement values will be NaN		Variable i	Double currX, currY, currOutP	for (i=0;i<dimsize(xwave,0);i+=1)		currX = xwave[i]; currY = ywave[i]		currOutP = x2pnt(out,currX)		out[currOutP] = currY	//	print currX, currY, currOutP	//	out[x2pnt(out,xwave[i])] = ywave[i]		endfor		Interpolate2/T=1 out		//dest is outRef + "_L"	return outRefendfunction/S analysis_fwhm(wv, outRef, preBaselineStartX, preBaselineEndX, postBaselineStartX, postBaselineEndX [nonDefaultProportion, useHeaderWave])	WAVE wv	String outRef	Double preBaselineStartX, preBaselineEndX, postBaselineStartX, postBaselineEndX	Double nonDefaultProportion		//pass to change proportion from default of 0.5 (half-max). should be 0 < nonDefaultProportion < 1	Variable useHeaderWave	//pass true to use a header wave instead of dimension labels		if (strlen(outref) < 1)		outref = nameofwave(wv) + "_fwhm"	endif		Double proportion = ParamIsDefault(nonDefaultProportion) ? 0.5 : nonDefaultProportion		wavestats/R=(preBaselineEndX,postBaselineStartX)/Q wv		Double maxVal = V_max	Double maxLoc = V_maxloc		Double preBaselineVal = mean(wv,preBaselineStartX, preBaselineEndX)	Double postBaselineVal = mean(wv, postBaselineStartX, postBaselineEndX)		Double preHalfMaxVal = (maxVal - preBaselineVal) * proportion	Double postHalfMaxVal = (maxVal - postBaselineVal) * proportion			FindLevel/EDGE=1/R=(preBaselineEndX,maxLoc)/Q wv, preHalfMaxVal	Double preHalfMaxLoc = V_LevelX		FindLevel/EDGE=2/R=(maxLoc,postBaselineStartX)/Q wv, postHalfMaxVal	Double postHalfMaxLoc = V_LevelX			Double fwhm = postHalfMaxLoc - preHalfMaxLoc	Double fwhm_centerVal = preHalfMaxLoc + fwhm/2		Variable numParams = 10	Make/O/D/N=(numParams) $outRef/wave=out		if (!ParamIsDefault(useHeaderWave) && useHeaderWave)		string headerStr = "HEADERTYPE:analysis_fwhm;" + "HEADER_NPARAMS:" + num2str(numPArams) + ";HEADER:"				out[0] = maxVal		out[1] = maxLoc		out[2] = preBaselineVal		out[3] = postBaselineVal		out[4] = preHalfMaxVal		out[5] = postHalfMaxVal		out[6] = preHalfMaxLoc		out[7] = postHalfMaxLoc		out[8] = fwhm		out[9] = fwhm_centerVal				headerStr += "0,maxVal."		headerStr += "1,maxLoc."		headerStr += "2,preBaselineVal."		headerStr += "3,postBaselineVal."		headerStr += "4,preHalfMaxVal."		headerStr += "5,postHalfMaxVal."		headerStr += "6,preHalfMaxLoc."		headerStr += "7,postHalfMaxLoc."		headerStr += "8,fwhm."		headerStr += "9,fwhm_centerVal."			headerStr += ";"		note/NOCR out, headerStr	else		dl_assignAndLbl(out, 0, maxVal, "maxVal")		dl_assignAndLbl(out, 1, maxLoc, "maxLoc")		dl_assignAndLbl(out, 2, preBaselineVal, "preBaselineVal")		dl_assignAndLbl(out, 3, postBaselineVal, "postBaselineVal")		dl_assignAndLbl(out, 4, preHalfMaxVal, "preHalfMaxVal")		dl_assignAndLbl(out, 5, postHalfMaxVal, "postHalfMaxVal")		dl_assignAndLbl(out, 6, preHalfMaxLoc, "preHalfMaxLoc")		dl_assignAndLbl(out, 7, postHalfMaxLoc, "postHalfMaxLoc")		dl_assignAndLbl(out, 8, fwhm, "fwhm")		dl_assignAndLbl(out, 9, fwhm_centerVal, "fwhm_centerVal")	endif		print "fwhm",fwhm,"fwhm_centerVal",fwhm_centerVal		return outRefendfunction/S wave_listGraphsWithWave(wv)	WAVE wv		string ref=nameofwave(wv) 	string listOfAllGraphs=WinList("*",";","WIN:1") 	String currGraph, currTraceList 	String listOfContainingGraphs = "" 	 	variable i  	for(i=0;i<itemsinlist(listOfAllGraphs);i+=1)    	currGraph = StringFromList(i,listOfAllGraphs)    	currTraceList = TraceNameList(currGraph,";",3)    	if (WhichListItem(ref, currTraceList) > -1)    		listOfContainingGraphs += currGraph + ";"    	endif    endfor        return listOfContainingGraphsend//stupid failed project attempting to allow images to be dragged with cursorfunction modMovesImage_set(winN,imageN,removeAll)	String winN	//pass "" for top window	String imageN		Variable removeAll	//pass to deactivate window hook functions		if (!removeAll)		setwindow $winN, userdata(modMovesImage_imageName) = imageN		setwindow $winN, hook(modMoveImageHook) = modMovesImage		setwindow $winN, userdata(inMoveStatusStr) = "0"	else		setwindow $winN, userdata(modMovesImage_imageName) = ""		setwindow $winN, userdata(inMoveStatusStr) = "" 		setwindow $winN, hook(modMoveImageHook) = $""		endifendfunction modMovesImage(s)	STRUCT WMWinHookStruct &s		String h_axName = "top"	String v_axName = "left"	Variable moveModifier = 2^1		//what s.eventMod code will start movement integration? 2^1 for shift	Variable moveCompleteModifier = 2^3		//what s.eventMod code will end movement integration? 2^3 for ctrl		if ( (s.eventCode != 3) && (s.eventCode != 5) )		return 0	endif		Print "ccc"		String winN = s.winname		//make sure autoscale if off. this way seems more reliable than setaxis/A=0?	getaxis/W=$winN/Q $h_axName	setaxis/W=$winN $h_axName, V_min, V_max		getaxis/W=$winN/Q $v_axName	setaxis/W=$winN $v_axName, V_min, V_max		//check the name of image to move	String imageName = GetUserData(winN, "", "modMovesImage_imageName")	if (!strlen(imageName))		Print "modMovesImage() named window hook function: use modMovesImage_set() to begin moving images with the mouse"	endif			//check whether in a shift	String inMoveStatusStr = GetUserData(winN, "", "inMoveStatusStr")	Variable inMoveStatus		//this, and the associated string inMoveStatusStr, are 1 from when movement is started to when it is completed	if (!strlen(inMoveStatusStr))	//set shift userdata..assume this is first time shift has been depressed		inMoveStatus = s.eventMod & moveModifier		setwindow $winN, userdata(inMoveStatusStr) = num2str(inMoveStatus)		//set current position to position at start of move		if (inMoveStatus)		//create 			WAVE/D/Z shiftMoveImage_pixelLocs			if (!WaveExists(shiftMoveImage_pixelLocs))				Make/O/D/N=4 shiftMoveImage_pixelLocs			endif			shiftMoveImage_pixelLocs[0] = disp_getMouseLoc(s, h_axName); 		SetDimLabel 0,0,modOn_pixVal_h,shiftMoveImage_pixelLocs			shiftMoveImage_pixelLocs[1] = disp_getMouseLoc(s, v_axName); 	SetDimLabel 0,1,modOn_pixVal_v,shiftMoveImage_pixelLocs			shiftMoveImage_pixelLocs[2] = DimOffset($imageName, 0);			SetDimLabel 0,2,modOn_offset_h,shiftMoveImage_pixelLocs			shiftMoveImage_pixelLocs[3] = DimOffset($imageName, 1); 		SetDimLabel 0,3,modOn_offset_v,shiftMoveImage_pixelLocs		endif				return 0		//now waits to run function upon modifier release	endif		variable currentMoveStatus = s.eventMod & moveModifier		//is modifier presently on?	Variable endMoveStatus = s.eventMod & moveCompleteModifier	inMoveStatus = str2num(inMoveStatusStr)						//was modifier already on?		Print "currentMoveStatus",currentMoveStatus,"inMoveStatus",inMoveStatus,"inMoveStatusStr",inMoveStatusStr		if (currentMoveStatus && !inMoveStatus)			//modifier presently down but wasn't already on--store location		Print "a"		WAVE/Z shiftMoveImage_pixelLocs		if (!WaveExists(shiftMoveImage_pixelLocs))			Make/O/D/N=4 shiftMoveImage_pixelLocs		endif		shiftMoveImage_pixelLocs[0] = disp_getMouseLoc(s, h_axName); 		SetDimLabel 0,0,modOn_pixVal_h,shiftMoveImage_pixelLocs		shiftMoveImage_pixelLocs[1] = disp_getMouseLoc(s, v_axName); 	SetDimLabel 0,1,modOn_pixVal_v,shiftMoveImage_pixelLocs		shiftMoveImage_pixelLocs[2] = DimOffset($imageName, 0);			SetDimLabel 0,2,modOn_offset_h,shiftMoveImage_pixelLocs		shiftMoveImage_pixelLocs[3] = DimOffset($imageName, 1); 		SetDimLabel 0,3,modOn_offset_v,shiftMoveImage_pixelLocs		setwindow $winN, userdata(inMoveStatusStr) = num2str(currentMoveStatus)	elseif (currentMoveStatus && inMoveStatus)		//modifier presently down and was already on, do nothing (wait for function to run upon modifier release)		Print "b"	elseif (!currentMoveStatus && !inMoveStatus)	//modifier not on and wasnt on before, do nothing		Print "c"	else		//!currentMoveStatus && inMoveSTatus  // modifier not currently on but had been				//calculate distance mouse moved since modifier was depressed and shift image that amount					Print "d"		WAVE/Z shiftMoveImage_pixelLocs			if (!WaveExists(shiftMoveImage_pixelLocs))						//if old pixel locations not found, wait for a better day...				return 0		endif					//current pixel locations of mouse				Double pixVal_h = disp_getMouseLoc(s, h_axName)			Double pixVal_v = disp_getMouseLoc(s, v_axName)					Double origClickLoc_h = shiftMoveImage_pixelLocs[%modOn_pixVal_h] - shiftMoveImage_pixelLocs[%modOn_offset_h]		Double origClickLoc_v = shiftMoveImage_pixelLocs[%modOn_pixVal_v] - shiftMoveImage_pixelLocs[%modOn_offset_v]		Double finalClickVal_h = disp_getMouseLoc(s, h_axName) - DimOffset($imageName, 0)		Double finalClickVal_v = disp_getMouseLoc(s, v_axName) - DimOffset($imageName, 1)		setscale/P x, finalClickVal_h + origClickLoc_h, dimdelta($imageName,0),$imageName		setscale/P y, finalClickVal_v - origClickLoc_v, dimdelta($imageName,1),$imageName			setwindow $winN, userdata(inMoveStatusStr) = num2str(currentMoveStatus)				//Print finalClickVal_h - origClickLoc_h,finalClickVal_v - origClickLoc_v	endif		return 0	endfunction/S disp_combineWithTopPlot(numPlots)	Variable numPlots		string topWin = winname(0,1)		string topAxes = axislist(topWin)			string lowerWins = WinList("*", ";", "WIN:1" )		variable i,j,isLeft,isBottom	String tracelist,traceinf, win,traceN,yWaveRef,yAx,xAx		for (i=1; (i<itemsinlist(lowerWins) && (i<numPlots+1)) ;i+=1)		win = stringfromlist(i,lowerWins)		tracelist = TraceNameList(win, ";", 1)		for (j=0;j<itemsinlist(tracelisT);j+=1)			traceN = stringfromlist(j,tracelisT)			yWaveRef = nameofwave(tracenametowaveref(win,traceN))			traceinf = TraceInfo(win, traceN, 0)			yAx = stringbykey("YAXIS",traceinf)			xAx = stringbykey("XAXIS",traceinf)			if ( (FindListItem(yAx,topAxes) > -1) && (FindListItem(xAx,topAxes) > -1) )				isLeft = stringmatch(yAx,"L*")		//if naming convention of L/B/T/R to start off names is followed, no need to check if axes are oriented as they should be				isBottom = stringmatch(xAx,"B*")				if (isLeft && isBottom)					appendtograph/W=$topWin/L=$yAx/B=$xAx $yWaveRef				elseif(isLeft && !isBottom)					appendtograph/W=$topWin/L=$yAx/T=$xAx $yWaveRef				elseif(!isLeft && isBottom)					appendtograph/W=$topWin/R=$yAx/B=$xAx $yWaveRef				else	//!isLeft && !isBottom					appendtograph/W=$topWin/R=$yAx/T=$xAx $yWaveRef				endif			endif					endfor	endfor		return topWinend	function disp_appendTitleToLabel(numWins)	Variable numWins		string wins = winlist("*",";","WIN:1")		variable i;string win,info,ax	for (i=0;( (i<numWins) && (i<itemsinlist(wins)) );i+=1)		win = stringfromlist(i,wins)		ax = stringfromlist(0,listmatch(AxisList(win ),"B*"))		info = AxisInfo(win, ax ) 		Label/W=$win $ax "\\Z06"+ win + " \\U"	endforendfunction/S text_dlsToList(wv,dim)	WAVE wv;variable dim		STring out = ""	variable i	for (i=0;i<Dimsize(wv,dim);i+=1)		out += getdimlabel(wv,dim,i) + ";"	endfor	return out	end//function status_normalityTest(inX) : CDFFunc//	Variable inX//	return StatsNormalCDF(inX,0,5)//Endfunction sumColsIf(ref_2d_sum,sumCol,ref_2d_test,testCol,testMatchStr)	String ref_2d_sum,ref_2d_test,testMatchStr	Variable sumCol,testCol		Variable testIsText	Variable sumIsText	Variable numRows=min(dimsize($ref_2d_sum,0),dimsize($ref_2d_test,0))		if (wavetype($ref_2d_test,1)==2)	//text		WAVE/T testWv_T = $ref_2d_test		testIsText = 1	else		WAVE testWv_V = $ref_2d_test		testIsText = 0	endif		if (wavetype($ref_2d_test,1)==2)	//text		WAVE/T sumWv_T = $ref_2d_test		testIsText = 1	else		WAVE sumWv_V = $ref_2d_test		testIsText = 0	endif		variable i	double sumout=0; string testStr	for (i=0;i<numRows;i+=1)		if (testIsText)			testStr = testWv_T[i][testCol]		else			testStr = num2str(testWv_V[i][testCol])		endif			if (!stringmatch(testStr,testMatchStr))			continue		endif				if (testIsText)			sumout += str2num(sumWv_T[i][sumCol])		else			sumout += sumWv_V[i][sumCol]		endif			endfor		return sumout	endfunction countNaNsInColIf(ref_2d_sum,countCol,ref_2d_test,testCols,testMatchStrs)	String ref_2d_sum,ref_2d_test,testMatchStrs	Variable countCol;string testCols		Variable matchForAnyColReqd = 0	//0 -- needs to be match for all test columns, 1 needs to be match for just one		Variable testIsText	Variable sumIsText	Variable numRows=min(dimsize($ref_2d_sum,0),dimsize($ref_2d_test,0))		if (wavetype($ref_2d_test,1)==2)	//text		WAVE/T testWv_T = $ref_2d_test		testIsText = 1	else		WAVE testWv_V = $ref_2d_test		testIsText = 0	endif		if (wavetype($ref_2d_test,1)==2)	//text		WAVE/T sumWv_T = $ref_2d_test		testIsText = 1	else		WAVE sumWv_V = $ref_2d_test		testIsText = 0	endif		variable i,j,testcol,isMatchForAny,isMatchForAll	double numReal=0,numNaN=0,numInf=0; string testStr,testMatchStr;variable type	for (i=0;i<numRows;i+=1)		isMatchForAll = 1		isMatchForAny = 0		for (j=0;j<itemsinlist(testCols);j+=1)			testCol = str2num(stringfromlist(j,testCols))			testMatchStr = stringfromlist(j,testMatchStrs)			if (testIsText)				testStr = testWv_T[i][testCol]			else				testStr = num2str(testWv_V[i][testCol])			endif						Print "i",i,"j",j,"testStr",testStr,"testMatchStr",testMatchStr						if (!stringmatch(testStr,testMatchStr))				isMatchForAll = 0			else				isMatchForAny = 1			endif				endfor				Print "isMatchForAll",isMatchForAll				if (matchForAnyColReqd)			if (!isMatchForAny)				continue			endif		else			if (!isMatchForAll)				continue			endif		endif							if (testIsText)			type = numtype(str2num(sumWv_T[i][countCol]))		else			type = numtype(sumWv_V[i][countCol])		endif				if (type==0)			numReal+=1		elseif (Type==1)			numInf+=1		else			numNaN+=1		endif			endfor		Print "numReal",numReal,"numInf",numInf,"numNaN",numNaN		return numReal	end//Saves any procedures displayed a procedure window. Include the AfterCompiledHook function below to call this after compiling procedure files//In limited testing, UTF-8 encoding (#pragma TextEncoding = "UTF-8") re-opens better than Windows-1252 after saving in the way this procedure does (via fprintf with strings)function saveProcs()//some default settings	String procMatchStrList = "GB Procedures*;"		//match string(s) of procedure windows to back up				String saveAppendStr = "_bu"		//optionally specify a string to append to each save file name		//In Igor7, it's probably best to specify a saveAppendStr or choose a directory other than one currently containing the to-be-saved procedure file(s).		//Using saveAppendStr="" and saving into the procedure file-containing directory will cause Igor7 to think the procedure file was modified externally. 		//Igor7 will keep trying to resolve the conflict after each compile, and when you choose to resolve it, each procedure needs to be recompiled, causing		//them to save again, re-call this function, and so on. There might be some settings where this is advantageous: putting off the conflict resolution, a reload from 		//file is like restoring to the last compile point while using file->"save procedure as..." would allow new updates to be saved	String allProcWins=winlist("*",";","WIN:128")	String procsToBackup=text_ListMatchStrList(allProcWins,procMatchStrList)	//list (semi-colon delimited) any procedures that should be saved. ".ipf" should end each list item			Variable numCharsPerWrite=500		//this has to below the limits of fprintf..not sure what that limit is, but 500 is ok	String saveExtension = ".ipf"		//I've also tested ".txt". The txt files can be copied into a procedure file and then work fine. The code might display properly in a txt file opened with proper encoding settings?			if (!itemsinlist(allProcWins))		return 0		//do nothing if no procedures match the list in procsToBackup	endif	 //choose a file to save backup(s) to; only necessary once per experiment//use newpath/O saveProcFiles_path to choose a new path	pathinfo saveProcFiles_path	if (!V_flag)		newpath/O saveProcFiles_path		if (V_flag)			Print "saveProcFiles(): user aborted selection of a folder for saving procedures; aborting"		endif	endif	//write each procedure to its save file with fprintf	Variable i,j,num=itemsinlist(procsToBackup),saveLen,strIndex,numFullWrites,sizeOfLastWrite,fileRefNum,writeIndexDelta=numCharsPerWrite-1	String procWinName,saveStr,fileName	for (i=0;i<num;i+=1)		procWinName = stringfromlist(i,procsToBackup)		saveStr = ProcedureText("" , inf, procWinName)				saveLen = strlen(saveStr)		fileName = replacestring(".ipf",procWinName,saveAppendStr+saveExtension)						//ReplaceString(".ipf",procWinName,".txt") to save as text		numFullWrites=floor(saveLen/numCharsPerWrite)		sizeOfLastWrite=mod(saveLen,numCharsPerWrite)		Open/P=saveProcFiles_path fileRefNum as fileName		for (j=0;j<numFullWrites;j+=1)			strIndex=j*numCharsPerWrite			fprintf fileRefNum,"%s",saveStr[strIndex,strIndex+writeIndexDelta]		endfor		strIndex+=numCharsPerWrite		fprintf fileRefNum,"%s",saveStr[strIndex,inf]		close fileRefNum	endforend function/S listFiles(extMatchStr,mainFolderOnly,returnFileFullPaths)	String extMatchStr	//file extension match string	Variable mainFolderOnly		//pass to only list files in the selected folder		Variable returnFileFullPaths		//pass true to have output list the full path to each file 		NewPath/O/Q/Z hierarchyRootFolderPath	if (V_flag)		Print "loadFromHierarchy(): user aborted selection of a root folder. Function aborting."	endif		PathInfo hierarchyRootFolderPath		String files = listFilesRec(S_path,extMatchStr,mainFolderOnly,returnFileFullPaths)		killpath/Z listFilesRecPathTemp		return filesendfunction/S listFilesRec(directoryPathStr,extMatchStr,mainFolderOnly,returnFileFullPaths)	String directoryPathStr	//full path to directory to search through	String extMatchStr	//file extension match string, e.g. ".txt"	Variable mainFolderOnly		//pass to only list files in the selected folder	Variable returnFileFullPaths		//pass true to have output list the full path to each file 		NewPath/O/Q listFilesRecPathTemp, directoryPathStr		string files = IndexedFile(listFilesRecPathTemp,-1,extMatchStr)	Variable i		if (returnFileFullPaths && itemsinlist(files))		String filesTemp = "";		for (i=0;i<itemsinlist(files);i+=1)			filesTemp += directoryPathStr + ":" + stringfromlist(i,files) + ";"			endfor		files = filesTemp	endif		if (!mainFolderOnly)		string dirs = IndexedDir(listFilesRecPathTemp,-1,1)		for (i=0;i<itemsinlist(dirs);i+=1)			files += listFilesRec(StringFromList(i,dirs),extMatchStr,mainFolderOnly,returnFileFullPaths)		endfor	endif		return filesend //listFilesRec()//for each respREf/cmdRef pair in list, searches for each step from searchStartX_list and makes a column in output for that row normalized and shifted to zerofunction step_exciseAndNorm_all(respREfs,cmdRefs,searchStartX_list,outRef_params,outRef_resp,absMinStepSize)	STring respREfs,cmdRefs; String  searchStartX_list		//list of searchStartX vals	Double absMinStepSize	//force a minimum step size (absolute value)	String outRef_params //place to store parameters collected	String outRef_resp	//place to store normalized response		Variable baselinePaddingX = 0.0002	Variable baselineSubLenX = 0.002		Variable numPArams=13		Double cmd_t0, cmd_t1, cmd_baseline, cmd_step	Variable searchStartX	Double cmd_range, cmd_t0_P, cmd_t1_P, respLen_P	Variable col,r,origLen_P	String respREf,cmdRef		Variable isNEgativeSTep		Variable refNum,i,numRefs=itemsinlist(respREfs),numCmds = itemsinlist(cmdRefs), numSteps = itemsinlist(searchStartX_list)	Variable count = 0	Double resp_baselineStartX,resp_baselineEndX,resp_baselineVal			for (refNum=0;refNum<numRefs;refNum+=1)				respref = stringfromlist(refNum,respRefs)		if (refNum >= numCmds)			cmdRef = stringfromlist(numCmds-1,cmdRefs)		else			cmdRef = stringfromlist(refNum,cmdRefs)		endif				for (i=0;i<numSteps;i+=1)			searchStartX = str2num(stringfromlist(i,searchStartX_list))			isNEgativeSTep = !mod(i,2)			analysis_cellParamsSimple_cmd(cmdRef,1,0,searchStartX,isNegativeStep,cmd_t0,cmd_t1,cmd_baseline,cmd_step,0,storeAndOrForceMinStepSize=absMinStepSize)			cmd_range = cmd_step - cmd_baseline			cmd_t0_P = x2pnt($respRef,cmd_t0)			cmd_t1_P = x2pnt($respRef,cmd_t1)			respLen_P = cmd_t1_P - cmd_t0_P + 1							//make or add column to store normalized wave			if ( count==0 )				//make response output				Make/O/D/N=(respLen_P,1) $outRef_resp/wave=out_resp				SetScale/P x,0,DimDelta($respRef,0),"s",out_resp								//make parameter output				Make/O/D/N=(numParams,1) $outRef_params/wave=out_params				col = 0			else				col = count				origLen_P = dimsize(out_resp,0)				Redimension/N=(max(origLen_P,respLen_P),col+1) out_resp									Redimension/N=(-1,col+1) out_params				endif							count += 1					SetDimlabel 1,col,$(respRef+"_"+num2str(i)),out_params,out_resp						Duplicate/O $respRef, resp						resp_baselineEndX = cmd_t0 - baselinePaddingX			resp_baselineSTartX = resp_baselineEndX - baselineSubLenX						resp_baselineVal = mean(resp,resp_baselineSTartX,resp_baselineEndX)			resp -= resp_baselineVal			resp /= cmd_range						Print "cmd_t0_P",cmd_t0_P						out_resp[][col] = resp[p+cmd_t0_P]					r = -1			r+=1;out_params[r][col]=isNEgativeSTep;SetDimLabel 0,r,$"cmd_isNEgativeSTep",out_params			r+=1;out_params[r][col]=absMinStepSize;SetDimLabel 0,r,$"cmd_absMinStepSize",out_params			r+=1;out_params[r][col]=cmd_t0;SetDimLabel 0,r,$"cmd_t0",out_params			r+=1;out_params[r][col]=cmd_t1;SetDimLabel 0,r,$"cmd_t1",out_params			r+=1;out_params[r][col]=cmd_baseline;SetDimLabel 0,r,$"cmd_baseline",out_params			r+=1;out_params[r][col]=cmd_step;SetDimLabel 0,r,$"cmd_step",out_params			r+=1;out_params[r][col]=cmd_t0_P;SetDimLabel 0,r,$"cmd_t0_P",out_params			r+=1;out_params[r][col]=cmd_t1_P;SetDimLabel 0,r,$"cmd_t1_P",out_params			r+=1;out_params[r][col]=respLen_P;SetDimLabel 0,r,$"respLen_P",out_params			r+=1;out_params[r][col]=cmd_range;SetDimLabel 0,r,$"cmd_range",out_params			r+=1;out_params[r][col]=resp_baselineSTartX;SetDimLabel 0,r,$"resp_baselineSTartX",out_params			r+=1;out_params[r][col]=resp_baselineEndX;SetDimLabel 0,r,$"resp_baselineEndX",out_params			r+=1;out_params[r][col]=resp_baselineVal;SetDimLabel 0,r,$"resp_baselineVal",out_params		endfor		endfor		end //step_exciseAndNorm_all()//searches for steps from searchStartX_list in respRef,cmdRef pairs, time shifts and normalizes these responses//stores average across respREf,cmdRef pairsfunction step_exciseAndNorm_avg(respREfs,cmdRefs,searchStartX_list,isNegativeStep_list,preStepLenX,absMinStepSize,outRef_params,outRef_resp,outRef_canonical,stimType)	STring respREfs,cmdRefs		//list of responses and command waves, paired by order	String  searchStartX_list		//list of searchStartX vals, paired with resp/cmds by order	String isNegativeStep_list	//list of whether steps are negative (1) or positive (0), paired again by order	Double absMinStepSize	//force a minimum step size (absolute value)	Variable preStepLenX	//how much time preceding each step should be excised?	String outRef_params //place to store parameters collected	String outRef_resp	//place to store normalized response	String outRef_canonical	//place to store canonical (grand average) response (normalized to unit voltage input)	Variable stimType		//for notekeeping: 0 = +/- 5,10 mV 1 = standard test step, large step, ramp protocol		String exRef = stringfromlist(0,respRefs)	if (!strlen(outRef_params))		outRef_params = exRef + "rc_p"	endif	if (!strlen(outRef_resp))		outRef_resp = exRef + "rc_r"	endif	if (!strlen(outRef_canonical))		outRef_canonical = exRef + "rc_c"	endif				Variable baselinePaddingX = 0.0002	Variable baselineSubLenX = 0.002		Variable numPArams=17		Double cmd_t0, cmd_t1, cmd_baseline, cmd_step	Double cmd_range,searchStartX,respStart_X	Variable cmd_t0_P, cmd_t1_P,respStart_P, respLen_P	Variable col,r,origLen_P	String respREf,cmdRef		Variable isNEgativeSTep		Variable refNum,i,numRefs=itemsinlist(respREfs),numCmds = itemsinlist(cmdRefs), numSteps = itemsinlist(searchStartX_list)	Variable count = 0	Variable avgCount = 0	Double resp_baselineStartX,resp_baselineEndX,resp_baselineVal			for (refNum=0;refNum<numRefs;refNum+=1)	//iterate response waves				respref = stringfromlist(refNum,respRefs)		if (refNum >= numCmds)			cmdRef = stringfromlist(numCmds-1,cmdRefs)		else			cmdRef = stringfromlist(refNum,cmdRefs)		endif		avgCount += 1				for (i=0;i<numSteps;i+=1)				//iterate steps			searchStartX = str2num(stringfromlist(i,searchStartX_list))			isNEgativeSTep = str2num(stringfromlist(i,isNegativeStep_list))			analysis_cellParamsSimple_cmd(cmdRef,1,0,searchStartX,isNegativeStep,cmd_t0,cmd_t1,cmd_baseline,cmd_step,0,storeAndOrForceMinStepSize=absMinStepSize)			cmd_range = cmd_step - cmd_baseline			respStart_X = cmd_t0 - preStepLenX		//where to start excising for this step			respStart_P = x2pnt($respRef,respStart_X)			cmd_t0_P = x2pnt($respRef,cmd_t0)			cmd_t1_P = x2pnt($respRef,cmd_t1)			respLen_P = cmd_t1_P - respStart_P							//make or add column to store normalized wave			if ( (refNum==0) && (i==0) )				//make response reps output				Make/O/D/N=(respLen_P,numSteps) $outRef_resp/wave=out_resp				SetScale/P x,0,DimDelta($respRef,0),"s",out_resp				out_resp = 0								//make parameter output				Make/O/D/N=(numParams,numSteps) $outRef_params/wave=out_params				out_params = 0			endif					SetDimlabel 1,i,$(respRef+"_"+num2str(i)),out_params,out_resp						WAVE respWv = $respRef						resp_baselineEndX = cmd_t0 - baselinePaddingX			resp_baselineSTartX = resp_baselineEndX - baselineSubLenX						resp_baselineVal = mean(respWv,resp_baselineSTartX,resp_baselineEndX)			//resp -= resp_baselineVal		//made into one line to avoid modifications to respWv, avoids need to duplicate original to avoid changes to it			//resp /= cmd_range						out_resp[][i] += (respWv[p+respStart_P] - resp_baselineVal) / cmd_range					r = -1			r+=1;out_params[r][i]=isNEgativeSTep;SetDimLabel 0,r,$"cmd_isNEgativeSTep",out_params			r+=1;out_params[r][i]=absMinStepSize;SetDimLabel 0,r,$"cmd_absMinStepSize",out_params			r+=1;out_params[r][i]+=1;SetDimLabel 0,r,$"avgCount",out_params						r+=1;out_params[r][i]+=cmd_t0;SetDimLabel 0,r,$"cmd_t0",out_params			r+=1;out_params[r][i]+=cmd_t1;SetDimLabel 0,r,$"cmd_t1",out_params			r+=1;out_params[r][i]+=cmd_baseline;SetDimLabel 0,r,$"cmd_baseline",out_params			r+=1;out_params[r][i]+=cmd_step;SetDimLabel 0,r,$"cmd_step",out_params			r+=1;out_params[r][i]+=cmd_t0_P;SetDimLabel 0,r,$"cmd_t0_P",out_params			r+=1;out_params[r][i]+=cmd_t1_P;SetDimLabel 0,r,$"cmd_t1_P",out_params			r+=1;out_params[r][i]+=respLen_P;SetDimLabel 0,r,$"respLen_P",out_params			r+=1;out_params[r][i]+=cmd_range;SetDimLabel 0,r,$"cmd_range",out_params			r+=1;out_params[r][i]+=resp_baselineSTartX;SetDimLabel 0,r,$"resp_baselineSTartX",out_params			r+=1;out_params[r][i]+=resp_baselineEndX;SetDimLabel 0,r,$"resp_baselineEndX",out_params			r+=1;out_params[r][i]+=resp_baselineVal;SetDimLabel 0,r,$"resp_baselineVal",out_params						r+=1;out_params[r][i]+=preStepLenX;SetDimLabel 0,r,$"preStepLenX",out_params			r+=1;out_params[r][i]+=respStart_X;SetDimLabel 0,r,$"respStart_X",out_params			r+=1;out_params[r][i]+=respStart_P;SetDimLabel 0,r,$"respStart_P",out_params		endfor		endfor		out_params[3,][] /= out_params[%avgCount][q]	out_resp /= out_params[%avgCount][q]		Duplicate/O/R=[][0] out_resp,$outRef_canonical/wave=out_canon	Redimension/N=(-1) out_canon	out_canon = 0	for (i=0;i<numSteps;i+=1)		out_canon += out_resp[p][i]	endfor	out_canon /= numSteps		Print "step_exciseAndNorm_avg(): outRef_params",outRef_params,"outRef_resp",outRef_resp,"outRef_canonical",outRef_canonical	String noteStr="exciseAndNorm_respRefs:"+sc2c(respRefs,1)+"exciseAndNorm_cmdRefs:"+sc2c(cmdRefs,1)+"exciseAndNorm_searchStartX_list:"+sc2c(searchStartX_list,1)	noteStr+= "exciseAndNorm_absMinStepSize:"+num2str(absMinStepSize)+";exciseAndNorm_stimType:"+num2str(stimType)+";"	note/nocr out_params,noteStr	note/nocr out_resp,noteSTr	note/nocr out_canon,noteStr	end //step_exciseAndNorm_avg()//excises and averages responses from steps based on timing determined from abf stimulus channel info//stores average across respREf,cmdRef pairsfunction/S step_exciseAndNorm_avgI(respList,respTypeIndexList,stepStartEpochLists,stepWeightWv,cmdChanChunk,baselineSubLenP,cmdOffsetPnts,preStepLenX,postStepLenX,outRef_baseOrAppendStr,outRef_useAppendNotBase,stimType,adjTimeBase[amplitudeScaling])	STring respList		//list of responses to analyze	String respTypeIndexList	//list of index in stepStartEpochList to use for each wave	String stepStartEpochLists	//list of epoch numbers, starting from 0 (as stored in the stim info wave generated by fd_getEpochInfo()) that start the step responses to analyze .. inithal and final holding don't count as an epoch in this numbering scheme	WAVE/d stepWeightWv			//wave with the same length as stepStartEpochList: for those steps, how should their responses be weighted into overall mean? (suggest smallest steps are 1, larger steps are proportion relative to 1 weighed by step size) follows Major et al. J Neurosci 1994)				//stepWeightWv has a new row for each unique epoch list -- but weights are relative across all 	Variable cmdChanChunk					//chunk in stepInfoRef (from fd_getEpochInfo()) for stimulus channel	Variable preStepLenX	//how much time preceding each step should be excised?	Variable postStepLenX		//how much time after the step should be excised	String outRef_baseOrAppendStr			//either a base string for saved waves (with outRef_useAppendNotBase == 0) or an append str fro the automatic base name (with outRef_useAppendNotBase == 0)	Variable outRef_useAppendNotBase 	//see outRef_baseOrAppendStr	Variable stimType		//for notekeeping: 0 = +/- 5,10 mV 1 = standard test step, large step, ramp protocol	Variable cmdOffsetPnts	//I find that the command is off by one point--the epoch should start when the level changes, but the points stored are one before it. Put 1 to correct								//worth examining each protocol with fd_epochStartsToGraph	Variable baselineSubLenP	//number of baseline points to average and subtract as a dc offset	Variable adjTimeBase		//should zero be at the beginning of the output waves (pass 0) or at the time of the step (pass 1)?	Double amplitudeScaling		//sometimes epochInfo wave has wrong scaling on amplitude sizes.. pass to multiply by a factor eg 0.001 for mV		Double amplitudeScaleFactor = (ParamIsDefault(amplitudeScaling) || numtype(amplitudeScaling)) ? 1 : amplitudeScaling		//repeat type indices if not enough were passed (assumes remainder are like the last one)	Variable numRefs=itemsinlist(respList)	Variable numInTypesList=itemsinlist(respTypeIndexList)		Variable missingTypeIndexes=numRefs-numInTypesList,i	String last=stringfromlist(numInTypesList-1,respTypeIndexList)	for (i=0;i<missingTypeIndexes;i+=1)		respTypeIndexList+=last+";"	endfor		String outRef_base	if (outRef_useAppendNotBase)		//auto generate base name if true		outRef_base = text_getInfoFromWaveName_S(stringfromlist(0,respList), 9) + outRef_baseOrAppendStr	else		outRef_base = outRef_baseOrAppendStr	endif			//STEP AVERAGES ARE NOW CALCULATED INDIVIDUALLY (across waves of the same weight AND step direction) AND NAMED AUTOMATICALLY		//weights are now stored in the parameters wave	String outRef_params = outRef_base + "_p"//place to store parameters collected	String outRef_all = outRef_base + "_a" 	//place to store all normalized ersponses, no averaging	String outRef_canonical_nw = outRef_base + "_c"	 //stores statistics including verage for each point, ignoring weighting	String outRef_canonical_w = outRef_base + "_cw"		//stores statistcs including average for each point, taking the relative weight of each wave into account		String outRefsList = "outRef_params:"+outRef_params+";outRef_all:"+outRef_all+";outRef_canonical_nw:"+outRef_canonical_nw+";outRef_canonical_w:"+outRef_canonical_w+";outRef_base:"+outRef_base+";"	outRefsList+= "outRef_grandAvg:"+outRef_canonical_w+";"		//hold over needed for ES params		Variable fd_fileNum = nan		//file num in use, for calculating sweep timing. Keep as NaN to look up automatically	//determine length in points	String exRef = stringfromlist(0,respList)	Variable delta=dimdelta($exRef,0)	Variable preStepLenP = preStepLenX / delta	Variable	postStepLenP = postStepLenX / delta	if (numtype(fd_fileNum))		String fName = text_getInfoFromWaveName_S(stringfromlist(0,respList), 9)		fd_fileNum = fd_getFIndexInFileInfoWave(fName)	endif		String stepInfoRef = fd_getEpochInfo(fd_fileNum,igor_is64() ? 0 : 2)	if (!strlen(stepInfoRef) || !WaveExists($stepInfoRef))		Print "step_exciseAndNorm_avgI(): failed to retrieve step info, run fd_getEpochInfo() on this file number to generate it. aborting"		return ""	endif	wave stepInfo = $stepInfoRef	Variable numPArams=27		Double cmd_t0, cmd_t1, cmd_baseline, cmd_step	Double cmd_range,searchStartX,respStart_X,respEnd_P	Variable cmd_t0_P, cmd_t1_P,respStart_P, respLen_P,respLen_x	Variable col,r,origLen_P	Variable startPointRow,amplitudeRow,durationRow	String respREf,cmdRef	Variable totalCount=0	Variable respNum,numSteps,sweepNum,weight,characteristicWeight	String respTypeIndexStr,stepStartEpochList,stepEpochNumStr	Variable respTypeIndex	Double resp_baselineVal	Variable stepEpochNum,infoCol_during,infoCol_pre,infoCol_post,isNEgativeSTep	Variable resp_baselineEndP,resp_baselineStartP,baselineSubLenX,setScaleParam	Variable currChunks,cmdChanChunk_used		//added in case of change in # channels down to 1		Variable weights_rows=dimsize(stepWeightWv,0),weights_cols=dimsize(stepWeightWv,1)		for (respNum=0;respNum<numRefs;respNum+=1)	//iterate response waves		fName = text_getInfoFromWaveName_S(stringfromlist(respNum,respList), 9)		fd_fileNum = fd_getFIndexInFileInfoWave(fName)		stepInfoRef = fd_getEpochInfo(fd_fileNum,1)		if (!strlen(stepInfoRef) || !WaveExists($stepInfoRef))			Print "step_exciseAndNorm_avgI(): failed to retrieve step info, run da_fd_calcStimInfo() on this file number to generate it. aborting"			return ""		endif		wave stepInfo = $stepInfoRef		startPointRow = FindDimLabel(stepInfo, 0, "duration_pre")		amplitudeRow = FindDimLabel(stepInfo, 0, "amplitude")		durationRow = FindDimLabel(stepInfo, 0, "duration")		currChunks=dimsize(stepInfo,3)		cmdChanChunk_used= currChunks < 2 ? 0 : cmdChanChunk				respref = stringfromlist(respNum,respList)		sweepNum = text_getInfoFromWaveName_V(respref, 2)				//get step start info for this response		respTypeIndexStr=stringfromlist(respNum,respTypeIndexList)		respTypeIndex=str2num(respTypeIndexStr)		stepStartEpochList=stringfromlisT(respTypeIndex,stepStartEpochLists,"|")		numSteps= itemsinlist(stepStartEpochList)		matrixop/o/free weights = col(stepWeightWv,respTypeIndex)//subrange(stepWeightsWv0,rows-1,respTypeIndex,respTypeIndex)		redimension/n=(-1) weights				for (i=0;i<numSteps;i+=1)				//iterate steps				//get epoch info for this step 			stepEpochNumStr=stringfromlist(i,stepStartEpochList)			stepEpochNum = str2num(stepEpochNumStr)			infoCol_during = stepEpochNum + 1		//the info column during the step is the epochNum + 1 because the 0th column is for the initial holding level			infoCol_pre = infoCol_during - 1				//the info column preceding the step is the one before that during the step			infoCol_post = infoCol_during + 1			cmd_t0_P = stepInfo[startPointRow][infoCol_during][sweepNum][cmdChanChunk_used] +cmdOffsetPnts			cmd_t0 = pnt2x($respref, cmd_t0_P)			cmd_t1_P = stepInfo[startPointRow][infoCol_post][sweepNum][cmdChanChunk_used] + cmdOffsetPnts			cmd_t1 = pnt2x($respref, cmd_t1_P)			cmd_baseline = stepInfo[amplitudeRow][infoCol_pre][sweepNum][cmdChanChunk_used]			cmd_step = stepInfo[amplitudeRow][infoCol_during][sweepNum][cmdChanChunk_used]						if (cmd_t1_P < (cmd_t0_P + postStepLenP) )				Print "step_exciseAndNorm_avgI()  respNum",respNum,"respref",respref,"stepNum",i,"step shorter than requested length postStepLenX",postStepLenx,"postStepLenP",postStepLenP,"cmd_t0",cmd_t0,"cmd_t1",cmd_t1			endif						isNEgativeSTep = cmd_step < cmd_baseline			cmd_range = (cmd_step - cmd_baseline)*amplitudeScaleFactor			respStart_P = cmd_t0_P - preStepLenP			respStart_X = x2pnt($respRef,respStart_P)			respEnd_P = cmd_t0_P + postStepLenP			respLen_P = respEnd_P - respStart_P			respLen_x = respLen_P * delta						//get weight for future reference			weight=weights[i]			characteristicWeight=weight* (isNegativeStep ? -1 : 1)							//make or add column to store normalized wave			if ( totalCount==0 )				//make non-averaged reps output				Make/O/D/N=(respLen_P,1) $outRef_all/wave=out_all				out_all = nan								if (adjTimeBase)					setScaleParam = -preStepLenP*delta				else					setScaleParam = 0				endif								SetScale/P x,setScaleParam,delta,"s",out_all								//make parameter output				Make/O/D/N=(numParams,1) $outRef_params/wave=out_params				out_params = 0			else		//redimension				redimension/n=(-1,totalCount+1) out_all				redimension/n=(-1,totalCount+1) out_params			endif			SetDimlabel 1,totalCount,$(respRef+"_"+num2str(i)+"_w"+num2str(weight)),out_params,out_all	//column labels are refName_[step#]_w[weight]						WAVE respWv = $respRef						resp_baselineEndP = cmd_t0_P 			baselineSubLenX = baselineSubLenP * dimdelta(respWv,0)			resp_baselineStartP  = resp_baselineEndP - baselineSubLenP						resp_baselineVal = mean(respWv,pnt2x(respWv,resp_baselineStartP),pnt2x(respWv,resp_baselineEndP))				out_all[][totalCount] = (respWv[p+respStart_P] - resp_baselineVal) / cmd_range						//store parameters			r=0;out_params[r][totalCount]=isNEgativeSTep			r+=1;out_params[r][totalCount]=nan			r+=1;out_params[r][totalCount]=1			r+=1;out_params[r][totalCount]=cmd_t0			r+=1;out_params[r][totalCount]=cmd_t1						r+=1;out_params[r][totalCount]=cmd_baseline			r+=1;out_params[r][totalCount]=cmd_step			r+=1;out_params[r][totalCount]=cmd_t0_P			r+=1;out_params[r][totalCount]=cmd_t0			r+=1;out_params[r][totalCount]=cmd_t1_P						r+=1;out_params[r][totalCount]=cmd_t1			r+=1;out_params[r][totalCount]=respLen_P			r+=1;out_params[r][totalCount]=respLen_X			r+=1;out_params[r][totalCount]=cmd_range			r+=1;out_params[r][totalCount]=resp_baselineVal						r+=1;out_params[r][totalCount]=preStepLenP			r+=1;out_params[r][totalCount]=preStepLenX			r+=1;out_params[r][totalCount]=respStart_P			r+=1;out_params[r][totalCount]=respStart_X			r+=1;out_params[r][totalCount]=baselineSubLenP						r+=1;out_params[r][totalCount]=baselineSubLenX			r+=1;out_params[r][totalCount]=infoCol_Pre			r+=1;out_params[r][totalCount]=infoCol_During			r+=1;out_params[r][totalCount]=infoCol_Post			r+=1;out_params[r][totalCount]=delta						r+=1;out_params[r][totalCount]=weight			r+=1;out_params[r][totalCount]=characteristicWeight			//end store parameters						totalCount+=1		endfor		endfor		//label the parameters wave	r=0;SetDimLabel 0,r,$"cmd_isNEgativeSTep",out_params //isNegStep param 0	r+=1;SetDimLabel 0,r,$"cmd_absMinStepSize",out_params	r+=1;SetDimLabel 0,r,$"avgCount",out_params	r+=1;SetDimLabel 0,r,$"cmd_t0",out_params	r+=1;SetDimLabel 0,r,$"cmd_t1",out_params		r+=1;setDimLabel 0,r,$"cmd_baseline",out_params	r+=1;SetDimLabel 0,r,$"cmd_step",out_params	r+=1;SetDimLabel 0,r,$"cmd_t0_P",out_params	r+=1;SetDimLabel 0,r,$"cmd_t0",out_params	r+=1;SetDimLabel 0,r,$"cmd_t1_P",out_params		r+=1;SetDimLabel 0,r,$"cmd_t1",out_params	r+=1;SetDimLabel 0,r,$"respLen_P",out_params	r+=1;SetDimLabel 0,r,$"respLen_X",out_params	r+=1;SetDimLabel 0,r,$"cmd_range",out_params			r+=1;SetDimLabel 0,r,$"resp_baselineVal",out_params		r+=1;SetDimLabel 0,r,$"preStepLenP",out_params	r+=1;SetDimLabel 0,r,$"preStepLenX",out_params	r+=1;SetDimLabel 0,r,$"respStart_P",out_params	r+=1;SetDimLabel 0,r,$"respStart_X",out_params	r+=1;SetDimLabel 0,r,$"baselineSubLenP",out_params		r+=1;SetDimLabel 0,r,$"baselineSubLenX",out_params	r+=1;SetDimLabel 0,r,$"infoCol_Pre",out_params	r+=1;SetDimLabel 0,r,$"infoCol_During",out_params	r+=1;SetDimLabel 0,r,$"infoCol_Post",out_params	r+=1;SetDimLabel 0,r,$"delta",out_params		r+=1;SetDimLabel 0,r,$"weight",out_params		//weight is param 25	r+=1;setDimLabel 0,r,$"characteristicWeight",out_params //characteristicWeight is param 26	//end parameters		String singleWeightWvNames=step_exciseAndNorm_avgI_g(out_all,out_params,26,outRef_canonical_nw,outRef_canonical_w)	String wavesOfOneWeightStatsAppend="A"	//must agree with string of same name in step_exciseAndNorm_avgI_g	outRefsLisT+="singleWeightWvs:"+sc2c(singleWeightWvNames,1)	outrefsList+="singleWeightStatsWvs:"+replacestring(";",singleWeightWvNames,wavesOfOneWeightStatsAppend+",")+";"		String noteStr="exciseAndNorm_respRefs:"+sc2c(respList,1)	noteStr+= "exciseAndNorm_stimType:"+num2str(stimType)+";"	noteStr+= outRefsList		//save note strings	String allOutRefs = list_allStrings_fromKeyedList(outRefsList,1)		//get all items in list	allOutRefs = list_keepOrRemoveWaves(allOutRefs,0)	wave_note(allOutRefs,noteStr,1,0)		return outRefsListend //step_exciseAndNorm_avgI()//takes in a bunch of columns and computes row statistics, weighting each column point by the value at the column index in that row index in allWv_wfunction/s step_exciseAndNorm_avgI_g(wv_a,paramsWv,characteristicWeightRow,outRef_unweighted,outRef_weighted)	WAVE/D wv_a	//columns to average, as from step_exciseAndNorm_avgI outRef_all2	WAVE/D paramsWv		//weight wave, one column for each column in the wave to average	Variable characteristicWeightRow		//row containing characteristic weight of step (weight multiplied by direction of step)	String outRef_unweighted		//stores statistics across all the columns of wv_a, no weighting is taken into account	String outRef_weighted		//stores statistics across all the columns of wv_a, taking into account weights in characteristicWeightRow by duplicating each column proportional to its weight, then computing stats		Variable reps = dimsize(wv_a,1),i	Variable pnts = dimsize(wv_a,0)	Variable sweeps = dimsize(wv_a,2)		String baseName = nameofwave(wv_a)	String wavesOfOneWeightStatsAppend="A"	String allWavesOfOneWeightName	String wavesOfOneWeightList=""		matrixop/o/free charWeights = subRange(paramsWv,characteristicWeightRow,characteristicWeightRow,0,reps-1)	matrixtranspose charweights;	redimension/n=(-1) charWeights	//characteristic weights as rows	matrixtranspose wv_a; matrixtranspose paramswv //move reps into rows so sort columns actually sorts on a per-rep basis	sortcolumns/diml keywaves={charWeights},sortwaves={wv_a,paramsWv}		//sort columns by characteristc weight for easy display	matrixtranspose wv_a; matrixtranspose paramswv //move them back to their orientation	sort charWeights,charWeights		//rearrange charweights too		//combine waves with the same characteristic weights into a new wave	variable j,weight,isNeg,charWeight,weightsListPos,weightCount=0,subWvCol	String weightsList="",weightStr,lb,notestr,colList	for (i=0;i<reps;i+=1)		matrixop/free/o col=col(wv_a,i)	//get the column of interest		lb=GetDimLabel(wv_a, 1, i )		charWeight = charWeights[i]		weight=abs(charWeight)		weightStr=num2str(charWeight)		weightsListPos=whichlistitem(weightStr,weightsList)				//collect all waves of a given weight into a new wave for gathering (characteristic)Weight-specific statistics		allWavesOfOneWeightName = baseName + "_w"+replacestring("-",weightStr,"n")		//will have names like base_wn1,base_w1,base_wn2...		if (weightsListPos < 0)		//new weight			weightsList += weightStr + ";"			weightsListPos=weightCount			weightCount+=1						duplicate/o col, $allWavesOfOneWeightName/wave=colwv			redimension/n=(-1,1) colWv			wavesOfOneWeightList+=allWavesOfOneWeightName+";"			note/nocr colwv,"allWvColList:"+num2str(i)+",;"		//stores a list of columns in wv_a (and paramsWv) associated with this weight		else			wave colwv=$allWavesOfOneWeightName			concatenate/np=1/dl {col},colwv		endif		subWvCol = dimsize(colwv,1)-1		setdimlabel 1,subWvCol,$lb,colwv			notestr=note(colwv)		colList=stringbykey("allWvColList",noteStr)		colList+=num2str(i)+","		notestr=replacestringbykey("allWvColList",noteStr,colList)		note/k/nocr colwv,notestr				//make a wave of all responses repeated based on their weighting, for overall statistics		if (i==0)		//first rep			matrixop/o allRepsRepeated=colRepeat(col(wv_a,i),weight)		else			matrixop/o/free repsRepeated=colRepeat(col(wv_a,i),weight)			concatenate/np=1 {repsRepeated},allRepsRepeated		endif	endfor		//calculate point-by-point statistics on overall wave, weighted overall wave, and single weight wvs	String wavesForStats=nameofwave(wv_a)+";"+nameofwave(allRepsRepeated)+";"+wavesOfOneWeightList	string ref,saveRef	Variable numWavesForStats=itemsinlist(wavesForstats)	for (i=0;i<numWavesForStats;i+=1)		ref=stringfromlist(i,wavesForStats)			//wavestats can run on a per-column basis, so move the points into columns (then back again later)		matrixtranspose $ref		wavestats/pcst/q $ref		//output is the average, sd, etc. of each point, params in rows and points in columns		switch (i)			case 0:				WAVE/D M_wavestats //first run, need to bring in auto-generated wave				saveRef=outRef_unweighted				matrixtranspose $ref		//input is back the way it was				break			case 1:				saveRef=outRef_weighted	//skip transpose because this wave is not saved				break			default:		//cases 2 and above, the single weight wvs				saveRef=ref+wavesOfOneWeightStatsAppend				matrixtranspose $ref		//input is back the way it was		endswitch				matrixtranspose M_wavestats		//now each point is a row again, params along columns		setscale/p x dimoffset(wv_a,0),dimdelta(wv_a,0),"s",M_wavestats	//transfer row scaling		duplicate/o M_wavestats, $saveRef	endfor		return wavesOfOneWeightListend//excises and averages responses from steps based on timing determined from abf stimulus channel info//stores average across respREf,cmdRef pairsfunction/S step_exciseAndNorm_avgI_old(respList,stepStartEpochList,stepWeightWv,cmdChanChunk,baselineSubLenP,cmdOffsetPnts,preStepLenX,outRef_baseOrAppendStr,outRef_useAppendNotBase,stimType,adjTimeBase)	STring respList		//list of responses to analyze	String stepStartEpochList		//list of epoch numbers, starting from 0 (as stored in the stim info wave generated by fd_getEpochInfo()) that start the step responses to analyze .. inithal and final holding don't count as an epoch in this numbering scheme	WAVE/d stepWeightWv			//wave with the same length as stepStartEpochList: for those steps, how should their responses be weighted into overall mean? (suggest smallest steps are 1, larger steps are proportion relative to 1 weighed by step size) follows Major et al. J Neurosci 1994)	Variable cmdChanChunk					//chunk in stepInfoRef (from fd_getEpochInfo()) for stimulus channel	Variable preStepLenX	//how much time preceding each step should be excised?	String outRef_baseOrAppendStr			//either a base string for saved waves (with outRef_useAppendNotBase == 0) or an append str fro the automatic base name (with outRef_useAppendNotBase == 0)	Variable outRef_useAppendNotBase 	//see outRef_baseOrAppendStr	Variable stimType		//for notekeeping: 0 = +/- 5,10 mV 1 = standard test step, large step, ramp protocol	Variable cmdOffsetPnts	//I find that the command is off by one point--the epoch should start when the level changes, but the points stored are one before it. Put 1 to correct								//worth examining each protocol with fd_epochStartsToGraph	Variable baselineSubLenP	//number of baseline points to average and subtract as a dc offset	Variable adjTimeBase		//should zero be at the beginning of the output waves (pass 0) or at the time of the step (pass 1)?		String outRef_base	if (outRef_useAppendNotBase)		//auto generate base name if true		outRef_base = text_getInfoFromWaveName_S(stringfromlist(0,respList), 9) + outRef_baseOrAppendStr	else		outRef_base = outRef_baseOrAppendStr	endif		String outRef_params = outRef_base + "_p"//place to store parameters collected	String outRef_resp = outRef_base + "_r"	//place to store normalized responses, averaged across sweeps but not steps	String outRef_all = outRef_base + "_a" 	//place to store all normalized ersponses, no averaging	String outRef_canonical_nw = outRef_base + "_c"	//place to store canonical (grand average) response (normalized to unit voltage input). this version is just a normal average of all responses (equally weighted)	String outRef_canonical_w = outRef_base + "_cw"		//canonical response taking into account weighting for each step on stepWeightWv	String outRef_grandAvg = outRef_Base + "_ga"	String outRef_stepAvgs = outRef_base + "_sa"	String outRef_weights = outRef_base + "_ww"		//weight wave		String outRefsList = "outRef_params:"+outRef_params+";outRef_resp:"+outRef_resp+";outRef_all:"+outRef_all+";outRef_canonical_nw:"+outRef_canonical_nw+";outRef_canonical_w:"+outRef_canonical_w+";"	outRefsList+= "outRef_base:"+outRef_base+";outRef_weights:"+outRef_weights+";outRef_grandAvg:"+outRef_grandAvg+";outRef_stepAvgs:"+outRef_stepAvgs+";"	duplicate/o/d stepWeightWv,$outRef_weights			Variable fd_fileNum = nan		//file num in use, for calculating sweep timing. Keep as NaN to look up automatically	if (numtype(fd_fileNum))		String exRef = stringfromlist(0,respList)		String fName = text_getInfoFromWaveName_S(stringfromlist(0,respList), 9)		fd_fileNum = fd_getFIndexInFileInfoWave(fName)	endif		String stepInfoRef = fd_getEpochInfo(fd_fileNum,1)	if (!strlen(stepInfoRef) || !WaveExists($stepInfoRef))		Print "step_exciseAndNorm_avgI(): failed to retrieve step info, run da_fd_calcStimInfo() on this file number to generate it. aborting"		return ""	endif	wave stepInfo = $stepInfoRef	Variable startPointRow = FindDimLabel(stepInfo, 0, "duration_pre")	Variable amplitudeRow = FindDimLabel(stepInfo, 0, "amplitude")	Variable durationRow = FindDimLabel(stepInfo, 0, "duration")	Variable preStepLenP			Variable numPArams=25		Double cmd_t0, cmd_t1, cmd_baseline, cmd_step	Double cmd_range,searchStartX,respStart_X	Variable cmd_t0_P, cmd_t1_P,respStart_P, respLen_P,respLen_x,delta	Variable col,r,origLen_P	String respREf,cmdRef			Variable respNum,i,numRefs=itemsinlist(respList),numSteps = itemsinlist(stepStartEpochList),sweepNum	Variable count = 0	Variable avgCount = 0	Double resp_baselineVal	Variable stepEpochNum,infoCol_during,infoCol_pre,infoCol_post,isNEgativeSTep	Variable totalSteps = numRefs * numSteps, allCount = 0	Variable resp_baselineEndP,resp_baselineStartP,baselineSubLenX,setScaleParam	String recWeight	Variable currChunks,cmdChanChunk_used		//added in case of change in # channels down to 1		for (respNum=0;respNum<numRefs;respNum+=1)	//iterate response waves		fName = text_getInfoFromWaveName_S(stringfromlist(respNum,respList), 9)		fd_fileNum = fd_getFIndexInFileInfoWave(fName)		stepInfoRef = fd_getEpochInfo(fd_fileNum,1)		if (!strlen(stepInfoRef) || !WaveExists($stepInfoRef))			Print "step_exciseAndNorm_avgI(): failed to retrieve step info, run da_fd_calcStimInfo() on this file number to generate it. aborting"			return ""		endif		wave stepInfo = $stepInfoRef		currChunks=dimsize(stepInfo,3)		cmdChanChunk_used= currChunks < 2 ? 0 : cmdChanChunk				respref = stringfromlist(respNum,respList)		avgCount += 1		sweepNum = text_getInfoFromWaveName_V(respref, 2)				for (i=0;i<numSteps;i+=1)				//iterate steps				//get epoch info for this step 			stepEpochNum = str2num(stringfromlist(i,stepStartEpochList))			infoCol_during = stepEpochNum + 1		//the info column during the step is the epochNum + 1 because the 0th column is for the initial holding level			infoCol_pre = infoCol_during - 1				//the info column preceding the step is the one before that during the step			infoCol_post = infoCol_during + 1			cmd_t0_P = stepInfo[startPointRow][infoCol_during][sweepNum][cmdChanChunk_used] +cmdOffsetPnts			cmd_t0 = pnt2x($respref, cmd_t0_P)			cmd_t1_P = stepInfo[startPointRow][infoCol_post][sweepNum][cmdChanChunk_used] + cmdOffsetPnts			cmd_t1 = pnt2x($respref, cmd_t1_P)			cmd_baseline = stepInfo[amplitudeRow][infoCol_pre][sweepNum][cmdChanChunk_used]			cmd_step = stepInfo[amplitudeRow][infoCol_during][sweepNum][cmdChanChunk_used]			delta=dimdelta($respRef,0)			preStepLenP = preStepLenX / delta						isNEgativeSTep = cmd_step < cmd_baseline			cmd_range = cmd_step - cmd_baseline			respStart_P = cmd_t0_P - preStepLenP			respStart_X = x2pnt($respRef,respStart_P)			respLen_P = cmd_t1_P - respStart_P			respLen_x = respLen_P * delta							//make or add column to store normalized wave			if ( (respNum==0) && (i==0) )				//make response reps output				Make/O/D/N=(respLen_P,numSteps) $outRef_resp/wave=out_resp				out_resp = 0								//make non-averaged reps output				Make/O/D/N=(respLen_P,numSteps,numRefs) $outRef_all/wave=out_all				out_all = nan								if (adjTimeBase)					setScaleParam = -preStepLenP*delta				else					setScaleParam = 0				endif								SetScale/P x,setScaleParam,delta,"s",out_resp,out_all								//make parameter output				Make/O/D/N=(numParams,numSteps) $outRef_params/wave=out_params				out_params = 0			endif					SetDimlabel 1,i,$(respRef+"_"+num2str(i)),out_params,out_resp						WAVE respWv = $respRef						resp_baselineEndP = cmd_t0_P 			baselineSubLenX = baselineSubLenP * dimdelta(respWv,0)			resp_baselineStartP  = resp_baselineEndP - baselineSubLenP						resp_baselineVal = mean(respWv,pnt2x(respWv,resp_baselineStartP),pnt2x(respWv,resp_baselineStartP))				out_resp[][i] += (respWv[p+respStart_P] - resp_baselineVal) / cmd_range			out_all[][i][respNum] = (respWv[p+respStart_P] - resp_baselineVal) / cmd_range			if (respNum == 0)		//so this will go through all i once				SetDimLabel 1,i,$("step_"+num2str(i)),out_all 			endif			if (i==0)			//so this will go through all respNum once				SetDimLabel 2,respNum,$("sweep_"+num2str(respNum)),out_all			endif			allCount += 1					r=0;out_params[r][i]=isNEgativeSTep;SetDimLabel 0,r,$"cmd_isNEgativeSTep",out_params			r+=1;out_params[r][i]=nan;SetDimLabel 0,r,$"cmd_absMinStepSize",out_params			r+=1;out_params[r][i]+=1;SetDimLabel 0,r,$"avgCount",out_params			r+=1;out_params[r][i]+=cmd_t0;SetDimLabel 0,r,$"cmd_t0",out_params			r+=1;out_params[r][i]+=cmd_t1;SetDimLabel 0,r,$"cmd_t1",out_params						r+=1;out_params[r][i]+=cmd_baseline;SetDimLabel 0,r,$"cmd_baseline",out_params			r+=1;out_params[r][i]+=cmd_step;SetDimLabel 0,r,$"cmd_step",out_params			r+=1;out_params[r][i]+=cmd_t0_P;SetDimLabel 0,r,$"cmd_t0_P",out_params			r+=1;out_params[r][i]+=cmd_t0;SetDimLabel 0,r,$"cmd_t0",out_params			r+=1;out_params[r][i]+=cmd_t1_P;SetDimLabel 0,r,$"cmd_t1_P",out_params						r+=1;out_params[r][i]+=cmd_t1;SetDimLabel 0,r,$"cmd_t1",out_params			r+=1;out_params[r][i]+=respLen_P;SetDimLabel 0,r,$"respLen_P",out_params			r+=1;out_params[r][i]+=respLen_X;SetDimLabel 0,r,$"respLen_X",out_params			r+=1;out_params[r][i]+=cmd_range;SetDimLabel 0,r,$"cmd_range",out_params			r+=1;out_params[r][i]+=resp_baselineVal;SetDimLabel 0,r,$"resp_baselineVal",out_params						r+=1;out_params[r][i]+=preStepLenP;SetDimLabel 0,r,$"preStepLenP",out_params			r+=1;out_params[r][i]+=preStepLenX;SetDimLabel 0,r,$"preStepLenX",out_params			r+=1;out_params[r][i]+=respStart_P;SetDimLabel 0,r,$"respStart_P",out_params			r+=1;out_params[r][i]+=respStart_X;SetDimLabel 0,r,$"respStart_X",out_params			r+=1;out_params[r][i]+=baselineSubLenP;SetDimLabel 0,r,$"baselineSubLenP",out_params						r+=1;out_params[r][i]+=baselineSubLenX;SetDimLabel 0,r,$"baselineSubLenX",out_params			r+=1;out_params[r][i]+=infoCol_Pre;SetDimLabel 0,r,$"infoCol_Pre",out_params			r+=1;out_params[r][i]+=infoCol_During;SetDimLabel 0,r,$"infoCol_During",out_params			r+=1;out_params[r][i]+=infoCol_Post;SetDimLabel 0,r,$"infoCol_Post",out_params			r+=1;out_params[r][i]+=delta;SetDimLabel 0,r,$"delta",out_params		endfor		endfor		out_params[3,][] /= out_params[%avgCount][q]	out_resp /= out_params[%avgCount][q]		Duplicate/O/R=[][0][0] out_resp,$outRef_canonical_nw/wave=out_canon_nw, $outRef_canonical_w/wave=out_canon_w	Redimension/N=(-1) out_canon_nw,out_canon_w	Variable weightedAvgCount = 0, unweightedAvgCount = 0, step	out_canon_nw = 0	out_canon_w = 0	for (respNum=0;respNum<numRefs;respNum+=1)	//iterate response waves				for (step=0;step<numSteps;step+=1)				//iterate steps			out_canon_nw += out_resp[p][step]			//out_resp[p][step][respNum]			out_canon_w += out_resp[p][step]  * stepWeightWv[step]			//out_resp[p][step][respNum] * stepWeightWv[step]			unweightedAvgCount += 1			weightedAvgCount += stepWeightWv[step]		endfor	endfor	out_canon_nw /= unweightedAvgCount		//should equal numSteps	out_canon_w /= weightedAvgCount		String noteStr="exciseAndNorm_respRefs:"+sc2c(respList,1)+"exciseAndNorm_cmdRefs:"+sc2c("",1)+"exciseAndNorm_searchStartX_list:"+sc2c("",1)	noteStr+= "exciseAndNorm_absMinStepSize:"+num2str(nan)+";exciseAndNorm_stimType:"+num2str(stimType)+";"	noteStr+= outRefsList		//post-processing: calculate SD, SEM, and variance within sub-averages .. also done in avgI_g so could eventually get rid of this	Variable subAvgCol, allStepCol	Variable numLayers = 7	Variable mean0_L = 0		//mean calculated "by hand" here	Variable mean1_L = 1		//mean calculated by Igor functions	Variable var_L = 2	Variable sd_L=3	Variable sem_L=4	Variable meanMinusSEM_L = 5	Variable meanPlusSEM_L = 6	Variable numForSEM = numSteps	Variable semDenom = sqrt(numForSEM)	Variable rowi	Variable numRows = dimsize(out_resp,0)	Redimension/N=(-1,-1,numLayers) out_resp	//label layers	SetDimLabel 2,mean0_L,mean0_L,out_resp	SetDimLabel 2,mean1_L,mean1_L,out_resp	SetDimLabel 2,var_L,var_L,out_resp	SetDimLabel 2,sd_L,sd_L,out_resp	SetDimLabel 2,sem_L,sem_L,out_resp	SetDimLabel 2,meanMinusSEM_L,meanMinusSEM_L,out_resp	SetDimLabel 2,meanPlusSEM_L,meanPlusSEM_L,out_resp		for (step=0;step<numSteps;step+=1)		for (rowi=0;rowi<numRows;rowi+=1)			matrixop/O/FREE sameRowPoints = beam(out_all,rowi,step)				matrixop/O/FREE stats = mean(sameRowPoints)			out_resp[rowi][step][mean1_L] = stats[0]			stats[0] = variance(sameRowPoints)			//makes n-1 correction, so sample sdev is sqrt			out_resp[rowi][step][var_L] = stats[0]			out_resp[rowi][step][sd_L] = sqrt(stats[0])			out_resp[rowi][step][sem_L] = out_resp[rowi][step][sd_L] / semDenom			out_resp[rowi][step][meanMinusSEM_L] = out_resp[rowi][step][mean1_L] - out_resp[rowi][step][sem_L]			out_resp[rowi][step][meanPlusSEM_L] = out_resp[rowi][step][mean1_L] + out_resp[rowi][step][sem_L]		endfor	endfor		step_exciseAndNorm_avgI_g_old(out_all,stepWeightWv,outRef_stepAvgs,outRef_grandAvg)		//save note strings	String allOutRefs = list_allStrings_fromKeyedList(outRefsList,1)		//get all items in list	allOutRefs = list_keepOrRemoveWaves(allOutRefs,0)	wave_note(allOutRefs,noteStr,1,0)		return outRefsListend //step_exciseAndNorm_avgI_old()//takes in a bunch of columns and computes row statistics, weighting each column point by the value at the column index in that row index in allWv_wfunction step_exciseAndNorm_avgI_g_old(wv_a,colWeightWv,outRef_stepAvgs,outRef_grandAvg)	WAVE/D wv_a	//columns to average, as from step_exciseAndNorm_avgI outRef_all2	WAVE/D colWeightWv		//weight wave, one row for each column in wv_a, as for step_exciseAndNorm_avgI outRef_all2w	String outRef_stepAvgs		//stores results with each type of stat in a layer, each step still in its own column, each time poitn still in row	String outRef_grandAvg		//stores results collapsed across steps (after weighting), so each row still a time point, but now stats in columns		Variable steps = dimsize(wv_a,1)	Variable pnts = dimsize(wv_a,0)	Variable sweeps = dimsize(wv_a,2)		Variable numStats = 7	Make/O/D/N=(1) $outRef_stepAvgs/wave=out_byStep	Make/O/D/N=(1) $outRef_grandAvg/wave=out_grand		//check for integer weights	matrixop/o/free temp = mod(colWeightWv,1)	if (sum(temp))		print "step_exciseAndNorm_avgI_g() weightWv has non-integer numbers. recommend making integer weights relative to smallest near to one. aborting"		return 0	endif		 //need all sweeps in rows, all timepoints in columns to use /pcst	 //want the number of sweeps from each step to be duplicated by how much weight that step gets	 variable i,j,weight	 for (i=0;i<steps;i+=1)	 	matrixop/free/o temp = col(wv_a,i)		//row is all timepoints, layers have sweeps	 	print "a",dimsize(temp,0),dimsize(temp,1),dimsize(temp,2)	 	matrixop/free/o temp = transposevol(temp,2)			//switch sweep into rows, timepoints into cols (r p q) for wavestats/pcst		print "b",dimsize(temp,0),dimsize(temp,1),dimsize(temp,2)				//by step		wavestats/pcst/q temp				if (i==0)			WAVE/D M_wavestats		//each row is the average and other stats for a point, timepoints still run along columns			duplicate/o/free M_wavestats, byStepTemp			redimension/n=(-1,-1,1) byStepTemp		else			concatenate/np=2 {M_wavestats}, byStepTemp		//concatenate along layers for now, so each step gets a layer		endif 				 	//all 	 	weight=colWeightWv[i]	 		 	for (j=0;j<weight;j+=1)	 		if ( (i==0) && (j==0))	 			duplicate/o/free temp, temp_withAll	 		else	 			concatenate/np=0 {temp}, temp_withAll	//append along rows, should potentially differ in num rows but not num cols (which is num time points)	 		endif	 	endfor	 endfor	 	 //swap to format by step output	 matrixop/o out_byStep = transposevol(byStepTemp,4)		//(q,r,p) was (stats,points,steps) want (points=q,steps=r,stats=p)	 dl_lblsToLbls(nameofwave(wv_a),1,0,inf,nameofwave(out_byStep),1,0,"",0)		//transfer step labels for columns	 dl_lblsToLbls(nameofwave(M_wavestats),0,0,inf,nameofwave(out_byStep),2,0,"",0) 		//transfer stats labels for layers		print "c",dimsize(temp_withAll,0),dimsize(temp_withAll,1),dimsize(temp_withAll,2)		//now run wavestats/pcst for all	wavestats/pcst/q temp_withAll			//(stats,points)	duplicate/o M_wavestats,out_grand	matrixtranspose out_grand	//(matrix transpose needed) was (stats,points) want (points,stats) 		//set scalings	setscale/p x dimoffset(wv_a,0),dimdelta(wv_a,0),"s",out_byStep,out_grandendfunction wave_layerMeanAcrossRows(wv,rowStartX,rowEndX,colIndex,layerIndex)	WAVE/D wv	Variable rowStartX,rowEndX,colIndex,layerIndex		duplicate/free/o/r=(rowstartX,rowendx)[colIndex][layerIndex] wv, temp	return mean(temp)endfunction wave_averageColsAndLayers(wv,outRef)	wave/d wv; string outref	duplicate/o wv, $outRef/wave=out	redimension/n=(-1) out	out = 0	variable i,rows = dimsize(out,0)	variable j,cols = dimsize(out,1)	variable k,layers = dimsize(out,2)	variable count 	for (i=0;i<rows;i+=1)		count = 0		for (j=0;j<cols;j+=1)			for (k=0;k<layers;k+=1)				if (numtype(wv[i][j][k]) == 0)					out[i] += wv[i][j][k]					count += 1				endif			endfor			endfor 		//out[i] /= count		endfor	return countendfunction/S step_capFromNorm(baseName,sealRespRef,sealCmdRef,doDisplay)	String baseName //from step_exciseAndNorm_avg	String sealRespRef	String sealCmdRef	Variable doDisplay		Variable minStepSize=0.002	Variable baselinePaddingX = 0.0002	Variable baselineSubLenX = 0.002		String paramRef=baseName+"rc_p";WAVE/D params=$paramRef	String respRef=baseName+"rc_r"	String avgRef=baseName+"rc_c"		String outFitRef=baseName+"rc_f"	String shortBaseName = ReplaceString("_000",baseName,"_")	shortBaseName = ReplaceString("_00",shortBaseName,"_")	Variable sweepNum = text_getInfoFromWaveName_V(baseName,2)	shortBaseName = ReplaceString("_"+num2str(sweepNum+1)+"_AD",shortBaseName,"_")	String outParamSaveRef=shortBaseName+"rp"		//shortest way to say params from rc data			Variable firstFileNum=text_getInfoFromWaveName_V(baseName,1)		Duplicate/O $avgRef,respAvgTemp		Double cmd_t0,cmd_t1,cmd_baseline,cmd_step,cmd_range,cmd_t0_P,cmd_t1_P,respLen_P,resp_baselineEndX,resp_baselineSTartX,resp_baselineVal	if (WaveExists($sealRespRef))		WAVe/D sealResp=$sealRespRef		analysis_cellParamsSimple_cmd(sealCmdRef,1,0,0.002,1,cmd_t0,cmd_t1,cmd_baseline,cmd_step,0,storeAndOrForceMinStepSize=minStepSize)		cmd_range = cmd_step - cmd_baseline		cmd_t0_P = x2pnt($respRef,cmd_t0)		cmd_t1_P = x2pnt($respRef,cmd_t1)		respLen_P = cmd_t1_P - cmd_t0_P				resp_baselineEndX = cmd_t0 - baselinePaddingX		resp_baselineSTartX = resp_baselineEndX - baselineSubLenX		resp_baselineVal = mean(sealResp,resp_baselineSTartX,resp_baselineEndX)		Make/O/D/N=(respLen_P) sealRespAdjTemp		SetScale/P x,0,dimdelta(sealResp,0),"s",sealRespAdjTemp		sealRespAdjTemp = (sealResp[p+cmd_t0_P] - resp_baselineVal)	/ cmd_range				respAvgTemp -= sealRespAdjTemp	endif		Double cmd_t1_final = respLen_P * dimdelta(sealResp,0)	matrixop/O sumWv = sumRows(params)	sumWv /= dimsize(params,1)	Variable vCmd_baseline_r = FindDimLabel(params, 0, "cmd_baseline")	Variable vCmd_step_r = FindDimLabel(params, 0, "cmd_step")	Variable step_baseline_r = FindDimLabel(params, 0, "resp_baselineVal")	Double vCmd_baseline = 0	Double vCmd_step = 1	Double resp_baseline = sumWv[step_baseline_r]	Double resp_ssWinEnd = sumWv[FindDimLabel(params,0,"cmd_t1")]	Double resp_step = mean($avgRef,resp_ssWinEnd-baselineSubLenX,resp_ssWinEnd)	analysis_cap_sub("respAvgTemp",firstFileNum,1,0,cmd_t1_final,vCmd_baseline,vCmd_step,0,"","","capFromNormParamsTemp","capFromNormFitTemp",forceMinExcursion=1e-12,forceBaseCurrent=resp_baseline,forceSSCurrent=resp_step)	dl_lblsToLbls(paramRef,0,0,nan,"sumWv",0,0,"",0)	dl_appendToLbls(sumWv,0,"rc_",1,-inf,inf)	concatenate/DL/NP=0/O {sumWv,$"capFromNormParamsTemp"}, $outParamSaveRef	note/nocr $outParamSaveRef, note($"capFromNormParamsTemp")	Duplicate/O $"capFromNormFitTemp", $outFitRef		Print "step_capFromNorm(): outParamSaveRef",outParamSaveRef,"outFitRef",outFitRef		if (doDisplay)		analysis_capTrans_dispFitStats(outParamSaveRef, "")		display/k=1 $outFitRef[][0]		appendtograph $outFitRef[][1]		appendtograph $outFitRef[][2]		appendtograph $outFitRef[][3]		ModifyGraph rgb($outFitRef)=(0,0,0),rgb($outFitRef#1)=(65535,0,0,19661),rgb($outFitRef#2)=(3,52428,1,19661),rgb($outFitRef#3)=(1,4,52428,19661),lstyle($outFitRef#3)=8	endif		return outParamSaveRef	end //step_capFromNorm()function step_addToParamWvs()	WAVE/D lsmFixed_lenData	WAVE/T exciseAndNorm_files		Variable numLSMParams = dimsize(lsmFixed_lenData,1)	Variable numExtraParams = 4	variable i,numRows=dimsize(exciseAndNorm_files,0),r	String paramRef,fileNumStr,fileName,avgRef	Variable lsmRow,numInitParams,isFoveal,after_dnase	for (i=0;i<numRows;i+=1)		paramRef=exciseAndNorm_files[i][%rc_paramSaveRef]		fileNumStr =exciseAndNorm_files[i][%fileNum]				WAVE/D paramWv=$paramRef		numInitParams=dimsize(paramWv,0)		redimension/N=(numInitParams+numLSMParams+numExtraParams) paramWv				if (!strlen(fileNumStr))			lsmRow = -2		else					lsmRow = FindDimLabel(lsmFixed_lenData, 0, fileNumStr )		endif		if (lsmRow <0)			exciseAndNorm_files[i][%hasFixedTracing]="0"		else			exciseAndNorm_files[i][%hasFixedTracing]="1"		endif				for (r=0;r<numLSMParams;r+=1)			if (lsmRow <0)				dl_assignAndLbl(paramWv,numInitParams+r,nan, "fixed_"+GetDimLabel(lsmFixed_lenData, 1, r ))			else				dl_assignAndLbl(paramWv,numInitParams+r,lsmFixed_lenData[lsmRow][r], "fixed_"+GetDimLabel(lsmFixed_lenData, 1, r ))			endif		endfor				dl_assignAndLbl(paramWv,numInitParams+r,!(lsmRow < 0), "fixed_hasInfo")		isFoveal = str2num(exciseAndNorm_files[i][%isFovealPiece])		dl_assignAndLbl(paramWv,numInitParams+r+1,isFoveal, "isFoveal")		fileName = exciseAndNorm_files[i][%fileName]		avgRef = fileName + "rc_c"		dl_assignAndLbl(paramWv,numInitParams+r+2,str2num(stringbykey("stimType",note($avgRef))), "stimType")		after_dnase=str2num(exciseAndNorm_files[i][%after_dnase])		dl_assignAndLbl(paramWv,numInitParams+r+3,after_dnase, "after_dnase")		Print "paramRef",paramRef,"fileNumStr",fileNumStr,"lsmRow",lsmRow,"original dim size=",numInitParams	endforendfunction disp_plotFromSummary(infoWave,plotCol,plotRefAppendStr,rulesStr,defaultColorCase)	WAVE/T infoWave	//wave containing info such as ref to wave to plot	Variable plotCol	//col to find ref to wave to plot in	String plotRefAppendStr	//string to append to plotCol ref .. e.g. rc_c for rc canonical/avg ref	String rulesStr		//format: includeOrExcludeIfMatch,colToMatch,matchStr;...;...; colToMatch = -2 to match to ref	Variable defaultColorCase		//see colorCases and matchBehavior. this can be 0 or more		Variable matchBehaviorRow=0	Variable colToMatchPos = 1	Variable matchStrPos = 2	Variable opac=0.4	//opacity		Variable numColorCases = 4	Make/O/N=(numColorCases,4)/U/I ccs		//ccs for color cases	ccs[0][0]=0;ccs[0][1]=0;ccs[0][2]=0;ccs[0][3]=0.8*(-1+2^16)//black	ccs[1][0]=(-1+2^16);ccs[1][1]=0;ccs[1][2]=0;ccs[1][3]=opac*(-1+2^16)//r	ccs[2][0]=0;ccs[2][1]=0;ccs[2][2]=(-1+2^16);ccs[2][3]=opac*(-1+2^16)//g	ccs[3][0]=0;ccs[3][1]=0;ccs[3][2]=(-1+2^16);ccs[3][3]=opac*(-1+2^16)//b	String plotList = "",colorList=""		variable i,num=dimsize(infoWave,0)	Variable j,numRules=itemsinlist(rulesStr)	Variable exclude,cc,isMatch		//cc for color case	String rule,matchStr,ref,testStr	Variable matchBehavior,colToMatch	for (i=0;i<num;i+=1)		ref=infoWave[i][plotCol]+plotRefAppendStr		exclude = 0;cc=-1		for (j=0;j<numRules;j+=1)			rule = c2sc(stringfromlist(j,rulesStr))			matchBehavior=str2num(stringfromlist(matchBehaviorRow,rule))			colToMatch=str2num(stringfromlist(colToMatchPos,rule))			matchStr=stringfromlist(matchStrPos,rule)			if (colToMatch >=0)				testStr=infoWave[i][colToMatch]			else				testStr=infoWave[i][plotCol]			endif			isMatch=stringmatch(testStr,matchStr)			if (isMatch)				if (matchBehavior==1)		//1 signifies exclude on match					exclude = 1				endif	//include if isMatch and include on match								if (matchBehavior>1)					cc = matchBehavior-2		//gives color cases for 2,3,4,5.... etc.				endif							else	//not a match, check if include 				if (matchBehavior==0)		//include on match only..and this is not a match, so exclude					exclude = 1				endif			endif		endfor				if (!exclude && (strlen(ref) > 0) )			plotList += ref + ";"			if (cc >= 0)				colorList += num2str(cc) + ";"			else				colorList += num2str(defaultColorCase) + ";"			endif		endif	endfor				display/k=1	String winN=s_name	Variable numTraces=itemsinlist(plotList)	for (i=0;i<numTraces;i+=1)		ref=stringfromlist(i,plotList)		cc=str2num(stringfromlist(i,colorList))		appendtograph/W=$winN/C=(ccs[cc][0],ccs[cc][1],ccs[cc][2],ccs[cc][3]) $ref	endforend////function rc_rerun()//	WAVE/T exciseAndNorm_files//	//	//	variable num=dimsize(exciseAndNorm_files,0),i//	String info,respRefs,cmdRefs,searchStartX_list//	Variable stimType,absMinStepSize//	String loadedWvs//	for (i=0;i<num;i+=1)//		loadedWvs=""//		info=note($(exciseAndNorm_files[i][0]+"rc_c"))//		if (!strlen(info))//			Print "failed to find info for ref=",exciseAndNorm_files[i][0]," (+\"rc_c\")"//			continue//		endif//		respREfs=c2sc(stringbykey("exciseAndNorm_respRefs",info))//		da_fd_loadWavesFromWaveName(respREfs)//		cmdREfs=c2sc(stringbykey("exciseAndNorm_cmdRefs",info))//		da_fd_loadWavesFromWaveName(cmdREfs)//		searchStartX_list=stringbykey("exciseAndNorm_searchStartX_list",info)//		absMinStepSize=str2num(stringbykey("exciseAndNorm_absMinStepSize",info))//		stimType=str2num(stringbykey("exciseAndNorm_stimType",info))//		step_exciseAndNorm_avg(respREfs,cmdRefs,searchStartX_list,"","","",absMinStepSize,stimType)//		exciseAndNorm_files[i][%rc_paramSaveRef]=step_capFromNorm(exciseAndNorm_files[i][%fileName],exciseAndNorm_files[i][%brkInResp],exciseAndNorm_files[i][%brkInCmd],1);exciseAndNorm_files[i][%rc_fitSaveRef]=exciseAndNorm_files[i][%fileName]+"rc_f"//		killwavesbyname(respRefs)//		killwavesbyname(cmdRefs)//	endfor//////endfunction/S wave_stitch(list)	String list		String saveNameAppendStr = "s"		//for stitch		Variable num = ItemsInList(list)		String outName = getWaveNameBySweeps(StringFromList(0, list), StringFromList(num-1, list)) + saveNameAppendStr	String noteAppendStr = "STITCH_COUNT:" + num2str(num) + ";STITCH_LIST:"		variable i;string ref	for (i=0;i<num;i+=1)		ref = stringfromlist(i,list)		if (i==0)			Duplicate/O $ref, $outName/wave=out		else			concatenate/dl/np=0 {$ref}, out		endif		noteAppendStr += ref + ";"	endfor		note/nocr out, noteAppendStr		return outNameendfunction/S em_removePulsesAndGetStairs(fullLenRef,nameBaseStr,stairsStartX,stairLenX,preStairLenX,testPulseStartX,interPulseIntervalX,testPulseLenX,postPulseDeletionDurX)	String fullLenRef		//full staircase, if not already intact use wave_stitch() to put together	String nameBaseStr	Variable stairsStartX		//start of first staircase light	Variable stairLenX		//len of each staircase step	Variable preStairLenX	//preStairCaseDurationToPullOut	Variable interPulseIntervalX		//equal to len of recording waves	Variable postPulseDeletionDurX	//len of time to delete 		Variable testPulseStartX,testPulseLenX		//time of first pulse start, len of pulses so that the location of these can be tracked for each excised step		Duplicate/O $fullLenRef, fullLenWvTemp		//related to finding stairs	Variable i	Variable xDelta = dimdelta(fullLenWvTemp,0)	Variable lenx_orig = xDelta*dimsize(fullLenWvTemp,0)	Variable numSteps = floor( (lenx_orig-stairsStartX)/stairLenX)	String wNote = note(fullLenWvTemp)	String outList = ""	String outRef	String appendStr = "se"		//append string for saved excised steps, eg se#	String infoAppendStr = "si"	//append string for info for excised steps, eg si	String stepTimingAppendStr = "st"		Make/O/D/N=(numSteps) stairStartTimesX,stairEndTimesX,isStairStartInPulse,stairStartTimesX_orig		stairStartTimesX = stairsStartX + p*stairLenX	stairStartTimesX_orig= stairStartTimesX	stairEndTimesX = stairStartTimesX[p] + stairLenX	isStairStartInPulse = 0		//related to finding pulses	Variable numPulses = floor( (lenx_orig-testPulseStartX)/interPulseIntervalX)	Make/O/D/N=(numPulses) pulseStartXs, pulseEndXs	pulseStartXs = testPulseStartX + p*interPulseIntervalX	pulseEndXs = pulseStartXs + testPulseLenX 		Variable pulseDeletionLenX = testPulseLenX + postPulseDeletionDurX	Variable numPulsePntsToDelete = pulseDeletionLenX / xDelta	Variable pulseDelStartP,pulseDelEndP,pulseDelStartX,pulseDelEndX	String listOfStairsStartingInPulse = ""; variable stairStartInPulse	for (i=0;i<numPulses;i+=1)		pulseDelStartX = pulseStartXs[i]		pulseDelEndX = pulseDelStartX + pulseDeletionLenX		pulseDelStartP = x2pnt(fullLenWvTemp,pulseDelStartX)		DeletePoints pulseDelStartP, numPulsePntsToDelete, fullLenWvTemp				//update timings		if (i<(numPulses-1))			pulseStartXs[i+1,] -=pulseDeletionLenX		endif				isStairStartInPulse =  isStairStartInPulse || ( (stairStartTimesX[p] > pulseDelStartX) && (stairStartTimesX[p] < pulseDelEndX) )		//if step starts before deleted region, leave the same		//if step starts after, check if it falls within deleted region		//if so set start to begnning of deleted region		//if not, subtracted deleted duration		stairStartTimesX = stairStartTimesX[p] < pulseDelStartX ?  stairStartTimesX[p]	: ( stairStartTimesX[p] < pulseDelEndX ? pulseDelStartX :  (stairStartTimesX[p] - pulseDeletionLenX) 	 )	//doesnt handle starts within a pulse well	endfor		//EXCISING STEPS	Variable isLastStep 	Variable stepStartX,exciseStartX,exciseEndX,excisedLenX,stepEndX	Variable origStepStartX,origStepEndX,excisedLenP,exciseStartX_temp		Variable excisedEndExpected	Variable lenx_final = dimsize(fullLenWvTemp,0) * xDelta		//related to saving info	String infoSaveStr = nameBaseStr + infoAppendStr	Variable numParams = 20	Make/O/D/N=(numParams,numSteps) $infoSaveStr/wave=info	SetDimLabel 0,0,stepNum,info	SetDimLabel 0,1,stairsStartX,info	SetDimLabel 0,2,stairLenX,info	SetDimLabel 0,3,preStairLenX,info	SetDimLabel 0,4,testPulseStartX,info	SetDimLabel 0,5,testPulseLenX,info	SetDimLabel 0,6,lenx_final,info	SetDimLabel 0,7,numSteps,info		SetDimLabel 0,8,interPulseIntervalX,info	SetDimLabel 0,9,postPulseDeletionDurX,info	SetDimLabel 0,10,isLastStep,info	SetDimLabel 0,11,stepStartX,info	SetDimLabel 0,12,stepEndX,info	SetDimLabel 0,13,exciseStartX,info		SetDimLabel 0,14,exciseEndX,info	SetDimLabel 0,15,excisedLenX,info	SetDimLabel 0,16,excisedLenP,info		SetDimLabel 0,17,origStepStartX,info	SetDimLabel 0,18,origStepEndX,info	SetDimLabel 0,19,lenx_orig,info		for (i=0;i<numSteps;i+=1)		outRef = nameBaseStr + appendStr + num2str(i)		outList += outRef + ";"		stepStartX = stairStartTimesX[i]		exciseStartX_temp = stepStartX - preStairLenX		exciseStartX = exciseStartX_temp < 0 ? 0 : exciseStartX_temp		//truncate start times to zero so first step may have less initial time				isLastStep = 		i==(numSteps-1)		if (isLastStep)		//last step, end excision at end of recording			stepEndX = lenx_final - xDelta		else			//all but last step, end excision at start of next step			stepEndX = stairStartTimesX[i+1]		endif		exciseEndX = stepEndX		excisedLenX = exciseEndX - exciseStartX		excisedLenP = excisedLenX / xDelta		excisedEndExpected = exciseStartX + excisedLenP * xDelta		Make/O/D/N=(excisedLenP) $outRef/wave=out		SetScale/P x, 0, xDelta, "s", out		out = fullLenWvTemp(x+exciseStartX)				origStepStartX = stairStartTimesX_orig[i]		origStepEndX = origStepStartX + stairLenX			//store info		SetDimLabel 1,i,$outRef,info				info[%stepNum][i] = i		info[%stairsStartX][i] = stairsStartX		info[%stairLenX][i] = stairLenX		info[%preStairLenX][i] = preStairLenX		info[%testPulseStartX][i] = testPulseStartX		info[%testPulseLenX][i] = testPulseLenX		info[%lenx_final][i] = lenx_final		info[%numSteps][i] = numSteps						info[%interPulseIntervalX][i] = interPulseIntervalX		info[%postPulseDeletionDurX][i] = postPulseDeletionDurX		info[%isLastStep][i] = isLastStep		info[%stepStartX][i] = stepStartX		info[%stepEndX][i] = stepEndX		info[%exciseStartX][i] = exciseStartX		info[%exciseEndX][i] = exciseEndX		info[%excisedLenX][i] = excisedLenX		info[%excisedLenX][i] = excisedLenP				info[%origStepStartX][i] = exciseEndX		info[%origStepEndX][i] = excisedLenX		info[%lenx_orig][i] = lenx_orig				endfor		Make/O/D/N=(numSteps,2) $(nameBaseStr + stepTimingAppendStr)/wave=steps_out	SetDimLabel 1,0,stepTime_orig,steps_out	SetDimLabel 1,1,stepTime_final,steps_out	steps_out[][0] = stairStartTimesX_orig[p]	steps_out[][1] = stairStartTimesX[p]	Print "em_removePulsesAndGetStairs(): infosaveStr:",infosaveStr,"stepTimingRef:",nameofwave(steps_out),"outList: ",outList	return outListendfunction appendVarianceRamps2(origRef,outRef,rampLenX,origRefStartX,origRefEndX,deletePntPairsStr)	String origRef,outRef	//pass "" for outRef to modify inref, but use with caution!	Variable rampLenX		//how long to make each ramp. final len will be original + 2*rampLenX	Variable origRefStartX,origRefEndX	//start and end points	String deletePntPairsStr		//start and end points for removal as noise .. semi colon between pairs, comma between start and end points for each pair		Duplicate/O/R=(origRefStartX,origRefEndX) $origRef, inTemp	WAVE inTemp_noDel = $origRef		//delete any points requested to be deleted	Variable numDeletePairs = itemsinlist(deletePntPairsStr)	Variable i	String currPairStr, deletePairsInitialXVals, deleteXPairsStr = ""	Variable startP,endP,startX,endX,startP_del,endP_del	Variable currDelSize,deletedPnts = 0	for (i=0;i<numDeletePairs;i+=1)		currPairStr = c2sc(stringfromlisT(i,deletePntPairsStr))		startP = str2num(stringfromlist(0,currPairStr))		endP = str2num(stringfromlist(1,currPairStr))		startX = pnt2x(inTemp_noDel, startP )		endX = pnt2x(inTemp_noDel, endP )		deleteXPairsStr += num2str(startX) + "," + num2str(endX) + ",;"		//save x values too		startP_del = startP - deletedPnts		endP_del = endP - deletedPnts		currDelSize = endP_del - startP_del		DeletePoints startP_del, currDelSize, inTemp		deletedPnts += currDelSize	endfor			Double meanVal = mean(inTemp)	inTemp -= meanVal		Variable xDelta = dimdelta(inTemp,0)	Variable inLen = dimsize(inTemp,0)	Variable rampLenP = rampLenX/xDelta		Duplicate/O/R=[1,1+rampLenP] inTemp, wvTemp_b		//before	Duplicate/O/R=[inLen-2-rampLenP,inLen-2] inTemp, wvTemp_a		//after	reverse/P wvTemp_a	reverse/P wvTemp_b		wvTemp_b *= p/rampLenP	wvTemp_a *= (rampLenP-p-1)/rampLenP		if (!strlen(outRef))		outRef = origRef	endif		concatenate/O {wvTemp_b,inTemp,wvTemp_a},$outRef		String meanValStr	sprintf meanValStr, "%f", meanVal	Note $outRef, "appendVarianceRamps_startX:"+num2str(origRefStartX)+";appendVarianceRamps_endX:"+num2str(origRefEndX)+";appendVarianceRamps_origRef:"+origRef+";appendVarianceRamps_meanVal:"+meanValStr+";"	Note $outRef, "appendVarianceRamps_deletePntPairsStr:"+deletePntPairsStr+";"	endfunction appendVarianceRamps(origRef,outRef_W, outRef_L,rampLenX,origRefStartX,origRefEndX,deletePntPairsStr)	String origRef,outRef_W,outRef_L		//outrefs for wide band and low pass filter	Variable rampLenX		//how long to make each ramp. final len will be original + 2*rampLenX	Variable origRefStartX,origRefEndX	//start and end points	String deletePntPairsStr		//start and end points for removal as noise .. semi colon between pairs, comma between start and end points for each pair		Duplicate/O/R=(origRefStartX,origRefEndX) $origRef, inTemp, inTemp_noDel		//delete any points requested to be deleted	Variable numDeletePairs = itemsinlist(deletePntPairsStr)	Variable i	String currPairStr, deletePairsInitialXVals, deleteXPairsStr = ""	Variable startP,endP,startX,endX,startP_del,endP_del	Variable currDelSize,deletedPnts = 0	for (i=0;i<numDeletePairs;i+=1)		currPairStr = c2sc(stringfromlisT(i,deletePntPairsStr))		startP = str2num(stringfromlist(0,currPairStr))		endP = str2num(stringfromlist(1,currPairStr))		startX = pnt2x(inTemp_noDel, startP )		endX = pnt2x(inTemp_noDel, endP )		deleteXPairsStr += num2str(startX) + "," + num2str(endX) + ",;"		//save x values too		startP_del = startP - deletedPnts		endP_del = endP - deletedPnts		currDelSize = endP_del - startP_del		DeletePoints startP_del, currDelSize, inTemp		deletedPnts += currDelSize	endfor			Double meanVal = mean(inTemp)	inTemp -= meanVal		Variable xDelta = dimdelta(inTemp,0)	Variable inLen = dimsize(inTemp,0)	Variable rampLenP = rampLenX/xDelta		Duplicate/O/R=[1,1+rampLenP] inTemp, wvTemp_b		//before	Duplicate/O/R=[inLen-2-rampLenP,inLen-2] inTemp, wvTemp_a		//before	reverse/P wvTemp_a	reverse/P wvTemp_b		wvTemp_b *= p/rampLenP	wvTemp_a *= (rampLenP-p-1)/rampLenP		concatenate/O {wvTemp_b,inTemp,wvTemp_a},$outRef_W		String meanValStr	sprintf meanValStr, "%f", meanVal	Note $outRef_W, "appendVarianceRamps_startX:"+num2str(origRefStartX)+";appendVarianceRamps_endX:"+num2str(origRefEndX)+";appendVarianceRamps_origRef:"+origRef+";appendVarianceRamps_meanVal:"+meanValStr+";"	Note $outRef_W, "appendVarianceRamps_deletePntPairsStr:"+deletePntPairsStr+";"	Duplicate/O $outRef_W,$outRef_L	//low pass filter -- wide	Make/O/D/N=0 coefs	FilterIIR/CASC/LO=0.25/ORD=4/COEF coefs, $outRef_W		//one quarter original sampling rate = 2.5 kHz -- ADJUST FOR USE ON NEW RATES		//low pass filter -- wide	Make/O/D/N=0 coefs	FilterIIR/CASC/LO=0.0001/ORD=4/COEF coefs, $outRef_L		//10,000th of original sampling rate = 1 Hz	endfunction flashVI_add(startName,repNum,flashNum,saveArray,isPositiveGoing)	String startName,saveArray	Variable repNum,flashNum,isPositiveGoing		Variable fullChan = 0, lpChan = 1, cmdChan = 2, lightMonChan=3, tempChan=nan	//should go AD[channum]	Variable lightRespStartX = 3.9274	Variable testPulseStartX = 1.2751, testPulseEndX = 1.4251	Variable holdingMeasureTimeStartX = 0	Variable holdingMeasureTimeEndX = 1	Variable holdMult = 1000		String ref_full = gc(fullChan),ref_lp=gc(lpChan),ref_cmd=gc(cmdChan),ref_light=gc(lightMonChan), ref_temp = ""//	ref_temp=gc(tempChan)		Double hold = mean($ref_cmd,holdingMeasureTimeStartX,holdingMeasureTimeEndX)	Double temp = nan// mean($ref_temp)	Variable hold_round = round(hold*holdMult)	String holdStr = ReplaceString("-",num2str(hold_round),"n")		String saveRef = "fIV_" + startName + "_" + num2str(flashNum) + "_" + holdStr + "_" + num2str(repNum)		Variable numParams = 15,actualNumParams		Variable row	if (!WaveExists($saveArray))		Make/O/D/N=(1,numParams) $saveArray/wave=saveArr		row = 0	else		WAVE/D saveArr = $saveArray		row = dimsize(saveArr,0)		actualNumParams = max(dimsize(saveArr,1),numParams)		redimension/N=(row+1,actualNumParams) saveArr	endif		SetDimLabel 0,row,$saveRef,saveArr	Variable c=0	saveArr[row][c] = repNum; SetDimLabel 1,c,repNum,saveArr	c+=1;saveArr[row][c] = flashNum; SetDimLabel 1,c,flashNum,saveArr	c+=1;saveArr[row][c] = fullChan; SetDimLabel 1,c,fullChan,saveArr	c+=1;saveArr[row][c] = lpChan; SetDimLabel 1,c,lpChan,saveArr	c+=1;saveArr[row][c] = cmdChan; SetDimLabel 1,c,cmdChan,saveArr	c+=1;saveArr[row][c] = lightMonChan; SetDimLabel 1,c,lightMonChan,saveArr	c+=1;saveArr[row][c] = lightRespStartX; SetDimLabel 1,c,lightRespStartX,saveArr	c+=1;saveArr[row][c] = testPulseStartX; SetDimLabel 1,c,testPulseStartX,saveArr	c+=1;saveArr[row][c] = holdingMeasureTimeStartX; SetDimLabel 1,c,holdingMeasureTimeStartX,saveArr	c+=1;saveArr[row][c] = holdingMeasureTimeEndX; SetDimLabel 1,c,holdingMeasureTimeEndX,saveArr	c+=1;saveArr[row][c] = hold; SetDimLabel 1,c,hold,saveArr	c+=1;saveArr[row][c] = hold_round; SetDimLabel 1,c,hold_round,saveArr		//12th item, c=11	c+=1;saveArr[row][c] = holdMult; SetDimLabel 1,c,holdMult,saveArr			c+=1;saveArr[row][c] = temp; SetDimLabel 1,c,temp,saveArr		c+=1;saveArr[row][c] = isPositiveGoing; SetDimLabel 1,c,isPositiveGoing,saveArr				String wNote = note(saveArr)	String listKey = num2str(row)	STring listItem = "saveRef:"+saveRef+";"+"ref_full:"+ref_full+";"+"ref_lp:"+ref_lp+";"+"ref_cmd:"+ref_cmd+";"+"ref_light:"+ref_light+";"+"ref_temp:"+ref_temp+";"	listItem = replacestring(";",listItem,",")	wNote = ReplaceStringByKey(listKey, wNote, listItem)	Note/K saveArr,wNote	Print "flashVI_add(): Saved saveRef=",saveRef,"saveArray=",saveArray,"hold",hold,"holdStr",holdStr,"row",row,"listItem",listItemendfunction flashVI_analyze(dataWv,startRow,numRows,firstFileNum,sealRef,hasPrePostControl)	WAVE/d dataWv; Variable startRow,numRows	Variable firstFileNum		//for analysis cap, what was the first file num for this cell?	String sealRef		//also for analysis cap	Variable hasPrePostControl	//handling for relative to before and after control condition--NOT YET IMPLEMENTED		Duplicate/O dataWv, dataWv_bu		String lbl,ref_full,ref_cmd,ref_lp,flashFitSaveRef	Variable lightRespStartX,isPositiveGoing,lenp,endX,totalNumParams,outRow	Variable preFlashBaselineLenX = 0.2		//0.2 seems like a good number	Variable numPreExistingParams=15	Variable numParamsInThisFunc=2	String wNote,listKey,listItem		Variable row,i,c,totalNumRows = dimsize(dataWv,0),maxCalcRows = min(numRows,totalNumRows-startRow)	for (i=0;i<maxCalcRows;i+=1)		Print "starting row=",i		row=i+startRow				lbl=GetDimLabel(dataWv, 0,row)		ref_full=data_getRowItemByKey(dataWv,row,"ref_full")		ref_cmd=data_getRowItemByKey(dataWv,row,"ref_cmd")		ref_lp=data_getRowItemByKey(dataWv,row,"ref_lp")				flashFitSaveRef = ref_lp + "ff"				lightRespStartX = dataWv[row][%lightRespStartX]		isPositiveGoing = dataWv[row][%isPositiveGoing]		lenp = dimsize($ref_lp,0)		endX = pnt2x($ref_lp, lenp)				wavestats/Q/R=(lightRespStartX,endX)/W $ref_lp		Duplicate/O $"M_wavestats", flashVI_analyze_wsTemp						analysis_cap(firstFileNum, ref_cmd, ref_full,0,0,sealRef,"fVI_analyze_caTemp","", "")				analysis_dimFlash_ipRGC(ref_lp,lightRespStartX,preFlashBaselineLenX,"fVI_analyze_fFitTemp",flashFitSaveRef,isPositiveGoing)				//put it all together		concatenate/O/NP=0/DL {$"fVI_analyze_fFitTemp",$"fVI_analyze_caTemp",flashVI_analyze_wsTemp}, flashVI_analyze_outTemp		outRow = dimsize(flashVI_analyze_outTemp,0)		Redimension/N=(outRow+numParamsInThisFunc) flashVI_analyze_outTemp		c=0;dl_assignAndLbl(flashVI_analyze_outTemp,outRow+c,endX,"flashVI_analyze_endX")		c=1;dl_assignAndLbl(flashVI_analyze_outTemp,outRow+c,preFlashBaselineLenX,"preFlashBaselineLenX") 				if (i==0)			totalNumParams=dimsize(flashVI_analyze_outTemp,0)			Redimension/N=(-1,numPreExistingParams+totalNumParams) dataWv			dl_labelsFromWvToWv(flashVI_analyze_outTemp,0,0,totalNumParams,dataWv,1,numPreExistingParams)		endif				dataWv[row][numPreExistingParams,] = flashVI_analyze_outTemp[q-numPreExistingParams]								wNote = note(dataWv);string/g wNote_backup = wNote		listKey = num2str(row)		listItem = ReplaceString(",",StringByKey(listKey, wNote),";")  // "saveRef:"+saveRef+";"+"ref_full:"+ref_full+";"+"ref_lp:"+ref_lp+";"+"ref_cmd:"+ref_cmd+";"+"ref_light:"+ref_light+";"+"ref_temp:"+ref_temp+";"		listItem+="flashFitSaveRef:"+flashFitSaveRef+";"		listItem= ReplaceString(";",listItem,",") 		wNote = ReplaceStringByKey(listKey, wNote, listItem)		Note/K dataWv,wNote	endfor	endfunction analysis_dimFlash_ipRGC(ref,flashStartX,preFlashBaselineLenX,outRef,outFitRef,isPositiveGoing)	String ref	//rec of light responses, usually an average from low pass filtered traces	String outRef	//where to store results	String outFitRef	//optionally pass pace to store ref	Variable flashStartX		//start time of light flash	Variable preFlashBaselineLenX	//how long before flash to use as baseline average? (recommend 200 ms or so)	Variable isPositiveGoing	//needed to generate appropriate fit guesses		Variable baseSubStartX = flashStartX - preFlashBaselineLenX	Variable ampGuess=12.2*10^-12*(isPositiveGoing ? 1 : -1)			//12.2*10^-12, 12.9, 1.3	Variable tau0Guess=12.9	Variable tau1Guess=1.3		String outCoefsRef = "analysis_dimFlash_ipTemp"	String fitTempRef = "analysis_dimFlashFit_ipTemp"		Double baselineVal = fit_getDblExpConv(ref,baseSubStartX,flashStartX,flashStartX,inf,ampGuess,tau0Guess,tau1Guess,outCoefsRef,fitTempRef,"")	WAVE/D coefs = $outCoefsRef	Double finalVal = baselineVal + coefs[0]		//amplitude with baseline put back	if (strlen(outFitRef))		Duplicate/O $fitTempRef, $outFitRef	endif		wavestats/Q $fitTempRef		//should be baseline subtracted	Double amp = isPositiveGoing ? V_max : V_min	Double peakLoc = isPositiveGoing ? V_maxLoc : V_minLoc		Double halfPeakVal = amp/2	Variable risingAtFirstHalfLoc = isPositiveGoing	Variable firstHalfEdgEtype = risingAtFirstHalfLoc ? 1 : 2	Variable risingAtSecondHalfLoc = !isPositiveGoing	Variable secondHalfEdgeType = risingAtSecondHalfLoc ? 1 : 2	FindLevel/EDGE=(risingAtFirstHalfLoc)/Q/R=(flashStartX,peakLoc) $fitTempRef, halfPeakVal	Variable flagForFirstFindLevel = V_flag	Double firstHalfLoc = V_LevelX	FindLevel/EDGE=(secondHalfEdgeType)/Q/R=(peakLoc,inf) $fitTempRef, halfPeakVal	Variable flagForSecondFindLevel = V_flag	Double secondHalfLoc = V_LevelX			Double fwhm = secondHalfLoc - firstHalfLoc	Double firstHalfLoc_relRecStart=firstHalfLoc+flashStartX	Double secondHalfLoc_relRecStart=secondHalfLoc+flashStartX	Double peakLoc_relRecStart=peakLoc+flashStartX		Double auc = area($fitTempRef,flashStartX,inf)	Double integrationTime = auc/amp		Variable numParams = 22		Make/O/D/N=(numParams) $outRef/wave=out	Variable c=0	dl_assignAndLbl(out,c,coefs[0],"flashFit_ampCoef")	c+=1;dl_assignAndLbl(out,c,coefs[1],"flashFit_tau0")	c+=1;dl_assignAndLbl(out,c,coefs[2],"flashFit_tau1")	c+=1;dl_assignAndLbl(out,c,baselineVal,"baselineVal")	c+=1;dl_assignAndLbl(out,c,finalVal,"flashFit_finalVal")	//5th item		c+=1;dl_assignAndLbl(out,c,amp,"flashFit_amp")	c+=1;dl_assignAndLbl(out,c,peakLoc,"flashFit_peakLoc")	c+=1;dl_assignAndLbl(out,c,halfPeakVal,"flashFit_halfPeakVal")	c+=1;dl_assignAndLbl(out,c,peakLoc_relRecStart,"flashFit_peakLoc_relRecStart")	c+=1;dl_assignAndLbl(out,c,risingAtFirstHalfLoc,"flashFit_risingAtFirstHalfLoc")		c+=1;dl_assignAndLbl(out,c,firstHalfEdgEtype,"flashFit_firstHalfEdgEtype")	c+=1;dl_assignAndLbl(out,c,flagForFirstFindLevel,"flashFit_flagForFirstFindLevel")	c+=1;dl_assignAndLbl(out,c,firstHalfLoc,"flashFit_firstHalfLoc")	c+=1;dl_assignAndLbl(out,c,firstHalfLoc_relRecStart,"flashFit_firstHalfLoc_relRecStart")	c+=1;dl_assignAndLbl(out,c,risingAtSecondHalfLoc,"flashFit_risingAtSecondHalfLoc")		c+=1;dl_assignAndLbl(out,c,secondHalfEdgEtype,"flashFit_secondHalfEdgEtype")	c+=1;dl_assignAndLbl(out,c,flagForSecondFindLevel,"flashFit_flagForSecondFindLevel")	c+=1;dl_assignAndLbl(out,c,secondHalfLoc,"flashFit_secondHalfLoc")	c+=1;dl_assignAndLbl(out,c,secondHalfLoc_relRecStart,"flashFit_secondHalfLoc_relRecStart")	c+=1;dl_assignAndLbl(out,c,fwhm,"flashFit_fwhm")		c+=1;dl_assignAndLbl(out,c,auc,"flashFit_auc")	c+=1;dl_assignAndLbl(out,c,integrationTime,"flashFit_integrationTime")		end		//analysis_dimFlash_ipRGC//modified from analysis_dimFlash_ipRGC for any fit so that other flashes, e.g. cones can be fitfunction analysis_flash_g(ref,typeStr,flashStartX,preFlashBaselineLenX,outRef,outFitRef,isPositiveGoing,flashDurS,phPerUmSqPerS,cw,userGuidedFit,[initGuessWv,catParams,useInitGuessWv,col])	String ref	//rec of light responses, usually an average from low pass filtered traces	String typeStr		//options supported now are "ipRGC" and "cone"	String outRef	//where to store results	String outFitRef	//optionally pass pace to store ref	Variable flashStartX		//start time of light flash	Variable preFlashBaselineLenX	//how long before flash to use as baseline average? (recommend 200 ms or so)	Variable isPositiveGoing	//needed to generate appropriate fit guesses	Double flashDurS,phPerUmSqPerS			//used to calculate dim flash sensitivity	Variable userGuidedFit	//pass true to have user guide fit through GUI (with ability to adjust initial guesses and test multiple fit runs), false to have fit procede automatically from initial guesses			//option not yet implmemented for ipRGC fit	WAVE/D initGuessWv		//optionally pass initial guesses for fitting	Variable useInitGuessWv	//pass to use initial guesses as fit (saves time refitting if already done) -- only implemented for cone fit at present	WAVE/D catParams			//optionally pass a params wave that will concatenated BEFORE the rest of the params into outREf	Variable cw	Variable col			//optionally specify a single column in a 2d wave containing time series to analyze (otherwise expects a 1D wave)		if (!ParamIsDefault(col) && (numtype(col)==0) )		duplicate/o/free/r=[][col] $ref,wv		redimension/n=(-1) wv	else		WAVE wv=$ref	endif		if (strlen(outRef)<1)		outRef=ref+"_dFFS"		//(dim) flash fit stats	endif	if (strlen(outFitRef)<1)		outFitRef=ref+"_dFF"		//(dim) flash fit	endif			//get flash fit	Variable baseSubStartX = flashStartX - preFlashBaselineLenX	Double baselineVal,finalVal=nan	String outCoefsRef = "analysis_dimFlash_ipTemp"	String fitTempRef = "analysis_dimFlashFit_ipTemp"	Variable fitLenX		Variable igw=!ParamIsDefault(initGuessWv)	Variable skipFit = igw && !ParamIsDefault(useInitGuessWv) && useInitGuessWv	Double ampGuess	strswitch (typeStr)		case "ipRGC":			ampGuess= igw ? initGuessWv[0] : 12.2*10^-12*(isPositiveGoing ? 1 : -1)			//12.2*10^-12, 12.9, 1.3			Double tau0Guess= igw ? initGuessWv[1] : 12.9			Double tau1Guess= igw ? initGuessWv[2] : 1.3				fitLenX=100			baselineVal = fit_getDblExpConv(ref,baseSubStartX,flashStartX,flashStartX,flashStartX+fitLenX,ampGuess,tau0Guess,tau1Guess,outCoefsRef,fitTempRef,"")			break					case "cone":		//{0.25,0.03,.08,1,0} {8*10^-12,0.03,.4,1,0}			fitLenX= min(pnt2x(wv,dimsize(wv,0)-1) - flashStartX	,1.5)	//use full length of response or 1.5 seconds, whatever is shorter			if (!skipFit)		//do fit				ampGuess= igw ? initGuessWv[0] : 8*10^-12				Double riseTauGuess =  igw ? initGuessWv[1] : 0.03				Double fallTauGuess =  igw ? initGuessWv[2] : 0.4				Double oscTauGuess =  igw ? initGuessWv[3] : 1				Double phiGuess =  igw ? initGuessWv[4] : 0				baselineVal = fit_getConeDimFlashFit_g(wv,baseSubStartX,flashStartX,flashStartX,flashStartX+fitLenX,ampGuess,riseTauGuess,fallTauGuess,oscTauGuess,phiGuess,userGuidedFit,outCoefsRef,fitTempRef,"",expTitle="fit for "+ref)			else				//usually performed within fit_getConeDimFlashFit_g()				print "analysis_flash_g() skipping fit for data wave",ref				duplicate/o initGuessWv, $outCoefsRef				baselineVal=mean(wv,baseSubStartX,flashStartX)					Duplicate/O/R=(flashStartX, flashStartX+fitLenX) wv, $outFitRef/WAVE=fit					fit = fit_angueyraDimFlash($outCoefsRef, x)				String noteStr				wfprintf noteStr, "%f,", $outCoefsRef				Note/k fit, "coefs:"+noteStr+";"						duplicate/o $outFitRef,$fitTempRef			endif			break		case "cone_ic":			//no fitting!												break	endswitch		Double phPerUmSq=flashDurS*phPerUmSqPerS		wavestats/Q wv		//should be baseline subtracted	Double amp_raw = isPositiveGoing ? V_max : V_min	Double peakLoc_raw = isPositiveGoing ? V_maxLoc : V_minLoc		Double halfPeakVal_raw = amp_raw/2	Variable risingAtFirstHalfLoc_raw = isPositiveGoing	Variable firstHalfEdgEtype_raw = risingAtFirstHalfLoc_raw ? 1 : 2	Variable risingAtSecondHalfLoc_raw = !isPositiveGoing	Variable secondHalfEdgeType_raw = risingAtSecondHalfLoc_raw ? 1 : 2	FindLevel/EDGE=(risingAtFirstHalfLoc_raw)/Q/R=(flashStartX,peakLoc_raw) wv, halfPeakVal_raw	Variable flagForFirstFindLevel_raw = V_flag	Double firstHalfLoc_raw = V_LevelX	FindLevel/EDGE=(secondHalfEdgeType_raw)/Q/R=(peakLoc_raw,inf) wv, halfPeakVal_raw	Variable flagForSecondFindLevel_raw = V_flag	Double secondHalfLoc_raw = V_LevelX			Double fwhm_raw = secondHalfLoc_raw - firstHalfLoc_raw	Double firstHalfLoc_relRecStart_raw=firstHalfLoc_raw+flashStartX	Double secondHalfLoc_relRecStart_raw=secondHalfLoc_raw+flashStartX	Double timeToPeak_raw=peakLoc_raw+flashStartX		Double auc_raw = area($fitTempRef,flashStartX,inf)	Double integrationTime_raw = auc_raw/amp_raw		Double phPerUmSq_raw=flashDurS*phPerUmSqPerS	Double sensitivity_raw=amp_raw/phPerUmSq		WAVE/D coefs = $outCoefsRef	if (strlen(outFitRef))		Duplicate/O $fitTempRef, $outFitRef	endif	if (stringmatch(typeStr,"iprgc"))		finalVal = baselineVal + coefs[0]		//amplitude with baseline put back	endif		wavestats/Q $fitTempRef		//should be baseline subtracted	Double amp = isPositiveGoing ? V_max : V_min	Double peakLoc = isPositiveGoing ? V_maxLoc : V_minLoc		Double halfPeakVal = amp/2	Variable risingAtFirstHalfLoc = isPositiveGoing	Variable firstHalfEdgEtype = risingAtFirstHalfLoc ? 1 : 2	Variable risingAtSecondHalfLoc = !isPositiveGoing	Variable secondHalfEdgeType = risingAtSecondHalfLoc ? 1 : 2	FindLevel/EDGE=(risingAtFirstHalfLoc)/Q/R=(flashStartX,peakLoc) $fitTempRef, halfPeakVal	Variable flagForFirstFindLevel = V_flag	Double firstHalfLoc = V_LevelX	FindLevel/EDGE=(secondHalfEdgeType)/Q/R=(peakLoc,inf) $fitTempRef, halfPeakVal	Variable flagForSecondFindLevel = V_flag	Double secondHalfLoc = V_LevelX			Double fwhm = secondHalfLoc - firstHalfLoc	Double firstHalfLoc_relRecStart=firstHalfLoc+flashStartX	Double secondHalfLoc_relRecStart=secondHalfLoc+flashStartX	Double timeToPeak=peakLoc+flashStartX		Double auc = area($fitTempRef,flashStartX,inf)	Double integrationTime = auc/amp		Double sensitivity=amp/phPerUmSq		//calculate R*/receptor from cw and phPerUmSq	String receptorNames="sCone;mCone;lCone;rod;mv;mc;"		//mv mc stand for melanopsin violet and cyan	String receptorLambdas="430;531;561;491;453;471;"		//peaks from baylor, nunn, and schnapft 1987 for cones; baylor nunn schnapf 84 for rods; Emanuel and Do 2015	STring receptorCAs="0.6;0.6;0.6;0.6;1;1;"		//no clue what to put for ipRGCs. rods and cones based on Angueyra and Rieke's standard		Variable numReceptors=min(itemsinlist(receptorNames),min(itemsinlist(receptorLambdas),itemsinlist(receptorCAs)))	Variable numPAramsPerReceptor=5,startRow	Variable numReceptorParams=numPAramsPerReceptor*numReceptors		if (!ParamIsDefault(catParams))		duplicate/o catParams,$outref		startRow=dimsize(catParams,0)		redimension/n=(startRow+numReceptorParams) $outRef	else		Make/O/D/N=(numReceptorParams) $outRef		startRow=0	endif	wave out=$outRef		String receptorName	Variable receptorCA,lambda,offsetRows,i	Double relActivation,rSPerRPerUmSq,rSPerR	for (i=0;i<numReceptors;i+=1)		receptorName=stringfromlist(i,receptorNames)		lambda=str2num(stringfromlist(i,receptorLambdas))		receptorCA=str2num(stringfromlist(i,receptorCAs))			relActivation=nomo_x(lambda,cw)		rSPerRPerUmSq=relActivation*phPerUmSq		rSPerR=rSPerRPerUmSq*receptorCA				offsetRows=startRow+i*numPAramsPerReceptor		dl_assignAndLbl(out,offsetRows+0,lambda,receptorName+"_"+"lambda")		dl_assignAndLbl(out,offsetRows+1,receptorCA,receptorName+"_"+"receptorCA")		dl_assignAndLbl(out,offsetRows+2,relActivation,receptorName+"_"+"relActivation")		dl_assignAndLbl(out,offsetRows+3,rSPerRPerUmSq,receptorName+"_"+"rSPerRPerUmSq")		dl_assignAndLbl(out,offsetRows+4,rSPerR,receptorName+"_"+"rSPerR")	endfor		Variable numParams = 42,c	startRow=dimsize(out,0)	Variable totalRows=startRow+numParams	redimension/n=(totalRows) out		c=startRow;dl_assignAndLbl(out,c,baselineVal,"baselineVal")	c+=1;dl_assignAndLbl(out,c,finalVal,"flashFit_finalVal")		c+=1;dl_assignAndLbl(out,c,amp_raw,"flashFit_amp_raw")	c+=1;dl_assignAndLbl(out,c,peakLoc_raw,"flashFit_peakLoc_raw")	c+=1;dl_assignAndLbl(out,c,halfPeakVal_raw,"flashFit_halfPeakVal_raw")		c+=1;dl_assignAndLbl(out,c,timeToPeak_raw,"flashFit_timeToPeak_raw")	c+=1;dl_assignAndLbl(out,c,risingAtFirstHalfLoc_raw,"flashFit_risingAtFirstHalfLoc_raw")	c+=1;dl_assignAndLbl(out,c,firstHalfEdgEtype_raw,"flashFit_firstHalfEdgEtype_raw")	c+=1;dl_assignAndLbl(out,c,flagForFirstFindLevel_raw,"flashFit_flagForFirstFindLevel_raw")	c+=1;dl_assignAndLbl(out,c,firstHalfLoc_raw,"flashFit_firstHalfLoc_raw")		c+=1;dl_assignAndLbl(out,c,firstHalfLoc_relRecStart_raw,"flashFit_firstHalfLoc_relRecStart_raw")	c+=1;dl_assignAndLbl(out,c,risingAtSecondHalfLoc_raw,"flashFit_risingAtSecondHalfLoc_raw")	c+=1;dl_assignAndLbl(out,c,secondHalfEdgEtype_raw,"flashFit_secondHalfEdgEtype_raw")	c+=1;dl_assignAndLbl(out,c,flagForSecondFindLevel_raw,"flashFit_flagForSecondFindLevel_raw")	c+=1;dl_assignAndLbl(out,c,secondHalfLoc_raw,"flashFit_secondHalfLoc_raw")		c+=1;dl_assignAndLbl(out,c,secondHalfLoc_relRecStart,"flashFit_secondHalfLoc_relRecStart_raw")	c+=1;dl_assignAndLbl(out,c,fwhm_raw,"flashFit_fwhm_raw")		c+=1;dl_assignAndLbl(out,c,auc_raw,"flashFit_auc_raw")	c+=1;dl_assignAndLbl(out,c,integrationTime_raw,"flashFit_integrationTime_raw")	c+=1;dl_assignAndLbl(out,c,sensitivity_raw,"sensitivity_raw")		c+=1;dl_assignAndLbl(out,c,amp,"flashFit_amp")	c+=1;dl_assignAndLbl(out,c,peakLoc,"flashFit_peakLoc")	c+=1;dl_assignAndLbl(out,c,halfPeakVal,"flashFit_halfPeakVal")	c+=1;dl_assignAndLbl(out,c,timeToPeak,"flashFit_timeToPeak")	c+=1;dl_assignAndLbl(out,c,risingAtFirstHalfLoc,"flashFit_risingAtFirstHalfLoc")		c+=1;dl_assignAndLbl(out,c,firstHalfEdgEtype,"flashFit_firstHalfEdgEtype")	c+=1;dl_assignAndLbl(out,c,flagForFirstFindLevel,"flashFit_flagForFirstFindLevel")	c+=1;dl_assignAndLbl(out,c,firstHalfLoc,"flashFit_firstHalfLoc")	c+=1;dl_assignAndLbl(out,c,firstHalfLoc_relRecStart,"flashFit_firstHalfLoc_relRecStart")	c+=1;dl_assignAndLbl(out,c,risingAtSecondHalfLoc,"flashFit_risingAtSecondHalfLoc")		c+=1;dl_assignAndLbl(out,c,secondHalfEdgEtype,"flashFit_secondHalfEdgEtype")	c+=1;dl_assignAndLbl(out,c,flagForSecondFindLevel,"flashFit_flagForSecondFindLevel")	c+=1;dl_assignAndLbl(out,c,secondHalfLoc,"flashFit_secondHalfLoc")	c+=1;dl_assignAndLbl(out,c,secondHalfLoc_relRecStart,"flashFit_secondHalfLoc_relRecStart")	c+=1;dl_assignAndLbl(out,c,fwhm,"flashFit_fwhm")			c+=1;dl_assignAndLbl(out,c,auc,"flashFit_auc")	c+=1;dl_assignAndLbl(out,c,integrationTime,"flashFit_integrationTime")	c+=1;dl_assignAndLbl(out,c,sensitivity,"sensitivity")	c+=1;dl_assignAndLbl(out,c,phPerUmSq,"phPerUmSq")	c+=1;dl_assignAndLbl(out,c,flashDurS,"flashDurS")		c+=1;dl_assignAndLbl(out,c,phPerUmSqPerS,"phPerUmSqPerS")	c+=1;dl_assignAndLbl(out,c,cw,"cw_func")		//cw is often also stored in catParams  42		dl_lblByInd(nameofwave(coefs),0,typeStr+"_C",1)		concatenate/dl/np=0 {coefs},out	end		//analysis_flash_gfunction/S data_getRowItemByKey(dataWv,row,itemKey)		WAVE dataWv; Variable row; string itemkey		STring noteStr = note(dataWv)	String info = ReplaceString(",",StringByKey(num2str(row), noteStr),";")	return stringbykey(itemKey,info)endfunction data_plotRefFromRows(dataWv,refKey,oneAxisName,rowNumList,[forceTNBase])	WAVE dataWv; string refKey; String oneAxisName	// pass oneAxisName to get all on one axis, or "" for individual axes as defined by the wave note	String rowNumList		//list of row nums to plot or "" for all rows	String forceTNBase		//optionally pass to make the trace name base overtly predictable; it will have "_rowNum" appended		Variable plotAllRows,rows	if (strlen(rowNumList))		rows = itemsinlist(rowNumList)		plotAllRows = 0	else		rows=dimsize(dataWv,0) 		plotAllRows = 1	endif		variable i,row	STring ref,lbl,axis	for (i=0;i<rows;i+=1)		if (plotAllRows)			row = i		else			row = str2num(stringfromlist(i,rowNumList))		endif		ref = data_getRowItemByKey(dataWv,row,refKey)		if ( ParamIsDefault(forceTNBase) || !strlen(forceTNBase) )			lbl = refkey + "_" + num2str(row)		//generate a trace name		else			lbl = forceTNBase + "_" + num2str(row)	//use user selection		endif		if (strlen(oneAxisName))			axis = oneAxisName		else			axis = "L_" + lbl		endif				appendtograph/L=$axis $ref/tn=$lbl	endforend		function bringToTopOnMouseOver(s) 	STRUCT WMWinHookStruct &s			if (s.eventCode != 4)		//only continue on mouse move (winthin window)		return 0	endif				dowindow/F $s.winname		//brings window to top			return 0endfunction bringToTopOnMouseOver2(s) 	STRUCT WMWinHookStruct &s			if (s.eventCode != 4)		//only continue on mouse move (winthin window)		return 0	endif			//to bring even past the command line window (which is currently invisible to winlist), remove the following if statement. 			//note that winname(0,whatever) currently reports a subset of the windows recognized by winList with the third parameter ""	if (!Stringmatch(s.winname,stringfromlist(0,winlist("*",";",""))))		//is this not the top one among all those of the selected types?		dowindow/F $s.winname		//brings window to top	endif			return 0end	//takes in a list of waves, effectively concatenates them but merges rows with a matching label//rows of nans are added as placeholders to waves that lacked the label//it will be an issue to handle duplicate labels occuring in the rows of the same wave//in fact, to be safe, I cause that to stop the function and alert user//another issue to be aware of is truncation of labels, especially when using appendWvNameToColLbls to elongate the inputs//the truncation that happens function dl_combine2DByRowLbls(wvList,appendWvNameToColLbls,appendStrList,outRef)	String wvList	Variable appendWvNameToColLbls	//pass 0 to copy over exact column labels from in waves; 1 to pre-append the name of the source wave to the output label, 2 to post-append it	String appendStrList //list with order corresponding to wvList; specifies a string to pre or post append to the dim label (according to appendWvNameToColLbls), passing 0 uses the wave name if appendWvNameToColLbls == 1 or 2						//entirety is blank to use wave names for all, or the list can be passed and left blank for specific waves to use wave names just for those	String outRef	//where to store the result wave										variable i,j,numRows,numWvs=itemsinlist(wvlist),lblListPos,numUniqueLbls = 0	string ref,lbl,wavesWithLbl_startCommaList = "", wavesWithLbl_currCommaList	Variable out_cols = 0		//out_rows will = numUniqueLbls	String inputWvStartColList = ""		//list of start columns for each wave, same order as wvList	String lblsList = ""	//list of unique labels found	//find unique rows and make a wave containing these	for (i=0;i<numWvs;i+=1)		ref = stringfromlist(i,wvlist)		WAVE wv = $ref		numRows = dimsize(wv,0)		inputWvStartColList += num2str(out_cols) + ";"		//first is zero, next is the end of the previous wave		out_cols += dimsize(wv,1)		//include all the rows 		for (j=0;j<numRows;j+=1)			lbl = GetDimLabel(wv, 0, j)			lblListPos = WhichListItem(lbl, lblsList)			if (lblListPos < 0)	//not in list -- new label				lblsList += lbl + ";"				numUniqueLbls += 1			endif		endfor	endfor	Make/O/T/N=(numUniqueLbls,2)/Free wvsWithLbl		//for each unique label (which will be a new row) make two columns, each row in first column holds a list of the waves with that label																	//each row in the second column holds a list in the same respective order with the row of the label in the respective source wave	//make a list of all waves containing each label	wvsWithLbl = ""	Variable lblRow	for (i=0;i<numUniqueLbls;i+=1)		lbl = stringfromlist(i,lblsList)		for (j=0;j<numWvs;j+=1)			ref = stringfromlist(j,wvlist)			WAVE wv = $ref			lblRow = FindDimLabel(wv, 0, lbl)			if (lblRow >= 0)			//in the wave				//quick check for duplicates:				if (WhichListItem(ref, wvsWithLbl[i][0]) > -1)					Print "dl_combine2DByRowLbls(): duplicate row label found in wave, no handling for this. aborting. wv=",ref,"lbl=",lbl,"lblRow=",lblRow				endif				wvsWithLbl[i][0] += ref + ";"		//just goes on order in which they are found				wvsWithLbl[i][1] += num2str(lblRow) + ";"				//order matched to the list in column 0			endif		endfor	endfor		Duplicate/O $stringfromlist(0,wvList), $outRef/wave=out		//hoping to be able to stay type neutral, not sure it works out though	Redimension/N=(numUniqueLbls,out_cols) out	out = nan		//any subrange that's not filled in gets NaN		Variable startCol,endCol,appendBeforeNotAfter, numWvsWithLbl,inWvRow,posInWvList	String colAppendLbl = "",lblInfo,wvRefAndInWvRow, appendStr	//assign column labels from waves	for (i=0;i<numWvs;i+=1)		ref = stringfromlist(i,wvlist)		startCol = str2num(stringfromlist(i,inputWvStartColList))		if (appendWvNameToColLbls > 0)			appendStr = stringfromlist(i,appendStrList)			if (!strlen(appendStr))				appendStr = ref			endif			if (appendWvNameToColLbls == 1)		//append wave names before column labels				colAppendLbl = appendStr + "_"				appendBeforeNotAfter = 1			elseif (appendWvNameToColLbls == 2)	//append wave names after column labels				colAppendLbl = "_" 	+ appendStr							appendBeforeNotAfter = 0			endif		endif		dl_lblsToLbls(ref,1,0,nan,outRef,1,startCol,colAppendLbl,appendBeforeNotAfter)	endfor		//check for duplicates	String duplicateColLbls = dl_getDupLbls(wv,1)	Variable numDups = itemsinlisT(duplicateColLbls)	if (numDups > 0)		print "dl_combine2DByRowLbls() warning! some column labels were duplicates:",duplicateColLbls	endif		//finally, transfer over the values from the source waves to the output	String wvsWithThisLbl	String posOfLblInTheseWvs	for (i=0;i<numUniqueLbls;i+=1)		lbl = stringfromlist(i,lblsList)		wvsWithThisLbl = wvsWithLbl[i][0]		posOfLblInTheseWvs = wvsWithLbl[i][1]		SetDimLabel 0,i,$lbl,out		numWvsWithLbl = ItemsInList(wvsWithThisLbl)		for (j=0;j<numWvsWithLbl;j+=1)			ref = stringfromlist(j,wvsWithThisLbl)			WAVE inWv = $ref			inWvRow = str2num(stringfromlist(j,posOfLblInTheseWvs))			posInWvList = whichlistitem(ref,wvList)			startCol = str2num(stringfromlist(posInWvList,inputWvStartColList))			endCol = startCol + dimsize(inWv,1) - 1			out[i][startCol,endCol] = inWv[inWvRow][q-startCol]		endfor			endfor		endfunction/s dl_getDupLbls(wv,dim)	WAVE wv; Variable dim		String allLbls = dl_getLblsAsList(nameofwave(wv),dim,0,inf)	return text_removeStringListDuplicates(allLbls, ";", returnDupsInstead=1)end//use when one wave contains all the rows of interest and another has all that and morefunction dl_merge2Dinto2D_allPresent(fullWv,overfullWv,outref)	WAVE fullWv		//these rows labels are used as basis, concatenates the matching row in overfullWv; rows in overfullWv without a matching label in fullWv are ignored	WAVE overfullWv; string outRef		variable fullWvCols = dimsize(fullWv,1),overfullWvCols=dimsize(overfullWv,1),overfullWvRows=dimsize(overfullWv,0)	String unusedRowsFromOverfull = ""		//make a list with a number for each row in the overfullWv.. will track which rows don't get used just to be helpful	Variable i	for (i=0;i<overfullWvRows;i+=1)		unusedRowsFromOverfull += num2str(i) + ";"	endfor	duplicate/o fullWv, $outref/wave=out	redimension/n=(-1,fullWvCols+overfullWvCols) out	out[][fullWvCols,] = nan		//default to nan for unfilled	//copy column labels from overfull to full	dl_lblsToLbls(nameofwave(overfullWv),1,0,overfullWvCols,outRef,1,fullWvCols,"",0)	variable rows=dimsize(fullWv,0),overfullRow	string lbl,missingRows=""	for (i=0;i<rows;i+=1)		lbl=GetDimLabel(out, 0, i )		overfullRow=FindDimLabel(overfullWv, 0, lbl )		if (overfullRow < 0)			missingRows += num2stR(i)+":" + lbl + ";"		else			out[i][fullWvCols,] = overfullWv[overfullRow][q-fullWvCols]		endif				unusedRowsFromOverfull = removefromlist(num2str(overfullRow),unusedRowsFromOverfull)	endfor	print "dl_merge2Dinto2D() complete. #missingRows",itemsinlist(missingRows),"missed rows from fullWv:",missingRows,"unusedRowsFromOverfull",unusedRowsFromOverfull			end//use for two waves with nonperfectly overlapping subsets//specifically for one when one wave, greaterRowWv, has all the row labels and some number of columns//and the other wave, lesserRowWv, has a subset of the row labelsfunction dl_merge2Dinto2D(greaterRowWv,lesserRowWv,outref)	WAVE greaterRowWv,lesserRowWv	string outref		variable greaterNumCols = dimsize(greaterRowWv,1),lesserNumCols=dimsize(lesserRowWv,1)	duplicate/o greaterrowWv, $outref/wave=out	redimension/n=(-1,greaterNumCols+lesserNumCols) out	out[][greaterNumCols,] = nan		//default to nan for unfilled	//copy column labels from lesser to new columns in greater	dl_lblsToLbls(nameofwave(lesserRowWv),1,0,lesserNumCols,outref,1,greaterNumCols,"",0)	variable i,rows=dimsize(lesserRowWv,0),outRow	string lbl,missingRows=""	for (i=0;i<rows;i+=1)		lbl=GetDimLabel(lesserRowWv, 0, i )		outRow=FindDimLabel(out, 0, lbl )		if (outRow < 0)			missingRows += num2stR(i)+":" + lbl + ";"		else			out[outRow][greaterNumCols,] = lesserRowWv[i][q-greaterNumCols]		endif	endfor	print "dl_merge2Dinto2D() complete. #missingRows",itemsinlist(missingRows),"missingRows list:",missingRowsend//merge the rows from two waves based on their column labels, which can be in any orderfunction dl_merge2DColsWithRepition(greaterColWv,lesserColWv,outref,fromLesserRowLblAppendStr,appendBeforeNotAfter)	WAVE greaterColWv,lesserColWv; string outref,fromLesserRowLblAppendStr	variable appendBeforeNotAfter		string lbl	variable i,numCols=dimsize(greaterColWv,1),lesserCol	variable greaterColWaveLen = dimsize(greaterColWv,0)	variable lesserColWaveLen = dimsize(lesserColWv,0)	variable outNumRows = greaterColWaveLen+lesserColWaveLen	duplicate/o greaterColWv,$outref/wave=out	redimension/n=(outNumRows,-1) out	dl_lblsToLbls(nameofwave(lesserColWv),0,0,nan,outref,0,greaterColWaveLen,fromLesserRowLblAppendStr,appendBeforeNotAfter)	for (i=0;i<numCols;i+=1)		lbl=getdimlabel(greaterColWv,1,i)		lesserCol=FindDimLabel(lesserColWv, 1, lbl )		print "lbl",lbl,"lesserCol",lesserCol		if (lesserCol < 0)			Print "dl_merge2DColsWithRepition() Failed to find lbl",lbl,"colNum",i,"in lesser wave",lesserColWv			continue		endif		out[greaterColWaveLen,][i] = lesserColWv[p-greaterColWaveLen][lesserCol]	endforend//takes data where cols are replicates of some type of data (where params are the same across rows)//makes a new 2D wave where each column is now each of the original 2D waves, which only take up a single row//columns from the original 2D are differentiated by the dimension label append string list//note: original number of input rows is assumed to be equal and there's no error handling//note: dl_combine2DByRowLbls can be helpful for forcing equal # rows (e.g., in the case of missing parameters)function data_linearize2DWvs(wvList,maxNumCols,dlAppendStrs,appendBeforeNotAfter,outColLblList,outRef,[truncColLbls])	String wvList		//list of 2D waves to make 1D and combine	Variable maxNumCols		//pass -1 to handle automatically. max num cols in the input 2D waves to transfer over (can be beyond even what is passed.. or less than it, in which case some columns will be skipped)							//note that for automatic handling there's a risk that some rows will not get unique labels, if numCols ends up > itemsinlist(dlAppendStrs)	String dlAppendStrs	//append string for each column, final row dim labels are the original ones + this	Variable appendBeforeNotAfter		//whether to append dim labels before or after originals	String outColLblList		//optionally pass to lbl for each output column (one for each input wave), or pass "" to have wave names used	String outRef		//save ref	Variable truncColLbls		//optionally pass a positive value to which the column labels should be truncated to. Useful for just getting cell names not wave names									//output column labels will go from original label[0,truncColLbls-1]										Variable i,j,inCols,usedCols,num=itemsinlist(wvList)	String ref = stringfromlist(0,wvList)		//grab an example ref	Variable text = wavetype($ref,1) == 2	Variable rowsIn = dimsize($ref,0)	//pre-calculate max num cols that will be encountered	if (maxNumCols < 0)		for (i=0;i<num;i+=1)			ref = stringfromlist(i,wvList)				inCols = min(dimsize($ref,1),1)		//force one column bc 0 screws up math			maxNumCols = max(maxNumCols,inCols)					endfor	endif	Variable colLblEnd = (!ParamIsDefault(truncColLbls) && (truncColLbls > 0)) ? (truncColLbls-1) : inf	String rowLbls = dl_getLblsAsList(ref,0,0,inf)	if (strlen(outColLblList) < 1)		outColLblList = wvList		//use wave names as col labels if not passed	endif	Variable rowsOut = rowsIn*maxNumCols	if (text)		duplicate/o/t $ref,$outref/wave=out_t		redimension/N=(rowsOut,num) out_t		out_t = ""	else		duplicate/o $ref,$outref/wave=out		redimension/N=(rowsOut,num) out		out = nan	endif	Variable maxColsSoFar = -1,outRowStart	String outColLbl,to_appendLabel	String outRowLbls	for (i=0;i<num;i+=1)		ref = stringfromlist(i,wvList)			if (text)			WAVE/T wv_t = $ref		else			WAVE wv = $ref		endif		inCols = dimsize($ref,1)		usedCols = min(inCols,maxNumCols)	//unnecessary check if maxNumCols was passed -1		if (usedCols < 1)			usedCols = 1		endif		outColLbl = stringfromlist(i,outColLblLisT)[0,colLblEnd]				setdimlabel 1,i,$outColLbl,$outRef				//transfer each column of data and, if needed, row labels		outRowStart = 0		for (j=0;j<usedCols;j+=1)			if (text)				out_t[outRowStart,outRowStart+rowsIn-1][i]=wv_t[p-outRowStart][j]				else				out[outRowStart,outRowStart+rowsIn-1][i]=wv[p-outRowStart][j]				endif			if (j > maxColsSoFar)				maxColsSoFar = j				to_appendLabel=stringfromlist(j,dlAppendStrs)				outRowLbls = text_appendToStrsInList(rowLbls,to_appendLabel,appendBeforeNotAFter,";")				dl_assignLblsFromList($outRef,0,outRowStart,outRowLbls,"",0)				//print "rowLbls",rowLbls,"to_appendLabel",to_appendLabel,"outRowStart",outRowStart,"outRowLbls"			endif			outRowStart+=rowsIn			endfor	endforendfunction/S disp_plotRep_2Ds(wv,catRef,xDataCol,yDataCol,newWinOrAppendToTop,usePreExistingHorizontalAxis,noBinPlot,noCorrCalcs,forceNewCorrelationMat[win,tn,x_ref,forceCatRef])	WAVE/D wv	Variable xDataCol,yDataCol	Variable newWinOrAppendToTop	String catRef		//as many rows as wv, defines each cell in a category either 0 or 1	Variable usePreExistingHorizontalAxis	Variable noBinPlot	String win,tn	Variable noCorrCalcs	String x_ref	//optionally pass a different wave to plot xDataCol from. useful when plotting a difference wave and e.g. a param like frequency is 0 across the board in the difference wave but in the originals	Variable forceNewCorrelationMat	//optionally pass as true to overwrite pre-existing correlation matrix	String forceCatRef		//optionally pass to force catagories for statistics from disp_plotRep_appendPearson. Should be ref to wave ssame size as # rows, with a category designation in each row for each row		Variable meansOnMainAx = 0	Variable simpleAxNames = 1		if (strlen(x_ref))		WAVE/D x_wv = $x_ref	else		WAVE/D x_wv = wv	endif			if (xDataCol < 0)		Print "disp_plotRep_2Ds(): xDataCol < 0, equal to",xDataCol,". aborting display"	endif	if (yDataCol < 0)		Print "disp_plotRep_2Ds(): yDataCol < 0, equal to",yDataCol,". aborting display"	endif		Variable fsize = 8.5			Variable dataDim =	1	// rowsNotCols ? 0 : 1		String winN	if (newWinOrAppendToTop)		if (!paramIsDefault(win) && strlen(win))			winN = win		else			winN = winname(0,1)		endif				if (Wintype(winN) != 1)		//not a graph or no graphs exist			Display/K=1			winN = S_name		endif	else		if (!paramIsDefault(win) && strlen(win))			Display/K=1/N=$win		else			winN = text_makeStrPresentable(NAmeOfwave(wv) + "_" + GetDimLabel(wv,dataDim, yDataCol ) + "_" + GetDimLabel(x_wv,dataDim, xDataCol ))			Display/K=1/N=$winN//attempts to come up with window name as sensible combination of input wave name and yData col label		endif		winN = S_name	endif		Variable useCatRef = strlen(catRef) > 0					//pretty much all related to plot sizing		Variable propOfColForMainPlot = noBinPlot ? 1 : 0.7 	Variable propOfColForBinPlot = 0.15			Variable j,col_graphsize = 1 	Variable currRowStart=0,currRowEnd=1, currColStart = 0, currColEnd = 1	Variable currColEnd_main = currColStart + ((currColEnd-currColStart) * propOfColForMainPlot)	Variable currColStart_bin = currColEnd - ((currColEnd-currColStart) * propOfColForBinPlot)	String xDL = getdimlabel(x_wv,dataDim,xDataCol)	String xBinLabel = text_makeStrPresentable(xDL + "_b")	String xLabel = xDL		String yAx,xAx = "bottom"	String xAx_bin = "bottom_b"		String yDL = getDimlabel(wv,dataDim,yDataCol)	String yLabel = yDL		if (simpleAxNames)		yAx = "left"	else		if (usePreExistingHorizontalAxis)			yAx = stringfromlist(0,ListMatch(AxisList(winN), "L*"))		else			yAx = text_makeStrPresentable("L_"+yLabel)		endif	endif		string main_tn	if (!ParamIsDefault(tn))		main_tn = tn	else		main_tn = yLabel	endif		string bin_tn = text_makeStrPresentable(main_tn+"_b")		appendtograph/W=$winN/B=$xAx/L=$yAx wv[][yDataCol]/TN=$main_tn vs x_wv[][xdataCol]	modifygraph/W=$winN axisEnab($xAx) = {currColStart,currColEnd_main} , axisEnab($yAx) = {currRowStart,currRowEnd} 		if (useCatRef)		WAVE catWv = $catRef	endif		if (useCatRef && !noBinPlot)		appendtograph/W=$winN/B=$xAx_bin/L=$yAx wv[][yDataCol]/TN=$bin_tn vs catWv		modifygraph/W=$winN axisEnab($xAx_bin) = {currColStart_bin,currColEnd} , axisEnab($yAx) = {currRowStart,currRowEnd}	endif 			if (!usePreExistingHorizontalAxis)		modifygraph/W=$winN freepos($yAx)=0,lblpos($yAx)=110		//gives more room		Label $yAx, yLabel + " \\U"	endif			Label $xAx, xLabel+" \\U"	modifygraph/W=$winN freepos($xAx)=0,lblpos($xAx)=40		if (!noBinPlot)		modifygraph/W=$winN freepos($xAx_bin)=0,lblpos($xAx_bin)=40		setaxis/W=$winN/A/N=2 $xAx_bin		ModifyGraph tick(bottom_b)=3,noLabel(bottom_b)=2,axRGB(bottom_b)=(65535,65535,65535)	//hide axis for bins	endif		modifygraph/W=$winN fsize=10,mode=3,marker=8,msize=2, btLen=2,stLen=2,fsize=fsize,rgb=(65535,0,0,52428)	if (useCatRef)		modifygraph/W=$winN zColor($main_tn) = {catWv,0,2.8,Green,0}		//0 to 2.8 range with 0,1 catagory data gives black and ~green		modifygraph/W=$winN zColorMin($main_tn) = NaN		//make points below min val transparent -- easy way to exclude points temporarily		modifygraph/W=$winN zColor($bin_tn) = {catWv,0,2.8,green,0}		//0 to 2.8 range with 0,1 catagory data gives black and ~green		modifygraph/W=$winN zColorMin($bin_tn) = NaN		//make points below min val transparent -- easy way to exclude points temporarily	endif		setwindow $winN, hook(disp_cursorClickHook)=disp_cursorClickHook		SetAxis/A/N=2/w=$winN		//calculate correlation statistics	if (noCorrCalcs)		//al done here		return main_tn	endif		//determine correlation coeffs	String corrMatAppendStr = "_corr"	String corrMatrixRef=nameofwave(wv)+corrMatAppendStr	String catAvgRef = disp_plotRep_appendPearson(winN,nameofwave(wv),xDl,yDL,xLabel,yLabel,0,forceNewCorrelationMat,catRef)		//"" for no catagorization wave			String catAvgWvRef = stringfromlist(0,catAvgRef)	WAVE catAvgWv = $catAvgWvRef	String catAvgCatWvRef = stringfromlist(1,catAvgRef)	WAVE catAvgCatWv = $catAvgCatWvRef	string avgBin_tn = main_tn+"_bina"	if (meansOnMainAx)				//plot y mean against x mean		appendtograph/W=$winN/L=$yAx/B=$xAx catAvgWv[][1]/TN=$avgBin_tn vs catAvgWv[][0]	else		//plot y mean against its category, on the bin plot, or dont plot if no bin plot		if (!noBinPlot)			appendtograph/W=$winN/L=$yAx/B=$xAx_bin catAvgWv[][1]/TN=$avgBin_tn vs catAvgCatWv		endif	endif		modifygraph/W=$winN zColor($avgBin_tn) = {catAvgCatWv,0,2.8,green,0}		//0 to 2.8 range with 0,1 catagory data gives black and ~green	modifygraph/W=$winN zColorMin($avgBin_tn) = NaN		//make points below min val transparent -- easy way to exclude points temporarily	ModifyGraph/W=$winN mode($avgBin_tn)=3,marker($avgBin_tn)=9,msize($avgBin_tn)=6,lsize($avgBin_tn)=2,mrkThick($avgBin_tn)=2			ModifyGraph msize($avgBin_tn)=6,mrkThick($avgBin_tn)=2		return main_tn	end//disp_plotRep_2Ds()//based on disp_plotRep_2Ds but uses symbols passed in catSymRef (instead of colors set by catRef) and puts average in its own columnfunction/S disp_plotRep_2Dsym(wv,catRef,catSymRef,xLbl,yLbl,newWinOrAppendToTop,usePreExistingHorizontalAxis,noBinPlot,forceNewCorrelationMat,outliersRef,doLoess[win,tn,x_ref,forceCatRef,transforms,forceNewGraph,xValBinTol,noFrmt])	WAVE/D wv	String xLbl,yLbl	Variable newWinOrAppendToTop	String catRef		//as many rows as wv, defines each cell in a category either 0 or 1	String catSymRef //as many rows as wv, defines a symbol for each cell; usually but not necessarily aligned to the cells categry	Variable usePreExistingHorizontalAxis	Variable noBinPlot	String win,tn	String x_ref	//optionally pass a different wave to plot xDataCol from. useful when plotting a difference wave and e.g. a param like frequency is 0 across the board in the difference wave but in the originals	Variable forceNewCorrelationMat	//optionally pass as true to overwrite pre-existing correlation matrix	String forceCatRef		//optionally pass to force catagories for statistics from disp_plotRep_appendPearson. Should be ref to wave ssame size as # rows, with a category designation in each row for each row	String outliersRef		//see outlierRulesWv optional parameter in wave_2D_getPearsonPValDist and pass "" to ignore	Variable doLoess		//pass true to run and append loess fit (defaults to 95% confidence intervals	String transforms //pass transform to try in stats_ksNormalityTest..wv0 transform goes in 0th element of string list, wv1 transform goes in 1st element of string list	Variable forceNewGraph	//optionally pass to avoid clearing a pre-existing graph of the name that will be used for this plot	Variable xValBinTol		//unrelated to catRef, pass a tolerance value and then will get statistical plots from wave_intoManyYBy1X	Variable noFrmt			//try to preserve previous window/graph format if window already exists		Variable meansOnMainAx = 0	Variable simpleAxNames = 1	Variable fsize = 16	Variable dataDim =	1// rowsNotCols ? 0 : 1		Redimension/I $catRef	WAVE/I catSymWv = $catSymRef	String catRGBRef = disp_fovPer_catToRGB($catRef,nan)	WAVE/I/U catRGBWv = $catRGBRef	dl_lblsToLbls(catSymRef,0,0,inf,catRGBRef,0,0,"",0)		if (!ParamIsDefault(x_ref) && (strlen(x_ref) > 0) )		WAVE/D x_wv = $x_ref	else		WAVE/D x_wv = wv	endif			Variable xDataCol=finddimlabel(wv,1,xLbl)	Variable yDataCol=finddimlabel(wv,1,yLbl)	if (xDataCol < 0)		Print "disp_plotRep_2Dsym(): xDataCol < 0, equal to",xDataCol,"xLbl",xLbl,". aborting display"	endif	if (yDataCol < 0)		Print "disp_plotRep_2Dsym(): yDataCol < 0, equal to",yDataCol,"yLbl",yLbl,". aborting display"	endif		//get the window	String winN 	if (newWinOrAppendToTop)		if (!paramIsDefault(win) && strlen(win))			winN = win		else			winN = winname(0,1)		endif				if (Wintype(winN) != 1)		//not a graph or no graphs exist			Display/K=1			winN = S_name		endif	else		if (!paramIsDefault(win) && strlen(win))			winN = win		else			winN = text_makeStrPresentable(NAmeOfwave(wv) + "_" + yLbl + "_" + xLbl +"_" + outliersRef)	//attempts to come up with window name as sensible combination of input wave name and yData col label		endif		if ((wintype(winN) == 1) && (ParamIsDefault(forceNewGraph) || !forceNewGraph) )//already a graph, clear it			vis_cleargraph(winN)			dowindow/f $winN		else			Display/K=1/N=$winN			winN = S_name		endif	endif				//determine correlation coeffs			Variable j,col_graphsize = 1 	Variable currRowStart=0,currRowEnd=1, currColStart = 0, currColEnd = 1	String xBinLabel = text_makeStrPresentable(xLbL + "_b")	String xLabel = xLbl	String yAx,xAx = "bottom"	String xAx_bin = "bottom_b"		String yLabel = yLbl	if (simpleAxNames)		yAx = "left"	else		if (usePreExistingHorizontalAxis)			yAx = stringfromlist(0,ListMatch(AxisList(winN), "L*"))		else			yAx = text_makeStrPresentable("L_"+yLabel)		endif	endif	string main_tn	if (!ParamIsDefault(tn) && (strlen(tn) > 0) )		main_tn = tn	else		main_tn = yLabel	endif		String passedTransformsStr=selectstring(PAramIsDefault(transforms),transforms,"")	String info = disp_plotRep_appendPearson_sym(winN,nameofwave(wv),xLbL,yLbl,xLAbel,yLabel,0,forceNewCorrelationMat,catRef,catSymRef,outliersRef,passedTransformsStr)		//"" for no catagorization wave	String corrMatAppendStr = "_corr"	String corrMatrixRef=nameofwave(wv)+corrMatAppendStr	String catAvgRef = stringbykey("catAvgRef",info)	String corrRawDataRef=stringbykey("corrRawDataRef",info)	WAVE corrRawDataWv=$corrRawDataRef		WAVE catAvgWv = $catAvgRef	String catAvgCatWvRef = stringbykey("catAvgCatLbls",info) 	String catAvgRGBWvRef = stringbykey("catRGBRef",info)	WAVE catAvgCatWv = $catAvgCatWvRef	WAVE catAvgRGBWv = $catAvgRGBWvRef	string avgBin_tn = main_tn[0,25]+"_bin"		//append main waves	appendtograph/W=$winN/B=$xAx/L=$yAx corrRawDataWv[][%$yLbl]/TN=$main_tn vs corrRawDataWv[][%$xLbl]	if (ParamIsDefault(noFrmt) || !noFrmt)		modifygraph/W=$winN mode=3,zmrkNum($main_tn) = {catSymWv}		if (!usePreExistingHorizontalAxis)			modifygraph/W=$winN freepos($yAx)=0,lblpos($yAx)=110		//gives more room			Label $yAx, yLabel + " \\U"		endif			Label $xAx, xLabel+" \\U"		modifygraph/W=$winN freepos($xAx)=0,lblpos($xAx)=40,fsize=fsize		modifygraph/W=$winN msize=3,zColor($main_tn)={catRGBWv,*,*,directRGB,0}		setwindow $winN, hook(disp_cursorClickHook)=disp_cursorClickHook		SetAxis/A/N=2/w=$winN	endif		if (noBinPlot)		return ""	endif		string bin_tn = text_makeStrPresentable(main_tn+"_b")	//overlay traces twice --one for line, once for symbol and plot against a single x value	appendtograph/W=$winN/L=$yAx/B=$xAx_bin catAvgWv[][1]/TN=$avgBin_tn vs catAvgWv[][3]		//use  vs catAvgWv[][2] to put avgs over same x value			if (ParamIsDefault(noFrmt) || !noFrmt)		setaxis $xAx_bin -1e6,1e6		//large range causes bins to be overlaid				//b is on top, so make it the symbol		modifygraph/W=$winN mode($avgBin_tn)=3,msize($avgBin_tn)=3,zmrkNum($avgBin_tn) = {catAvgWv[*][4]}, zColor($avgBin_tn)={catAvgRGBWv,*,*,directRGB,0}, opaque($avgBin_tn) = 1		modifygraph/W=$winN tick($xAx_bin)=3,noLabel($xAx_bin)=2,axRGB($xAx_bin)=(65535,65535,65535,6554)		modifygraph/W=$winN fsize=fsize,height=72*2.25,width=72*2.25*1.1		modifygraph/W=$winN height=0,width=0		//make width height adjustable again		ErrorBars/W=$winN/T=0/L=0.7/RGB=(0,0,0) $avgBin_tn Y,wave=(catAvgWv[*][%c1_sem],catAvgWv[*][%c1_sem])		//Y=[bar len]				//adjust x axis sizes		modifygraph/W=$winN axisEnab($xAx) = {0,.8}		modifygraph/W=$winN axisEnab($xAx_bin)={.85,1}		modifygraph/W=$winN mrkThick = 1.7,fsize=12	endif		print "command:","analysis_loess_2col("+nameofwave(corrRawDataWv)+",\"\",\"\",0.8,0,2,0.95,100,\"\",1,2,1,winN=\""+winN+"\")"	if (doLoess)		analysis_loess_2col(corrRawDataWv,"","",0.8,0,2,0.95,100,"",1,2,1,winN=winN)	endif			if (!ParamIsDefault(xValBinTol) && (numtype(xValBinTol)==0))		String xBinStatsRef = nameofwave(corrRawDataWv)+"_xys"		WAVE xBinStatsWv = wave_intoManyYBy1X(corrRawDataWv,xValBinTol,0,1,1,xBinStatsRef)		appendtograph/W=$winN xBinStatsWv[][%avg] vs xBinStatsWv[][%xVals]		if (ParamIsDefault(noFrmt) || !noFrmt)			modifygraph/W=$winN mode=3,rgb($xBinStatsRef)=(0,0,0),marker=9		endif		ErrorBars/T=0/L=0.7/RGB=(0,0,0) $xBinStatsRef Y,wave=(xBinStatsWv[*][%sem],xBinStatsWv[*][%sem])	endif		if (ParamIsDefault(noFrmt) || !noFrmt)		disp_setwinsize(2,2*0.8,1,winN=winN);doupdate;disp_setwinsize(0,0,1,winN=winN);	endif		return main_tnend //disp_plotRep_2Dsym()//based on disp_plotRep_appendPearsonfunction/S disp_plotRep_appendPearson_sym(winN,dataWvRef,xDL,yDL,xLbl,yLbl,appendToYNotX,forceNewOutputWave,categoryWvRef,catSymRef,outliersRef,transforms)	STring winN		//window to append to	String dataWvRef	String xDL,yDL		//name of dimensions	String xLbl,yLbl		//labels for x and y axes, if any	Variable appendToYNotX	//pass 1 to append to y label, 0 to append to x label	Variable forceNewOutputWave		//pass to foce overwriting of output correlation matrix	String categoryWvRef			//ref to wave with as many points as rows as rows in dataWvRef, 0 or 1 for group 0 or group 	String catSymRef					//add symbols to groups	String outliersRef			//see outlierRulesWv optional parameter in wave_2D_getPearsonPValDist and pass "" to ignore	String transforms			//"" or pass transform to try in stats_ksNormalityTest..wv0 transform goes in 0th element of string list, wv1 transform goes in 1st element of string list	WAVE/D dwv= $dataWvRef	wave cwv = $categoryWvRef; Redimension/I cwv	wave scwv = $catSymRef	Variable yCol = FindDimLabel($dataWvRef,1,yDL)	Variable xCol = FindDimLabel($dataWvRef,1,xDL)		//auto naming -- unique for each ro/col pair	String corrMatAppendStr="_cst_" + num2str(xCol) + "_" + num2str(yCol) +outliersRef		//for correlation stats	String dataMatAppendStr="_rdn_"+ num2str(xCol) + "_" + num2str(yCol)	+outliersRef	//rdn raw data no outliers, for holding raw data	String corrMatrixRef=dataWvRef+corrMatAppendStr	String corrRawDataRef=dataWvRef+dataMatAppendStr	String fitRef = corrMatrixRef + "f"	Variable expectedNumParams_compStats = 8		//this can be incorrect and is checked if a wave has to be created and filled in	Variable finalNumParams_compStats	Variable expctedNumParams_lineFit = 7		//determined below	Variable totalNumParams=expectedNumParams_compStats+expctedNumParams_lineFit		Variable numPermutations = 10^4//100000//100000	Variable numCols=dimsize($dataWvRef,1)		String axisStartStr, axLabel, pearsonStr, pValStr, line_a_str, line_b_str, line_ssRes_str	if (appendToYNotX)		axisStartStr = "L"		axLabel = yLbl	else		axisStartStr = "B"		axLabel = xLbl	endif	Variable corrMatrixJustCreated	if (forceNewOutputWave || !waveexists($corrMatrixRef))		Make/O/D/N=(totalNumParams) $corrMatrixRef/wave=cm		cm = NaN		corrMatrixJustCreated = 1		//will append layer dim labels	else		WAVE/D cm = $corrMatrixRef		corrMatrixJustCreated = 0	endif						if (corrMatrixJustCreated || (FindDimLabel(cm, 0,"numPointsInclNaN" ) < 0) || numtype(cm[%numPointsInclNaN]) ) //if no dim labels or num points is not a real number, analysis needs to be performed		//MAKE NEW MATRIX		if ( (strlen(outliersRef)>0) && waveexists($outliersRef))			wave_2D_getPearsonPValDist($dataWvRef,xCol,yCol,numPermutations,categoryWvRef,"compStats",transforms,out_dataRef=corrRawDataRef,outlierRulesWv=$outliersRef)				else			wave_2D_getPearsonPValDist($dataWvRef,xCol,yCol,numPermutations,categoryWvRef,"compStats",transforms,out_dataRef=corrRawDataRef)		endif					WAVE compStats		//assign dim labels to correlation matrix layers if needed (this cant be done with rows and cols because need to get these by calling the wave_2D_getPearsonPValDist function		if ( corrMatrixJustCreated )			dl_lblsToLbls(nameofwave(compStats),0,0,nan,corrMatrixRef,0,0,"",0)		//assign layer dimension labels		endif				//assign stats to the correlation matrix		finalNumParams_compStats = dimsize(compStats,0)+expctedNumParams_lineFit		Duplicate/O compStats, $corrMatrixRef		//corrMatrixRef is pointed to by wave cm too		Redimension/N=(finalNumParams_compStats,-1) $corrMatrixRef				//add line fit results		if (corrMatrixJustCreated)			Variable r=dimsize(compStats,0)-1			r+=1;SetDimLabel 0,r,line_a,cm			r+=1;SetDimLabel 0,r,line_b,cm			r+=1;SetDimLabel 0,r,ssRes,cm			r+=1;SetDimLabel 0,r,V_FitError,cm			r+=1;SetDimLabel 0,r,V_FitQuitReason,cm			r+=1;SetDimLabel 0,r,V_Pr,cm			r+=1;SetDimLabel 0,r,V_r2,cm		endif				Make/O/D/N=(2)/free W_coef;Double V_FitError,V_Pr,V_r2,V_FitQuitReason		Curvefit/Q/W=2/N=1 line,dwv[*][yCol]/X=dwv[*][xCol]		cm[%line_a][0]=W_coef[0]		cm[%line_b][0]=W_coef[1]		cm[%V_FitError][0]=V_FitError		cm[%V_FitQuitReason][0]=V_FitQuitReason		cm[%V_Pr][0]=V_Pr		cm[%V_r2][0]=V_r2				Make/O/D/N=(dimsize(dwv,0)) $fitRef/wave=fit		Duplicate/O/free fit, fitres_temp		fit = w_coef[0] + W_coef[1]*dwv[p][xCol]		fitres_temp = (dwv[p][yCol] - fit[p])^2		matrixop/O fitres_temp = replaceNaNs(fitres_temp,0)		//NaNs will not contribute to sum, without doing this sum() function returns NaN		cm[%ssRes][0] = sum(fitres_temp)	else		WAVE/D fit = $fitRef			endif		String pVal_Str 	sprintf pVal_Str, "%e",cm[%pVal][0]	ModifyGraph/W=$winN margin(bottom)=80		sprintf pearsonStr, "%1.2f", cm[%pearson][0]	sprintf pValStr, "%0.2e", cm[%pVal][0]	sprintf line_a_str, "%4.3e", cm[%line_a][0]	sprintf line_b_str, "%4.3e", cm[%line_b][0]	sprintf line_ssRes_str, "%4.3e", cm[%ssRes][0]		SetDrawEnv/W=$winN fsize= 10	DrawText/W=$winN 0.302083333333333,0.00649350649350649,"r="+pearsonStr+"\rp="+pValStr	//	String axN = stringfromlist(0,listmatch(AxisList(winN),axisStartStr+"*"))//	//axLabel += " \\U\r[R= \\f01" + pearsonStr +"\\f00; p=\\f01" + pValStr +"\\f00]\r[b= \\f01" + line_a_str +"\\f00; m= \\f01" + line_b_str+"\\f00]" //+"\\f00; ssRes= \\f01" + line_ssRes_str +"\\f00]"//	axLabel = xLbl//	Label/W=$winN $axN, axLabel		//UNCOMMENT TO ADD FIT TO GRAPH	//appendtograph/W=$winN fit vs dwv[*][xCol]	//modifygraph/W=$winN height=2.5*72,width=2.5*72;doupdate;modifygraph/W=$winN height=0,width=0,lstyle($fitRef)=8,rgb($fitRef)=(0,0,0,19661)		//display catagory averages if present	Variable numCalculatedCats =dimsize(cm,1) - 1,i,col;string catLabelStr,outStr = "corrRawDataRef:"+corrRawDataRef+";categoryWvRef:"+categoryWvRef+";"	Variable exampleRow,exampleRowVal	if (numCalculatedCats > 0)		String catAvgRef=corrMatrixRef + "C"		String catAvgCatLbls=corrMatrixRef + "D"		Make/O/D/N=(numCalculatedCats,11) $catAvgRef/WAVE=cmca		//for catagory averages ... 0th column for x vals, 1st column for y vals		Make/O/N=(numCalculatedCats) $catAvgCatLbls/WAVE=cmcac	//for catagory averages cat labels .. matches colors to colors of cats on plots		//Make/O/I/N=(dimsize($dataWvRef,0)) categoriesTemp		outStr += "catAvgRef:"+catAvgRef+";catAvgCatLbls:"+catAvgCatLbls+";"		for (i=0;i<numCalculatedCats;i+=1)			col = i+1			catLabelStr=ReplaceString("cat_",GetDimLabel(cm, 1, col ),"")			cmcac[i] = str2num(catLabelStr)			cmca[i][0] = cm[%c0_avg][col]			cmca[i][1] = cm[%c1_avg][col]			cmca[i][2] = 0			//allows averages to be plotted on same x value			cmca[i][3] = cmcac[i]	//category might be useful here too			exampleRowVal = cmcac[i]			FindValue/I=(exampleRowVal) cwv		//find the first instance of the category in the cat wave			exampleRow = V_Value			cmca[i][4] = scwv[exampleRow]		//store that in the main average output wave so that it can be plotted for the average points			cmca[i][5] = cm[%c0_sdev][col]			cmca[i][6] = cm[%c1_sdev][col]			cmca[i][7] = cm[%c0_sem][col]			cmca[i][8] = cm[%c1_sem][col]					cmca[i][9] = cm[%c0_numPoints][col]				cmca[i][10] = cm[%c1_numPoints][col]		endfor						setdimlabel 1,0,c0_avg,cmca		setdimlabel 1,1,c1_avg,cmca		setdimlabel 1,2,zeroval,cmca		setdimlabel 1,3,category,cmca		setdimlabel 1,4,zmrkNum,cmca		setdimlabel 1,5,c0_sdev,cmca		setdimlabel 1,6,c1_sdev,cmca		setdimlabel 1,7,c0_sem,cmca		setdimlabel 1,8,c1_sem,cmca		setdimlabel 1,9,c0_numPoints,cmca		setdimlabel 1,10,c1_numPoints,cmca	endif		String catRGBRef = disp_fovPer_catToRGB(cmca,3)	outstr += "catRGBRef:"+catRGBRef + ";"  		Print/D "disp_plotRep_appendPearson(): corrRawDataRef",corrRawDataRef,"pearsonRef", corrMatrixRef,"pearson",cm[%pearson][0],"pVal",cm[%pVal][0],pVal_Str,"nUsed",cm[%pVal][0],"yCol",yCol,"xCol",xCol,"corrMatrixRef",corrMatrixRef///	Print/D "disp_plotRep_appendPearson(): line_a",cm[%line_a][0],"line_b",cm[%line_b][0],"ssRes",cm[%ssRes][0],"c0_avg",cm[%c0_avg],"c1_avg",cm[%c1_avg]			return outStr	end //disp_plotRep_appendPearson_sym()function/S disp_fovPer_catToRGB(catWv,col_orNaNForFirst)	WAVE catWv	Variable col_orNaNForFirst		//pass a column where categories are fuond in a 2D wave, if non-real number, 0 is used		Variable catCol = numtype(col_orNaNForFirst) ? 0 : col_orNaNForFirst			String appendStr = "_R"	Variable numRows = dimsize(catWv,0)	Variable maxVal_rgb = 256	Variable bit8To16 = 256 - 1/256		//max one point below 2^16  		//based on color chart at http://www.somersault1824.com/tips-for-designing-scientific-figures-for-color-blind-readers/	Make/O/U/I/N=(4) soma_trace_rgb,ped_trace_rgb,fov_pop_rgb,per_pop_rgb	soma_trace_rgb={0,0,0,maxVal_rgb}		//BLACK	ped_trace_rgb={146,0,0,maxVal_rgb}		//RED	fov_pop_rgb={0,109,219,maxVal_rgb}		//BLUE	per_pop_rgb={146,73,0,maxVal_rgb}		//YELLOW BROWN		//convert to 16 bit value from 8 bit	soma_trace_rgb*=bit8To16;ped_trace_rgb*=bit8To16;fov_pop_rgb*=bit8To16;per_pop_rgb*=bit8To16		String outRef = nameofwave(catWv) + appendStr	Make/O/U/I/N=(numRows,4) $outRef/wave=out	out = mod(catWv[p][catCol],2) ? fov_pop_rgb[q] : per_pop_rgb[q]		Print "RGBA color wave ref",outRef			return outRefend//FOR WORKING WITH NEURON DATAfunction/S nrn_parse(changePath,outRef,deltaFromNrn_ms,[altBaseName])	Variable changePath		//pass to change path to data folder	String outRef	Variable deltaFromNrn_ms		//pass to apply a delta so starts at step start (equal to source f(t) dur0) e.g. 1.0125	String altBaseName			//force an alternative base name for the saved file (basename.bin, basebame.txt, if other than the current automatic from neuron, which is out		Variable outOutRef=!strlen(outRef)	if (outOutRef)		outRef = "out"	endif		String baseName = selectstring(ParamIsDefault(altBaseName),altBaseName, "out")			//use "out" as basename unless altBaseName is passed	string textFileName = baseName + ".txt"	String binaryFileName = baseName + ".bin"		if (changePath)		NewPath/O nrnPath	else		//have user select folder with 		PathInfo nrnPath		if (!V_flag)			NewPath/O nrnPath		endif		endif	//check that path is good	PathInfo nrnPath	if (!V_flag)		Print "nrn_parse() failed to set path to data folder. Aborting"		return ""	endif			Variable txtRefNum,binRefNum	Open/R/P=nrnPath txtRefNum as textFileName	String txtFileFullPath = S_fileName	Open/R/P=nrnPath binRefNum as binaryFileName	String binFileFullPath = S_fileName			String header	FReadLine txtRefNum, header;	Print "header",header 		close txtRefNum	close binRefNum		Double dt_msec = NumberByKey("dt", header)	Double tstop = NumberByKey("tstop",header)	String sites_info = stringbykey("SITES_INFO",header)		variable i,numSites = itemsinlist(sites_info,"|")		//import: B=1 specifies low-byte-first (little endian), this is used for my Ubuntu	//should also work for windows	//on Ubuntu, this can be explicitly checked by typing into the command line:	//lscpu | grep "Byte Order" (on Ubuntu, fwiw)	GBLoadWave/O/B=1/T={4,4}/W=(numSites) binFileFullPath	Variable numWvsLoaded = itemsinlist(S_waveNames)	Variable outcols = min(numSites,numWvsLoaded),hasDups	make/o/u/n=(outcols) rowsWv	rowsWv = dimsize($stringfromlist(p,S_waveNames),0)	if (outCols > 1)		findduplicates/free/dn=dups rowsWv		hasDups = dimsize(dups,0) != outCols-1		//all numRows except the first should be duplicates for equal	else		hasDups = 0	endif		Print "numSites",numSites,"numWvsLoaded",numWvsLoaded,"outcols",outcols,"hasDups",hasDups //these should be equal		Double delta = numtype(deltaFromNrn_ms) ? dt_msec : deltaFromNrn_ms		String name,outRefs="",ref	if (!hasDups)		Concatenate/O/D/KILL/NP=1 S_wavenames, $outRef		WAVE/D out = $outRef		String info		for (i=0;i<outcols;i+=1)			info = stringfromlist(i,SITES_INFO,"|")			name = stringfromlist(0,info,",")			SetDimLabel 1,i,$name,out		endfor		SetScale/P x, 0, delta/1000,"s", out				return outref	else		if (outOutRef)			outRef+="_"		endif		for (i=0;i<numSites;i+=1) 			info = stringfromlist(i,SITES_INFO,"|")			name = stringfromlist(0,info,",")			ref=outRef+name			duplicate/o $stringfromlist(i,s_wavenames),$ref			outRefs+=ref+";"		endfor				SetScale/P x, 0, delta/1000,"s", out				return outRefs	endifendfunction nrn_parse_noTxt(changePath,baseName,outRef,dt_msec)	Variable changePath		//pass to change path to data folder	String baseName			//base name of binary file. full file name should be [baseName].bin	String outRef	Variable dt_msec		//would normally come from text header file, but user can pass to here instead		if (!strlen(outRef))		outRef = baseName	endif		String binaryFileName = baseName + ".bin"		if (changePath)		NewPath/O nrnPath	else		//have user select folder with 		PathInfo nrnPath		if (!V_flag)			NewPath/O nrnPath		endif		endif	//check that path is good	PathInfo nrnPath	if (!V_flag)		Print "nrn_parse() failed to set path to data folder. Aborting"		return 0	endif		Variable binRefNum	Open/R/P=nrnPath binRefNum as binaryFileName	String binFileFullPath = S_fileName		variable i,numSites = 1		//import: B=1 specifies low-byte-first (little endian), this is used for my Ubuntu	//on Ubuntu, this can be explicitly checked by typing into the command line:	//lscpu | grep "Byte Order"	GBLoadWave/O/B=1/T={4,4}/W=(numSites) binFileFullPath	Variable numWvsLoaded = itemsinlist(S_waveNames)	Print "numSites",numSites,"numWvsLoaded",numWvsLoaded //these should be equal		Variable outRows = dimsize($stringfromlist(0,S_waveNames),0)	Duplicate/O $Stringfromlist(0,S_wavenames), $outRef/wave=out	SetScale/P x, 0, dt_msec/1000,"s", out		close binRefNumend//saves to neuron for playing the vector e.g. as a command there//does not include timing, that would be saved with a separate call to this function and then loaded on its own//the vector class can auto-generate timing as index*[timeStep] or take a second vector as timingfunction nrn_saveForNrn(saveWvRef,changePath,outputfileBaseName,scaleFactor,saveTiming,startX,endX,col)	String saveWvRef		//wave to save	Variable changePath		//pass to change path to data folder	String outputfileBaseName		//file will be saved in path chosen in response to user prompt under outputfileBaseName with .bin extension	Variable scaleFactor		//neuron expects specific units, so pass a scale factor if needed. e.g., for mV from V, pass 1000. wv will be wv *= scaleFactor									//my voltage commands are normalized for 0V o 1V, so I am actually passing 0.001 to give commands of 0 to 1 mV									//scaleFactor is ignored if it is not a real number (numtype != 0) or if it a real number equal to 1	Variable saveTiming			//pass to save timing too, file name base is set to "[outputfileBaseName]_t.bin"	Variable startX,endX		//start time and end time 	Variable col			if (numtype(col))		col =0	endif		if (strlen(outputfileBaseName)<1)		outputfileBaseName=savewvref	endif		//code is as for nrn_parse	String fname = outputfileBaseName + ".bin"		if (changePath)		NewPath/O nrnPath	else		//have user select folder with 		PathInfo nrnPath		if (!V_flag)			NewPath/O nrnPath		endif		endif	//check that path is good	PathInfo nrnPath	if (!V_flag)		Print "nrn_parse() failed to set path to data folder. Aborting"		return 0	endif		//end of code same as nrn_parse		if (numtype(startX))		startX = -inf	endif		if (numtype(endX))		endX = inf	endif		//prepare wave for saving	Duplicate/O/R=(startX,endX)[col] $saveWvRef, $"nrn_saveForNrn_temp"/wave=wv	redimension/n=(-1) wv	wv *= scaleFactor		Variable fNum	Open/P=nrnPath fNum as fname	//same explanation of B flag as for GBLoadWave in nrn_parse() function:	//export: B=3 specifies low-byte-first (little endian), this is used for my Ubuntu	//on Ubuntu, this can be explicitly checked by typing into the command line:	//lscpu | grep "Byte Order"		//F=5 is writing 64 bit float point, which matches up with neurons precision parameter = 4, as written out in vector.vwrite() at https://www.neuron.yale.edu/neuron/static/new_doc/programming/math/vector.html?highlight=fread#Vector.fread	FbinWrite/B=3/F=5 fNum, wv	close fNum		Print "nrn_saveForNrn(): #Items saved",dimsize(wv,0),"deltax (s)",dimdelta(wv,0),"deltax (ms)",dimdelta(wv,0)*1000,"sum",sum(wv),"into",fname,"(path: ",S_path,")","saved wave temporarily in nrn_saveForNrn_temp"		if (saveTiming)		Duplicate/O wv, nrn_saveForNrN_timeTemp		Double xdelta = dimdelta(wv,0)		nrn_saveForNrN_timeTemp = xdelta*p*1000				//convert to ms by multipication, ms is used by neuron		nrn_saveForNrn("nrn_saveForNrN_timeTemp",0,outputfileBaseName+"_t",1,0,nan,nan,0)	endifend//not multidimensionally aware -- will string rows togetherfunction bin_saveBin(wv,changePath,saveLbls,outputfileBaseName,bParam,fParam,unsigned)	WAVE wv	Variable changePath	Variable saveLbls		//pass true to save a wave with row labels and (if 2D) column labels	String outputfileBaseName	//see fbinWrite for these:	Variable bParam		//default to b=3 for low-byte-first little endian, intel standard	Variable fParam		//default to f=5 for 64 bit float or whatever is desired	Variable unsigned 	//default to 0 since float is signed		String fname = outputfileBaseName + ".bin"	if (changePath)		NewPath/O binarySavePath	else		//have user select folder with 		PathInfo binarySavePath		if (!V_flag)			NewPath/O binarySavePath		endif		endif	//check that path is good	PathInfo binarySavePath	if (!V_flag)		Print "bin_saveBin() failed to set path to data folder. Aborting"		return 0	endif		//end of code same as nrn_parse		Variable fNum	Open/P=binarySavePath fNum as fname	//same explanation of B flag as for GBLoadWave in nrn_parse() function:	//export: B=3 specifies low-byte-first (little endian), this is used for my Ubuntu	//on Ubuntu, this can be explicitly checked by typing into the command line:	//lscpu | grep "Byte Order"		if (unsigned)		FbinWrite/B=(bParam)/F=(fParam)/U fNum, wv		//write little endian	else		FbinWrite/B=(bParam)/F=(fParam) fNum, wv	endif	close fNum		Variable rows=dimsize(wv,0),cols=dimsize(wv,1)	Print "bin_saveBin(): rows",rows,"cols",cols,"total items",rows*cols	if (saveLbls)		String rowLbls=dl_getLblsAsList(nameofwave(wv),0,0,inf),rowFileName=outputfileBaseName+"_r.txt"		String colLbls=dl_getLblsAsList(nameofwave(wv),1,0,inf),colFileName=outputfileBaseName+"_c.txt"		if (rows>0)			open/p=binarySavePath fnum as rowFileName			fprintf fnum,"%s\r\n",rowLbls			close fnum		endif		if (cols>0)			open/p=binarySavePath fnum as colFileName			fprintf fnum,"%s\r\n",colLbls			close fnum		endif				endifendfunction nrn_an_sites(wv, pulseStartX)		//works with output from nrn_parse()	WAVE/D wv; Double pulseStartX			Variable i,numSites = dimsize(wv,1)	Variable startP = x2pnt(wv,pulseStartX)	Variable lenP = dimsize(wv,0) - startP - 1	Print "startP",startP,"lenP",lenP	if (!mod(lenP,2))		lenP-=1	endif		string namebase = nameofwave(wv)	String fdRef = nameBase + "_FD"		//stores raw frequency domain power spectrum	String fdFCRef = fdRef + "_FC"		//stores fold changes in FDs from 1st site	String paramsRef = nameBase+ "_P"		String suffix,name, firstName,lastName	for (i=0;i<numSites;i+=1)		suffix = GetDimLabel(wv, 1, i)		duplicate/o/r=[startP,startP+lenP][i] wv, tempwv		redimension/N=(-1) tempwv		fft/dest=tempwv_f tempwv		tempwv_f *= conj(tempwv_f)				wavestats/W/Q tempwv		if (i==0)			WAVE M_wavestats			duplicate/O M_wavestats,$paramsRef/wave=params			duplicate/O tempwv_f, $fdRef/wave=fd 			Redimension/N=(-1,1) params, fd			dl_lblsToLbls("M_wavestats",0,0,nan,paramsRef,0,0,"",0)		else			concatenate/NP=1 {M_wavestats}, params			concatenate/NP=1 {tempwv_f}, fd		endif	endfor		dl_lblsToLbls(nameofwave(wv),1,0,nan,paramsRef,1,0,"",0)	dl_lblsToLbls(nameofwave(wv),1,0,nan,fdRef,1,0,"",0)		//calculate fold changes from first site for fd	Redimension/R fd	DUplicate/O fd, $fdFCRef/wave=fd_fc	fd_fc = fd[p][q] / fd[p][0]		Print "paramsRef",paramsref,"fdRef",fdRef,"fdFCRef",fdFCRefendfunction/WAVE imageStats_getWv()		String vars="V_adev;V_avg;V_kurt;V_min;V_minColLoc;V_minRowLoc;V_max;V_maxColLoc;V_maxRowLoc;"	vars+="V_npnts;V_rms;V_sdev;V_skew;"		Variable i,numPossibleVars = itemsinlist(vars),numVarsFound=0	String varStr	Make/O/D/N=(numPossibleVars) imagestatsWv	for (i=0;i<numPossibleVars;i+=1)		varStr = stringfromlist(i,vars)		NVAR/Z var = $varStr		if (NVAR_Exists(var))			imagestatsWv[numVarsFound] = var			SetDimLabel 0,numVarsFound,$varStr,imagestatsWv			numVarsFound+=1		endif		endfor		Redimension/N=(numVarsFound) imagestatsWv	return imagestatsWvend//some notes on wn from analysis scripts.txt file://uncertain excel namesstring possiblyAmbiguousExcelNames = "15091708;15091709;16081110;16081111;"//blocked cellswn_blockAndUnblock="G16091708_0030_1;G16091708_0033_1;G16110208_0020_1;G16110208_0028_1;G16090200_0013_1;G16090200_0021_1;G16060303_0031_1;G16060303_0043_1;"wn_sfs_Bpairs_pars = fio_stream_listByKey("wn_refs_main0","","paramsSaveRef_fMainR",wn_blockAndUnblock,"",0)wn_pfs_Bpairs_pars = fio_stream_listByKey("wn_refs_main0","","paramsSaveRef_fSecR",wn_blockAndUnblock,"",0)wn_fs_Bpairs_dpars = fio_stream_listByKey("wn_refs_main0","","paramsSaveRef_diffR",wn_blockAndUnblock,"",0)wn_fs_Bpairs_fdpars = fio_stream_listByKey("wn_refs_main0","","paramsSaveRef_fdiffR",wn_blockAndUnblock,"",0)calcDiffRefs(1,wn_sfs_Bpairs_pars,wn_pfs_Bpairs_pars)wn_block_refs=text_semiColonsToCommas(wn_sfs_Bpairs_pars)+";"+text_semiColonsToCommas(wn_pfs_Bpairs_pars)+";"wn_block_refs+=text_semiColonsToCommas(wn_fs_Bpairs_dpars)+";"+text_semiColonsToCommas(wn_fs_Bpairs_fdpars)+";"wn_sfs_Bpairs_pars_ind = fio_stream_listByKey("wn_refs_main0","","paramsSaveRef_fMainR",wn_blockAndUnblock,"",0,returnIndicesInstead=1)wn_pfs_Bpairs_pars_ind = fio_stream_listByKey("wn_refs_main0","","paramsSaveRef_fSecR",wn_blockAndUnblock,"",0,returnIndicesInstead=1)wn_fs_Bpairs_dpars_ind = fio_stream_listByKey("wn_refs_main0","","paramsSaveRef_diffR",wn_blockAndUnblock,"",0,returnIndicesInstead=1)wn_fs_Bpairs_fdpars_ind = fio_stream_listByKey("wn_refs_main0","","paramsSaveRef_fdiffR",wn_blockAndUnblock,"",0,returnIndicesInstead=1)wn_block_refs_ind=text_semiColonsToCommas(wn_sfs_Bpairs_pars_ind)+";"+text_semiColonsToCommas(wn_pfs_Bpairs_pars_ind)+";"wn_block_refs_ind+=text_semiColonsToCommas(wn_fs_Bpairs_dpars_ind)+";"+text_semiColonsToCommas(wn_fs_Bpairs_fdpars_ind)+";"wn_blockRefs_dls_all="wnfs_s_;wnfs_p_;wnfs_d_;wnfs_fd_;"wn_blockRefs_sources = "wn_refs_main0;wn_refs_main0;wn_refs_main0;wn_refs_main0;"wn_blockRefs_paramColList = "0;0;0;0;"wn_blockRefs_headerList = wnHeaderRef+";"+wnHeaderRef+";"+wnHeaderRef+";"+wnHeaderRef+";"fio_disp_mParamsVsExcelParams("wn_blockRefs",wn_block_refs,wn_blockRefs_dls_all,"",wn_blockRefs_headerList,wn_blockAndUnblock,excelParamStrList,excelParamBinList,wn_block_refs_ind,wn_blockRefs_sources,paramColList=wn_blockRefs_paramColList)row = FindDimLabel(wn_blockRefs, 1, "wnfs_fd_respPower_Below20HzArea" );disp_plotRep_2D(wn_blockRefs,"wn_blockRefs_Cat",0,0,row,0,0,0);print rowrow = FindDimLabel(wn_blockRefs, 1, "wnfs_fd_respPower_20to40HzArea" );disp_plotRep_2D(wn_blockRefs,"wn_blockRefs_Cat",0,0,row,0,0,0);print rowrow = FindDimLabel(wn_blockRefs, 1, "wnfs_fd_respPower_40to60HzArea" );disp_plotRep_2D(wn_blockRefs,"wn_blockRefs_Cat",0,0,row,0,0,0);print rowrow = FindDimLabel(wn_blockRefs, 1, "wnfs_fd_respPower_60to250HzArea" );disp_plotRep_2D(wn_blockRefs,"wn_blockRefs_Cat",0,0,row,0,0,0);print rowrow = FindDimLabel(wn_blockRefs, 1, "wnfs_fd_respPhase_Below20Hz_pos" );disp_plotRep_2D(wn_blockRefs,"wn_blockRefs_Cat",0,0,row,0,0,0);print rowrow = FindDimLabel(wn_blockRefs, 1, "wnfs_fd_respPhase_Below20Hz_neg" );disp_plotRep_2D(wn_blockRefs,"wn_blockRefs_Cat",0,0,row,0,0,0);print rowrow = FindDimLabel(wn_blockRefs, 1, "wnfs_fd_respPhase_20to40Hz_posA" );disp_plotRep_2D(wn_blockRefs,"wn_blockRefs_Cat",0,0,row,0,0,0);print rowrow = FindDimLabel(wn_blockRefs, 1, "wnfs_fd_respPhase_40to60Hz_posA" );disp_plotRep_2D(wn_blockRefs,"wn_blockRefs_Cat",0,0,row,0,0,0);print rowrow = FindDimLabel(wn_blockRefs, 1, "wnfs_fd_respPhase_60to250Hz_posA" );disp_plotRep_2D(wn_blockRefs,"wn_blockRefs_Cat",0,0,row,0,0,0);print row//display -- again can run with 7 also by substituting		col=FindDimLabel(ic_pars_6,1,"cpp_int_C");disp_plotRep_2D(ic_pars_6,"ic_pars_6_cat",1,0,col,0,0,0,"ic_pars_6_pearson","ic_pars_6_pearson_p");print col//somatic cap from int vs lencol=FindDimLabel(ic_pars_6,1,"cps_int_C");disp_plotRep_2D(ic_pars_6,"ic_pars_6_cat",0,0,col,0,0,0,"ic_pars_6_pearson","ic_pars_6_pearson_p");print col//ped cap from int vs lencol_y=FindDimLabel(ic_pars_6,1,"cpp _int_C");col_x=FindDimLabel(ic_pars_6,1,"cps_int_C");disp_plotRep_2D(ic_pars_6,"ic_pars_6_cat",0,col_x,col_y,0,0,1,"ic_pars_6_pearson","ic_pars_6_pearson_p");print "col_x",col_x,"col_y",col_y	//related to cell params -- no strong correlation between total capacitance and initial pipette capacitance according to that that was compensated while sealedcol_y=FindDimLabel(ic_pars_6,1,"cps_int_C");col_x=FindDimLabel(ic_pars_6,1,"cps_p_cp_fast_amp_pF");disp_plotRep_2D(ic_pars_6,"ic_pars_6_cat",0,col_x,col_y,0,0,1,"ic_pars_6_pearson","ic_pars_6_pearson_p");print "col_x",col_x,"col_y",col_ycol_y=FindDimLabel(ic_pars_6,1,"cpp_int_C");col_x=FindDimLabel(ic_pars_6,1,"cps_s_cp_fast_amp_pF");disp_plotRep_2D(ic_pars_6,"ic_pars_6_cat",0,col_x,col_y,0,0,1,"ic_pars_6_pearson","ic_pars_6_pearson_p");print "col_x",col_x,"col_y",col_y//somatic cap transients -- results are from analysis_expFit_again -- this is just for 60 cmd and soma; can repeat for otherscol=FindDimLabel(ic_pars_6,1,"cps_expFIT_1_C_0_cap_v0_c");disp_plotRep_2D(ic_pars_6,"ic_pars_6_cat",1,0,col,0,0,0,"ic_pars_6_pearson","ic_pars_6_pearson_p");print col		//nice correlation herecol=FindDimLabel(ic_pars_6,1,"cps_expFIT_1_C_1_cap_v0_c");disp_plotRep_2D(ic_pars_6,"ic_pars_6_cat",1,0,col,0,0,0,"ic_pars_6_pearson","ic_pars_6_pearson_p");print col		//generally decent correlation herecol=FindDimLabel(ic_pars_6,1,"cps_expFIT_1_cap_v0_csum");disp_plotRep_2D(ic_pars_6,"ic_pars_6_cat",1,0,col,0,0,0,"ic_pars_6_pearson","ic_pars_6_pearson_p");print col		//nice correlation here --simialr for ped except for one weird outlier, longest cellcol_y=FindDimLabel(ic_pars_6,1,"cps_expFIT_1_cap_v0_csum");col_x=FindDimLabel(ic_pars_6,1,"cps_int_C");disp_plotRep_2D(ic_pars_6,"ic_pars_6_cat",0,col_x,col_y,0,0,1,"ic_pars_6_pearson","ic_pars_6_pearson_p");print "col_x",col_x,"col_y",col_y	//correlation between 2 comp model and total itnegral cap -- remarkably poor??col_y=FindDimLabel(ic_pars_6,1,"cps_expFIT_1_cap_v0_csum");col_x=FindDimLabel(ic_pars_6,1,"cps_accessR_noModel");disp_plotRep_2D(ic_pars_6,"ic_pars_6_cat",0,col_x,col_y,0,0,1,"ic_pars_6_pearson","ic_pars_6_pearson_p");print "col_x",col_x,"col_y",col_y		//not much correlation between access and total cap 2 modelcol_y=FindDimLabel(ic_pars_6,1,"cps_int_C");col_x=FindDimLabel(ic_pars_6,1,"cps_accessR_noModel");disp_plotRep_2D(ic_pars_6,"ic_pars_6_cat",0,col_x,col_y,0,0,1,"ic_pars_6_pearson","ic_pars_6_pearson_p");print "col_x",col_x,"col_y",col_y				//same for integral capcol_y=FindDimLabel(ic_pars_6,1,"cps_expFIT_1_C_0_cap_v0_c");col_x=FindDimLabel(ic_pars_6,1,"cps_accessR_noModel");disp_plotRep_2D(ic_pars_6,"ic_pars_6_cat",0,col_x,col_y,0,0,1,"ic_pars_6_pearson","ic_pars_6_pearson_p");print "col_x",col_x,"col_y",col_y	col_y=FindDimLabel(ic_pars_6,1,"cps_expFIT_1_C_1_cap_v0_c");col_x=FindDimLabel(ic_pars_6,1,"cps_accessR_noModel");disp_plotRep_2D(ic_pars_6,"ic_pars_6_cat",0,col_x,col_y,0,0,1,"ic_pars_6_pearson","ic_pars_6_pearson_p");print "col_x",col_x,"col_y",col_y		//or for each component//voltage response params at each site and then checks against access and inputcol=FindDimLabel(ic_pars_6,1,"ics_exp_expFIT_0_cWave_2");disp_plotRep_2D(ic_pars_6,"ic_pars_6_cat",1,0,col,0,0,0,"ic_pars_6_pearson","ic_pars_6_pearson_p");print col	//tau for response at ped from soma -- strong Rcol=FindDimLabel(ic_pars_6,1,"icp_exp_expFIT_0_cWave_2");disp_plotRep_2D(ic_pars_6,"ic_pars_6_cat",1,0,col,0,0,0,"ic_pars_6_pearson","ic_pars_6_pearson_p");print col	//tau for response at soma from ped -- strong Rcol_y=FindDimLabel(ic_pars_6,1,"ics_exp_expFIT_0_cWave_2");col_x=FindDimLabel(ic_pars_6,1,"cps_accessR_noModel");disp_plotRep_2D(ic_pars_6,"ic_pars_6_cat",0,col_x,col_y,0,0,1,"ic_pars_6_pearson","ic_pars_6_pearson_p");print "col_x",col_x,"col_y",col_y //weak Rcol_y=FindDimLabel(ic_pars_6,1,"ics_exp_expFIT_0_cWave_2");col_x=FindDimLabel(ic_pars_6,1,"cpp_accessR_noModel");disp_plotRep_2D(ic_pars_6,"ic_pars_6_cat",0,col_x,col_y,0,0,1,"ic_pars_6_pearson","ic_pars_6_pearson_p");print "col_x",col_x,"col_y",col_y //weak R -- almost significantcol_y=FindDimLabel(ic_pars_6,1,"ics_exp_expFIT_0_cWave_2");col_x=FindDimLabel(ic_pars_6,1,"cps_ssRin");disp_plotRep_2D(ic_pars_6,"ic_pars_6_cat",0,col_x,col_y,0,0,1,"ic_pars_6_pearson","ic_pars_6_pearson_p");print "col_x",col_x,"col_y",col_y	//even weakercol_y=FindDimLabel(ic_pars_6,1,"ics_exp_expFIT_0_cWave_2");col_x=FindDimLabel(ic_pars_6,1,"cpp_ssRin");disp_plotRep_2D(ic_pars_6,"ic_pars_6_cat",0,col_x,col_y,0,0,1,"ic_pars_6_pearson","ic_pars_6_pearson_p");print "col_x",col_x,"col_y",col_y	//even weakercol=FindDimLabel(ic_pars_6,1,"ics_propL_line_BaselineCrossX_rel_t"[0,31]);disp_plotRep_2D(ic_pars_6,"ic_pars_6_cat",1,0,col,0,0,0,"ic_pars_6_pearson","ic_pars_6_pearson_p");print col		//strong correlation between baseline cross time and lencol=FindDimLabel(ic_pars_6,1,"ics_propL_line_BaselineCrossX_rel_t"[0,31]);disp_plotRep_2D(ic_pars_6,"ic_pars_6_cat",0,2,col,0,0,0,"ic_pars_6_pearson","ic_pars_6_pearson_p");print col		//against axon length has even larger correlation//sin averaging -- all dual cell non blockblock cells analyzed separately, see those pxps for comparison / summaries. sin_block0="G16110208_0037;G16090200_0024;"•sin_sels="G16110208_0015;G16110209_0008;G16092000_0010;G16092003_0011;G16092005_0006;G16091703_0018;G16090102_0013;"•sin_Sels += "G16090106_0022;G16090200_0014;G16090201_0009;"		//removed 16090100 due to poor access, as for white noisefio_stream_listByKey("sin_refs_main0","sin_dual_sels","",sin_sels,"respAtBoth,!*0*,0,0,;",1,"")fio_stream_listByKey("sin_refs_main0","sin_dual_sels_refs","",sin_sels,"respAtBoth,!*0*,0,0,;",1,"")fio_stream_listByKey("sin_refs_main0","sin_dual_params_S","combinedParamRef_S",sin_dual_sels_refs,"",1,"")fio_stream_listByKey("sin_refs_main0","sin_dual_params_P","combinedParamRef_P",sin_dual_sels_refs,"",1,"")fio_stream_listByKey("sin_refs_main0","sin_dual_dparams","sp_diffParams",sin_dual_sels_refs,"",1,"")//sp_diffParamsfio_stream_listByKey("sin_refs_main0","sin_dual_fdparams","sp_fDiffParams",sin_dual_sels_refs,"",1,"")//sp_fDiffParamsfio_stream_listByKey("sin_refs_main0","sin_dual_predParams_S","combinedParamRef_pred_S",sin_dual_sels_refs,"",1,"")//wn_predParamWvRef_Sfio_stream_listByKey("sin_refs_main0","sin_dual_predParams_P","combinedParamRef_pred_P",sin_dual_sels_refs,"",1,"")//wn_predParamWvRef_Sfio_stream_listByKey("sin_refs_main0","sin_dual_pred_dparams","sp_pred_diffParams",sin_dual_sels_refs,"",1,"")//wn_predParamWvRef_Sfio_stream_listByKey("sin_refs_main0","sin_dual_pred_fdparams","sp_pred_fDiffParams",sin_dual_sels_refs,"",1,"")//wn_predParamWvRef_S//display a param across frequencies and mark foveal and peripheral cels		//lines are solid for cell 0 and 1, style 3 for 2nd, style 1 for 3rdyParamStr="impedence";disp_plotReps_2DParams(sin_dual_fdparams,sin_dual_params_S,"freq_Hz",yParamStr,1,sin_dual_sels_e,"region;*P*;",0,win=yParamStr+"_fd",dolog=1)//impedence diffyParamStr="impedence";disp_plotReps_2DParams(sin_dual_pred_fdparams,sin_dual_params_S,"freq_Hz",yParamStr,1,sin_dual_sels_e,"region;*P*;",0,win=yParamStr+"_pfd",dolog=1)//predicted impedence diffyParamStr="phase_rad_diff_v1";disp_plotReps_2DParams(sin_dual_fdparams,sin_dual_params_S,"freq_Hz",yParamStr,1,sin_dual_sels_e,"region;*P*;",0,win=yParamStr+"_fd",dolog=1)//phase diffyParamStr="phase_rad_diff_v1";disp_plotReps_2DParams(sin_dual_pred_fdparams,sin_dual_params_S,"freq_Hz",yParamStr,1,sin_dual_sels_e,"region;*P*;",0,win=yParamStr+"_pfd",dolog=1)//phase predicted diff//these indicate response envelopes at soma and pedyParamStr="impedence";disp_plotReps_2DParams(sin_dual_params_S,sin_dual_params_S,"freq_Hz",yParamStr,1,sin_dual_sels_e,"region;*P*;",0,win=yParamStr+"_fS",dolog=1)//impedence diffyParamStr="impedence";disp_plotReps_2DParams(sin_dual_predParams_S,sin_dual_params_S,"freq_Hz",yParamStr,1,sin_dual_sels_e,"region;*P*;",0,win=yParamStr+"_pfS",dolog=1)//impedence diffyParamStr="impedence";disp_plotReps_2DParams(sin_dual_params_P,sin_dual_params_P,"freq_Hz",yParamStr,1,sin_dual_sels_e,"region;*P*;",0,win=yParamStr+"_fP",dolog=1)//impedence diffyParamStr="impedence";disp_plotReps_2DParams(sin_dual_predParams_P,sin_dual_params_P,"freq_Hz",yParamStr,1,sin_dual_sels_e,"region;*P*;",0,win=yParamStr+"_pfP",dolog=1)//impedence diff//now phase -- invert y by offset (muloffset = {0,-1}) so that its showing phase lag like for wn stimuli•yParamStr="phase_rad_diff_v1";disp_plotReps_2DParams(sin_dual_params_S,sin_dual_params_S,"freq_Hz",yParamStr,1,sin_dual_sels_e,"region;*P*;",0,win=yParamStr+"_fS",dolog=1)//phase diff•yParamStr="phase_rad_diff_v1";disp_plotReps_2DParams(sin_dual_predParams_S,sin_dual_params_S,"freq_Hz",yParamStr,1,sin_dual_sels_e,"region;*P*;",0,win=yParamStr+"_pfS",dolog=1)//phase diff•yParamStr="phase_rad_diff_v1";disp_plotReps_2DParams(sin_dual_params_P,sin_dual_params_P,"freq_Hz",yParamStr,1,sin_dual_sels_e,"region;*P*;",0,win=yParamStr+"_fP",dolog=1)//impedence diff•yParamStr="phase_rad_diff_v1";disp_plotReps_2DParams(sin_dual_predParams_P,sin_dual_params_P,"freq_Hz",yParamStr,1,sin_dual_sels_e,"region;*P*;",0,win=yParamStr+"_pfP",dolog=1)//impedence diffcol=FindDimLabel(scp_allndc_pars,1,"S_ssRin");disp_plotRep_2D(scp_allndc_pars,"scp_allndc_pars_cat",1,0,col,0,0,0,0,0)col=FindDimLabel(scp_allndc_pars,1,"S_int_C");disp_plotRep_2D(scp_allndc_pars,"scp_allndc_pars_cat",1,0,col,0,0,0,0,0)col=FindDimLabel(scp_allndc_pars,1,"S_accessR_noModel");disp_plotRep_2D(scp_allndc_pars,"scp_allndc_pars_cat",1,0,col,0,0,0,0,0)col=FindDimLabel(scp_allndc_pars,1,"P_accessR_noModel");disp_plotRep_2D(scp_allndc_pars,"scp_allndc_pars_cat",0,0,col,0,0,0,0,0)sin_refs_str_list="sin_dual_params_S;sin_dual_params_P;sin_dual_fdparams;sin_dual_predParams_S;sin_dual_predParams_P;sin_dual_pred_dparams;sin_dual_pred_fdparams;"•fio_mParamVsExcelParams_set(1,"sin_dual_pars",sin_refs_str_list,"sin_refs_main0;","s_;p_;d_;fd_;sp_;pp_;dp_;fp_;")=//VIfio_stream_listByKey("vi_refs_main0","vi_all_refs","","*","",0,"")fio_stream_listByKey("vi_refs_main0","testStep_outRef_SfS_all","testStep_outRef_SfS",vi_all_refs,"",1,"",forceCellNameList=vi_all_refs_e) fio_stream_listByKey("vi_refs_main0","testStep_outRef_SfP_all","testStep_outRef_SfP",vi_all_refs,"",1,"",forceCellNameList=vi_all_refs_e) fio_stream_listByKey("vi_refs_main0","testStep_outRef_PfP_all","testStep_outRef_PfP",vi_all_refs,"",1,"",forceCellNameList=vi_all_refs_e) fio_stream_listByKey("vi_refs_main0","testStep_outRef_PfS_all","testStep_outRef_PfS",vi_all_refs,"",1,"",forceCellNameList=vi_all_refs_e) fio_stream_listByKey("vi_refs_main0","testSteps_outRef_diffs_fS_all","testSteps_outRef_diffs_fS",vi_all_refs,"",1,"",forceCellNameList=vi_all_refs_e) fio_stream_listByKey("vi_refs_main0","testSteps_outRef_diffs_fP_all","testSteps_outRef_diffs_fP",vi_all_refs,"",1,"",forceCellNameList=vi_all_refs_e) fio_stream_listByKey("vi_refs_main0","testSteps_outRef_fD_fS_all","testSteps_outRef_fDiffs_fS",vi_all_refs,"",1,"",forceCellNameList=vi_all_refs_e)fio_stream_listByKey("vi_refs_main0","testSteps_outRef_fD_fP_all","testSteps_outRef_fDiffs_fP",vi_all_refs,"",1,"",forceCellNameList=vi_all_refs_e)//display vi -- all fold differences•yParamStr="resp_ssBaselineDiff";disp_plotReps_2DParams(testSteps_outRef_fD_fS_all,testStep_outRef_SfS_all,"stim_ri_deltaMean",yParamStr,1,vi_all_refs_e,"region;*P*;",0,win=yParamStr+"_fS")•yParamStr="resp_peakBaselineDiff";disp_plotReps_2DParams(testSteps_outRef_fD_fS_all,testStep_outRef_SfS_all,"stim_ri_deltaMean",yParamStr,1,vi_all_refs_e,"region;*P*;",0,win=yParamStr+"_fS")//scp main//first add vclamp/wc infoiterate_listWvFunc("scp_refs_main0",0,"fio_scp_addVCStatus",0) //27,29,45,46,50,53,58,60 need checkingfio_scp_storeInfo(46,1,0,1)	//fromPed, in_dc, in_wcfio_scp_storeInfo(50,1,0,0)	//fromPed, in_dc, in_wcfio_scp_storeInfo(53,1,0,0)	//fromPed, in_dc, in_wcfio_scp_storeInfo(58,1,0,0)	//fromPed, in_dc, in_wcfio_scp_storeInfo(60,1,1,0)	//fromPed, in_dc, in_wcfio_addParamsToWvsFromKeyStr(scp_refs_main0,"paramSaveName_S","inDualClampDuringRec_fS","inDualClampDuringRec")fio_addParamsToWvsFromKeyStr(scp_refs_main0,"paramSaveName_S","wcDistalSiteDuringRec_fS","wcDistalSiteDuringRec")fio_addParamsToWvsFromKeyStr(scp_refs_main0,"paramSaveName_S","effectiveClampStatus_fS","effectiveClampStatus")fio_addParamsToWvsFromKeyStr(scp_refs_main0,"paramSaveName_P","inDualClampDuringRec_fP","inDualClampDuringRec")fio_addParamsToWvsFromKeyStr(scp_refs_main0,"paramSaveName_P","wcDistalSiteDuringRec_fP","wcDistalSiteDuringRec")fio_addParamsToWvsFromKeyStr(scp_refs_main0,"paramSaveName_P","effectiveClampStatus_fP","effectiveClampStatus")fio_addStreamKey(scp_refs_main0,"paramSaveName_S","vCmd_baseline","vCmd_baseline_S")		//add information on holding levelfio_addStreamKey(scp_refs_main0,"paramSaveName_P","vCmd_baseline","vCmd_baseline_P")fio_stream_listByKey("scp_refs_main0","scp_allndc6_refs","","!*D","vCmd_Baseline_S,-6*,0,0,",0,"")	//all ndc 60 mV holdingfio_stream_listByKey("scp_refs_main0","scp_allDC6_refs","","*D","vCmd_Baseline_S,-6*,0,0,",0,"")		//all dual clampfio_stream_listByKey("scp_refs_main0","scp_allndc7_refs","","!*D","vCmd_Baseline_S,-7*,0,0,",0,"")	//all ndc 70 mV holdingfio_stream_listByKey("scp_refs_main0","scp_allDC7_refs","","*D","vCmd_Baseline_S,-7*,0,0,",0,"")		//all dual clamprefLists="scp_allndc_refs;scp_allDC_refs;scp_allndc6_refs;scp_allDC6_refs;scp_allndc7_refs;scp_allDC7_refs;"moreCellsWithCurrentInjIss="G16092005;G16090102;G16081110;G16090201;G16090106;G16080602;G16081106;G16081109;G16081111;G16090200;G16090100;G16090109;G16081202;G16080605;G16081201;"scp_allndc6_refs = RemoveFromList(moreCellsWithCurrentInjIss,scp_allndc6_refs);scp_allDC6_refs = RemoveFromList(moreCellsWithCurrentInjIss,scp_allDC6_refs);scp_allndc7_refs = RemoveFromList(moreCellsWithCurrentInjIss,scp_allndc7_refs);scp_allDC7_refs = RemoveFromList(moreCellsWithCurrentInjIss,scp_allDC7_refs)	•print itemsinlist(scp_allndc6_refs),itemsinlist(scp_allDC6_refs),itemsinlist(scp_allndc7_refs),itemsinlist(scp_allDC7_refs)	scp_listOfRefs="scp_allndc6_refs;scp_allndc6_refs;scp_allDC6_refs;scp_allDC6_refs;scp_allndc7_refs;scp_allndc7_refs;scp_allDC7_refs;scp_allDC7_refs;"scp_listOfKeysForRefs="paramSaveName_S;paramSaveName_P;paramSaveName_S;paramSaveName_P;paramSaveName_S;paramSaveName_P;paramSaveName_S;paramSaveName_P;"scp_listOfAppendsForRefs="_parS;_parP;_parS;_parP;_parS;_parP;_parS;_parP;"scp_parWaves_list=fio_stream_wvListsFromRefLists("scp_refs_main0",scp_listOfRefs,scp_listOfAppendsForRefs,scp_listOfKeysForRefs,0)fio_mParamVsExcelParams_set(1,"scp_all_w67",scp_parWaves_list,"scp_refs_main0","S6_;P6_;S6d_;P6d_;S7_;P7_;S7d_;P7d_;")col=FindDimLabel(scp_all_w67,1,"S6_ssRin");disp_plotRep_2D(scp_all_w67,"scp_all_w67_cat",1,0,col,0,0,0,0,0)col=FindDimLabel(scp_all_w67,1,"P6_ssRin");disp_plotRep_2D(scp_all_w67,"scp_all_w67_cat",0,0,col,0,0,0,0,0)col=FindDimLabel(scp_all_w67,1,"S6_int_C");disp_plotRep_2D(scp_all_w67,"scp_all_w67_cat",0,0,col,0,0,0,0,0)col=FindDimLabel(scp_all_w67,1,"S6_accessR_noModel");disp_plotRep_2D(scp_all_w67,"scp_all_w67_cat",0,0,col,0,0,0,0,0)col=FindDimLabel(scp_all_w67,1,"P6_accessR_noModel");disp_plotRep_2D(scp_all_w67,"scp_all_w67_cat",0,0,col,0,0,0,0,0)col_y=FindDimLabel(scp_all_w67,1,"S6_ssRin");col_x=FindDimLabel(scp_all_w67,1,"S6_vCmd_baseline");disp_plotRep_2D(scp_all_w67,"scp_all_w67_cat",0,col_x,col_y,0,0,0,1,0);print "col_x",col_x,"col_y",col_ycol_y=FindDimLabel(scp_all_w67,1,"P6_ssRin");col_x=FindDimLabel(scp_all_w67,1,"P6_vCmd_baseline");disp_plotRep_2D(scp_all_w67,"scp_all_w67_cat",0,col_x,col_y,0,0,0,1,0);print "col_x",col_x,"col_y",col_ycol_y=FindDimLabel(scp_all_w67,1,"S6_ssRin");col_x=FindDimLabel(scp_all_w67,1,"S6_accessR_noModel");disp_plotRep_2D(scp_all_w67,"scp_all_w67_cat",0,col_x,col_y,0,0,0,1,0);print "col_x",col_x,"col_y",col_ycol_y=FindDimLabel(scp_all_w67,1,"P6_ssRin");col_x=FindDimLabel(scp_all_w67,1,"P6_accessR_noModel");disp_plotRep_2D(scp_all_w67,"scp_all_w67_cat",0,col_x,col_y,0,0,0,1,0);print "col_x",col_x,"col_y",col_ycol_y=FindDimLabel(scp_all_w67,1,"S6_ssRin");col_x=FindDimLabel(scp_all_w67,1,"P6_ssRin");disp_plotRep_2D(scp_all_w67,"scp_all_w67_cat",0,col_x,col_y,0,0,0,1,0);print "col_x",col_x,"col_y",col_ycol_y=FindDimLabel(scp_all_w67,1,"S6_accessR_noModel");col_x=FindDimLabel(scp_all_w67,1,"P6_accessR_noModel");disp_plotRep_2D(scp_all_w67,"scp_all_w67_cat",0,col_x,col_y,0,0,0,1,0);print "col_x",col_x,"col_y",col_ycorrelations in scp exp fit 0 and 1st component and totals vs len get much better after removing those where second pipette is wc (or clamped,though I don't think there are any of those in the usual data)•duplicate/O scp_all_w67_cat, scp_all_w67_cat_buduplicate/o scp_all_w67_cat_bu,scp_all_w67_cat; scp_all_w67_cat= scp_all_w67[p][%S6_wcDistalSiteDuringRec] || scp_all_w67[p][%S6_inDualClampDuringRec] ? -inf : scp_all_w67_cat[p] //this masks out those somatic cells. would have to repeat for pedduplicate/o scp_all_w67_cat_bu,scp_all_w67_cat; scp_all_w67_cat= scp_all_w67[p][%P6_wcDistalSiteDuringRec] || scp_all_w67[p][%P6_inDualClampDuringRec] ? -inf : scp_all_w67_cat[p]	//this masks for ped cells. n=3 only in this data set//OLD befoer sep into 60 and 70 mV commandscol=FindDimLabel(scp_all_pars,1,"S_ssRin");disp_plotRep_2D(scp_all_pars,"scp_all_pars_cat",1,0,col,0,0,0,0,0)col=FindDimLabel(scp_all_pars,1,"P_ssRin");disp_plotRep_2D(scp_all_pars,"scp_all_pars_cat",0,0,col,0,0,0,0,0)col=FindDimLabel(scp_all_pars,1,"S_int_C");disp_plotRep_2D(scp_all_pars,"scp_all_pars_cat",0,0,col,0,0,0,0,0)col=FindDimLabel(scp_all_pars,1,"S_accessR_noModel");disp_plotRep_2D(scp_all_pars,"scp_all_pars_cat",0,0,col,0,0,0,0,0)col=FindDimLabel(scp_all_pars,1,"P_accessR_noModel");disp_plotRep_2D(scp_all_pars,"scp_all_pars_cat",0,0,col,0,0,0,0,0)col_y=FindDimLabel(scp_all_pars,1,"S_ssRin");col_x=FindDimLabel(scp_all_pars,1,"S_vCmd_baseline");disp_plotRep_2D(scp_all_pars,"scp_all_pars_cat",0,col_x,col_y,0,0,0,1,0);print "col_x",col_x,"col_y",col_ycol_y=FindDimLabel(scp_all_pars,1,"P_ssRin");col_x=FindDimLabel(scp_all_pars,1,"P_vCmd_baseline");disp_plotRep_2D(scp_all_pars,"scp_all_pars_cat",0,col_x,col_y,0,0,0,1,0);print "col_x",col_x,"col_y",col_ycol_y=FindDimLabel(scp_all_pars,1,"S_ssRin");col_x=FindDimLabel(scp_all_pars,1,"S_accessR_noModel");disp_plotRep_2D(scp_all_pars,"scp_all_pars_cat",0,col_x,col_y,0,0,0,1,0);print "col_x",col_x,"col_y",col_ycol_y=FindDimLabel(scp_all_pars,1,"P_ssRin");col_x=FindDimLabel(scp_all_pars,1,"P_accessR_noModel");disp_plotRep_2D(scp_all_pars,"scp_all_pars_cat",0,col_x,col_y,0,0,0,1,0);print "col_x",col_x,"col_y",col_ycol_y=FindDimLabel(scp_all_pars,1,"S_ssRin");col_x=FindDimLabel(scp_all_pars,1,"P_ssRin");disp_plotRep_2D(scp_all_pars,"scp_all_pars_cat",0,col_x,col_y,0,0,0,1,0);print "col_x",col_x,"col_y",col_ycol_y=FindDimLabel(scp_all_pars,1,"S_accessR_noModel");col_x=FindDimLabel(scp_all_pars,1,"P_accessR_noModel");disp_plotRep_2D(scp_all_pars,"scp_all_pars_cat",0,col_x,col_y,0,0,0,1,0);print "col_x",col_x,"col_y",col_y//ic0ic0_noBlockRefs="G16110201_0003_1_AD0;G16110208_0005_1_AD0;G16090100_0005_1_AD2;G16090200_0005_1_AD2;G16080605_0005_1_AD0;G16081201_0003_1_AD2;G16060303_0004_1_AD0;"ic0_blockrefs="G16110201_0026_1_AD0;G16110208_0024_1_AD0;G16090100_0028_1_AD2;G16090200_0022_1_AD2;G16080605_0013_1_AD0;G16081201_0014_1_AD2;G16060303_0048_1_AD0;"fio_stream_listByKey("ic0_refs_main0","ic0_noblockrefs","",ic0_noblockrefs,"",0,"")	//make _e and _i waves for these listsfio_stream_listByKey("ic0_refs_main0","ic0_blockrefs","",ic0_blockrefs,"",0,"")ic0_selrefs="G16110201_0003_1_AD0;G16110200_0003_1_AD2;G16110203_0003_1_AD0;G16110208_0005_1_AD0;G16110209_0002_1_AD2;G16110102_0011_1_AD2;G16092907_0001_1_AD2;G16093000_0006_1_AD0;G16093005_0007_1_AD0;G16092000_0004_1_AD0;G16092002_0010_1_AD0;G16092003_0005_1_AD2;G16092005_0001_1_AD2;G16091905_0005_1_AD0;G16091906_0003_1_AD2;G16091703_0001_1_AD0;G16091707_0001_1_AD2;G16091708_0007_1_AD0;G16091712_0006_1_AD0;G16090100_0005_1_AD2;G16090102_0005_1_AD0;G16090106_0013_1_AD2;G16090200_0005_1_AD2;G16090201_0002_1_AD0;G16072802_0003_1_AD2;G16072901_0005_1_AD2;G16080501_0002_1_AD2;G16080507_0003_1_AD0;G16080508_0001_1_AD0;G16080602_0004_1_AD0;G16080605_0005_1_AD0;G16081106_0005_1_AD0;G16081109_0008_1_AD2;G16081110_0003_1_AD0;G16081110_0015_1_AD2;G16081113_0001_1_AD0;G16081115_0002_1_AD2;G16081200_0001_1_AD2;G16081201_0003_1_AD2;G16081202_0030;G16081206_0005_1_AD2;G16060300_0005_1_AD2;G16060303_0004_1_AD0;G16060403_0003_1_AD2;G15090300_0003_1_AD0;  G15090303_0005_1_AD2;G15090404_0003_1_AD2;G15091700_0002_1_AD0;G15091701_0003_1_AD2;G15092801_0004_1_AD0;G15092900_0004_1_AD2;G15092907_0004_1_AD0;G15092909_0008_1_AD2;G15120101_0007_1_AD2;"fio_stream_listByKey("ic0_refs_main0","ic0_selrefs","",ic0_selrefs,"",0,"")	//this has had duplicates from other portions of wave and block refs removed carefullyfio_stream_listByKey("ic0_refs_main0","ic0_params_S","s1_params",ic0_selrefs,"",0,"",forceCellNameList=all_ic0selrefs_excel)fio_stream_listByKey("ic0_refs_main0","ic0_params_P","s2_params",ic0_selrefs,"",0,"",forceCellNameList=all_ic0selrefs_excel)fio_stream_listByKey("ic0_refs_main0","ic0_params_D","params_diff_ref",ic0_selrefs,"",0,"",forceCellNameList=all_ic0selrefs_excel)fio_stream_listByKey("ic0_refs_main0","ic0B_params_S","s1_params",ic0_blockrefs,"",0,"")fio_stream_listByKey("ic0_refs_main0","ic0B_params_P","s2_params",ic0_blockrefs,"",0,"")fio_stream_listByKey("ic0_refs_main0","ic0B_params_D","params_diff_ref",ic0_blockrefs,"",0,"")fio_mParamVsExcelParams_set(1,"ic0_allpars","ic0_params_S;ic0_params_P;ic0_params_D;ic0B_params_S;ic0B_params_P;ic0B_params_D;","ic0_refs_main0","S_;P_;D_;Sb_;Pb_;Db_;")//mean and standard deviation differencescol=FindDimLabel(ic0_allpars,1,"S_avg");disp_plotRep_2D(ic0_allpars,"ic0_allpars_cat",1,0,col,0,0,0,0,0)col=FindDimLabel(ic0_allpars,1,"P_avg");disp_plotRep_2D(ic0_allpars,"ic0_allpars_cat",1,0,col,0,0,0,0,0)col_y=FindDimLabel(ic0_allpars,1,"P_avg");col_x=FindDimLabel(ic0_allpars,1,"S_avg");disp_plotRep_2D(ic0_allpars,"ic0_allpars_cat",0,col_x,col_y,0,0,0,1,0);print "col_x",col_x,"col_y",col_ycol=FindDimLabel(ic0_allpars,1,"S_sdev");disp_plotRep_2D(ic0_allpars,"ic0_allpars_cat",1,0,col,0,0,0,0,0)col=FindDimLabel(ic0_allpars,1,"P_sdev");disp_plotRep_2D(ic0_allpars,"ic0_allpars_cat",1,0,col,0,0,0,0,0)col_y=FindDimLabel(ic0_allpars,1,"P_sdev");col_x=FindDimLabel(ic0_allpars,1,"S_sdev");disp_plotRep_2D(ic0_allpars,"ic0_allpars_cat",0,col_x,col_y,0,0,0,1,0);print "col_x",col_x,"col_y",col_y//power with windowcol=FindDimLabel(ic0_allpars,1,"S_power_to10_win");disp_plotRep_2D(ic0_allpars,"ic0_allpars_cat",1,0,col,0,0,0,0,0)col=FindDimLabel(ic0_allpars,1,"S_power_10to20_win");disp_plotRep_2D(ic0_allpars,"ic0_allpars_cat",1,0,col,0,0,0,0,0)col=FindDimLabel(ic0_allpars,1,"S_power_20to30_win");disp_plotRep_2D(ic0_allpars,"ic0_allpars_cat",1,0,col,0,0,0,0,0)col=FindDimLabel(ic0_allpars,1,"S_power_30to40_win");disp_plotRep_2D(ic0_allpars,"ic0_allpars_cat",1,0,col,0,0,0,0,0)col=FindDimLabel(ic0_allpars,1,"S_power_40to60_win");disp_plotRep_2D(ic0_allpars,"ic0_allpars_cat",1,0,col,0,0,0,0,0)col=FindDimLabel(ic0_allpars,1,"S_power_60to100_win");disp_plotRep_2D(ic0_allpars,"ic0_allpars_cat",1,0,col,0,0,0,0,0)col=FindDimLabel(ic0_allpars,1,"S_power_100to200_win");disp_plotRep_2D(ic0_allpars,"ic0_allpars_cat",1,0,col,0,0,0,0,0)col=FindDimLabel(ic0_allpars,1,"S_power_200toInf_win");disp_plotRep_2D(ic0_allpars,"ic0_allpars_cat",1,0,col,0,0,0,0,0)col=FindDimLabel(ic0_allpars,1,"P_power_to10_win");disp_plotRep_2D(ic0_allpars,"ic0_allpars_cat",1,0,col,0,0,0,0,0)col=FindDimLabel(ic0_allpars,1,"P_power_10to20_win");disp_plotRep_2D(ic0_allpars,"ic0_allpars_cat",1,0,col,0,0,0,0,0)col=FindDimLabel(ic0_allpars,1,"P_power_20to30_win");disp_plotRep_2D(ic0_allpars,"ic0_allpars_cat",1,0,col,0,0,0,0,0)col=FindDimLabel(ic0_allpars,1,"P_power_30to40_win");disp_plotRep_2D(ic0_allpars,"ic0_allpars_cat",1,0,col,0,0,0,0,0)col=FindDimLabel(ic0_allpars,1,"P_power_40to60_win");disp_plotRep_2D(ic0_allpars,"ic0_allpars_cat",1,0,col,0,0,0,0,0)col=FindDimLabel(ic0_allpars,1,"P_power_60to100_win");disp_plotRep_2D(ic0_allpars,"ic0_allpars_cat",1,0,col,0,0,0,0,0)col=FindDimLabel(ic0_allpars,1,"P_power_100to200_win");disp_plotRep_2D(ic0_allpars,"ic0_allpars_cat",1,0,col,0,0,0,0,0)col=FindDimLabel(ic0_allpars,1,"P_power_200toInf_win");disp_plotRep_2D(ic0_allpars,"ic0_allpars_cat",1,0,col,0,0,0,0,0)col_y=FindDimLabel(ic0_allpars,1,"P_power_to10_win");col_x=FindDimLabel(ic0_allpars,1,"S_power_to10_win");disp_plotRep_2D(ic0_allpars,"ic0_allpars_cat",0,col_x,col_y,0,0,0,1,0);print "col_x",col_x,"col_y",col_ycol_y=FindDimLabel(ic0_allpars,1,"P_power_10to20_win");col_x=FindDimLabel(ic0_allpars,1,"S_power_10to20_win");disp_plotRep_2D(ic0_allpars,"ic0_allpars_cat",0,col_x,col_y,0,0,0,1,0);print "col_x",col_x,"col_y",col_ycol_y=FindDimLabel(ic0_allpars,1,"P_power_20to30_win");col_x=FindDimLabel(ic0_allpars,1,"S_power_20to30_win");disp_plotRep_2D(ic0_allpars,"ic0_allpars_cat",0,col_x,col_y,0,0,0,1,0);print "col_x",col_x,"col_y",col_ycol_y=FindDimLabel(ic0_allpars,1,"P_power_30to40_win");col_x=FindDimLabel(ic0_allpars,1,"S_power_30to40_win");disp_plotRep_2D(ic0_allpars,"ic0_allpars_cat",0,col_x,col_y,0,0,0,1,0);print "col_x",col_x,"col_y",col_ycol_y=FindDimLabel(ic0_allpars,1,"P_power_40to60_win");col_x=FindDimLabel(ic0_allpars,1,"S_power_40to60_win");disp_plotRep_2D(ic0_allpars,"ic0_allpars_cat",0,col_x,col_y,0,0,0,1,0);print "col_x",col_x,"col_y",col_ycol_y=FindDimLabel(ic0_allpars,1,"P_power_60to100_win");col_x=FindDimLabel(ic0_allpars,1,"S_power_60to100_win");disp_plotRep_2D(ic0_allpars,"ic0_allpars_cat",0,col_x,col_y,0,0,0,1,0);print "col_x",col_x,"col_y",col_ycol_y=FindDimLabel(ic0_allpars,1,"P_power_100to200_win");col_x=FindDimLabel(ic0_allpars,1,"S_power_100to200_win");disp_plotRep_2D(ic0_allpars,"ic0_allpars_cat",0,col_x,col_y,0,0,0,1,0);print "col_x",col_x,"col_y",col_ycol_y=FindDimLabel(ic0_allpars,1,"P_power_200toInf_win");col_x=FindDimLabel(ic0_allpars,1,"S_power_200toInf_win");disp_plotRep_2D(ic0_allpars,"ic0_allpars_cat",0,col_x,col_y,0,0,0,1,0);print "col_x",col_x,"col_y",col_y//cross correlationcol=FindDimLabel(ic0_allpars,1,"D_AC_maxLoc");disp_plotRep_2D(ic0_allpars,"ic0_allpars_cat",0,0,col,0,0,0,0,0)col=FindDimLabel(ic0_allpars,1,"D_AC_fwhm");disp_plotRep_2D(ic0_allpars,"ic0_allpars_cat",0,0,col,0,0,0,0,0)col=FindDimLabel(ic0_allpars,1,"D_AC_fwhm_centerVal");disp_plotRep_2D(ic0_allpars,"ic0_allpars_cat",0,0,col,0,0,0,0,0)  16110208;16080605;16081201;16110201;16110203;16093000;15092900;15092907;15092909;16091712;16090200;16060403;16081109;15092801;15091701;16060303;16091905;16060300;16091708;16090100;16090102;16090106;  16110208 ;16080605 ;16081201 ;16110201 ;16110203 ;16093000 ;15092900 ;15092907   ;15092909 ;16091712 ;16090200 ;16060403 ;16081109 ;15092801 ;15091701 ;16060303 ;16091905 ;16060300   ;16091708 ;16090100 ;16090102 ;16090106 ;G16110201_0011_1G16110200_0012_1G16110203_0008_1G16110201_0012_1pG16110201_0019_1G16110201_0020_1pG16110201_0027_1G16110201_0028_1pG16110208_0010_1G16110208_0011_1G16110208_0012_1pG16110208_0020_1G16110208_0028_1G16110209_0006_1G16093000_0010_1G16092000_0006_1pG16092000_0009_1pG16092003_0007_1G16092003_0008_1G16092005_0004_1G16091905_0009_1G16091703_0011_1G16091703_0014_1G16091708_0023_1	//named 09 in excelG16091708_0030_1G16091708_0033_1G16091708_0034_1G16091708_0035_1G16091712_0009_1G16090100_0016_1G16090100_0017_1pG16090100_0026_1G16090100_0027_1pG16090102_0011_1G16090102_0012_1pG16090106_0018_1G16090106_0019_1G16090200_0013_1G16090200_0021_1G16090200_0020_1G16090201_0005_1G16090201_0006_1G16080507_0009_1G16080507_0008_1G16080605_0008_1pG16080605_0014_1G16080605_0016_1pG16081109_0013_1G16081109_0014_1pG16081200_0008_1G16081200_0009_1G16081200_0011_1G16081200_0013_1G16081200_0014_1G16081201_0010_1G16081201_0011_1pG16081201_0018_1G16060300_0016_1G16060300_0017_1pG16060303_0012_1G16060303_0013_1pG16060303_0031_1G16060303_0032_1pG16060303_0039_1G16060303_0043_1G16060303_0051_1G16060303_0052_1G16060303_0055_1G16060403_0010_1G16060403_0011_1pG15090303_0018_1G15090303_0021_1G15090303_0022_1G15091701_0019_1G15091701_0020_1G15092801_0023_1G15092801_0024_1G15092801_0025_1G15092900_0026_1G15092907_0018_1G15092907_0019_1pG15092909_0022_1G15092909_0023_1p//FINAL DISPLAY COMMANDS FOR FASEB TALKcx=FindDimLabel(wn_PP_alleec,1,"inPips__total_dist_micron");cy=finddimlabel(wn_PP_alleec,1,"wds_filterMaxLoc");disp_plotRep_2Dsym(wn_PP_alleec,"wn_PP_alleec_c","wn_PP_alleec_catSym",cx,cy,0,0,0,0,1);print "col",colcx=FindDimLabel(wn_PP_alleec,1,"inPips__total_dist_micron");cy=finddimlabel(wn_PP_alleec,1,"wfs_respPower_40to60HzArea");disp_plotRep_2Dsym(wn_PP_alleec,"wn_PP_alleec_c","wn_PP_alleec_catSym",cx,cy,0,0,0,0,1);print "col",colcx=FindDimLabel(wn_PP_alleec,1,"inPips__total_dist_micron");cy=finddimlabel(wn_PP_alleec,1,"wfs_respPower_Below20HzArea");disp_plotRep_2Dsym(wn_PP_alleec,"wn_PP_alleec_c","wn_PP_alleec_catSym",cx,cy,0,0,0,0,1);print "col",colfunction img_rotate3D(imgWv,rotPlaneNum,outRef)	WAVE imgWv	Variable rotPlaneNum	String outRef		if (rotPlaneNum!=1)		//only straightforward for rotPlaneNum == 1 see below		return 0	endif		Variable i, perpDim, lenPerpDim							//takes xz slices, puts y into z	perpDim = 1			//reverse is just repeating the same call on the resultant image							//y is in z, so swap xz again to put z back into z									lenPerpDim = dimsize(imgwv,perpDim)		for (i=0;i<lenPerpDim;i+=1)		imagetransform/PTYP=(rotPlaneNum)/P=(i) getplane imgWv		WAVE M_imagePlane		if (i==0)			Duplicate/O M_ImagePlane, $outref/wave=out		else			Concatenate/NP=2 {M_imagePlane},out		endif		endfor	end//precision appears to be one decimal place short of the swc file :( but it could be much worse!function img_loadSWC(outRef,numLinesGuess)	String outRef	Variable numLinesGuess	//pass this will help it run faster.. can be over or under, over is safer		if (!strlen(outRef))		outRef = "out"	endif			Variable txtRefNum	Open/R/T=".swc" txtRefNum as ""	if (!txtRefNum)		return -1	endif		Variable lineNumber=0, len,firstLine=1	String buffer	Variable overGuessBufferSize = 50		//how many more lines to add if over guess? (bigger should reduce overhead at a small cost of wave size)		Variable numParams = 7	//expected format of input:	//each line except the 1st which is header is:	//pntNum typeNum xPos yPos zPos radius parentNum[newLine]	Variable pntNum,typeNum,parentNum	Double xPos,yPos,zPos,radius	Make/O/D/N=(numLinesGuess,numParams) $outRef/wave=out	do		FReadLine txtRefNum, buffer		len = strlen(buffer)		if (firstLine)			Print "header/line0 text = ",buffer			firstLine = 0			continue		endif		if (len == 0)			break		// No more lines to be read		endif		//check if over the size guess and redimension by 1 (this is the inefficient part)		if (lineNumber > (dimsize(out,0) - 1))			redimension/N=(dimsize(out,0) + overGuessBufferSize,-1) out		endif		sscanf buffer, "%i %i %f %f %f %f %i",pntNum,typeNum,xPos,yPos,zPos,radius,parentNum		out[lineNumber][0] = pntNum		out[lineNumber][1] = typeNum		out[lineNumber][2] = xPos		out[lineNumber][3] = yPos		out[lineNumber][4] = zPos		out[lineNumber][5] = radius		out[lineNumber][6] = parentNum				lineNumber += 1	while (1)		//resize to actual number of lines read	Redimension/N=(lineNumber,-1) out	SetDimLabel 1,0,pntNum,out	SetDimLabel 1,1,typeNum,out	SetDimLabel 1,2,xPos,out	SetDimLabel 1,3,yPos,out	SetDimLabel 1,4,zPos,out	SetDimLabel 1,5,radius,out	SetDimLabel 1,6,parentNum,out	Close txtRefNumend//OVERWRITES INPUT WAVE, considering making a backup of the original firstfunction img_swcToPixels(swcWv,micronPerPixel_x,micronPerPixel_y,micronPerPixel_z)	WAVE swcWv	Double micronPerPixel_x, micronPerPixel_y,micronPerPixel_z		swcWv[][%xPos] /= micronPerPixel_x	swcWv[][%yPos] /= micronPerPixel_y	swcWv[][%zPos] /= micronPerPixel_z	end//MAY OVERWRITE ANY TRACING ON CURRENT SEGMENT//tracing window should be top graph//currently doesn't handle radius scaling. all are set to 10 pnt 10 pixels...function img_pixelSwcToTracing(pixelSwcWv)	WAVE pixelSwcWv //expect wave loaded from img_loadSWC and converted to pixel values with img_swcToPixels		SVAR/Z tracing_currTracingWaveName	if (!Svar_exists(tracing_currTracingWaveName))		Print "initialize image tracing with tracing_addseg() before calling this function"	endif		WAVE currTraceWv = $tracing_currTracingWaveName	//currTraceWv has format xPixLoc yPixLoc xPixNearest yPixNearest zPixLoc radiusPnts radiusPix	//swc has format pntNum typeNum xPix yPix zPix radius parentNum	Variable np = dimsize(pixelSwcWv,0)	Redimension/N=(np,-1) currTraceWv	currTraceWv[][0] = pixelSwcWv[p][2]		//transfer x values	currTraceWv[][2] = pixelSwcWv[p][2]		currTraceWv[][1] = pixelSwcWv[p][3]	currTraceWv[][3] = pixelSwcWv[p][3]	currTraceWv[][4] = pixelSwcWv[p][4]	currTraceWv[][5,6] = nan//10		tracing_doUpdates(winname(0,1),nan,nan,nan)		//updates the ancillary tracing variables/waves	tracing_follow("",0,nan,1)							//start off at point 0 (this also seems to be a way to start the radius tracking)	endfunction tracing_autoRadius_all(winN,maxNumSteps,arcRadius,numArcRadiusSteps,startPnt,num,numTestAngles,updateCenters)	String winN	Variable maxNumSteps 	//see tracing_getXYSlope	Variable arcRadius,numArcRadiusSteps	Variable startPnt,num,numTestAngles,updateCenters		Variable invert=0	String autoRadiusThresholdInfo=""//"1;0;"		if (!strlen(winN))		winN = winname(0,1)	endif		Variable start=numtype(startPnt) ? 0 : startpnt			String tracedWaveName = tracing_getTracedWvNmFromWinN(winN)	String combinedSegRef = tracing_getCombinedSegref(tracedWaveName)	WAVE/D ccWv = $combinedSegRef		//reset history wave storing automated radius measurement results	String autoRadiusAllRef = combinedSegRef + "_rad"	Variable numRows = dimsize(ccwv,0)	Variable numInterpParams = 43	//check end of interp function	Make/O/d/n=(numRows,numInterpParams) $autoRadiusAllRef/wave=results;results=nan		Variable pnts = numtype(num) ? dimsize(ccwv,0) : num,i,pnt		//stopping after first and before last pnt	for (i=0;i<pnts;i+=1)		pnt=start+i		tracing_follow(winN,pnt,nan,1)		//print "pnt",pnt,"slopeStepSizes",slopeStepSizes,"arcRadius",arcRadius,"numArcRadiusSteps",numArcRadiusSteps,"autoRadiusThresholdInfo",autoRadiusThresholdInfo,"invert",invert		tracing_autoRadius(pnt,winN,maxNumSteps,arcRadius,numArcRadiusSteps,invert,autoRadiusThresholdInfo,autoRadiusAllRef,numTestAngles,updateCenters)		doupdate	endfor		Print "tracing_autoRadius_all_ref:",autoRadiusAllRefendfunction tracing_autoRadius(ccPntNum,winN,maxNumSteps,arcRadius,numArcRadiusSteps,invert,autoRadiusThresholdInfo,resultsRef,numTestAngles,updateCenters)	Variable ccPntNum; String winN	Variable maxNumSteps 	//see number of points to average in either direction of current point for determining slope	Variable arcRadius,numArcRadiusSteps	String resultsRef	Variable invert		//was designed for cells brighter inside, dimmer outside. if flipped (as in DIC), pass true for this	String autoRadiusThresholdInfo	Variable numTestAngles		//pass >1 to try more test angles and make sure we have the most orthogonal	Variable updateCenters		if (numtype(ccPntNum))		ccPntNum = tracing_getSelPntData("Graph0",nan)		//current selection	endif		Variable origWidth_pix = 100	Variable xyCropSize_pix = 100		if (!strlen(winN))		winN = winname(0,1)	endif		setwindow $winN userdata(autoRadiusPerformed) = num2str(1)		//allows other helpful windows to be created by tracing_follow()		String tracedWaveName = tracing_getTracedWvNmFromWinN(winN)	String combinedSegRef = tracing_getCombinedSegref(tracedWaveName)	WAVE/D ccWv = $combinedSegRef	Double x0=ccWv[ccPntNum][0],y0=ccWv[ccPntNum][1],z0=ccWv[ccPntNum][4]	Double angle = tracing_getXYSlope(ccPntNum,winN,maxNumSteps)	if (numTestAngles < 2)		tracing_interp(angle-90,arcRadius,numArcRadiusSteps,invert,autoRadiusThresholdInfo,ccPntNum,winN,"interpTest",resultsRef,0,updateCenters)	else		//numTestangles should be even so total is odd to allow main angle to be central		make/o/d/n=(numTestAngles+1) testAngles,angleResults		Variable spaceBetweenTests = 180 / (numTestAngles-1)		testAngles[0]=angle-90		testAngles[1,]=angle-180+(p-1)*spaceBetweenTests		//180 degrees of non-redundant space, 90 on each side of angle		angleResults=tracing_interp(testAngles[p],arcRadius,numArcRadiusSteps,invert,autoRadiusThresholdInfo,ccPntNum,winN,"interpTest",resultsRef,1,updateCenters)		wavestats/q angleResults		tracing_interp(testAngles[V_minLoc],arcRadius,numArcRadiusSteps,invert,autoRadiusThresholdInfo,ccPntNum,winN,"interpTest",resultsRef,0,updateCenters)			//print "testAngles",testAngles,"angleResults",angleResults	endifendfunction tracing_getXYSlope(ccPntNum,winN,maxNumSteps)	Variable ccPntNum; String winN	Variable maxNumSteps		//how far out to look in estimating points		if (!strlen(winN))		winN = winname(0,1)	endif		String tracedWaveName = tracing_getTracedWvNmFromWinN(winN)	String combinedSegRef = tracing_getCombinedSegref(tracedWaveName)	WAVE/D ccWv = $combinedSegRef		Variable xCol=0,yCol=1		Double cc_x=ccwv[ccPntNum][xCol],cc_y=ccwv[ccPntNum][yCol],dx,dy,currMag,currAngle,totalAngle=0,totalMultiplier=0	Variable i,minInd=0,maxInd=dimsize(ccwv,0)-1,count=0,weight=0	Variable prevInd,postInd	Complex currSlope	for (i=0;i<maxNumSteps;i+=1)		prevInd = ccPntNum-i-1		postInd = ccPntNum+i+1				if (prevInd >= minInd)		//only consider points in range			count+=1			dx=cc_x-ccwv[prevInd][xCol]			dy=cc_y-ccwv[prevInd][yCol]			currSlope=r2polar(cmplx(dx,dy))			currMag=real(currSlope)			currAngle=imag(currSlope) * 180 / pi			totalAngle+=currAngle 		endif				if (postInd <= maxInd)			//only consider points in range			count+=1			dx=ccwv[postInd][xCol]-cc_x			dy=ccwv[postInd][yCol]-cc_y			currSlope=r2polar(cmplx(dx,dy))			currMag=real(currSlope)			currAngle=imag(currSlope) * 180 / pi			totalAngle+=currAngle			endif		endfor		totalAngle /= count			return totalAngleendfunction tracing_interp(sectionAngle,arcRadius,numArcRadiusSteps,invert,autoRadiusThresholdInfo,ccPntNum,winN,outRef,resultsRef,noSave,updateCenters)	Variable ccPntNum; String winN	Double sectionAngle		//estimated angle of neuron local to this point e.g. from calls to tracing_getXYSlope()	Variable arcRadius			//number of pixels of length to interpolate on either side of point	Variable numArcRadiusSteps	//number of steps within that length to take	String outRef				//interpolated result	String resultsRef		//optionally pass to store results for this point in an array for all points	Variable invert		//was designed for cells brighter inside, dimmer outside. if flipped (as in DIC), pass true for this	String autoRadiusThresholdInfo	Variable noSave		//pass to get radius estiamte only	Variable updateCenters		//recenter based on interpolation and width. Ignored if noSave is true	//ccPnt pass to store line 		Variable saveRawData=1		//set to store orthogonal interpolation (orthoInterp)	String interpRef=winN+ "ORTHO"	String interpFitRef=winN+"ORTHOF"	String interpXVals="winN"+"ORTHOX"	String interpYVals="winN"+"ORTHOY"	String interpWidth="winN"+"ORTHOW"	Variable useThreshold=strlen(autoRadiusThresholdInfo)>0		//use a threshold (held in this variable, cannot be zero)to determine edges instead of fit.. intended for use with ROI tracing to get widths		Variable orthoNum = 5		//number of orthogonal steps to add to average. 1 is an average of 3: main line, one negative and one positive orthogonal line	Variable padPix = 40//20		if (!strlen(winN))		winN = winname(0,1)	endif	String tracedWaveName = tracing_getTracedWvNmFromWinN(winN)	String combinedSegRef = tracing_getCombinedSegref(tracedWaveName)	WAVE/D ccWv = $combinedSegRef	String segLabel = 	GetDimLabel(ccwv, 0, ccPntNum)		if (!strlen(segLabel))		Print "tracing_interp(): could not find seg label! aborting"		return 0	endif		Variable segNum = tracing_segNumFromSegRef(segLabel)	Variable segPntNum = tracing_getSegPntFromSegRef(segLabel)	String segRef = tracing_getSegNameForCCPnt(winN,ccPntNum)	WAVE segWv= $segRef		Double sectionAngle_rad=sectionAngle*pi/180	Double m = tan(sectionAngle_rad)	Double xv = ccWv[ccPntNum][0],dx	Double yv = ccWv[ccPntNum][1],dy	Double zv = ccWv[ccPntNum][4]		Double yint = -m*xv + yv	Variable stepSize = arcRadius / numArcRadiusSteps	Variable totalNumSteps = 1 + 2*numArcRadiusSteps		//get value at center point and values along radius on either side	Variable centerPnt=numArcRadiusSteps	Make/O/D/N=(totalNumSteps) $outRef/wave=out	Make/o/d/N=(totalNumSteps,2) tracing_interpXYVals		if (m == 0)		//flat line, dx = stepSize		dx = stepSize		dy = 0	elseif (numtype(m) == 1)		//verticle line dy = stepSize, dx = 0		dx = 0		dy = stepSize	else		dx = stepSize/sqrt(1+m^2)		dy = stepSize/sqrt(1+(1/m^2)) * ( (m < 0) ? -1 : 1)		//slope information not held in dx,dy calc, add that with by multipying by -1 or 1	endif	Double m2 = dy/dx		//sanity check	tracing_interpXYVals[][0] = xv + (p-numArcRadiusSteps)*dx		//x values	tracing_interpXYVals[][1] = yv + (p-numArcRadiusSteps)*dy		//y values		//print/d "origAngle",sectionAngle+90,"sectionAngle",sectionAngle,"ccPntNum",ccPntNum,"xv",xv,"dx",dx,"yv",yv,"dy",dy,"m",m,"m2",m2,"yint",yint		imagetransform/PTYP=0/P=(zv) getplane $tracedWaveName	WAVE/D M_imagePlane	Redimension/N=(-1,-1) M_ImagePlane	img_cropToCenter(xv,yv,2*arcRadius+padPix,M_ImagePlane,"tracing_interpTemp")	ImageInterpolate/U=8/Dest=tracing_interpTemp2 bilinear $"tracing_interpTemp"	try		out = tracing_interpTemp2(xv + (p-numArcRadiusSteps)*dx)(yv + (p-numArcRadiusSteps)*dy)		catch 		print "tracing_interp() on ccpnt",ccPntNum,"error on tracing_interpTemp2 ignored,err",GetRTError(1)	endtry	Variable averageCount = 1		//take average across orthogonal slices	Variable i,orthoMult	for (i=0;i<orthoNum;i+=1)		orthoMult = i+1		out += tracing_interpTemp2(xv-dx*orthoMult + (p-numArcRadiusSteps)*dx)(yv+dy*orthoMult + (p-numArcRadiusSteps)*dy)		orthoMult *= -1		//to get other direction		out += tracing_interpTemp2(xv-dx*orthoMult + (p-numArcRadiusSteps)*dx)(yv+dy*orthoMult + (p-numArcRadiusSteps)*dy)		averageCount += 2	endfor	out /= averageCount		//get axis scaling right (depends on #numArcRadiusSteps)	setscale/P x,0,stepSize,"p",out	duplicate/o out,radiusDisp		Variable bkgProp=nan,bkgLen_P=nan,noRiseCross=nan,noFallCross=nan,inLevel=nan,outLevel=nan	Double leftBkg=nan,rightBkg=nan,bkg=nan,risePos=nan,risePos1=nan,fallPos=nan,width=nan,centerCalc=nan,fallPos1=nan,centerCalc1=nan,normFactor=nan	Double tauFromfit=nan,riseFromFit=nan,fallFromFit=nan,widthFromfit=nan,centerFromFit=nan,interpStart=nan,interpEnd=nan	Double rise_p1,fall_p1,width_p1,center_p1,rise_p5,fall_p5,width_p5,center_p5,rise_p9,fall_p9,width_p9,center_p9,fitMaskThreshold	Double gauss_y0,gauss_A,gauss_x0,gauss_width,K0,gauss_fwhm=nan,gauss_fwtm=nan	if (useThreshold)	//SEE WHEN LINE CROSSES THRESHOLD -- assumes center is ABOVE threshold		inLevel=str2num(stringfromlist(0,autoRadiusThresholdInfo))		outLevel=str2num(stringfromlist(1,autoRadiusThresholdInfo))		noRiseCross=1;noFallCross=1		for (i=centerPnt;i>=0;i-=1)			if (out[i] == outLevel)				risePos=pnt2x(out,i)				noRiseCross=0				break			endif				endfor		for (i=centerPnt;i<totalNumSteps;i+=1)			if (out[i] == outLevel)				fallPos=pnt2x(out,i)				noFallCross=0				break			endif				endfor				width = fallPos-risePos		centerCalc = risePos + width/2		if (noRiseCross || noFallCross)			Print "noRiseCross",noRiseCross,"noFallCross",noFallCross,"risePos",risePos,"fallPos",fallPos,"width",width,"centerCalc",centerCalc		endif				if (noSave)			return width		endif	else		//FIT TO LINE SCAN			//subtract background (bkg) from average --added after original version, so not stored as parameter. probably should be...		bkgProp = 0.05		//percent before AND after image to use in baseline sub		bkgLen_P = floor(totalNumSteps * bkgProp)		leftBkg = mean(out,0,bkgLen_P-1)		//x and pnt nums are equal		rightBkg = mean(out,totalNumSteps-1-bkgLen_P,totalNumSteps-1)		bkg = (leftBkg + rightBkg)/2		out -= bkg		setscale/P x, -arcRadius,stepsize,out				if (invert)			out*=-1		endif				Smooth 4, out				WaveStats/Z/Q/P out				//find the rising and falling peak --assumes perfect baseline subtraction so start and end level is 0		if (V_maxLoc != 0)		//need to watch out for bad angles where orthogonal line is straight along cell			edgestats/Q/r=[0,V_maxloc]/L=(0,V_max*0.98)/T=10 out			rise_p1 = V_EdgeLoc1			rise_p5 = V_EdgeLoc2			rise_p9 = V_EdgeLoc3		else			rise_p1 = 0			rise_p5 = 0			rise_p9 = 0		endif		if (V_maxLoc < totalNumSteps-1)			edgestats/Q/r=[V_maxloc,totalNumSteps-1]/L=(V_max*0.98,0)/T=10 out			fall_p1 = V_EdgeLoc1			fall_p5 = V_EdgeLoc2			fall_p9 = V_EdgeLoc3		else			fall_p1 = totalNumSteps-1			fall_p5 = fall_p1			fall_p9 = fall_p1		endif		width_p1 = fall_p1 - rise_p1		width_p5 = fall_p5 - rise_p5		width_p9 = fall_p9 - rise_p9				center_p1 = rise_p1 + width_p1/2		center_p5 = rise_p5 + width_p5/2		center_p9 = rise_p9 + width_p9/2							//fit to gaussian, masking any saturation		fitMaskThreshold = V_max * 0.98		duplicate/o out,tracing_interp_fitMask		tracing_interp_fitMask=out[p] > fitMaskThreshold ? nan : 1		k0=0		curvefit/N=1/Q/W=2/H="1000" gauss out/M=tracing_interp_fitMask		WAVE/D w_Coef		gauss_y0=W_coef[0]		gauss_A=W_coef[1]		gauss_x0=W_coef[2]		gauss_width=W_coef[3]		gauss_fwhm=gauss_width*2*sqrt(2*ln(2))		//full width half max		gauss_fwtm=gauss_width*2*sqrt(2*ln(10))	//full with at one tenth of max		centerCalc=gauss_x0		interpStart=centerCalc-gauss_width/2		interpEnd=interpStart+gauss_width		if (noSave)			return gauss_width		endif				duplicate/o out,interptestfit,interpWidthDisp		interptestfit=	gauss_y0+gauss_A*exp(-((x-gauss_x0)/gauss_width)^2)		//W_coef[0]+W_coef[1]*exp(-((x-W_coef[2])/W_coef[3])^2)		interpWidthDisp=	(x >= interpStart) && (x <= interpEnd) ? 1 : 0	endif		Double center_dx,center_dy,new_x,new_y	if (numtype(m))		//m inf, so vertical		center_dx=0		center_dy=centerCalc	elseif (m==0)			//horizontal		center_dx=centerCalc		center_dy=0	else		center_dx=centerCalc*cos(sectionAngle_rad)		center_dy=centerCalc*sin(sectionAngle_rad)	endif		new_x = xv+center_dx	new_y = yv+center_dy		if (updateCenters)		WAVE segWv= $segRef		segWv[segPntNum][0]=new_x		segWv[segPntNum][1]=new_y		print "oldx",xv,"newx",new_x,"oldy",yv,"newy",new_y	endif		//currently using wit from edgestats, skipping the fit: uncomment other version to use fit stats	tracing_storeZValueForCurrPnt(winN,setToPixelVal=gauss_width/2,setDisplay=1)	//tracing_storeZValueForCurrPnt(winN,setToPixelVal=widthFromfit,setDisplay=1)		tracing_doUpdates(winN,nan,nan,nan)	//Print "m",m,"m2",m2,risePos",risePos, "fallPos",fallPos, "width",width,"centerCalc","tauFromfit",tauFromfit,"riseFromFit",riseFromFit,"fallFromFit",fallFromFit,"widthFromfit",widthFromfit		if (saveRawData)		WAVE/Z interpSave = $interpRef		Variable cols=dimsize(ccWv,0)		Variable rows=dimsize(out,0)				//handle interpolation saving		if (!WaveExists(interpSave) || (rows != dimsize(interpSave,0)) || (cols != dimsize(interpSave,1)) || (segPntNum==0))			Duplicate/o out,$interpRef/wave=interpSave			Duplicate/o out,$interpFitRef/wave=interpFitSave			duplicate/o out,$interpXVals/wave=interpX			duplicate/o out,$interpYVals/wave=interpY			duplicate/o out,$interpWidth/wave=interpW			redimension/n=(-1,cols) interpSave,interpFitSave,interpX,interpY,interpW			interpSave=nan;interpFitSave=nan;interpX=nan;interpY=nan;interpW=nan;		else			wave interpFitSave = $interpFitRef			wave interpX = $interpXVals			wave interpY = $interpYVals			wave interpW = $interpWidth		endif			interpSave[][ccPntNum] = out[p]		interpFitSave[][ccPntNum] = interptestfit[p]		interpX[][ccPntNum] = tracing_interpXYVals[p][0]		interpY[][ccPntNum] = tracing_interpXYVals[p][1]		interpW[][ccPntNum] = interpWidthDisp[p]	endif		if (strlen(resultsRef) && WAveExists($resultsRef))		Variable paramsStart = 0		wave/d results = $resultsRef		Variable c=0;results[ccPntNum][paramsStart+c]=sectionAngle		c+=1;results[ccPntNum][paramsStart+c]=numArcRadiusSteps		c+=1;results[ccPntNum][paramsStart+c]=m		c+=1;results[ccPntNum][paramsStart+c]=xv		c+=1;results[ccPntNum][paramsStart+c]=yv				c+=1;results[ccPntNum][paramsStart+c]=zv		c+=1;results[ccPntNum][paramsStart+c]=yint		c+=1;results[ccPntNum][paramsStart+c]=stepSize		c+=1;results[ccPntNum][paramsStart+c]=totalNumSteps		c+=1;results[ccPntNum][paramsStart+c]=dx				c+=1;results[ccPntNum][paramsStart+c]=dy		c+=1;results[ccPntNum][paramsStart+c]=orthoNum		c+=1;results[ccPntNum][paramsStart+c]=padPix		c+=1;results[ccPntNum][paramsStart+c]=averageCount		c+=1;results[ccPntNum][paramsStart+c]=rise_p1				c+=1;results[ccPntNum][paramsStart+c]=fall_p1		c+=1;results[ccPntNum][paramsStart+c]=width_p1		c+=1;results[ccPntNum][paramsStart+c]=center_p1			c+=1;results[ccPntNum][paramsStart+c]=rise_p5		c+=1;results[ccPntNum][paramsStart+c]=fall_p5				c+=1;results[ccPntNum][paramsStart+c]=width_p5		c+=1;results[ccPntNum][paramsStart+c]=center_p5			c+=1;results[ccPntNum][paramsStart+c]=rise_p9		c+=1;results[ccPntNum][paramsStart+c]=fall_p9		c+=1;results[ccPntNum][paramsStart+c]=width_p9				c+=1;results[ccPntNum][paramsStart+c]=center_p9				c+=1;results[ccPntNum][paramsStart+c]=fitMaskThreshold		c+=1;results[ccPntNum][paramsStart+c]=gauss_y0		c+=1;results[ccPntNum][paramsStart+c]=gauss_A				c+=1;results[ccPntNum][paramsStart+c]=gauss_x0				c+=1;results[ccPntNum][paramsStart+c]=gauss_width	 		c+=1;results[ccPntNum][paramsStart+c]=gauss_width/2				c+=1;results[ccPntNum][paramsStart+c]=centerCalc				c+=1;results[ccPntNum][paramsStart+c]=center_dx		c+=1;results[ccPntNum][paramsStart+c]=center_dy				c+=1;results[ccPntNum][paramsStart+c]=new_x		c+=1;results[ccPntNum][paramsStart+c]=new_y 		c+=1;results[ccPntNum][paramsStart+c]=interpStart 		c+=1;results[ccPntNum][paramsStart+c]=interpEnd 		c+=1;results[ccPntNum][paramsStart+c]=gauss_fwhm 				c+=1;results[ccPntNum][paramsStart+c]=gauss_fwhm/2 		c+=1;results[ccPntNum][paramsStart+c]=gauss_fwtm 		c+=1;results[ccPntNum][paramsStart+c]=gauss_fwtm/2 //43						setdimlabel 0, ccPntNum,$GetDimLabel(ccwv, 0, ccPntNum ),results		if (ccPntNum==0)			c=0;SetDimLabel 1,paramsStart+c,sectionAngle,results			c+=1;SetDimLabel 1,paramsStart+c,numArcRadiusSteps,results			c+=1;SetDimLabel 1,paramsStart+c,m,results			c+=1;SetDimLabel 1,paramsStart+c,xv,results			c+=1;SetDimLabel 1,paramsStart+c,yv,results						c+=1;SetDimLabel 1,paramsStart+c,zv,results			c+=1;SetDimLabel 1,paramsStart+c,yint,results			c+=1;SetDimLabel 1,paramsStart+c,stepSize,results			c+=1;SetDimLabel 1,paramsStart+c,totalNumSteps,results			c+=1;SetDimLabel 1,paramsStart+c,dx,results						c+=1;SetDimLabel 1,paramsStart+c,dy,results			c+=1;SetDimLabel 1,paramsStart+c,orthoNum,results			c+=1;SetDimLabel 1,paramsStart+c,padPix,results			c+=1;SetDimLabel 1,paramsStart+c,averageCount,results			c+=1;SetDimLabel 1,paramsStart+c,rise_p1,results						c+=1;SetDimLabel 1,paramsStart+c,fall_p1,results			c+=1;SetDimLabel 1,paramsStart+c,width_p1,results			c+=1;SetDimLabel 1,paramsStart+c,center_p1	,results			c+=1;SetDimLabel 1,paramsStart+c,rise_p5,results			c+=1;SetDimLabel 1,paramsStart+c,fall_p5,results						c+=1;SetDimLabel 1,paramsStart+c,width_p5,results			c+=1;SetDimLabel 1,paramsStart+c,center_p5	,results			c+=1;SetDimLabel 1,paramsStart+c,rise_p9,results			c+=1;SetDimLabel 1,paramsStart+c,fall_p9,results			c+=1;SetDimLabel 1,paramsStart+c,width_p9,results						c+=1;SetDimLabel 1,paramsStart+c,center_p9	,results				c+=1;SetDimLabel 1,paramsStart+c,fitMaskThreshold,results			c+=1;SetDimLabel 1,paramsStart+c,gauss_y0,results			c+=1;SetDimLabel 1,paramsStart+c,gauss_A	,results				c+=1;SetDimLabel 1,paramsStart+c,gauss_x0,results						c+=1;SetDimLabel 1,paramsStart+c,gauss_width	 ,results			c+=1;SetDimLabel 1,paramsStart+c,gauss_radius,results			c+=1;SetDimLabel 1,paramsStart+c,centerCalc,results			c+=1;SetDimLabel 1,paramsStart+c,center_dx,results			c+=1;SetDimLabel 1,paramsStart+c,center_dy,results						c+=1;SetDimLabel 1,paramsStart+c,new_x,results			c+=1;SetDimLabel 1,paramsStart+c,new_y,results			c+=1;SetDimLabel 1,paramsStart+c,interpStart,results			c+=1;SetDimLabel 1,paramsStart+c,interpEnd,results			c+=1;SetDimLabel 1,paramsStart+c,gauss_fwhm,results						c+=1;SetDimLabel 1,paramsStart+c,gauss_fwhm_radius,results			c+=1;SetDimLabel 1,paramsStart+c,gauss_fwtm,results			c+=1;SetDimLabel 1,paramsStart+c,gauss_fwtm_radius,results		endif	endif	if (invert) //swap back now	//	out*=-1	//	interptestfit*=-1	endif		WAVE/Z interp_disp	if (!waveexists(interp_disp))		make/o/n=(2,2) interp_disp	endif		interp_disp[][1] = 0.5		//y values 0.5 sets height on graph	interp_disp[0][0] = risePos	interp_disp[1][0] = fallPos	endfunction tracing_interpz(sectionAngle,arcRadius,numArcRadiusSteps,ccPntNum,winN,outRef)	Variable ccPntNum; String winN	Double sectionAngle		//estimated angle of neuron local to this point e.g. from calls to tracing_getXYSlope()	Variable arcRadius			//number of pixels of length to interpolate on either side of point	Variable numArcRadiusSteps	//number of steps within that length to take	String outRef				//interpolated result		Variable orthoNum = 0		//number of orthogonal steps to add to average. 1 is an average of 3: main line, one negative and one positive orthogonal line	Variable padPix = 20	Variable initZRadius = 10		if (!strlen(winN))		winN = winname(0,1)	endif	String tracedWaveName = tracing_getTracedWvNmFromWinN(winN)	String combinedSegRef = tracing_getCombinedSegref(tracedWaveName)	WAVE/D ccWv = $combinedSegRef	String segLabel = 	GetDimLabel(ccwv, 0, ccPntNum)		if (!strlen(segLabel))		Print "tracing_interp(): could not find seg label! aborting"		return 0	endif		Variable segNum = tracing_segNumFromSegRef(segLabel)	Variable segPntNum = tracing_getSegPntFromSegRef(segLabel)	String segRef = tracing_getSegNameForCCPnt(winN,ccPntNum)	WAVE segWv= $segRef		Double m = tan(sectionAngle*pi/180)	Double xv = ccWv[ccPntNum][0],dx	Double yv = ccWv[ccPntNum][1],dy	Double zv = ccWv[ccPntNum][4]		Double yint = -m*xv + yv	Variable stepSize = arcRadius / numArcRadiusSteps	Variable totalNumSteps = 1 + 2*numArcRadiusSteps		//get value at center point and values along radius on either side	Make/O/D/N=(totalNumSteps) $outRef/wave=out	Make/o/d/N=(totalNumSteps,2) tracing_interpXYVals		if (m == 0)		//flat line, dx = stepSize		dx = stepSize		dy = 0	elseif (numtype(m) == 1)		//verticle line dy = stepSize, dx = 0		dx = 0		dy = stepSize	else		dx = stepSize/sqrt(1+m^2)		dy = stepSize/sqrt(1+(1/m^2)) * ( (m < 0) ? -1 : 1)		//slope information not held in dx,dy calc, add that with by multipying by -1 or 1	endif	Double m2 = dy/dx	tracing_interpXYVals[][0] = xv + (p-numArcRadiusSteps)*dx		//x values	tracing_interpXYVals[][1] = yv + (p-numArcRadiusSteps)*dy		//y values		imagetransform/PTYP=0/P=(zv) getplane $tracedWaveName	WAVE/D M_imagePlane	Redimension/N=(-1,-1) M_ImagePlane	img_cropToCenter(xv,yv,2*arcRadius+padPix,M_ImagePlane,"tracing_interpTemp")	ImageInterpolate/U=8/Dest=tracing_interpTemp2 bilinear $"tracing_interpTemp"	out = tracing_interpTemp2(xv + (p-numArcRadiusSteps)*dx)(yv + (p-numArcRadiusSteps)*dy)		Variable averageCount = 1		Variable i,orthoMult	for (i=0;i<orthoNum;i+=1)		orthoMult = i+1		out += tracing_interpTemp2(xv-dx*orthoMult + (p-numArcRadiusSteps)*dx)(yv+dy*orthoMult + (p-numArcRadiusSteps)*dy)		orthoMult *= -1		//to get other direction		out += tracing_interpTemp2(xv-dx*orthoMult + (p-numArcRadiusSteps)*dx)(yv+dy*orthoMult + (p-numArcRadiusSteps)*dy)		averageCount += 2	endfor	out /= averageCount	setscale/P x, -arcRadius,stepsize,out	WaveStats/Z/Q/P out		edgestats/Q/r=[0,V_maxloc]/L=(V_max*0.05,V_max*0.95)/F=0.25/T=10 out	Double risePos = V_EdgeLoc1	edgestats/Q/r=[V_maxloc,totalNumSteps-1]/L=(V_max*0.95,V_max*0.05)/T=10 out	Double fallPos = V_EdgeLoc3		Double centerCalc = risePos + (fallPos - risePos)/2	Double width = fallPos - risePos		Double normFactor = 0.95*V_max	out /= normFactor	Make/O/D/N=(3) tracing_interpfitCoefs	tracing_interpfitCoefs[0] = 2.3		//got this in an initial test run	tracing_interpfitCoefs[1] = risePos	tracing_interpfitCoefs[2] = fallPos		FuncFit/N=1/Q/W=2 fit_simpleSigmoids,tracing_interpfitCoefs,out	Double tauFromfit = tracing_interpfitCoefs[0]	Double riseFromFit = min(tracing_interpfitCoefs[1],tracing_interpfitCoefs[2])	Double fallFromFit = max(tracing_interpfitCoefs[1],tracing_interpfitCoefs[2])	Double widthFromfit = fallFromfit-riseFromFit	Duplicate/o out, interptestfit	interptestfit = fit_simpleSigmoids(tracing_interpfitCoefs,x)		tracing_storeZValueForCurrPnt(winN,setToPixelVal=widthFromfit,setDisplay=1)		tracing_doUpdates(winN,nan,nan,nan)	//Print "risePos",risePos, "fallPos",fallPos, "width",width,"centerCalc","tauFromfit",tauFromfit,"riseFromFit",riseFromFit,"fallFromFit",fallFromFit,"widthFromfit",widthFromfitendfunction img_cropToCenter(xCenter,yCenter,size,inWv,outRef)	Variable xCenter,yCenter,size		//all in pixels, e.g., rows/cols	WAVE inWv	String outRef		if (mod(size,2) != 0)		size+=1		//force evenness, so that same number of rows/cols in either direction from center	endif		Variable sizeOnSide = size/2	variable xStart = xCenter-sizeOnSide	Variable xEnd = xCenter+size		//note that e.g. duplicate/r=[xStart,xStart+size] will actually center the xValue by including one more point that size	Variable yStart = yCenter-sizeOnSide	Variable yEnd = yCenter+size			//NEWNEWNEWNEW//	xStart=max(xStart,dimsize(inwv,0))//	xEnd=min(xEnd,dimsize(inwv,0))//	yStart=max(yStart,dimsize(inwv,1))//	yEnd=min(yEnd,dimsize(inwv,1))		Duplicate/O/R=[xStart,xEnd][yStart,yEnd] inWv, $outRef		endfunction img_maskAroundCenter(xCenter,yCenter,maskFullLen_pix,maskForParticleNotThreshold,inWv,outRef)	Variable xCenter,yCenter,maskFullLen_pix		//all in pixels, e.g., rows/cols	WAVE inWv	String outRef	VAriable maskForParticleNotThreshold	//pass to specify type of output			//if 0 (for threshold) type is /b/u and outside ROI == 0, in ROI == 1			//if 1 (for imageanalyzeparticles) type is still /b/u but outside ROI = 1 and in = 0					if (mod(maskFullLen_pix,2) != 0)		maskFullLen_pix+=1		//force evenness, so that same number of rows/cols in either direction from center	endif		Variable sizeOnSide = maskFullLen_pix/2	variable xStart = xCenter-sizeOnSide	Variable xEnd = xCenter+sizeOnSide		//note that e.g. duplicate/r=[xStart,xStart+size] will actually center the xValue by including one more point that size	Variable yStart = yCenter-sizeOnSide	Variable yEnd = yCenter+sizeOnSide		Variable valAtUnmaskedPixels, valAtMaskedPixels	Variable dim0 = dimsize(inWv,0)	Variable dim1 = dimsize(inWv,1)	make/o/b/u/n=(dim0,dim1) $outref/wave=out	if (maskForParticleNotThreshold)		valAtUnmaskedPixels = 0		valAtMaskedPixels = 1	else		valAtUnmaskedPixels = 0		valAtMaskedPixels = 1		endif		out = (p < xStart) || (p > xEnd) || (y < yStart) || (y > yEnd) ? valAtMaskedPixels : valAtUnmaskedPixelsendfunction ellipse_momentsToCoords(points,outRef_params,outRef_ellipse,inclParamDimLabels)	Variable points	//number of points 	String outRef_params,outRef_ellipse		//pass "" to skip either one. params still calculated but not saved if the former is ""	Variable inclParamDimLabels		//pass to include param dim labels		Variable particleNum = 0		if (numtype(points) != 0)		points = 400		//default plot size	endif		WAVE M_Moments		//from imageanalyzeparticles		Double xCenter = M_moments[particleNum][0]	Double yCenter = M_moments[particleNum][1]	Double majorAxisRadius = M_moments[particleNum][2]	Double minorAxisRadius = M_moments[particleNum][3]	Double angle_rad = M_moments[particleNum][4]		Print "xCenter",xCenter,"yCenter",yCenter,"majorAxisRadius",majorAxisRadius,"minorAxisRadius",minorAxisRadius,"angle_rad",angle_rad	return elipse_coords(xCenter,yCenter,majorAxisRadius,minorAxisRadius,angle_rad,points,outRef_params,outRef_ellipse,inclParamDimLabels)end//the X-center of the ellipse, the Y-center of the ellipse, the major axis, the minor axis, //and the angle (radians) that the major axis makes with the X-direction.function elipse_coords(xCenter,yCenter,majorAxisRadius,minorAxisRadius,angle_rad,points,outRef_params,outRef_ellipse,inclParamDimLabels)	Double xCenter,yCenter,majorAxisRadius,minorAxisRadius,angle_rad,points	String outRef_params,outRef_ellipse		//pass "" to skip either one. params still calculated but not saved if the former is ""	Variable inclParamDimLabels		//pass to include param dim labels			Double majorAxis_p0x = xCenter - majorAxisRadius*cos(angle_rad-pi)		//not sure why but x needs a mirror image flip to overlay	Double majorAxis_p1x = xCenter + majorAxisRadius*cos(angle_rad-pi)	Double majorAxis_p0y = yCenter - majorAxisRadius*sin(angle_rad)	Double majorAxis_p1y = yCenter + majorAxisRadius*sin(angle_rad)		Double minorAxis_p0x = xCenter - minorAxisRadius*cos(angle_rad-pi)	Double minorAxis_p1x = xCenter + minorAxisRadius*cos(angle_rad-pi)	Double minorAxis_p0y = yCenter - minorAxisRadius*sin(angle_rad)	Double minorAxis_p1y = yCenter + minorAxisRadius*sin(angle_rad)		Double w = atan2(majorAxis_p1y-majorAxis_p0y,majorAxis_p1x-majorAxis_p0x);			if (strlen(outRef_params))		Variable numParams = 6 + 9 + 1		//input params + ellipse calculation params + derived params		make/o/d/n=(numParams) $outRef_params/wave=outp		outp[0] =  xCenter		outp[1] =  yCenter		outp[2] =  majorAxisRadius		outp[3] =  minorAxisRadius		outp[4] =  angle_rad		outp[5] =  points			outp[6] =  majorAxis_p0x		outp[7] =  majorAxis_p1x		outp[8] =  majorAxis_p0y		outp[9] =  majorAxis_p1y		outp[10] =  minorAxis_p0x		outp[11] =  minorAxis_p1x		outp[12] =  minorAxis_p0y		outp[13] =  minorAxis_p1y		outp[14] =  w		outp[15] =  majorAxisRadius/minorAxisRadius	//how much larger was major than minor axis?		if (inclParamDimLabels)			SetDimLabel 0,0,xCenter,outp			SetDimLabel 0,1,yCenter,outp			SetDimLabel 0,2,majorAxisRadius,outp			SetDimLabel 0,3,minorAxisRadius,outp			SetDimLabel 0,4,angle_rad,outp			SetDimLabel 0,5,points	,outp			SetDimLabel 0,6,majorAxis_p0x,outp			SetDimLabel 0,7,majorAxis_p1x,outp			SetDimLabel 0,8,majorAxis_p0y,outp			SetDimLabel 0,9,majorAxis_p1y,outp			SetDimLabel 0,10,minorAxis_p0x,outp			SetDimLabel 0,11,minorAxis_p1x,outp			SetDimLabel 0,12,minorAxis_p0y,outp			SetDimLabel 0,13,minorAxis_p1y,outp			SetDimLabel 0,14,w,outp			SetDimLabel 0,15,ratio_MajorToMinorRad,outp	//how much larger was major than minor axis?						endif	endif		if (strlen(outRef_ellipse))		ellipse_plot(points,majorAxisRadius,minorAxisRadius,w,majorAxis_p0x,majorAxis_p1x,majorAxis_p0y,majorAxis_p1y,outRef_ellipse)	endif			//Print "majorAxis_p0x",majorAxis_p0x,"majorAxis_p1x",majorAxis_p1x,"majorAxis_p0y",majorAxis_p0y,"majorAxis_p1y",majorAxis_p1y	return minorAxisRadius*2endfunction ellipse_plot(points,majorAxisRadius,minorAxisRadius,w,majorAxis_p0x,majorAxis_p1x,majorAxis_p0y,majorAxis_p1y,outRef)	Variable points //number of points calculated (density/resolution)	String outRef		//place to store	Double majorAxisRadius	//rest are as in elipse_coords	Double minorAxisRadius	Double w	Double majorAxis_p0x	Double majorAxis_p1x	Double majorAxis_p0y	Double majorAxis_p1y		if (!strlen(outRef))		return 0	endif		Variable usedPnts	if (!numtype(points))		//passed has precedence		usedPnts = points	else		usedPnts = 50		//default #	endif		make/o/d/n=(usedPnts)/Free arrx,arry	Make/O/D/N=(usedPnts,2) $outRef/wave=out	arrx=majorAxisRadius*cos(p*2*pi/usedPnts);	arry=minorAxisRadius*sin(p*2*pi/usedPnts);	out[][0] = (majorAxis_p0x+majorAxis_p1x)/2 + arrx[p]*cos(w) - arry[p]*sin(w)		//x values	out[][1] = (majorAxis_p0y+majorAxis_p1y)/2 + arrx[p]*sin(w) + arry[p]*cos(w)		//y values	setdimlabel 1,0,xPos,out	setdimlabel 1,1,yPos,outendfunction tracing_fitAllSecs(winN)	String winN		if (!strlen(winN))		winN = winname(0,1)	endif		Variable i		String tracedWaveName = tracing_getTracedWvNmFromWinN(winN)	String combinedSegRef = tracing_getCombinedSegref(tracedWaveName)	WAVE/D combinedSegWv = $combinedSegRef		Variable numPoints = dimsize(combinedSegWv,0)	for (i=0;i<numPoints;i+=1)		tracing_fitSec(winN,i)	endforend//calls tracing_fitEllipse which fits an ellipse at the current z plane//redimensions the segment params wave and stores ellipse parameters//without changing original parameters//stores results from  tracing_fitEllipse and its sub-functionsfunction tracing_fitSec(winN,ccPntNum)	String winN	Variable ccPntNum 	//pnt num in [img_name]_cc wave		Variable tracing_plotEllipses = 1	//1 to plot, 0 to hide	Variable maskFullLen_pix = 100		//WARNING MAY BE DRAMATICALLY EFFECTED BY PIXEL DENSITY	Variable inclParamDimLabels = 0		//see ellipse_momentsToCoords		if (!strlen(winN))		winN = winname(0,1)	endif		//get its center loc	//extract its z plane based on zLoc	//mask around region based on center loc and maskWidthHeight_pix	//threshold based on...	//fit ellipse	//store fit info after resizing segment data refs	//set radius to small ellipse radius		String tracedWaveName = tracing_getTracedWvNmFromWinN(winN)	String combinedSegRef = tracing_getCombinedSegref(tracedWaveName)	WAVE/D combinedSegWv = $combinedSegRef		String segLabel = 	GetDimLabel(combinedSegWv, 0, ccPntNum)		if (!strlen(segLabel))		return 0	endif		Variable segNum = tracing_segNumFromSegRef(segLabel)	Variable segPntNum = tracing_getSegPntFromSegRef(segLabel)	String segRef = tracing_getSegNameForCCPnt(winN,ccPntNum)	Variable origParams = 7		//number of parameters included before adding ellipse analysis	Wave/D segWv = $segRef	Variable likelyIncorrectDims = dimsize(segWv,1) <= origParams	inclParamDimLabels = max(inclParamDimLabels,likelyIncorrectDims)		//if either is 1, will set inclParamDimLabels to 1 	Variable origCenterPixX = 	segWv[segPntNum][0]	//anything with "orig" is potential changed below and so the original is stored	Variable origCenterPixY = 	segWv[segPntNum][1]	Variable origNearestPixX = segWv[segPntNum][2]		Variable origNearestPixY = segWv[segPntNum][3]		Variable origRadiusPnts = segWv[segPntNum][5]	Variable origRadiusPix = segWv[segPntNum][6]	Variable zPixLoc = segWv[segPntNum][4]		//grab the image at the z plane	imagetransform/PTYP=0/P=(zPixLoc) getplane $tracedWaveName	WAVE M_imagePlane	Redimension/N=(-1,-1) M_imagePlane	//appears to have a third dimension of length 1 instead of 0 from imagetransform		String outRef_params = "tracing_ellipseParamsTemp"		tracing_fitEllipse(M_imagePlane,origCenterPixX,origCenterPixY,maskFullLen_pix,inclParamDimLabels,outRef_params,"ellipseFitTest")	WAVE/D ellipseParams = $outRef_params		Variable numEllipsePArams = dimsize($outRef_params,0)		//expect 7 for origParams and 16 for numEllipseParams. If changes, update tracing_numParamCols	Variable numColsNeeded = origParams + numEllipsePArams	Variable needsRedimension = dimsize(segWv,1) < numColsNeeded	if (needsRedimension)		redimension/N=(-1,numColsNeeded) segWv		//segWv[segPntNum][origParams,2*origParams-1] = segWv[p][q-origParams]		//save all original parameters	endif	Variable ellipseParamsStart = 2*origParams	segWv[segPntNum][origParams,*] = ellipseParams[q-origParams]end//takes in a 2d wave and fits an ellipse. if centerX,center, and maskFullLen_pix are specified, then fits in the subregion they describefunction tracing_fitEllipse(imgWv,centerPixX,centerPixY,maskFullLen_pix,inclParamDimLabels,outRef_params,outRef_ellipse)	WAVE imgWv	Double centerPixX,centerPixY,maskFullLen_pix	String outRef_params,outRef_ellipse	Variable inclParamDimLabels	//see ellipse_momentsToCoords		Variable minArea = pi*4^2			//			NVAR/Z tracing_plotEllipses	if (!NVAR_exists(tracing_plotEllipses))		Variable/G tracing_plotEllipses = 1 //default for now is to plot ellipses	endif		//mask for thresholding	Variable maskForParticleNotThreshold = 0	img_maskAroundCenter(centerPixX,centerPixY,maskFullLen_pix,maskForParticleNotThreshold,imgWv,"tracing_fitEllipseTemp0")	imagethreshold/R=$"tracing_fitEllipseTemp0"/M=1/I/Q imgWv	WAVE M_imageThresh	maskForParticleNotThreshold = 1	img_maskAroundCenter(centerPixX,centerPixY,maskFullLen_pix,maskForParticleNotThreshold,M_ImageThresh,"tracing_fitEllipseTemp")	imageanalyzeparticles/E/R=$"tracing_fitEllipseTemp"/Q/A=(minArea)/F stats M_imageThresh	//imageanalyzeparticles/E/Q/A=(minArea) stats M_imageThresh		ellipse_momentsToCoords(nan,outRef_params,outRef_ellipse,inclParamDimLabels)		//endfunction tracing_calcEllipsePlots(winN)	String winN		Variable numEllipsePlotPoints = 100	Variable numLayers = 2			//likely 2: one layer for x values, 1 layer for y values		if (!strlen(winN))		winN = winname(0,1)	endif	String tracedWaveName = tracing_getTracedWvNmFromWinN(winN)	String combinedSegRef = tracing_getCombinedSegref(tracedWaveName)	WAVE/D combinedSegWv = $combinedSegRef	Variable numRows = dimsize(combinedSegWv,0)		String plotWvRef = tracing_getPlottedEllipseWvName(winN)	WAVE/D/Z plotWv = $plotWvRef	if (!waveExists(plotWv))		Make/O/D/N=(numRows,numEllipsePlotPoints,numLayers) $plotWvRef/wave=plotWv	else		if (dimsize(plotWv,0) != numRows)			Redimension/N=(numRows,-1,numLayers) plotWv		endif		if (dimsize(plotWv,1) != numEllipsePlotPoints)			Redimension/N=(-1,numEllipsePlotPoints,numLayers) plotWv		endif	endif		Variable i	Variable xCenter,yCenter,majorAxisRadius,minorAxisRadius,angle_rad	Variable xCenter_P,yCenter_P,majorAxisRadius_P,minorAxisRadius_P,angle_rad_P	xCenter_P=FindDimLabel(combinedSegWv,1,"xCenter")	yCenter_P=FindDimLabel(combinedSegWv,1,"yCenter")	majorAxisRadius_P=FindDimLabel(combinedSegWv,1,"majorAxisRadius")	minorAxisRadius_P=FindDimLabel(combinedSegWv,1,"minorAxisRadius")	angle_rad_P=FindDimLabel(combinedSegWv,1,"angle_rad")	String outRef_params = ""		//pass null to skip storing params, which makes sense since they should have been calculated previously	Variable inclParamDimLabels = 0		//only matters when outRef_params is not null	String outRef_ellipse = "tracing_ellipsePlotTemp"	for (i=0;i<numRows;i+=1)		xCenter = combinedSegWv[i][xCenter_P]		yCenter = combinedSegWv[i][yCenter_P]		majorAxisRadius = combinedSegWv[i][majorAxisRadius_P]		minorAxisRadius = combinedSegWv[i][minorAxisRadius_P]		angle_rad = combinedSegWv[i][angle_rad_P]		elipse_coords(xCenter,yCenter,majorAxisRadius,minorAxisRadius,angle_rad,numEllipsePlotPoints,outRef_params,outRef_ellipse,inclParamDimLabels)		//if (i==0)			WAVE/D ellipseTemp = $outRef_ellipse		//endif		plotWv[i][][0] = ellipseTemp[q][0]		plotWv[i][][1] = ellipseTemp[q][1]		if (i==1052)			Print "xCenter",xCenter,"yCenter",yCenter,"majorAxisRadius",majorAxisRadius,"minorAxisRadius",minorAxisRadius,"angle_rad",angle_rad		endif	endforendfunction nrn_tracing_toHoc(winN,neuron_name,xyMicronsPerPix,zMicronsPerPix,[alsoSaveWithSegAppendStr,saveWithSegAppendStr,fullPathStr,ssf])	String winN,neuron_name	Double xyMicronsPerPix,zMicronsPerPix		//saves from pixel measurements, so needs these conversion factors to save in microns	String alsoSaveWithSegAppendStr		//optionally pass to also save a copy where all segment names have this string appended												//useful for creating two copies of the cell for parallel fitting		..output file name also received append str	String saveWithSegAppendStr			//as above but only save with segments names that have this string appended, do not save original segment names	String fullPathStr	Variable ssf		//same save folder for repeated saving		String nlc = "\r\n"		//new line characters .. \r\n looks right in txt opened in notepad	if (strlen(winN) < 1)		winN = winname(0,1)	endif		if (strlen(neuron_name) < 1)		neuron_name = tracing_getTracedWvNmFromWinN(winN)	endif		String segNameAppendStr=""	if (!ParamIsDefault(saveWithSegAppendStr) && (strlen(saveWithSegAppendStr)>0) )		segNameAppendStr=saveWithSegAppendStr	endif	Variable refNum	String fileFilters = "Hoc Files (*.hoc):.hoc;"		if (!paramIsDefault(fullPathStr) && (strlen(fullPathStr)>0))		newpath/o/q/z nrn_tracing_toHocPath,fullPathStr		if (V_flag != 0)		//failed			Open/F=fileFilters/M="Failed to store path after first save -- do manual"  refNum as "anat"+segNameAppendStr+".hoc"		else			Open/F=fileFilters/p=nrn_tracing_toHocPath refNum as "anat"+segNameAppendStr+".hoc"		endif	else		pathinfo $"nrn_tracing_toHocPath"		if (!paramIsDefault(ssf) && ssf && V_flag)			Open/F=fileFilters/p=nrn_tracing_toHocPath refNum as "anat"+segNameAppendStr+".hoc"		else			Open/F=fileFilters refNum as "anat"+segNameAppendStr+".hoc"		endif	endif	String saveFullPathStr = S_fileName	if (!refNum)		return -1	endif		variable i,j,numSpecLines = 2	Make/t/o/n=(numSpecLines)/free specs	specs[0] = "strdef neuron_name"	specs[1] = "neuron_name = \"" + neuron_name +"\""	String cs = "\tpt3dadd("		//command start: each point is specificed by starting with this prefix (a tab and then the command then open parenthesis)	String ce = ")"+nlc				//command end: each point ends with close parenthesis and new line		for (i=0;i<numSpecLines;i+=1)		fprintf refNum,"%s%s",specs[i],nlc	endfor		fprintf refNum,"%s",nlc		//add a blank line		String tracedWaveName = tracing_getTracedWvNmFromWinN(winN)	String indexWvRef = tracing_getTracingIndexWaveRef(tracedwaveName)	WAVE/T indexWv = $indexWvRef		Variable numSegs = dimsize(indexWv,0),pnts	Variable xPixLoc = 0, yPixLoc = 1, zPixLoc = 4,radiusPixLoc=6	//should match combined wave dim labels	Double x0,y0,z0			Double xv,yv,zv,dv	String segName,segref,line,lastSegName	for (i=0;i<numSegs;i+=1)		segName = indexWv[i][1]+segNameAppendStr		segRef = indeXwv[i][0]		WAVE seg = $segref		pnts = dimsize(seg,0)		fprintf refNum,"create %s%s",segName,nlc		fprintf refNum,"%s {%s",segName,nlc		//start each segment specification with name {		fprintf refNum,"\t%s%s","pt3dclear()",nlc	//then pt3dclear() command, using tabs for everything within the segment's brackets		//print this sections points		for (j=0;j<pnts;j+=1)			if (j==0)			//the first point in each segment should connect to the previous one and should be a zero in relative coordinates								//that's my take away, though its not really stated that clearly								//here's the best refs. 								//http://www.neuron.yale.edu/neuron/static/new_doc/modelspec/programmatic/topology/geometry.html#d-specification-of-geometry								//http://www.neuron.yale.edu/phpBB/viewtopic.php?f=13&t=3277&p=13778&hilit=+pt3dadd+coordinates#p13778				x0 = seg[j][xPixLoc]				y0 = seg[j][yPixLoc]				z0 = seg[j][zPixLoc]			endif			xv = (seg[j][xPixLoc]-x0)*xyMicronsPerPix		//current x,y,z values (as microns offset from first point)			yv = (seg[j][yPixLoc]-y0)*xyMicronsPerPix			zv = (seg[j][zPixLoc]-z0)*zMicronsPerPix			dv = 2*seg[j][radiusPixLoc]*xyMicronsPerPix			fprintf refNum, "%s%40.35f,%40.35f,%40.35f,%40.35f%s",cs,xv,yv,zv,dv,ce							endfor				fprintf refNum,"}%s%s",nlc,nlc				//end each segment specification with } and a new line				//connect segments to preceding segment unless its the first segment		if (i > 0)			lastSegName = indexWv[i-1][1]+segNameAppendStr			fprintf refNum,"connect %s(0), %s(1)%s%s",segName,lastSegName,nlc,nlc		//prints the line then adds a space		endif	endfor				fprintf refNum,"define_shape()%s",nlc		//recommended to call this, no fucking clue what it does	close refNum		if (!ParamIsdefault(alsoSaveWithSegAppendStr) && (strlen(alsoSaveWithSegAppendStr)>0) )		nrn_tracing_toHoc(winN,neuron_name,xyMicronsPerPix,zMicronsPerPix,saveWithSegAppendStr=alsoSaveWithSegAppendStr,fullPathStr=saveFullPathStr)	endifend//uses the bruxton macros to get info about epochs used during a clampex abf file//not all info is extracted, though its possible that all of it could be, an example of something missing is whether there were pulses or sine waves etc.//at least some of that information could be gleaned with the bruxton macro ABFEpochGetPrototype//after running this function, type into the command line edit/k=1 $outRef.ld (aka outputWaveName.ld) to see the data. click on top right of table to move through sweeps (in layers)//use CTRL + ALT + up/down arrow to select from the channels that were active //returns 1 if file was episodic, 0 if not, -1 for failure to open ABFfunction da_fd_calcStimInfo(fileNum,filePath,outRef,[usePreOpenedABF])		Variable fileNum		//pass a file number if the file has been catalogued and the paths are up to date for the computer being used	String filePath			//if not, pass nan for fileNum and pass the full path to the file into filePath	String outRef			//place to save info	Variable usePreOpenedABF	//pass to use (and leave unaltered the currently opened file		Variable useFilePanel		//if used (by passing a fileNum), saves a copy of the info for future reference		Variable openABF = ParamIsdefault(usePreOpenedABF) || !usePreOpenedABF		String pathUsed	if (numtype(fileNum))		pathUsed = filePath		useFilePanel = 0		if (strlen(outRef) < 1)			outRef = "epochInfo"		endif	else		pathUsed = fd_getFilePathFromFileDir(fileNum)		useFilePanel = 1				if (strlen(outRef) < 1)			outRef = fd_getEpochInfoRef(fileNum,1)		endif	endif		if (openABF)		Variable openFailure = da_openABF(pathUsed, reportFailure=1)		//retuns 0 for successful open, > 0 for unsuccessful		if (openFailure)			return -1		endif		endif		//parameters have to be globals so that macros can be run from the function (at the command line)	Variable/G getStim_status		//0 for no error	Variable noEpochStatus = 13		//status 13 is an expected error state when there are no more epochs for the channel. The function will look out for this to determine how many epochs there are											//I believe that the number of epochs should be constant so we should not have to check each sweep											//some other epoch parameters are also constant (e.g. type), but they get returned anyway so might as well log them in case that becomes incorrect		Variable invalidChannelStatus = 10		//status return when channel is invalid	Variable nonEpisodicFileStatus = 20		//status returns 20 when a file is non-episodic; if this is found the function aborts	Variable/G getStim_type		//type of the epoch: 0:disabled,1:step,2:ramp	 	Variable/G getStim_duration	//epoch length in sample points	Variable/G getStim_amplitude	//amplitude of epoch		--ramps go from this amplitude to the starting amplitude of the next epoch, I believe	Variable/G getStim_digital	//digital output pattern, not sure if this bitwise?	Variable/G getStim_currChanNum	Variable/G getStim_currEpochNum			Variable/G getStim_initHoldAmp	Variable/G getStim_initHoldDur	Variable/G getStim_finalHoldAmp	Variable/G getStim_finalHoldDur				Variable numCommandChannels = 4	//there are 4 possible command/stimulus channels	String epochList = ""		//there are 4 possible command/stimulus channels; this will track which epoch numbers are valid for each channel									//at this time it appears that epochs will not switch valid/invalid status within a file, so this is only checked once, then invalid epochs are ignored									//tracking: epochList will be a semi-colon delimited list, within it will be kept comma delimited lists with the valid epoch numbers for each		Variable maxNumEpochs = 10	//each channel may have up to 10 epochs (A-J in clampex10), during the first sweep, each channel is scanned and this value updated based on when noEpochStatus is returned	Make/I/O/Free/N=(numCommandChannels) epochsCount		//stores a simple count of the number of epochs found 	epochsCount = 0	Variable numChansWithValidEpochs = 0	String validEpochsList = "", validChansList = ""		//for dimension labels to know which channel goes with which portion of the output wave	Variable i,j,k,stimType,chan0Failed=0	Variable numSweeps = da_getOpenFileNumSweeps()	if (numSweeps < 1)		Make/O/N=1 $outref/wave=outn		note outn, "NO_SWEEPS_FOUND"		outn = nan		if (useFilePanel)			fd_setEpochInfo(fileNum,outRef)		endif		return 0	endif	String cmd	//initial screen for valid epochs in each channel, basing off of the first sweep	da_setOpenFileSweep(0)	for (i=0;i<numCommandChannels;i+=1)		stimType=da_getOpenFileStimSource(i)		if (!stimType)	//no stimulus, asking for its info may cause a crash			if (i==0)		//possible still something on channel 1, so continue				chan0Failed=1				continue			else				if (chan0Failed)		//neither worked, make a placeholder wave .. continuing would cause igor to crash					da_closeABF()					Make/O/N=1 $outref/wave=outn					note outn, "NOT_EPISODIC"					outn = nan					if (useFilePanel)						fd_setEpochInfo(fileNum,outRef)					endif					return 0		//returns 0 in case of non-episodic wave, but creates a placeholder so that this info is tracked				endif			endif		endif		validEpochsList = ""		//reset for each channel		getStim_currChanNum = i		for (j=0;j<maxNumEpochs;j+=1)								getStim_currEpochNum = j			getStim_type=nan;getStim_duration=nan;getStim_amplitude=nan;getStim_digital=nan;getStim_status=nan			cmd = "ABFEpochGet getStim_currChanNum,getStim_currEpochNum,getStim_type,getStim_duration,getStim_amplitude,getStim_digital,getStim_status"			Execute/Q cmd						if (getStim_status == nonEpisodicFileStatus)				//Print "da_fd_getStimInfo(): File appears to be non-episodic, aborting"				da_closeABF()				Make/O/N=1 $outref/wave=outn				note outn, "NOT_EPISODIC"				outn = nan				if (useFilePanel)					fd_setEpochInfo(fileNum,outRef)				endif				return 0		//returns 0 in case of non-episodic wave, but creates a placeholder so that this info is tracked			endif						if (getStim_status == invalidChannelStatus)		//stop looking at channel and ignore it				validEpochsList = ""				epochsCount[i] = 0				break		//exit loop			endif						if (getStim_status != noEpochStatus)				validEpochsList += num2str(j) + ","			//store valid epochs in a comma-delimited list				epochsCount[i] += 1			endif		endfor		//did this channel have at least one epoch?		if (epochsCount[i] > 0)			numChansWithValidEpochs += 1			validChansList += num2str(i) + ";"		endif				epochList += validEpochsList + ";"				//in any case, each channel's epoch list is seperated in a semicolon-delimited list.. no valid channels will return null strings from a channel's index 	endfor			//make a place to store info on each epoch	Variable maxNumEpochsFound = wavemax(epochsCount)	Variable numEpochParams = 19	Variable numCols = maxNumEpochsFound+2	Make/O/D/N=(numEpochParams,numCols,numSweeps,numChansWithValidEpochs) $outref/wave=out		//params in rows,epochs in columns,sweeps in layers,channels in chunks..	Note out, epochList		//save epoch list 		//label epochs by index; unfortunately this won't correspond to the actual epoch # because different channels can have different numbers.. it helps to read the multidimensional wave in table though	for (i=0;i<numCols;i+=1)		if (i==0)	//first column: initial holding			setdimlabel 1,i,initialHolding,out		elseif (i==(numCols-1))		//last column: final holding			setdimlabel 1,i,finalHolding,out		else			setdimlabel 1,i,$("epoch_"+num2str(i)),out		endif	endfor		//make a wave to track the summed duration of the epochs across the current sweep, on each channel	Make/O/N=(numCommandChannels) channelDurationSums		Variable numValidEpochs,sweepLen_P,sweepLen_X,sweepStart_X,sweepStart_P,epochDuration_pre,epochDuration_pre_secs,epochDuration_post,epochDuration_post_secs	Variable secsPerPoint = da_getOpenfileSampleInterval()		//note that this will not take into account files recorded with two sample intervals. might be able to deal with that with bruxton macro ABFFileGetSecondInterval	Variable preEpochLen_P,preEpochLen_X	for (i=0;i<numSweeps;i+=1)		if (i==0)			//set dim label for this layer (1 layer per sweep)			SetDimLabel 2,i,$("sweep_"+num2str(i)),out							else				//set currently accessed sweep, 0 doesnt need to be set because it was set above			da_setOpenFileSweep(i)		//I figure but am not sure that this is the slowest step in the function, so we'll make sure to minimize its use		endif				preEpochLen_P = da_getOpenFilePreEpisodePoints(0,-1)		//if an error is returned, try changing channel number (0th parameter) to 1 or possibly 2 or 3		preEpochLen_X = preEpochLen_P * secsPerPoint 				//also may not be necessary and may even lead to an error that were checking on EACH sweep--might be constant throughout file. however, its not well documented				channelDurationSums = preEpochLen_P		//reset epoch duration sums so that it just tracks within a sweep				sweepStart_X = da_getSetSweepStartTime()	//time that sweep starts relative to experiment/file start		..varies depending on intersweep interval, sweep lens, etc.		sweepStart_P = sweepStart_X / secsPerPoint		sweepLen_P = da_getOpenFileSweepLen(i)		//sweeps could have differing lengths, length is returned in points		sweepLen_X = sweepLen_P * secsPerPoint		Variable col				for (j=0;j<numChansWithValidEpochs;j+=1)					//get info about epochs for this file			getStim_currChanNum = str2num(stringfromlist(j,validChansList))			validEpochsList = stringfromlist(getStim_currChanNum,epochList)		//retrieve the list of valid epochs, change "," into ";" for easier use			numValidEpochs = epochsCount[getStim_currChanNum]									//get pre-epoch holding info	-- epoch and "holding period" are interchangable in comments			sprintf cmd,"ABFHoldingInitialGetAmplitude %d,getStim_initHoldAmp,getStim_status",getStim_currChanNum			Execute/Z cmd			sprintf cmd,"ABFHoldingInitialGetDuration %d,getStim_initHoldDur,getStim_status",getStim_currChanNum		//shouldnt be necessary if the same for all sweeps all chans, but just in case and curious if I get errors down the line			Execute/Z cmd			col = 0			out[0][col][i][j] = nan					//type 0:disabled;1:step;2:ramp			out[1][col][i][j] = nan				////digital output pattern			out[2][col][i][j] = getStim_initHoldAmp				//amplitude during epoch						//durations relevant to pre-holding			out[3][col][i][j] = getStim_initHoldDur				//duration of epoch in points	 (duration)			out[4][col][i][j] = getStim_initHoldDur * secsPerPoint	//duration of epoch in seconds	(duration_secs)					out[5][col][i][j] = 0				//stores a running tally of the number of points preceding this epoch for this channel (duration_pre)			out[6][col][i][j] = 0		//same running tally converted to seconds		(duration_pre_secs)							//in case it ever helps, store the point number where the epoch/ holding period ends and the length up to the point (particularly useful for the last epoch, as there's no following to calculate this value)			out[7][col][i][j] = getStim_initHoldDur-1				//in points (duration_post)			out[8][col][i][j] = (getStim_initHoldDur-1) * secsPerPoint	//in seconds	(duration_post_secs)						//just for ease of bookkeeping, store sweep length in points and second as well, though its the same across all channels			out[9][col][i][j] = sweepLen_P		//sweep duration in points (sweepLen)			out[10][col][i][j] = sweepLen_X		//sweep duration in seconds (sweepLen_secs)						//track the start time of the holding period/epoch relative to the entire experiment -- now putting seconds before points because this is more relevant that points (as there can be unrecorded intervals)			out[11][col][i][j] = sweepStart_X		//sweep start relative to experiment start in seconds (sweepStart_secs)		--usually more useful			out[12][col][i][j] = sweepStart_P		//sweep start relative to experiment start in seconds (sweepStart)			--probably not particularly useful						out[13][col][i][j] = sweepStart_X			out[14][col][i][j] = sweepStart_P			out[15][col][i][j] = sweepStart_X + (getStim_initHoldDur-1) * secsPerPoint	//end of epoch in seconds relative to start of experiment (epochEnd_secs)			out[16][col][i][j] = sweepStart_P + getStim_initHoldDur-1					//end of epoch in points relative to start of experiment (epochEnd) (again probably less useful than seconds)					out[17][col][i][j] = preEpochLen_P					//preEpoch1Len	, same for all, at least within a sweep and possibly the whole file, but might be useful			out[18][col][i][j] = preEpochLen_X					//preEpoch1Len	_secs, same for all, at least within a sweep and possibly the whole file, but might be useful						for (k=0;k<numValidEpochs;k+=1)				if ( (i==0) && (k==0) )		//if first sweep and first valid epoch for a channel, label the chunk for the channel					setdimlabel 3,i,$( "chan_"+num2str(j)+"_E_"+ReplaceString(",",validEpochsList,"") ), out		//make label that shows the channel for the chunk and which epochs were used (currently only #'d 0-9 so unambiguous even without commas)				endif				getStim_currEpochNum = str2num(stringfromlist(k,validEpochsList,","))				cmd = "ABFEpochGet getStim_currChanNum,getStim_currEpochNum,getStim_type,getStim_duration,getStim_amplitude,getStim_digital,getStim_status"				Execute/Q cmd				col = k+1				out[0][col][i][j] = getStim_type					//type 0:disabled;1:step;2:ramp				out[1][col][i][j] = getStim_digital				////digital output pattern				out[2][col][i][j] = getStim_amplitude				//amplitude during epoch								//durations relevant to epoch:				out[3][col][i][j] = getStim_duration				//duration of epoch in points	 (duration)				out[4][col][i][j] = getStim_duration * secsPerPoint	//duration of epoch in seconds	(duration_secs)						out[5][col][i][j] = channelDurationSums[j]				//stores a running tally of the number of points preceding this epoch for this channel (duration_pre)				out[6][col][i][j] = channelDurationSums[j] * secsPerPoint		//same running tally converted to seconds		(duration_pre_secs)									//add this epoch to duration sum for this channel (in points)				epochDuration_pre = channelDurationSums[j]		//store since we're about to update the sum				epochDuration_pre_secs = channelDurationSums[j] * secsPerPoint	//store since we're about to update the sum				channelDurationSums[j] += getStim_duration		//add this duration for use with the next time the channel comes up									//in case it ever helps, store the point number where the epoch ends and the length up to the point (particularly useful for the last epoch, as there's no following to calculate this value)				out[7][col][i][j] = (channelDurationSums[j] 	-1)				//in points (duration_post)				out[8][col][i][j] = (channelDurationSums[j] -1) * secsPerPoint	//in seconds	(duration_post_secs)								//just for ease of bookkeeping, store sweep length in points and second as well, though its the same across all channels				out[9][col][i][j] = sweepLen_P		//sweep duration in points (sweepLen)				out[10][col][i][j] = sweepLen_X		//sweep duration in seconds (sweepLen_secs)								//track the start time of the epoch relative to the entire experiment -- now putting seconds before points because this is more relevant that points (as there can be unrecorded intervals)				out[11][col][i][j] = sweepStart_X		//sweep start relative to experiment start in seconds (sweepStart_secs)		--usually more useful				out[12][col][i][j] = sweepStart_P		//sweep start relative to experiment start in seconds (sweepStart)			--probably not particularly useful								out[13][col][i][j] = sweepStart_X + epochDuration_pre_secs			//start of epoch in seconds relative to start of experiment (epochStart_secs)				out[14][col][i][j] = sweepStart_P + epochDuration_pre				//start of epoch in points relative to start of experiment (epochStart) (probably less useful than seconds)				out[15][col][i][j] = sweepStart_X + (channelDurationSums[j] 	-1)* secsPerPoint	//end of epoch in seconds relative to start of experiment (epochEnd_secs)				out[16][col][i][j] = sweepStart_P + (channelDurationSums[j] -1) 				//end of epoch in points relative to start of experiment (epochEnd) (again probably less useful than seconds)							out[17][col][i][j] = preEpochLen_P					//preEpoch1Len	, same for all, at least within a sweep and possibly the whole file, but might be useful				out[18][col][i][j] = preEpochLen_X					//preEpoch1Len	_secs, same for all, at least within a sweep and possibly the whole file, but might be useful								if (getStim_status != 0)		//shouldn't get any errors due to our pre-checks in the first loop. re-write code to deal with new errors as they occur					if (getStim_status == 21)						//21 is "stimulus was disabled" but info still seems to be passed; so not going to alert for this					else						Print "da_fd_getStimInfo(): unexpected status, status =",getStim_status,"sweep",i,"stim chan",j,"epoch",getStim_currEpochNum					endif				endif								//reset values to nan for diagnostic purposes				getStim_type=nan;getStim_digital=nan;getStim_amplitude=nan;getStim_duration=nan;epochDuration_pre=nan;epochDuration_pre_secs=nan							endfor //endfor for k						//get post-epoch holding info			sprintf cmd,"ABFHoldingFinalGetAmplitude %d,getStim_finalHoldAmp,getStim_status",getStim_currChanNum			Execute/Z cmd			sprintf cmd,"ABFHoldingFinalGetDuration %d,getStim_finalHoldDur,getStim_status",getStim_currChanNum		//shouldnt be necessary if the same for all sweeps all chans, but just in case and curious if I get errors down the line			Execute/Z cmd								col=numCols-1			out[0][col][i][j] = nan					//type 0:disabled;1:step;2:ramp			out[1][col][i][j] = nan				////digital output pattern			out[2][col][i][j] = getStim_finalHoldAmp				//amplitude during epoch						//durations relevant to epoch:			out[3][col][i][j] = getStim_finalHoldDur				//duration of epoch in points	 (duration)			out[4][col][i][j] = getStim_finalHoldDur * secsPerPoint	//duration of epoch in seconds	(duration_secs)					out[5][col][i][j] = channelDurationSums[j]				//stores a running tally of the number of points preceding this epoch for this channel (duration_pre)			out[6][col][i][j] = channelDurationSums[j] * secsPerPoint		//same running tally converted to seconds		(duration_pre_secs)							//add this epoch to duration sum for this channel (in points)			epochDuration_pre = channelDurationSums[j]		//store since we're about to update the sum			epochDuration_pre_secs = channelDurationSums[j] * secsPerPoint	//store since we're about to update the sum			channelDurationSums[j] += getStim_finalHoldDur		//add this duration for use with the next time the channel comes up							//in case it ever helps, store the point number where the epoch ends and the length up to the point (particularly useful for the last epoch, as there's no following to calculate this value)			out[7][col][i][j] = (channelDurationSums[j] 	-1)				//in points (duration_post)			out[8][col][i][j] = (channelDurationSums[j] -1) * secsPerPoint	//in seconds	(duration_post_secs)						//just for ease of bookkeeping, store sweep length in points and second as well, though its the same across all channels			out[9][col][i][j] = sweepLen_P		//sweep duration in points (sweepLen)			out[10][col][i][j] = sweepLen_X		//sweep duration in seconds (sweepLen_secs)						//track the start time of the epoch relative to the entire experiment -- now putting seconds before points because this is more relevant that points (as there can be unrecorded intervals)			out[11][col][i][j] = sweepStart_X		//sweep start relative to experiment start in seconds (sweepStart_secs)		--usually more useful			out[12][col][i][j] = sweepStart_P		//sweep start relative to experiment start in seconds (sweepStart)			--probably not particularly useful						out[13][col][i][j] = sweepStart_X + epochDuration_pre_secs			//start of epoch in seconds relative to start of experiment (epochStart_secs)			out[14][col][i][j] = sweepStart_P + epochDuration_pre				//start of epoch in points relative to start of experiment (epochStart) (probably less useful than seconds)			out[15][col][i][j] = sweepStart_X + (channelDurationSums[j] 	-1)* secsPerPoint	//end of epoch in seconds relative to start of experiment (epochEnd_secs)			out[16][col][i][j] = sweepStart_P + (channelDurationSums[j] -1) 				//end of epoch in points relative to start of experiment (epochEnd) (again probably less useful than seconds)					out[17][col][i][j] = preEpochLen_P					//preEpoch1Len	, same for all, at least within a sweep and possibly the whole file, but might be useful			out[18][col][i][j] = preEpochLen_X					//preEpoch1Len	_secs, same for all, at least within a sweep and possibly the whole file, but might be useful						//reset for holding parameters			getStim_finalHoldAmp=nan;getStim_finalHoldDur=nan;getStim_initHoldAmp=nan;getStim_initHoldDur=nan		endfor					endfor			setdimlabel 0,0,type,out	setdimlabel 0,1,digital,out	setdimlabel 0,2,amplitude,out	setdimlabel 0,3,duration,out	setdimlabel 0,4,duration_secs,out	setdimlabel 0,5,duration_pre,out	setdimlabel 0,6,duration_pre_secs,out	setdimlabel 0,7,duration_post,out	setdimlabel 0,8,duration_post_secs,out	setdimlabel 0,9,sweepLen,out	setdimlabel 0,10,sweepLen_secs,out	setdimlabel 0,11,sweepStart_secs,out	setdimlabel 0,12,sweepStart,out	setdimlabel 0,13,epochStart_secs,out	setdimlabel 0,14,epochStart,out	setdimlabel 0,15,epochEnd_secs,out	setdimlabel 0,16,epochEnd,out	setdimlabel 0,17,preEpochLen_P,out	setdimlabel 0,18,preEpochLen_X,out	//currently 19 epoch params			if (openABF)		da_closeABF()	endif		if (useFilePanel)		fd_setEpochInfo(fileNum,outRef)	endif		return 1		//returns 1 if file was episodic, 0 if not, -1 for failure to open ABFendfunction fd_checkEpochDir()	String dfSav= GetDataFolder(1)	String target_df = fd_getMainFolder()	if (!DataFolderExists(target_df))		//check that data folder exists		df_makeFolder(target_df, -inf)		//make data folder, but return to root level		setdatafolder dfSav						//ensure that current data folder hasn't changed	endifendfunction fd_setEpochInfo(fileNum,infoRef)	Variable fileNum; String infoRef		//infoRef is the reference to the wave containing the epoch info		String dfSav= GetDataFolder(1)	String saveName = fd_getEpochInfoRef(fileNum,0)	Duplicate/O $infoRef, fd_setEpochInfo_temp		//store wave with a temporary name just to avoid any naming issues	String target_df = fd_getMainFolder()	if (!DataFolderExists(target_df))		//check that data folder exists		df_makeFolder(target_df, -inf)		//make data folder, but return to root level		setdatafolder dfSav						//ensure that current data folder hasn't changed	endif		String fullDestWaveRef = fd_getEpochInfoRef(fileNum,1)	if (!WaveExists($fullDestWaveRef))		//then save to move wave there		moveWave fd_setEpochInfo_temp, $fullDestWaveRef		//now that data folder exists, make the move	else		Duplicate/O fd_setEpochInfo_temp, $fullDestWaveRef		killwaves/Z fd_setEpochInfo_temp	endifend//if epoch info has been saved for a file (indexed in filePanel), this retrieves the info ref including the full path to the wave //returns null if no wave by that name exists (which means it was probably never savedfunction/S fd_getEpochInfo(fileNum,calcIfMissingOrForce,[out_loadAndTypeStatus])	Variable fileNum	Variable calcIfMissingOrForce	//pass to attempt  to calcaulate info if info isnt present -- original abf files must be available in correct path from fileDirectory	Variable &out_loadAndTypeStatus		//pass optional variable by reference for a place to store the loadAndTypeStatus -- -1 if ABF could not be loaded,0 if loaded and 		fd_checkEpochDir() 	String targetWave = fd_getEpochInfoRef(fileNum,1)	String returnStr		Variable loadAndTypeStatus = nan		if (calcIfMissingOrForce == 2)		//force new		loadAndTypeStatus = da_fd_calcStimInfo(fileNum,"","fd_getEpochInfo_temp")		killwaves/Z $"fd_getEpochInfo_temp"		if (WaveExists($targetWave))			returnStr=targetWave		else			returnStr = ""		endif	else			if (WaveExists($targetWave))			returnStr = targetWave		else			if (calcIfMissingOrForce)				loadAndTypeStatus = da_fd_calcStimInfo(fileNum,"","fd_getEpochInfo_temp")				killwaves/Z $"fd_getEpochInfo_temp"				if (WaveExists($targetWave))					returnStr = targetWave				else					returnStr = ""				endif			else				returnStr = ""			endif		endif			endif		if (!ParamIsDefault(out_loadAndTypeStatus))		out_loadAndTypeStatus = loadAndTypeStatus	endif		return returnStrendfunction fd_epochStartsToGraph(fileNum,winN,sweepNum,chanNumChunk,exampleWaveRef)	Variable fileNum	String winN	Variable sweepNum		//sweepNum to draw epoch times from, default is 0 for nonreal input	Variable chanNumChunk	//chunk of channel number to plot in epochRef (from fd_getEpochInfo())	String exampleWaveRef	//example wave ref is needed for x2pnt calc		if (numtype(sweepNum))		sweepNum = 0	endif		if (!strlen(winN))		winN = winnamE(0,1)	endif		String epochRef = fd_getEpochInfo(fileNum,1)	WAVE epochInfo = $epochRef		Variable epochStartRow = FindDimLabel(epochInfo, 0, "duration_pre")	Variable numCols = dimsize(epochInfo,1),i	Variable epochStartX,epochStartP	for (i=0;i<numCols;i+=1)		epochStartP = epochInfo[epochStartRow][i][sweepNum][chanNumChunk]		epochStartX = pnt2x($exampleWaveRef,epochStartP)		SetDrawEnv xcoord= bottom,linefgc= (21845,21845,21845,52428)		DrawLine epochStartx,0,epochStartx,1		endforendfunction fd_goToEpochStartOnGraph(fileNum,winN,epochCol,sweepNum,exampleWaveRef,chanNumChunk,winSizeP)	Variable fileNum	String winN	Variable sweepNum		//sweepNum to draw epoch times from, default is 0 for nonreal input	Variable chanNumChunk	//chunk of channel number to plot in epochRef (from fd_getEpochInfo())	Variable epochCol		//epoch column number 0 for hold beforehand, 1 for epoch A, 2 for epoch B... up to at most epoch 9 (for 10 total epochs max) then post hold	String exampleWaveRef	Variable winSizeP	//size of window to show in points		if (numtype(sweepNum))		sweepNum = 0	endif		if (!strlen(winN))		winN = winnamE(0,1)	endif		if (!mod(winSizeP,2))		winSizeP += 1		//make odd	endif		String epochRef = fd_getEpochInfo(fileNum,1)	WAVE epochInfo = $epochRef		Variable epochStartRow = FindDimLabel(epochInfo, 0, "duration_pre")	Variable epochStartP = epochInfo[epochStartRow][epochCol][sweepNum][chanNumChunk]	Variable winMidX = pnt2x($exampleWaveRef,epochStartP)	Variable winSizeX = winSizeP*dimdelta($exampleWaveRef,0) 	setaxis/A=2	setaxis bottom winMidX - winSizeX/2, winMidX + winSizeX/2	//Print winMidX - winSizeX/2, winMidX + winSizeX/2endfunction/S fd_checkEpochInfoForAll(recreateIfMissing,reportFreq)	Variable recreateIfMissing	Variable reportFreq		//pass positive number to report every so often on progress		Variable report=reportFreq > 0		WAVE fileInfoWave	Variable i,num=dimsize(fileInfoWave,0),isMissing	String missing="",ref	for (i=0;i<num;i+=1)		ref=fd_getEpochInfo(i,0)		isMissing=!WaveExists($ref)		if (isMissing)			if (recreateIfMissing)				fd_getEpochInfo(i,1)				isMissing=!WaveExists($ref)				if (isMissing)					missing+=num2str(i)+";"				endif			else				missing+=num2str(i)+";"			endif		endif					if (report)			if (mod(i,reportFreq)==0)				print "fd_checkEpochInfoForAll() at i",i			endif		endif	endfor		print "fd_checkEpochInfoForAll() num missing",itemsinlist(missing)		return missingendfunction/S fd_getEpochInfoRef(fileNum,returnFullPathNotJustWaveRef)		//handles naming for stored epoch info for waves in filedirectory	Variable fileNum	Variable returnFullPathNotJustWaveRef	//1 for full path to wave, including data folders (still referencable), 0 for just wave name (may not be referencable if in wrong file directory)		fd_checkEpochDir()		string ref		sprintf ref, "epochInfo_%u" , fileNum		//request number print as unsigned integer (normally e.g. num2str() numbers get changed to scientific)	ref = ReplaceString(" ",ref,"")		//remove extra spaces caused by insisting on 10 digits		if (returnFullPathNotJustWaveRef)		return fd_getMainFolder() + ":" + ref	else		return ref	endifendfunction/S fd_getMainFolder()	return "root:Packages:ABFFilePanel"end//akl stands for append to key list. takes a string by reference and returns "<stringvarname>:<strinvalue>;"function/s akl(key,listItem)	String key,listItem	return key+":"+listItem+";"	end//applies a threshold then reports spike times based on when the threshold is crossed in the rising direction in the dvdt wave//(so spike times vary depending on rise time)//then plots results in a graph (created on first run)//															//TRY REVERSING TO AVOID SMALL BUMPS DUE TO BUILD UP -- THOSE ARE INTERESTING SUGGEST CHANNELS THAT BOOST TO THRESHOLD FOR spike-generator Na CURRENT?function/s spike_timesFromDvDt(voltageWv,spikeBinsSaveRef,staSaveRefAndWindow,refractoryPerX,nonSpikeWinStartX,nonSpikeWinEndX,forceThreshold,startX,endX)	Wave voltageWv	String spikeBinsSaveRef	//stores binned spike times, only computed if passed, not currently used in automatic display	String staSaveRefAndWindow				//computes spike triggered averages, pass "" to skip. to run must pass spikeBinsSaveRef AND a list: "stimulusRef;spikeBinsSaveRef;prePulseAvgDurX;avgLenX;" additionally runs on a subregion if a list is passed: "staSaveRef;startX,endX;"	Variable nonSpikeWinStartX,nonSpikeWinEndX		//region lacking spikes, to calculate sigma and thus threshold for spike	Variable refractoryPerX			//refractory period: helps with initial dvdt bump in AP rising phase that can get countedr as an extra spike, giving 2 spikes for each one	//String nonSpikeWinList	//optionally pass a list of x values for a one second bin after, spike threshold will be calculated from the average of these bins	Double forceThreshold	//pass NaN to calculate threshold from nonSpikeWinStartX,nonSpikeWinEndX, or pass a real number to force a threshold (e.g., to use one from a previous sweep)	Variable startX,endX	//range for spike finding, does not need to include nonSpikeWin		String winN = "spike_win"	String tabN = "spike_tab"		//displays spike times and other parameters in table	String panelN = "spike_pan"	//displays parameter distributions based on user input	String distN = "spike_dist"	String histN = "spike_hist"	//histogram of spike parameters		String vDispRef = "spike_v"	String dvdtDispRef = "spike_dr"	//differentiation result, also used as temp wave unless a name is passed	String dvdt2DispRef = "spike_dr2"		//second derivative result, also used as temp wave unless a name is passed	String smDispRef = "spike_rs"	String dvdtSmDispRef = "spike_drs"	//differentiation result, also used as temp wave unless a name is passed	String dvdt2SmDispRef = "spike_dr2s"		//second derivative result, also used as temp wave unless a name is passed		String spikeTimeDispRef = "spike_st"	//spike times, also used as temp wave unless a name is passed	Double numSDThreshold = 50		//milner found 6 to be a safe bet for what is conveyed to the axon		Variable LPHz = 1000			//low pass filtering performed on dvdt wave for 6*sd thresholding, as per Milner's protocol. make nan to skip	Variable peakStatsSmoothing = 1		//smooth over how many points before differentiation for peak stats? Should be odd, 1 = no smoothing. does not effect threshold crossings	Variable assumedMaxSpikeRiseTimeX = 1		//determines findpeak window after a dvdt threshold crossing		//set output names -- these are all initialized as "" and then set automatically below	//they are first initialized to "" for easy addition to the input parameter list	String voltageWvSaveRef="",dvdtSaveRef="",dvdt2SaveRef="",spikeTimeSaveRef=""	//place to store	String smSaveRef="",dvdtSmSaveRef="",dvdt2SmSaveRef=""	//place to store for smoothed responses	String outlist=""		//list of generated waves	String basename=nameofwave(voltageWv)		//use input wave name by default	if (strlen(voltageWvSaveRef)>0)		vDispRef = voltageWvSaveRef	else		vDispRef = basename + "_V"	endif	outlist+=akl("vDispRef",vDispRef)	if (strlen(dvdtSaveRef)>0)		dvdtDispRef = dvdtSaveRef	else		dvdtDispRef = basename + "_dV"	endif	outlist+=akl("dvdtDispRef",dvdtDispRef)	if (strlen(dvdt2SaveRef)>0)		dvdt2DispRef = dvdt2SaveRef	else		dvdt2DispRef = basename + "_dV2"	endif		outlist+=akl("dvdt2DispRef",dvdt2DispRef)	if (strlen(smSaveRef)>0)		smDispRef = smSaveRef	else		smDispRef =  basename + "_smV"	endif		outlist+=akl("smDispRef",smDispRef)		if (strlen(dvdtSmSaveRef)>0)		dvdtSmDispRef = dvdtSmSaveRef	else		dvdtSmDispRef =  basename + "_smdV"	endif	outlist+=akl("dvdtSmDispRef",dvdtSmDispRef)	if (strlen(dvdt2SmSaveRef)>0)		dvdt2SmDispRef = dvdt2SmSaveRef	else		dvdt2SmDispRef =  basename + "_smdV2"	endif		outlist+=akl("dvdt2SmDispRef",dvdt2SmDispRef)	if (strlen(spikeTimeSaveRef)>0)		spikeTimeDispRef = spikeTimeSaveRef	else		spikeTimeDispRef =  basename + "_ST"	endif		outlist+=akl("spikeTimeDispRef",spikeTimeDispRef)		if (strlen(spikeBinsSaveRef)>0)		//could delete this and make it optional		spikeBinsSaveRef = spikeBinsSaveRef	else		spikeBinsSaveRef =  basename + "_SB"	endif		outlist+=akl("spikeBinsSaveRef",spikeBinsSaveRef)	outlist+=akl("staSaveRefAndWindow",staSaveRefAndWindow)			String finalSpikeTimesRef = basename + "_STF"		//stf for final spike times	outList+=akl("finalSpikeTimesRef",finalSpikeTimesRef)			//boundries for analysis	Variable startX_used,endX_used	if (numtype(startX) != 0)		startX_used = pnt2x(voltageWv,0)	else		startX_used = startx	endif	if (numtype(endX) != 0)		endX_used = pnt2x(voltageWv,dimsize(voltageWv,0)-1)	else		endX_used = endX	endif		Duplicate/O/R=(startX_used,endX_used) voltageWv, $vDispRef/wave=voltageWv		//compute derivatives		//no smoothing	Differentiate voltageWv/D=$dvdtDispRef		//used for threshold -- no smoothing, but 1 khZ filtering as per Milner's protocol	Wave dvdt = $dvdtDispRef	if (!numtype(LPHz))		Variable srate = 1/dimdelta(dvdt,0)		Variable pass_coef = LPHz/srate		Variable reject_coef = (LPHz+1)/srate		Make/O/D/N=0 coefs; DelayUpdate		FilterFIR/DIM=0/LO={pass_coef,reject_coef,101}/COEF coefs, dvdt	endif		Differentiate dvdt/D=$dvdt2DispRef	Wave dvdt2 = $dvdt2DispRef			//possibly smoothed	Duplicate/o voltageWv, $smDispRef/wave=v_sm		//used for peakStats, voltage response possibly smoothed	if (peakStatsSmoothing > 1)		Smooth peakStatsSmoothing, v_sm	endif		Differentiate v_sm/D=$dvdtSmDispRef		//used for threshold -- no smoothing	Wave dvdt_sm = $dvdtSmDispRef	Differentiate dvdt/D=$dvdt2SmDispRef	Wave dvdt2_sm = $dvdt2SmDispRef		Double noiseVar = Variance(dvdt,nonSpikeWinStartX,nonSpikeWinEndX)	Double noiseSD = sqrt(noiseVar)	Double noiseThreshold_calc = numSDThreshold * noiseSD	Double noiseMean = mean(dvdt,nonSpikeWinStartX,nonSpikeWinEndX)	Variable noiseThreshold_used = numtype(forceThreshold) ? noiseThreshold_calc : forceThreshold		//only use forceThreshold if its a real number, otherwise use calculated	FindLevels/EDGE=1/D=$spikeTimeDispRef/Q/B=1 $dvdtDispRef, noiseThreshold_used	WAVE spikeTimes = $spikeTimeDispRef	Variable numCrossings = dimsize(spikeTimes,0)		//add some info for each point -- would be more efficient to do this after eliminating non-spikes, but this is easier for troubleshooting as the wave 	//is displayable from this point on	Variable numParamCols = 17	Redimension/N=(-1,numParamCols) spikeTimes	spikeTimes[][5] = spikeTimes[p][0]		//need first 5 rows for plotting purposes sadly.. but avoids making two waves	spikeTimes[][6,*] = nan	//for plotting purposes	spikeTimes[][4] = 0	spikeTimes[][0,2] = 0	//default color black, opaque	spikeTimes[][3] = 0.7*2^16	//not actually working, probably becuse the wave has more than 4 columns, keeping it in hope of a better tomorrow		//get some spike characteristics	Variable i,sx,nextSx,precedingSx	Variable minPeakLevel,peakFindFailCount = 0,dvdtPeakFindFailCount=0,vPeakLoc	Variable peakSearchEndX	for (i=0;i<numCrossings;i+=1)		sx  = spikeTimes[i][5]		//threshold crossing time		peakSearchEndX = min(sx + assumedMaxSpikeRiseTimeX,pnt2x(dvdt,dimsize(dvdt,0)-1))		//either assumedMaxSpikeRiseTimeX after sx or the end of the wave		//precedingSx = (i > 0) ? spikeTimes[i-1][5] : pnt2x(dvdt,0)		//nextSx = i < ( numCrossings - 1) ? spikeTimes[i+1][5] : pnt2x(dvdt,dimsize(dvdt,0)-1)		//next spike time: search for neg threshold crossing between this spike and next one, or the end of the wave if the last spike		//find voltage wave peak (spike vmax)		minPeakLevel = voltageWv(sx)		//peak should be higher than dv/dt level crossing .. may not be necessary?		Findpeak/b=3/m=(minPeakLevel)/r=(sx,peakSearchEndX)/Q  voltageWv			if (V_flag)		//peak was found			peakFindFailCount += 1		else			//save spike stats			spikeTimes[i][6] = V_peakLoc			spikeTimes[i][7] = V_peakVal			spikeTimes[i][8] = V_peakWidth			spikeTimes[i][9] = V_LeadingEdgeLoc			spikeTimes[i][10] = V_TrailingEdgeLoc			spikeTimes[i][11] = V_flag		endif		vPeakLoc = V_peakLoc	endfor		spikeTimes[*][13,14] = 1		//let 13 track the final accepted spikes, nans for others	Variable numAcceptedSpikes = numCrossings	//implement refractory period by deleting any spike detected before (emphasis on that since usually the issue is spike rising phase) another spike	if (refractoryPerX > 0)		for (i=numCrossings-1;i>0;i-=1)			sx = spikeTimes[i][5]			precedingSx = spikeTimes[i-1][5]			if ( (sx - precedingSx) < refractoryPerX )				//DeletePoints i-1, 1, spikeTimes	//delete preceding--siterates down one index, so checks this point again, which is desirable in case of multiple quick spurrious crossings labeled spikes				spikeTimes[i-1][4] = -1		//-1 to indicate rejected for refractory period				spikeTimes[i-1][13] = nan		//delete from final spike set for presence/absence				spikeTimes[i-1][14] = 0		//delete from final spike set for 0 or 1				numAcceptedSpikes -= 1			endif		endfor	endif		string noteStr = "spike_numCrossings:"+num2str(numCrossings)+";spike_numAcceptedSpikes:"+num2str(numAcceptedSpikes)+";"	noteStr += "spike_noiseThreshold_calc:"+num2str(noiseThreshold_calc)+";spike_noiseThreshold_used:"+num2str(noiseThreshold_used)+";"	noteStr += "spike_numSDThreshold:"+num2str(numSDThreshold)+";spike_noiseSD:"+num2str(noiseSD)+";"	noteStr += "spike_noiseMean:"+num2str(noiseMean)+";spike_nonSpikeWinStartX:"+num2str(nonSpikeWinStartX)+";"	noteStr += "spike_nonSpikeWinEndX:"+num2str(nonSpikeWinEndX)+";spike_peakFindFailCount:"+num2str(peakFindFailCount)+";"	noteStr += "spike_voltageWv:"+nameofwave(voltageWv)+";spike_voltageWvSaveRef:"+voltageWvSaveRef+";"	noteStr += "spike_finalSpikeTimesRef:"+finalSpikeTimesRef+";spike_finalSpikeTimesRefSaveRef:"+finalSpikeTimesRef+";"	noteStr += "spike_dvdtSaveRef:"+dvdtSaveRef+";spike_dvdt2SaveRef:"+dvdt2SaveRef+";"	noteStr += "spike_smSaveRef:"+smSaveRef+";spike_dvdtSmSaveRef:"+dvdtSmSaveRef+";"	noteStr += "spike_dvdt2SmSaveRef:"+dvdt2SmSaveRef+";spike_forceThreshold:"+num2str(forceThreshold)+";"	noteStr += "spike_refractoryPerX:"+num2str(refractoryPerX)+";spike_startX:"+num2str(startX)+";"	noteStr += "spike_endX:"+num2str(endX)+";spike_spikeBinsSaveRef:"+spikeBinsSaveRef+";" 	noteStr += "spike_startX_used:"+num2str(startX_used)+";spike_endX_used:"+num2str(endX_used)+";"	note/nocr spikeTimes, noteStr		if (strlen(spikeBinsSaveRef))		spike_slidingAverage(spikeTimes,5,14,1,spikeBinsSaveRef,startX_used,endX_used)	//compute spike times from column 14		if (strlen(staSaveRefAndWindow))			String staStimRef = stringfromlist(0,staSaveRefAndWindow)			String staOutRef = stringfromlist(1,staSaveRefAndWindow)			Variable prePulseAvgDurX = str2num(stringfromlist(2,staSaveRefAndWindow))			Variable avgLenX = str2num(stringfromlist(3,staSaveRefAndWindow))			String winStartXStr = stringfromlist(4,staSaveRefAndWindow)			String winEndXStr = stringfromlist(5,staSaveRefAndWindow)			Variable winStartX = str2num(winStartXStr)			Variable winEndX = str2num(winEndXStr)			winStartX = numtype(winStartX) ? startX_used : winStartX		//only used start and end if they are real numbers			winEndX = numtype(winEndX) ? endX_used : winEndX			spike_sta($staStimRef,spikeTimes,5,14,1,$spikeBinsSaveRef,staOutRef,winStartX,winEndX,prePulseAvgDurX,avgLenX)		endif	endif		Variable bottom_lastVMin=nan,bottom_lastVMax=nan	winN = disp_makeOrClear(winN, vMinOut=bottom_lastVMin, vMaxOut=bottom_lastVMax)	String smoothedWvsDispList	if (peakStatsSmoothing) 		smoothedWvsDispList = nameofwave(v_sm) + ";" + nameofwave(dvdt_sm) + ";" + nameofwave(dvdt2_sm) + ";" 	else		smoothedWvsDispList = ""	endif	spike_plotSpikes(winN,noiseThreshold_used,voltageWv,dvdt,dvdt2,smoothedWvsDispList,spikeTimes)		Print "spike_timesFromDvDt() results:",noteStr	print "spike_timesFromDvDt() plotting on winN=",winN		//set back to old bottom range if had one	if (!numtype(bottom_lastVMin) && !numtype(bottom_lastVMax))		setaxis/W=$winN bottom,bottom_lastVMin, bottom_lastVMax	endif			setwindow $winN userdata(voltageWv)=nameofwave(voltageWv)	setwindow $winN userdata(dvdtSaveRef)=dvdtSaveRef	setwindow $winN userdata(dvdtDispRef)=dvdtDispRef	setwindow $winN userdata(dvdt2SaveRef)=dvdt2SaveRef	setwindow $winN userdata(dvdt2DispRef)=dvdt2DispRef		setwindow $winN userdata(smSaveRef)=smSaveRef	setwindow $winN userdata(smDispRef)=smDispRef	setwindow $winN userdata(dvdtSmSaveRef)=dvdtSmSaveRef	setwindow $winN userdata(dvdtSmDispRef)=dvdtSmDispRef	setwindow $winN userdata(dvdt2SmSaveRef)=dvdt2SmSaveRef	setwindow $winN userdata(dvdt2SmDispRef)=dvdt2SmDispRef		setwindow $winN userdata(spikeTimeSaveRef)=spikeTimeSaveRef	setwindow $winN userdata(spikeTimeDispRef)=spikeTimeDispRef	setwindow $winN userdata(spikeBinsSaveRef)=spikeBinsSaveRef		setwindow $winN userdata(refractoryPerX)=num2str(refractoryPerX)	setwindow $winN userdata(nonSpikeWinStartX)=num2str(nonSpikeWinStartX)	setwindow $winN userdata(nonSpikeWinEndX)=num2str(nonSpikeWinEndX)	setwindow $winN userdata(dvdtDispRef)=dvdtDispRef	setwindow $winN userdata(spikeTimeDispRef)=spikeTimeDispRef	setwindow $winN userdata(numSDThreshold)=num2str(numSDThreshold)	setwindow $winN userdata(noiseVar)=num2str(noiseVar)	setwindow $winN userdata(noiseSD)=num2str(noiseSD)	setwindow $winN userdata(noiseThreshold_calc)=num2str(noiseThreshold_calc)	setwindow $winN userdata(forceThreshold)=num2str(forceThreshold)	setwindow $winN userdata(noiseThreshold_used)=num2str(noiseThreshold_used)	setwindow $winN userdata(peakStatsSmoothing)=num2str(peakStatsSmoothing)	setwindow $winN userdata(noiseMean)=num2str(noiseMean)	setwindow $winN userdata(lastDispSpikeNum) = num2str(nan)		//set automatically not to zero in on a spikeook	setwindow $winN userdata(tabN) = tabN	setwindow $winN userdata(panelN) = panelN	setwindow $winN userdata(distN) = distN	setwindow $winN userdata(histN) = histN	setwindow $winN hook(spike_winHook) = spike_winHook		//label results wave columns	Variable p=-1	p+=1;SetDimLabel 1,p,R_color,spikeTimes	p+=1;SetDimLabel 1,p,G_color,spikeTimes	p+=1;SetDimLabel 1,p,B_color,spikeTimes	p+=1;SetDimLabel 1,p,O_color,spikeTimes	p+=1;SetDimLabel 1,p,yDispVal,spikeTimes		//-1 for deleted due to refractory period, 0 for accepted		p+=1;SetDimLabel 1,p,dvdtThresholdX,spikeTimes		p+=1;SetDimLabel 1,p,vPeakLoc,spikeTimes	p+=1;SetDimLabel 1,p,vPeakVal,spikeTimes	p+=1;SetDimLabel 1,p,vPeakWidth_auto,spikeTimes		p+=1;SetDimLabel 1,p,vLeadingEdgeLoc_auto,spikeTimes	p+=1;SetDimLabel 1,p,vtrailingEdgeLoc_auto,spikeTimes	p+=1;SetDimLabel 1,p,vFlag_auto,spikeTimes			p+=1;SetDimLabel 1,p,acceptedSpikesOnly,spikeTimes		//nans for rejected points, 0 for accepted	p+=1;SetDimLabel 1,p,acceptedSpikes1Else0,spikeTimes		print "final spike times stored in",spike_getFinalTimes(finalSpikeTimesRef,0,winN=winN)		return outlistendfunction spike_plotSpikes(winN,noiseThreshold,voltageWv,dvdtWv,dvdt2Wv,smoothedWvsDispList,spikeTimeDispWv)	WAVE voltageWv,dvdtWv,dvdt2Wv,spikeTimeDispWv	String winN	Double noiseThreshold	String smoothedWvsDispList		//list of smoothed voltage wave;dvdtWv;dvdt2Wv for possible display, pass "" for any list item not to be displayed		if (!strlen(winN))		winN = winname(0,1)	endif			Variable yCol = 4	Variable plotCol = 5	//use  e.g. 6 to plot voltage peak instead of derivative crossing	Variable smoothedWvOpacity = 0.6		//0 to 1	appendtograph/L=left/W=$winN voltageWv	appendtograph/L=L_dvdt/W=$winN dvdtWv	appendtograph/L=L_dvdt2/W=$winN dvdt2Wv	appendtograph/L=L_st/W=$winN spikeTimeDispWv[*][yCol] vs spikeTimeDispWv[*][plotCol]	modifygraph/W=$winN axisenab(left) = {0,.39},axisenab(L_dvdt)={.51,.75},axisenab(L_dvdt2)={.77,1},axisEnab(L_st)={.41,.49},axoffset=0,freepos=0,lblpos=52	String timeDispRef = nameofwave(spikeTimeDispWv)	ModifyGraph/W=$winN mode($timeDispRef)=3,marker($timeDispRef)=10,msize($timeDispRef)=12,mrkThick($timeDispRef)=1.5	ModifyGraph/W=$winN zColor($timeDispRef)={spikeTimeDispWv,*,*,directRGB,0}	ModifyGraph/W=$winN axRGB(L_st)=(65535,65535,65535),tlblRGB(L_st)=(65535,65535,65535);DelayUpdate	//hide spike time axis except for its label		//draw threshold line	GEtaxis/W=$winN/Q bottom	SetDrawEnv/W=$winN xcoord= bottom,ycoord= L_dvdt,linefgc= (0,0,0,49151),dash= 3;DelayUpdate	DrawLine/W=$winN pnt2x(dvdtWv, 0 ),noiseThreshold,pnt2x(dvdtWv,dimsize(dvdtWv,0)-1),noiseThreshold		//add smoothed waves:	String v_smRef=stringfromlist(0,smoothedWvsDispList),dvdt_smRef=stringfromlist(1,smoothedWvsDispList),dvdt2_smRef=stringfromlist(2,smoothedWvsDispList)	if (strlen(v_smRef))		Appendtograph/W=$winN/L=left/C=(0,0,0,smoothedWvOpacity*(-1+2^16)) $V_smRef		reordertraces/W=$winN _back_,{$V_smRef}		//keep behind unsmoothed wave	endif	if (strlen(dvdt_smRef))		Appendtograph/W=$winN/L=L_dvdt/C=(0,0,0,smoothedWvOpacity*(-1+2^16)) $dvdt_smRef		reordertraces/W=$winN _back_,{$dvdt_smRef}		//keep behind unsmoothed wave	endif	if (strlen(dvdt2_smRef))		Appendtograph/W=$winN/L=L_dvdt2/C=(0,0,0,smoothedWvOpacity*(-1+2^16)) $dvdt2_smRef		reordertraces/W=$winN _back_,{$dvdt2_smRef}		//keep behind unsmoothed wave	endif		//axis labels	Label/W=$winN L_st "Spike Times\r(lower, rejected\rupper, accepted)"	Label/W=$winN L_dvdt "dv/dt\\u#2"	Label/W=$winN L_dvdt2 "d\\S2\\Mv/dt\\S2\\M\\u#2"	setaxis/A/W=$winN L_st		//want this to adjust to full range of data, not just what is shown locally (other axes will act differently)	ModifyGraph/W=$winN lblPos(L_st)=70	setVertAxesA2(winN=winN)		//draw accepted spike range (yDispVal >= 0)	SetDrawEnv/W=$winN xcoord= bottom,ycoord=L_st,linefgc= (0,0,0,49151),dash= 3;DelayUpdate	DrawLine/W=$winN pnt2x(dvdtWv, 0 ),-0.5,pnt2x(dvdtWv,dimsize(dvdtWv,0)-1),-0.5endfunction spike_plotrespSpikesAndBins(respWv,spiketimesWv,binWv)	WAVe respWv,spiketimesWv,binWv		display/k=1	String winN =s_name	appendtograph/w=$winN respWv	appendtograph/w=$winN/L=L_spikeTimes spikeTimesWv[][13]/tn=spikeTimes vs spikeTimesWv[][5]		//plot dvdt threshold crossing column vs only accepted spikes column	Label/w=$winN L_spikeTimes,"spikeTimes\\u#2"	appendtograph/w=$winN/L=L_spikeRate binWv[][0]/tn=spikeBins	Label/w=$winN L_spikeRate,"Spike Rate (Hz)\\u#2"	appendtograph/w=$winN/L=L_spikeRate binWv[][1]/tn=spikeAvg		modifygraph/W=$winN freepos=0,lblpos=52,axisenab(left)={0,.5},axisenab(L_spikeTimes)={.52,.58},axisenab(L_spikeRate)={.6,1}		//format spike times	ModifyGraph/W=$winN mode(spikeTimes)=3,marker(spikeTimes)=10,msize(spikeTimes)=12,mrkThick(spikeTimes)=1.5,rgb=(0,0,0)		//format bins	ModifyGraph/W=$winN  rgb(spikeBins)=(0,0,65535,26214),lsize(spikeBins)=1.6	endfunction spike_lbHook(s) : ListboxControl	STRUCT WMListboxAction &s	if (s.eventcode != 2)		//click not completed		return 0	endif		//find selections	String selListStr = ""	variable i,numParams=dimsize(s.selWave,0)	for (i=0;i<numParams;i+=1)		if (s.selWave[i])			selListStr += num2str(i) + ";"		endif	endfor	variable numSels = itemsinlist(selListStr)	if (numSels < 1)		return 0	endif		String winN = GetUserData(s.win, "", "winN")		//name of main display graph	String distN = GetUserData(winN, "", "distN")		//name of distribution graph	if (strlen(distN))		//create if doesnt exist		if (!wintype(distN))			display/k=1/N=$distN			distN = S_name			setwindow $winN, userdata(distN) = distN		else			vis_clearGraph(distN)		endif	else		Print "spike_lbHook() set distN named user data for main window to display distributions. aborting"		return 0	endif		Variable individualLeftAxes = 0	String spikeTimeDispRef = GetUserData(winN, "", "spikeTimeDispRef")	WAVE spikeTimes = $spikeTimeDispRef	Variable gap=0.02		//space between graphs x	Variable totalGap = gap * (numSEls-1)	Variable totalGraph = 1- totalGap	Variable graph = totalGraph/numSels	String histN	variable sel; string paramN,leftN,bottomN,topN,traceN	Variable start,finish	for (i=0;i<numSels;i+=1)		sel = str2num(stringfromlist(i,selListStr))		paramN = s.listwave[sel]		histN = "spike_h_"+paramN		traceN = paramN		matrixop/o/free temp = col(spikeTimes,sel)		histogram/dest=$histN temp		start = i*(graph+gap)		finish = start+graph		if (individualLeftAxes)			leftN = "L_h_"+paramN	///left axis plots histogram occurances (hist y values)		else			leftN = "left"		endif		bottomN = "B_h_"+paramN	//bottom plots histogram bin values (hist x values, param y values)		appendtograph/W=$distN/R/B=$bottomN spiketimes[*][5]/tn=$traceN vs spikeTimes[*][sel]		appendtograph/W=$distN/L=$leftN/B=$bottomN $histN		modifygraph/W=$distN axisenab($bottomN)={start,finish}		modifygraph/W=$distN mode($histN)=5,toMode($histN)=1		ModifyGraph/W=$distN mode($traceN)=2,lsize($traceN)=2,rgb($traceN)=(0,0,0)		ModifyGraph/W=$distN zColor($traceN)={spikeTimes,*,*,directRGB,0}, rgb($histN)=(1,3,39321,45875)		label/w=$distN $bottomN,paramN+" \\U"	endfor	modifygraph/W=$distN freepos=0,lblpos=50	Label/w=$distN right, "Spike Times" 	return 0end//handles user spike selection//shift click to select spike by mouse//right and left arrow to move to spike -- with ctrl key down to include rejects//up and down arrow to "promote" or "demote"  spike to/from accepted statusfunction spike_winHook(s)		STRUCT WMWinHookStruct &s		Variable moveType = 0		//move type 0 for mouse selection with shift	if (s.keycode == 28)		moveType = -1			//keyboard left, move back one spike from current selection	elseif (s.keycode == 29)		moveType = 1				//keyboard right, move forward one spike from current selection	elseif (s.keycode == 30)			moveType = 2				//keyboard up, promote spike	elseif (s.keycode == 31)		moveType = -2			//keyboard down, demote spike	elseif ( (s.eventmod & 2^1) && (s.eventcode == 5) )		//shift key and mouse release		movetype = 0				//shift and mouse released, go to nearest spike (possibly under other conditions, e.g. mouse in spike time plot)	else		return 0	endif		STring spikeTimeDispRef = GetUserData(s.winname, "", "spikeTimeDispRef")		if (!moveType)		//handle mouse selection of spike		if (!strlen(spikeTimeDispRef))			Print "spike_goToSpike(): no information found, unexpectedly. Aborting"			return 0		endif		if (!WaveExists($spikeTimeDispRef))			return 0		endif		wave spikeTimes=$spikeTimeDispRef		//Variable relSpikeY = disp_getMouseLoc(s, "L_st")		//doesnt work because function reports a range of 0, 		Variable relSpikeX = disp_getMouseLoc(s, "bottom")		matrixop/o/free temp = col(spikeTimes,6)		//get spike times column		Variable clickedPos = 	binarysearch(temp,relSpikeX)		if (numtype(clickedPos))	//couldnt find in spike times			return 0		endif		Variable maxPos = dimsize(spikeTimes,0)-1		if (clickedPos == -1)		//start of wave			clickedPos = 0		elseif ( (clickedPos == -2) || (clickedPos == maxPos) )	//end of wave			clickedPos = maxPos		else		//somewhere in between: find closest spike			//always returns value of spike to the left			Variable leftDist = relSpikeX - spikeTimes[clickedPos][5]			Variable rightDist = spikeTimes[clickedPos+1][5]  - relSpikeX			if (rightDist < leftDist)				clickedPos+=1			endif		endif		spike_goToSpike(s.winName,clickedPos,0)		return 0	endif		//handle possible promotion/demotion of spike first	Variable ctrlKeyDown = (s.eventmod & 2^3) > 0	Variable promote = moveType == 2	Variable demote = moveType == -2	Variable lastSpikePos	if (promote || demote)		lastSpikePos = str2num(GetUserData(s.winName, "", "lastDispSpikeNum"))		wave spikeTimes=$spikeTimeDispRef		spikeTimes[lastSpikePos][%yDispVal]+=promote ? 1 : -1		return 1	endif		if ((s.eventmod & 2^1) == 0) 		//shift key NOT down		lastSpikePos = str2num(GetUserData(s.winName, "", "lastDispSpikeNum"))		Variable newSpikePos		if (!numtype(lastSpikePos))		//already a spike pos			newSpikePos = lastSpikePos + moveType		else			newSpikePos = 0			setVertAxesA2(winN=s.winName)		endif				spike_goToSpike(s.winName,newSpikePos,ctrlKeyDown ? 0 : moveType)	else		//shift key down: for clicks, go to point		String dvdtDispRef =  GetUserData(s.winName, "", "spikeTimeDispRef")		variable xLowerLimit = pnt2x($dvdtDispRef,0)		variable xUpperLimit = pnt2x($dvdtDispRef, dimsize($dvdtDispRef,0)-1 )		Variable winSizeX = min(10,xUpperLimit-xLowerLimit)		//use 10 or the size of the wave if smaller than 10 (moving should do nothing but display the whole wave in that case)		getaxis/W=$s.winname/Q bottom		if (moveType == 1)		//forward movement			if (V_max >= xUpperLimit)		//already at end of wave, move start of wave				setaxis/W=$s.winname bottom, xLowerLimit,xLowerLimit+winSizeX			else				setaxis/W=$s.winname bottom, V_max,V_max +winSizeX		//step by one window size			endif		elseif (moveType == -1)		//backward movement			if (V_min <= xLoweRLimit)	//already at end of wave, move to end of wave				setaxis/W=$s.winname bottom, xUpperLimit-winSizeX,xUpperLimit			else				setaxis/W=$s.winname bottom, V_min-winSizeX,V_min	//step by one window size			endif						endif	endif	setaxis/A/W=$s.winname L_st	//keep axis showing its full range	return 1		//keeps control in window not to command lineendfunction spike_goToSpike(winN,spikeNum,skipDirection)	STring winN; Variable spikeNum	Variable skipDirection		//0 to just go to the spikeNum, positive to jump forward if this spike is a reject, negative to jump backwards if the spike is a reject	//color prefs...should match those in spike_timesFromDvDt()	Variable nonSelSpikeR=0,nonSelSpikeG=0,nonSelSpikeB=0,nonSelSpikeO=0.7*2^16	Variable selSpikeR=-1+2^16,selSpikeG=0,selSpikeB=0,selSpikeO=0.7*2^16	if (!strlen(winN))		winN = winname(0,1)	endif		STring spikeTimeDispRef = GetUserData(winN, "", "spikeTimeDispRef")	if (!strlen(spikeTimeDispRef))		Print "spike_goToSpike(): no information found, unexpectedly. Aborting"		return 0	endif		String dvdtDispRef = GetUserData(winN, "", "dvdtDispRef")	WAVE spikeTimes =  $spikeTimeDispRef	Variable numSpikes = dimsize(spikeTimes,0)	if (numSpikes ==0)		Print "spike_goToSpike(): no spikes found to Disp! aborting"		return 0	endif	Variable dispSpike = mod(spikeNum,numSpikes)	//wrap around by modulus for positive values	if (dispSpike < 0)		dispSpike += numSpikes		//wrap around from negative values	endif		if (skipDirection != 0)		Variable yDispValCol=finddimlabel(spikeTimes,1,"yDispVal")		if (spikeTimes[dispSpike][yDispValCol]<0)		//if this spike has a display value < 0, find the next spike in skip direction >=0			Variable rows=dimsize(spikeTimes,0)			make/o/free/n=(rows) rowInds = p		 	if (skipDirection>0)				if (dispSpike == 0)		//search all points starting from this one					matrixop/free/o yDispVals = subrange(spikeTimes,0,rows-1,yDispValCol,yDispValCol)					matrixop/free/o rowIndsFinal =  subrange(rowInds,0,rows-1,0,0)								else								//search all points from  this one and then starting from 0 to before this one					matrixop/free/o yDispVals = catrows(subrange(spikeTimes,dispSpike,rows-1,yDispValCol,yDispValCol),subrange(spikeTimes,0,dispSpike-1,yDispValCol,yDispValCol))					matrixop/free/o rowIndsFinal = catrows(subrange(rowInds,dispSpike,rows-1,0,0),subrange(rowInds,0,dispSpike-1,0,0))				endif			else				if (dispSpike == rows-1)		//search all points starting from this last one					matrixop/free/o yDispVals = reversecols(subrange(spikeTimes,0,rows-1,yDispValCol,yDispValCol))					matrixop/free/o rowIndsFinal =  reversecols(subrange(rowInds,0,rows-1,0,0))							else								//search all starting from this one and before, then all points from end to just after this one					matrixop/free/o yDispVals = catrows(reversecols(subrange(spikeTimes,0,dispSpike,yDispValCol,yDispValCol)),reversecols(subrange(spikeTimes,dispSpike+1,rows-1,yDispValCol,yDispValCol)))					matrixop/free/o rowIndsFinal = catrows(reversecols(subrange(rowInds,0,dispSpike,0,0)),reversecols(subrange(rowInds,dispSpike+1,rows-1,0,0)))				endif						endif			redimension/i yDispVals			Findvalue/I=0/Z  yDispVals	//truncate at zero for binary search to only have to deal with one value			if (V_value >= 0)				spike_goToSpike(winN,rowIndsFinal[V_value],0)		//we know this is an acceptable spike so we can just go to it now				return 1			else				print "spike_goToSpike() no other accepted spike to move to, staying put"				return 1			endif		endif	endif			//set window	Variable maxWinSizeX = 1		//how big a window size to allow before stepping in and setting view around spike to default	Variable limitXLow = pnt2x($dvdtDispRef,0)	Variable limitXHigh = pnt2x($dvdtDispRef,dimsize($dvdtDispRef,0)-1)	getaxis/W=$winN/Q bottom	Variable currRange  = V_max - v_min	Variable dispRange = min(currRange,maxWinSizeX)	Variable spikeTimeX = spikeTimes[dispSpike][5]	Variable newStartX = spikeTimeX - dispRange/2	newStartX = newStartX < 0 ? 0 : newSTartX		//cutoff at zero 	Variable newEndX = newStartX + dispRange	if (newEndX > limitXHigh)		newEndX = limitXHigh		newStartX = newEndX - dispRange		newStartX = newStartX < 0 ? 0 : newSTartX		//cutoff at zero 	endif	Setaxis bottom, newStartX,newEndX 		//deal with coloring spike	Variable lastSpikePos = str2num(GetUserData(winN, "", "lastDispSpikeNum"))	if (!numtype(lastSpikePos) &&  (lastSpikePos != dispSpike))		//there was a spike position set previously, remove its color if necessary		spikeTimes[lastSpikePos][0] = nonSelSpikeR		spikeTimes[lastSpikePos][1] = nonSelSpikeG		spikeTimes[lastSpikePos][2] = nonSelSpikeB		spikeTimes[lastSpikePos][3] = nonSelSpikeO	endif		if (lastSpikePos != dispSpike)		spikeTimes[dispSpike][0] = selSpikeR		spikeTimes[dispSpike][1] = selSpikeG		spikeTimes[dispSpike][2] = selSpikeB		spikeTimes[dispSpike][3] = selSpikeO		endif		setwindow $winN, userdata(lastDispSpikeNum) = num2str(dispSpike)		//update table	String tabN = GetUserData(winN, "", "tabN")	if (strlen(tabN))		//create if doesnt exist		if (!wintype(tabN))			edit/k=1/n=$tabN spikeTimes.ld			tabN = S_name	//in case of new name generation			setwindow $winN userdata(tabN) = tabN			modifytable/W=$tabN autosize={0,0,-1,0,0},showparts=( (1*2^0)+(0*2^1)+(1*2^2)+(1*2^3)+(1*2^4)+(1*2^5)+(1*2^6)+(1*2^7) )		else		//check that the appropriate spike time wave is displayed (usually probably not needed)			String tabInfo = TableInfo(tabN, 0)		//get info about wave stored in first column, which should be the spikeTimes wave			String dispRef = StringByKey("WAVE", tabInfo)			if (!stringmatch(dispRef,spikeTimeDispRef))				RemoveFromTable/W=$tabN $dispRef				appendtotable/W=$tabN $spikeTimeDispRef			endif		endif		//go to new point		Variable topleftcell = dispSpike-5 < 0 ? 0 : dispSpike-5		Modifytable/W=$tabN topleftcell  = (topleftcell,-1)		modifytable/W=$tabN selection=(dispSpike,0,dispSpike,dimsize(spikeTimes,1),dispSpike,-1)	endif		//update panel	String panelN = GetUserData(winN, "", "panelN")	if (strlen(panelN))		//create if doesnt exist		if (!wintype(panelN))			NewPanel/n=$panelN/k=1			panelN = S_name	//in case of new name generation			setwindow $winN userdata(panelN) = panelN			setwindow $panelN userdata(winN) = winN			string paramListBoxN = panelN + "lb"			string paramListBox_listWvN = panelN + "lw"			string paramListBox_selWvN = panelN + "sw"			Make/o/t/n=(dimsize(spikeTimes,1)) $paramListBox_listWvN/wave=listwv			listwv = GetDimLabel(spikeTimes, 1, p)			make/o/n=(dimsize(spikeTimes,1)) $paramListBox_selWvN			setwindow $winN userdata(paramListBoxN) = paramListBoxN			listbox $paramListBoxN win=$panelN,proc=spike_lbHook,mode=4,listwave=listwv,selwave=$paramListBox_selWvN,pos={0,0},size={150,200}		else						endif	endifendfunction/S spike_getFinalTimes(outRef,includeValues[winN])	String outRef	Variable includeValues		//pass 0 to get a wave containing the time of accpted spikes. Pass 1 to get a wave with 2 columns, second is the displayed value at the spike (in the yDispVal column of the spikeTimeDispRef wave)	String winN		//optionally pass a window name to use a window other than top window		string usedWin	if (ParamIsDefault(winN) || (strlen(winN)<1))		usedWin=winname(0,1)	else		usedWin=winN	endif		STring spikeTimeDispRef = GetUserData(usedWin, "", "spikeTimeDispRef")	if (strlen(outRef)<1)		outRef=spikeTimeDispRef+"_final"	endif		String dispColLbl="yDispVal"	STring spikeTimesColLbl="dvdtThresholdX"	Variable spikeTimesCol=finddimlabel($spikeTimeDispRef,1,spikeTimesColLbl)		Variable dispCol = finddimlabel($spikeTimeDispRef,1,dispColLbl)		//shows displayed status as an accepted or rejected spike	Variable minAccepted=0		//negative values were removed (usually due to violating refractory period)	duplicate/o/r=[][spikeTimesCol] $spikeTimeDispRef,$outRef/wave=out	duplicate/o/R=[][dispCol]/free $spikeTimeDispRef,dispVals	Variable i,rows=dimsize(out,0)	for (i=rows-1;i>-1;i-=1)		if (dispVals[i] < minAccepted)			deletepoints i,1,out,dispVals		endif	endfor		if (includeValues)		concatenate/np=1/dl {dispVals},out		setdimlabel 1,0,spikeTimes,out		setdimlabel 1,1,spikeDispVal,out	endif		print "spike_getFinalTimes() output stored in wave",outRef		redimension/n=(-1) out	return outRef	end	function spike_slidingAverage(spikeTimesWv,spikeTimesCol,hasSpikeCol,hasSpikeVal,outRef,startX,endX)	Wave spikeTimesWv	Variable spikeTimesCol	//col containing spike times -- should be 0 for no spike, 1 for spike	Variable hasSpikeCol	//col for checking whether spike occured, based on a match to hasSpikeVal, or Nan/inf to skip check	Variable hasSpikeVal	String outRef	Variable startX,endX	//time range in which to look for spikes, usually should match that used for searching for spikes (e.g., entire raw voltage wave)		Variable binSizeX = 1		//used for bin size	Variable slidingAvgSizeX = 5		//should probably be larger than binSizeX and an ODD MULTIPLE OF IT	Variable smoothPoints = slidingAvgSizeX/binSizeX		variable lenX = endX - startX	Variable outpnts = ceil(lenX/binSizeX)		//make one point longer than may be absolutely necessary	make/o/d/n=(outpnts) $outref/wave=out	out = 0	setscale/p x, startX + binSizeX, binSizeX, "s", out	variable i,binNum	variable numPossibleSpikes=dimsize(spikeTimesWv,0),spikeTime	Variable checkSpikes = !numtype(hasSpikeCol)		//need a real number for hasSpikeCol	for (i=0;i<numPossibleSpikes;i+=1)		//check if spike occured at time		if (checkSpikes)			if (spikeTimesWv[i][hasSpikeCol] != hasSpikeVal)				continue		//move on to next index			endif		endif				//its a spike so place it in correct bin		spikeTime = spikeTimesWv[i][spikeTimesCol]		binNum = floor((spikeTime - startX) / binSizeX)		out[binNum] += 1	endfor	setscale/p x, startX + 0.5*binSizeX, binSizeX, "s", out			//calculated smoothed wave (sliding average)	duplicate/o/free out, smTemp	smooth/b smoothPoints,smTemp 	concatenate {smTemp},out		//shift bin times to their actual center	setscale/p x, startX + 0.5*binSizeX, binSizeX, "s", out		SetDimLabel 1,0,$"bins_"+num2str(binSizeX)+"s",out 	SetDimLabel 1,1,$"slidingAvg_"+num2str(slidingAvgSizeX)+"s",out			String noteStr= "spike_slidingAverage_spikeTimesWv:"+nameofwave(spikeTimesWv)+";" 	notestr += "spike_slidingAverage_spikeTimesCol:"+num2str(spikeTimesCol)+";" 	notestr += "spike_slidingAverage_hasSpikeCol:"+num2str(hasSpikeCol)+";" 	notestr += "spike_slidingAverage_hasSpikeVal:"+num2str(hasSpikeVal)+";" 	notestr += "spike_slidingAverage_startX:"+num2str(startX)+";" 	notestr += "spike_slidingAverage_endX:"+num2str(endX)+";" 	notestr += "spike_slidingAverage_checkSpikes:"+num2str(checkSpikes)+";" 	note/nocr out, noteStr + note(spikeTimesWv)	endfunction spike_sta(stimOrRespWv,spikeTimesWv,spikeTimesCol,hasSpikeCol,hasSpikeVal,spikeBinsWv,outRef,startX,endX,prePulseAvgDurX,avgLenX)	WAVE stimOrRespWv //pass e.g. the voltage response to overlay spikes, pass the stimulus to get a traditional sta	WAVE spikeTimesWv,spikeBinsWv		//formated respectively as by spike_timesFromDvDt and spike_slidingAverage respectively	String outRef		//store result	Variable spikeTimesCol,hasSpikeCol,hasSpikeVal //for spikeTimesWv, column of spike times, column for whether theres a spike based on match to hasSpikeVal, or nan for hasSpikeCol to use all times	Variable startX,endX		//region of interest, does not need to match bounds of input waves	Variable prePulseAvgDurX,avgLenX		//time before pulse to start averaging, length of average		Variable limitXLow = pnt2x(stimOrRespWv,0)	Variable limitXHigh = pnt2x(stimOrRespWv,dimsize(stimOrRespWv,0)-1)		//basic sta from impulse times	duplicate/o/r=(0,avgLenX) stimOrRespWv,$outRef/wave=out	SetScale/p x, -prePulseAvgDurX, dimdelta(stimOrRespWv,0), "s", out	String usedSpikeTimes = ""	out = 0		variable i,numPossibleSpikes=dimsize(spikeTimesWv,0),spikeTime	Variable checkSpikes = !numtype(hasSpikeCol)		//need a real number for hasSpikeCol		duplicate/o/free out, repsTemp	redimension/n=(-1,numPossibleSpikes) repsTemp				variable count = 0	for (i=0;i<numPossibleSpikes;i+=1)		//check if spike occured at this index		if (checkSpikes)			if (spikeTimesWv[i][hasSpikeCol] != hasSpikeVal)				continue		//move on to next index			endif		endif				//check if spike time is in range of interest		spikeTime = spikeTimesWv[i][spikeTimesCol]		if ( (spikeTime < startX) || (spikeTime > endX) )			continue		endif				//check if spike time permits getting out the region around the spike without a bounds error		if ( ( (spikeTime-prePulseAvgDurX) < limitXLow ) || ( (spikeTime-prePulseAvgDurX + avgLenX) > limitXHigh) )			continue		endif				repsTemp[][count] = stimOrRespWv(x + spikeTime)		out += stimOrRespWv(x + spikeTime)		//x starts at -prePulseAvgDur, so grabs starting from spikeTime-prepulseAvgDur, up to spikeTime-prepulseAvgDur+avgLenX		count += 1		usedSpikeTimes += num2str(spikeTime) + ";"	endfor			out[] /= count	redimension/n=(-1,count) repsTemp		//remove unused columns		//subtract mean from each point in reps and square to get squared resuiduals	duplicate/o/free repsTemp, repsTempRes	repsTempRes = (repsTempRes[p][q] - out[p])^2	make/o/d/free/n=1 var	SumDimension/D=1/DEST=var repsTempRes	//sum across columns (within rows)	duplicate/o/free var,sd,sem	sd = sqrt(var[p]/(count-1))		//corrected sd	sem = sd[p]/sqrt(count)	concatenate/np=1 {var,sd,sem,repsTemp}, out	setdimlabel 1,0,avg,out	setdimlabel 1,1,var,out	setdimlabel 1,2,sd,out	setdimlabel 1,3,sem,out	setdimlabel 1,4,rep0,out		string noteStr = ""	notestr += "spike_sta_basic_count:"+num2str(count)+";"		notestr += "spike_sta_basic_usedTimes:"+replaceString(";",usedSpikeTimes,",")+";"		note/nocr out, noteStr	Print "spike_sta() results:",noteStrend//for a given column in a list of wave, calculates mean across wave and other stats (var,sd,sem)function analysis_avgStatsWave_fromList(list,col,outRef)	String list	//list of waves --should have same # rows	Variable col		//optionally pass a column to use from 2D wave, (pass 0 for 1D)	String outRef		//stores avg, var, sd, sem in columns		Duplicate/o/r=[] $stringfromlist(0,list), $outref/wave=out	redimension/n=(-1) out		variable len = dimsize(out,0)		//compute average	variable i,count=itemsinlist(list)	for (i=1;i<count;i+=1)		wave temp = $stringfromlist(i,list)		out += temp[p][col]	endfor	out /= count		//compute sum of residuals (variance at each point)	duplicate/o/free out, var, sd, sem	var = 0	for (i=0;i<count;i+=1)		wave temp = $stringfromlist(i,list)		var += (temp[p][col] - out[p])^2	endfor		sd = sqrt( var/(count-1) )	sem = sd / sqrt(count)		concatenate/np=1 {var,sd,sem},out	setdimlabel 1,0,avg,out	setdimlabel 1,1,var,out	setdimlabel 1,2,sd,out	setdimlabel 1,3,sem,out		string noteStr = ""	notestr += "analysis_avgStatsWave_fromList_count:"+num2str(count)+";"		notestr += "analysis_avgStatsWave_fromList:"+replaceString(";",list,",")+";"		note/nocr out, noteStr	Print "analysis_avgStatsWave_fromList() results:",noteStr	endfunction analysis_avgStatsWave_disp(wv,newGraph,leftAxN)	WAVE wv		//formatted as from analysis_avgStatsWave_fromList(): columns that are avg,variance,sd,sem	variable newGraph	String leftAxN		if (!strlen(leftAxN))		leftAxN = "left"	endif	variable pCol = 0, eCol=3		//e.g. plotted column in 0, error col is SEM, 3	if (newGraph)		display/k=1	endif		appendtograph/c=(0,0,0)/L=$leftAxN wv[][pCol]	ErrorBars $nameofwave(wv) SHADE= {0,0,(0,0,65535,26214),(0,0,0,0)},wave=(wv[*][eCol],wv[*][eCol])endfunction fit_transferFunc(w,x) : FitFunc	//returns the real component of the transfer function of a parallel RC circuit													//= w[0] / (1-x*sqrt(-1)*2*pi*w[0]*w[1])													//= R/(1-freq*i*2pi*R*C)													//where w[0]=R is resistance, freq is x (e.g., in Hz), w[1]=C is capacitance													//this is the (real and) complex impedence of a parallel RC circuit	WAVE w	//contains tau	Variable x		return real( transferFunc(w,x) )endfunction/C transferFunc(w,x) : FitFunc		//returns the transfer function of a parallel RC circuit													//= w[0] / (1-x*sqrt(-1)*2*pi*w[0]*w[1])													//= R/(1-freq*i*2pi*R*C)													//where w[0]=R is resistance, freq is x (e.g., in Hz), w[1]=C is capacitance													//this is the (real and) complex impedence of a parallel RC circuit	WAVE w	//contains tau	Variable x		return w[0] / ( 1-x*sqrt(-1)*2*pi*w[0]*w[1] )endfunction spike_countInWin(spikeTimesWv,spikeTimesCol,hasSpikeCol,hasSpikeVal,startX,endX)	WAVE spikeTimesWv //from spikeTimesFromDVDT function	Variable startX, endX		//start and end times  INCLUSIVE	Variable spikeTimesCol //column containing spike times	Variable hasSpikeCol, hasSpikeVal	//column containing whether or not a spike occured and the value that indicates a spike occured (must be real, not NaN inf)	//	Variable co = 13		//column with final spikes as 1, rejected events as NaN//	Variable tCo = 5		//column of spike times (dvdt crossings)		Variable i,num=dimsize(spikeTimesWv,0),spikecount=0,totalEventCount=0,st	for (i=0;i<num;i+=1)		if (!numtype(spikeTimesWv[i][hasSpikeCol]) && (spikeTimesWv[i][hasSpikeCol] == hasSpikeVal) )			st = spikeTimesWv[i][spikeTimesCol]			if ( (st >= startX) && (st <= endX) )				spikecount += 1			endif			totalEventcount += 1		endif		endfor		Print "spike_countInWin(): spikeTimesWv",nameofwave(spikeTimesWv),"spikecount",spikecount,"totalEventcount",totalEventcount	return spikecountendfunction spike_ISIsAndHist(spikeTimesWv,spikeTimesCol,hasSpikeCol,hasSpikeVal,startX,endX,isiOutRef,histOutRef)	WAVE spikeTimesWv //from spikeTimesFromDVDT function	Variable startX, endX		//start and end times  INCLUSIVE	Variable spikeTimesCol //column containing spike times	Variable hasSpikeCol, hasSpikeVal	//column containing whether or not a spike occured and the value that indicates a spike occured (must be real, not NaN inf)	String isiOutRef,histOutRef		Variable i,num=dimsize(spikeTimesWv,0),count=-1,st,last_st,last_i,isi	Variable numOut = spike_countInWin(spikeTimesWv,spikeTimesCol,hasSpikeCol,hasSpikeVal,startX,endX) - 1	Variable isiMean = 0,isiMin=inf,isiMax=-inf	if (numOut < 0)		Print "spike_ISIsAndHist() less than 2 spikes in window. aborting!"	endif	Duplicate/o/r=[0,numOut-1][0,2] spikeTimesWv,  $isiOutRef/wave=out	//will store: col 0 -- isi, col 1 -- spike time, col 2 -- index in spikeTimesWv	out = nan		for (i=0;i<num;i+=1)		if (numtype(spikeTimesWv[i][hasSpikeCol]) || (spikeTimesWv[i][hasSpikeCol] != hasSpikeVal) )		//is it a spike?			continue		//move on if not		endif		st = spikeTimesWv[i][spikeTimesCol]		if ( (st < startX) || (st > endX) )		//is it in the range of interest?			continue		//move on if not		endif						if (count==-1)		//have we found the first spike? if so, just note its time and index and move on			last_st = st			last_i = i		//index by spike at the beginning of the interval, not the spike at the end			count = 0			//iterate so we don't get caught at this stage again			continue		endif				//for all following spikes, calculate the isi, store the time and index of the preceding spike		isi = st - last_st				out[count][0] = isi		out[count][1] = last_st		out[count][2] = last_i					isiMean += isi		isiMin = min(isiMin,isi)		isiMax = max(isiMax,isi)				//store values from this spike for next spike		last_st = st		last_i = i				count += 1		if (count == numOut)		//are we now about to start looking for the (non-existent) next spike after the last spike in the window? if so, stop			break		endif					endfor	isiMean /= count		setdimlabel 1,0,isi,out	setdimlabel 1,1,spikeTime,out	setdimlabel 1,2,indexInSpikeTimeWv,out		String noteStr = "spike_ISIsAndHist_spikeTimesWv:"+nameofwave(spikeTimesWv)+";"	noteStr += "spike_ISIsAndHist_spikeTimesCol:"+num2str(spikeTimesCol)+";"	noteStr += "spike_ISIsAndHist_hasSpikeCol:"+num2str(hasSpikeCol)+";"	noteStr += "spike_ISIsAndHist_hasSpikeVal:"+num2str(hasSpikeVal)+";"	noteStr += "spike_ISIsAndHist_startX:"+num2str(startX)+";"	noteStr += "spike_ISIsAndHist_endX:"+num2str(endX)+";"	noteStr += "spike_ISIsAndHist_isiMean:"+num2str(isiMean)+";"	noteStr += "spike_ISIsAndHist_isiMin:"+num2str(isiMin)+";"	noteStr += "spike_ISIsAndHist_isiMax:"+num2str(isiMax)+";"	noteStr += "spike_ISIsAndHist_count:"+num2str(count)+";"	noteStr += "spike_ISIsAndHist_isiOutRef:"+isiOutRef+";"	noteStr += "spike_ISIsAndHist_histOutRef:"+histOutRef+";"		Variable mean		histogram/dest=$histOutRef out		note/nocr out, noteStr	note/nocr $histOutRef,note(out)		Print "spike_ISIsAndHist(): isiMean",isiMean,"isiMax",isiMax,"isiMin",isiMin,"count",count,"isiOutRef",isiOutRef,"histOutRef",histOutRef	endfunction img_crossingsToCoords(img,level,outRef)	WAVE img	Double level	String outRef		variable i,j,rows=dimsize(img,0),cols=dimsize(img,1)	make/o/n=(cols) $outref/wave=out	out = nan	for (i=0;i<cols;i+=1)		for (j=0;j<rows;j+=1)			if (img[j][i] > level)				out[i] = j				break			endif		endfor	endfor	print "img_crossingsToCoords",rows,colsendfunction img_toLineShiftedPairs(img,m,b,doDisplay,interpCoef)	WAVE img	Double m,b		//m is a slope rows per column						//b is an offset in rows						//calculated from fitting the level crossing for each column of a thresholded img with 						//imagethreshold/o/m=2 and then img_crossingsToCoords	Variable doDisplay	Double interpCoef	//see end of function		variable rows=dimsize(img,0)	variable cols=dimsize(img,1)	variable maxOffset = m*cols		make/o/d/n=(rows,cols) zVals	make/o/d/n=(rows,cols) relRow	Variable totalPnts=rows*cols	make/o/d/n=(totalPnts) combinedZVals,combinedRelRow		//for each column, add its relative offset to the point values	zVals = img[p][q][0]	relRow = p - m*q			//relRow = p - b - m*q		//relative row position is the actual row position - the offset in rows - the additional offset from the sloping line 	combinedRelRow = relRow[mod(p,rows)][floor(p/rows)]	combinedZVals = zVals[mod(p,rows)][floor(p/rows)]		duplicate/o combinedZVals,combinedZValsSort	duplicate/o combinedRelRow,combinedRelRowSort	sort combinedRelRow,combinedZValsSort,combinedRelRowSort	if (doDisplay)	display/k=1		Variable i		for (i=0;i<cols;i+=1)			appendtograph/W=$S_name zVals[][i] vs relRow[][i]		endfor		ModifyGraph/W=$S_name mode=2	endif	double maxGap=0,gap	for (i=1;i<totalPnts;i+=1)		gap = combinedRelRowSort[i] - combinedRelRowSort[i-1]		if (gap > maxgap)				maxgap = gap		endif	endfor		Print "maxGap",maxGap		Double startRow = combinedRelRowSort[0]	Double range = combinedRelRowSort[totalPnts-1] - startRow	Double interpSpacing = maxgap*interpCoef	Variable interpPnts = floor(range / interpSpacing)	if (mod(interpPnts,2) != 0)		interpPnts-=1		//shave off a point to make it even (for FFT)	endif	Variable origScalePnts = floor(rows-maxOffset)	if (mod(origScalePnts,2) != 0)		origScalePnts-=1		//shave off a point to make it even (for FFT)	endif		make/o/d/n=(interpPnts) combinedInterp	make/o/d/n=(origScalePnts) origScaleInterp	setscale/p x,startRow,interpSpacing,combinedInterp	combinedInterp = interp(x, combinedRelRowSort, combinedZValsSort )	origScaleInterp = interp(x,combinedRelRowSort, combinedZValsSort )		differentiate combinedInterp/D=lsf	differentiate origScaleInterp/D=lsf_p		fft/dest=otf lsf	fft/dest=oft_p lsf_pendfunction img_deblur(img,outRef,gaussianMat,relaxationGamma)	WAVE img,gaussianMat		//gaussianMat must be single or double precision float, use redimension/d if not	String outRef	Double relaxationGamma	//as in imageRestore			Variable i,planes=dimsize(img,2)	for (i=0;i<planes;i+=1)		if (mod(i,5) == 0)			Print "starting iteration",i		endif		imagetransform/p=(i) getPlane,img		WAVE plane = $"M_imageplane"		redimension/d plane		ImageRestore/DEST=$"img_restored" srcWave=plane , psfWave=gaussianMat, relaxationGamma=(relaxationGamma)		wave restored = $"img_restored"		if (i==0)			duplicate/o restored, $outRef/wave=out			redimension/n=(-1,-1,1) $outRef		else			imagetransform/p=(i)/insw=restored/o insertzplane , $outRef		endif	endfor	endfunction te_getIO(inList,outList,startX,endX,outRef_in,outRef_out)	String inList,outList		//list of sweeps containing input rec and output rec	Variable startX,endX		//window to get stats on	String outRef_in,outRef_out		//store wavestats for input waves and output waves respectively	Variable i,num = min(itemsinlist(inList),itemsinlist(outList))	String in,out	for (i=0;i<num;i+=1)		in = stringfromlist(i,inList)		out = stringfromlist(i,outList)		wavestats/Q/R=(startX,endX)/W  $in		if (i==0)			WAVE M_wavestats			duplicate/o M_wavestats,$outref_in/wave=out_in			//redimension/n=(-1,i+1) out_in 		else			redimension/n=(-1,i+1) out_in 			out_in[][i] = M_wavestats[p]		endif				wavestats/Q/R=(startX,endX)/W  $out		if (i==0)			duplicate/o M_wavestats,$outref_out/wave=out_out		else			redimension/n=(-1,i+1) out_out 			out_out[][i] = M_wavestats[p]		endif			endforend//FITTING GUIfunction/S fits_getPackStr()		//sets name of package data folder for fitter related stuff	return "fits_gui_data"endfunction fits_newFitter(fitterWinN)	String fitterWinN		DFREF fitterDFR = getPackageInstanceDFREF(fits_getPackStr(),fitterWinN)		//make a folder for this fitter window		newpanel/k=1/n=$fitterWinN/w=(0,0,200,200)	setwindow $fitterWinN hook(fits_winHook) = fits_winHook	button addFit,win=$fitterWinN,size={50,15},pos={0,0},title="New Fit",proc=fits_addFitActionendfunction fits_winHook(s)	STRUCT WMWinHookStruct &s		if (s.eventCode == 2)		//window being killed		fits_deleteFitterPackage(s.winname)		Print "fits_winHook() fitter window ",s.winname," killed. deleting package info"	endifendfunction fits_deleteFitterPackage(fitterWinN)	String fitterWinN		DFREF fitterDFR = getPackageInstanceDFREF(fits_getPackStr(),fitterWinN)		killdatafolder/Z fitterDFR 	if (V_flag)		Print "fits_deleteFitterPackage(): package instance directory for win",fitterWinN,"could not be killed. Likely a wave in the directory is plotted."	endifendfunction  fits_addFitAction(s) :  ButtonControl	STRUCT WMButtonAction &s	if (s.eventCode != 2)		//ignore unless mouse up (after click)		return 0	endif	fits_addFit(s.win,"")		return 0endfunction fits_addFit(fitterWinN,fitname)	String fitterWinN	String fitname		//optionally pass "" to prompt user		if (!strlen(fitname))		fitName = "fit_"+num2str(numPackageInstanceOrSubfolder(fits_getPackStr(),fitterWinN))		prompt fitname, "Select a name for the fit"		doprompt "Name the fit", fitname	endif		if (V_flag || !strlen(fitname))		return 0	endif		DFREF fitterDFR = getPackageInstanceDFREF(fits_getPackStr(),fitterWinN)		SVAR/Z fitList = fitterDFR:fitList	if (!svar_exists(fitList))		String/G fitterDFR:fitList		SVAR fitList = fitterDFR:fitList		fitList = ""	endif	Variable prevNumFits = itemsinlist(fitList)	Variable fitnamepos = WhichListItem(fitname,fitList)	if (fitnamepos > -1)		Print "fits_addFit() requested new fit name ",fitname," exists (fit #",fitnamepos,"). Choose a new name (aborting)"		return 0	else		fitList += fitname + ";"		fitnamepos = prevNumFits	endif		//gui-related	Variable height = 400	Variable widthPerFit = 200, fitSpacing = 4	Variable topStart = 17	Variable leftStart = 20	Variable fitStart = leftStart+ (widthPerFit+fitSpacing) * fitnamepos	Variable fitEnd = fitStart + widthPerFit	DFREF fitDFR = getPackageInstanceSubFoldDFREF(fits_getPackStr(),fitterWinN,fitname)		//create subfolder		Variable numInitRows = 25	Make/o/t/n=(numInitRows) fitDFR:listwave/wave=listwave; variable c=0	c=0;listwave[c] = "myExp"; 				SetDimLabel 0,c,fitFunc,listwave 	c=1;listwave[c] = "3" ; 					SetDimLabel 0,c,numExps,listwave 	c=2;listwave[c] = fitname + "_coef"; 	SetDimLabel 0,c,coefWave,listwave 	c=3;listwave[c] = ""	; 					SetDimLabel 0,c,dataWave,listwave 	//data wave	c=4;listwave[c] = "0.01"; 				SetDimLabel 0,c,fitStartX,listwave 		//FIT startx	c=5;listwave[c] = "0.06"	; 				SetDimLabel 0,c,fitEndX,listwave 		//FIT endx	c=6;listwave[c] = fitname + "_fit"; 	SetDimLabel 0,c,fitWave,listwave 	c=7;listwave[c] = fitname + "_disp"; 	SetDimLabel 0,c,dispWin,listwave 	//window for display	c=8;listwave[c] = "0.01"; 				SetDimLabel 0,c,x0,listwave 	c=9;listwave[c] = "1"; 					SetDimLabel 0,c,computeOnCoefWaveChange,listwave 	c=10;listwave[c] = "0.01"; 				SetDimLabel 0,c,fitStartX,listwave 		//MODEL startx	-- where to compute fit from, e.g. different than FIT start/end for extrapolation	c=11;listwave[c] = "0.05"	; 				SetDimLabel 0,c,fitEndX,listwave 		//MODEL endx	c=12;listwave[c] = "0.01;"	;			SetDimLabel 0,c,dispStartXList,listwave		//list of other display range startxs	c=13;listwave[c] = "0.012;"	;			SetDimLabel 0,c,dispEndXList,listwave		//list of other display range endxs (pairs with startx list)	c=14;listwave[c] = fitname + "_res";	SetDimLabel 0,c,resWave,listwave	c=15;listwave[c] = fitname + "_con";	SetDimLabel 0,c,constraintsWave,listwave		c=16;listwave[c] = "";						SetDimLabel 0,c,lastFitChiSq,listwave			//chiSq (ssRes) at end of fitting	c=17;listwave[c] = "";						SetDimLabel 0,c,calcChiSq,listwave				//calculated chiSq from the model, including an extrapolation	c=18;listwave[c] = "";						SetDimLabel 0,c,min_fitChiSq,listwave			//chiSq (ssRes) at end of fitting  -- min seen at all (saved to fitChiSq_minCoefs)	c=19;listwave[c] = "";						SetDimLabel 0,c,min_calcChiSq,listwave				//calculated chiSq from the model, including an extrapolation	 -- min seen at all (saved to calcChiSq_minCoefs)		c=20;listwave[c] = "2";					SetDimLabel 0,c,randomizeByFactor,listwave //choose coef randomization factor, double click row to randomize by values -- skips constants	c=21;listwave[c] = "0.00001";				SetDimLabel 0,c,V_fitTol,listwave	//fractional decrease in chisq (SSres) before fit stops. between 0.1 and 0.00001	c=22;listwave[c] = "10";					SetDimLabel 0,c,searchSubdiv,listwave	c=23;listwave[c] = fitname+"_absRes";	SetDimLabel 0,c,absResWave,listwave	c=24;listwave[c] = "";						SetDimLabel 0,c,absChiSq,listwave	Make/o/n=(numInitRows) fitDFR:selwave/wave=selwave	selwave = ( (p >= 16) && (p <= 19) ) ? 2^0 : 2^1		//make cell(s) editable	Make/o/t/n=(numInitRows) fitDFR:titlewave/wave=titlewave	titlewave[0] = fitname		listbox $fitname,win=$fitterWinN,listwave=listwave,selwave=selwave,titlewave=titlewave,size={widthPerfit,height},pos={fitStart,topStart},proc=fits_lbAction			fits_updateCoefs(fitterWinN,fitname)	//note: fitname cannot be the name of any other control in the window (e.g., a button). This would be avoidable by giving the listbox a safe, arbitrary name	//but then recovering the fitname during a listbox action becomes slightly more complicatedend//handles coef wave, coef value display, limits setvars, and constants check boxfunction fits_updateCoefs(fitterWinN,fitname)	//keeps # of setVars equal to numCoefs	String fitterWinN	String fitname			Variable defaultMin=0	Variable defaultMax=1e5			DFREF fitDFR = getPackageInstanceSubFoldDFREF(fits_getPackStr(),fitterWinN,fitname)		//create subfolder	WAVE/T listwave = fitDFR:listwave	Variable numCoefs = str2num(listwave[1])	//need this many setVars	SVAR/Z coefSetVarList = fitDFR:coefSetVarList	Variable prevNumSetVars	if (!svar_exists(coefSetVarList))		prevNumSetVars = 0		String/G fitDFR:coefSetVarList		SVAR coefSetVarList = fitDFR:coefSetVarList		coefSetVarList = ""	else		prevNumSetVars = itemsinlist(coefSetVarList)	endif		if (prevNumSetVars == numCoefs)		return 0	endif	String minAppendStr = "_l"		//for low limit set var	String maxAppendStr = "_h"		//for high limit set var	String holdCBAppendStr = "_a"	//for constant.. cant think of anything better	Variable i,index,numToDelete = prevNumSetVars - numCoefs	String setvar	for (i=0;i<numToDelete;i+=1)		index = prevNumSetVars - 1 - i		setvar = stringfromlist(index,coefSetVarList)		killcontrol/w=$fitterWinN $setvar		//kill the main set variable containing the coefs value		killcontrol/w=$fitterWinN $(setvar+minAppendStr)		//the one for min		killcontrol/w=$fitterWinN $(setvar+maxAppendStr)		//the one for max		killcontrol/W=$fitterWinN $(setvar+holdCBAppendStr)		coefSetVarList = removelistitem(index,coefSetVarList)	endfor		Variable numSetVars = itemsinlist(coefSetVarList)	//will be zero if first time through		String setVarBaseName = fitname + "_csv_"	//must be unique to each fitname and setvar as different fits could otherwise have the same setvar names (csv = coef set var)	String titleBaseName = ""		//set variable title string, index in coef wave is appended	String minTitleStr = "l"	String maxTitleStr = "h"	String constantCBTitleStr = ""		//no title to save space at present		//find out position of main listbox	controlinfo/W=$fitterWinN/G=0 $fitname		//check that coefWAve,constraints wave, and constants string exist are are the right size	String coefWaveRef = listwave[2]	WAVE/Z/D coefWave = $coefWaveREf	if (!WaveExists(coefWave))		make/o/d/n=(numCoefs) $("root:"+coefWaveRef)/wave=coefWave	else		if (dimsize(coefwave,0) != numCoefs)			redimension/n=(numCoefs) coefWave		endif	endif	String constraintsWaveRef = listwave[15]	WAVE/Z/D constraintsWave = $constraintsWaveRef	if (!WaveExists(constraintsWave))		make/o/d/n=(numCoefs,2) $("root:"+constraintsWaveRef)/wave=constraintsWave		setdimlabel 1,0,mins,constraintsWave		setdimlabel 1,1,maxes,constraintsWave	else		if (dimsize(constraintsWave,0) != numCoefs)			redimension/n=(numCoefs,2) constraintsWave			constraintsWave[][0] = defaultMin			constraintsWave[][1] = defaultMax		endif	endif		//update constraints text wave (also called when constraints are altered in GUI)	fits_updateConstraintsTextWave(fitterWinN,fitname)		SVAR/Z fitConstantsString = fitDFR:fitConstantsString	if (!SVAR_Exists(fitConstantsString))		String/G fitDFR:fitConstantsString		SVAR fitConstantsString = fitDFR:fitConstantsString		fitConstantsString = text_makeStringList("0", numCoefs, "")	endif	Variable constStrLen = strlen(fitConstantsString)	if (constStrLen > numCoefs)		fitConstantsString = fitConstantsString[0,numCoefs-1]	elseif (constStrLen < numCoefs)		fitConstantsString += text_makeStringList("0", numCoefs-constStrLen, "")	endif			Variable ySpace = 3		//dist between lbbox and first setvar	Variable start_top = V_top + V_height + ySpace	Variable start_left = V_left 		Variable setVarSpacingHeight = 2		//dist between setVars		Variable setVarHeight = 14	Variable mainSetVarWidth = V_width/2.6	Variable minMaxSetVarWidth = V_width / 3.8	Variable constCBWidth = V_width - minMaxSetVarWidth - mainSetVarWidth	variable curry		Variable mainSetVarLeftOffset=start_left	Variable minSetVarLeftOffset=mainSetVarLeftOffset+mainSetVarWidth	Variable maxSetVarLeftOffset=minSetVarLeftOffset+minMaxSetVarWidth	Variable constCBLeftOffset=maxSetVarLeftOffset+minMaxSetVarWidth		//makes any more set vars needed	for (i=numSetVars;i<numCoefs;i+=1)		setvar = setVarBaseName + num2str(i)		curry = start_top + (setVarHeight + setVarSpacingHeight) * i		//main set var (containing coef value)		SetVariable $setvar win=$fitterWinN,value=coefWave[i],title=(titleBaseName+num2str(i)),disable=0,proc=fits_setVarAction		SetVariable $setvar win=$fitterWinN,pos={mainSetVarLeftOffset,curry},size={mainSetVarWidth,setVarHeight}		SetVariable $setvar win=$fitterWinN,userdata(fitname)=fitname		SetVariable $setvar win=$fitterWinN,userdata(coefIndex)=num2str(i)		//min set var		SetVariable $(setvar+minAppendStr) win=$fitterWinN,value=constraintsWave[i][0],title=minTitleStr,disable=0,proc=fits_conSetVarAction		SetVariable $(setvar+minAppendStr) win=$fitterWinN,pos={minSetVarLeftOffset,curry},size={minMaxSetVarWidth,setVarHeight}		SetVariable $(setvar+minAppendStr) win=$fitterWinN,userdata(fitname)=fitname		SetVariable $(setvar+minAppendStr) win=$fitterWinN,userdata(coefIndex)=num2str(i)		//max set var		SetVariable $(setvar+maxAppendStr) win=$fitterWinN,value=constraintsWave[i][1],title=maxTitleStr,disable=0,proc=fits_conSetVarAction		SetVariable $(setvar+maxAppendStr) win=$fitterWinN,pos={maxSetVarLeftOffset,curry},size={minMaxSetVarWidth,setVarHeight}		SetVariable $(setvar+maxAppendStr) win=$fitterWinN,userdata(fitname)=fitname		SetVariable $(setvar+maxAppendStr) win=$fitterWinN,userdata(coefIndex)=num2str(i)		coefSetVarList += setvar + ";"		//hold constant checkbox -- start at 0 and start text wave at zero; individual cbs will handle themselves		checkbox $(setVar+holdCBAppendStr) win=$fitterWinN,title=constantCBTitleStr,value=0,disable=0,proc=fits_constCBAction		checkbox $(setVar+holdCBAppendStr) win=$fitterWinN,pos={constCBLeftOffset,curry},size={constCBWidth,setVarHeight}		checkbox $(setVar+holdCBAppendStr) win=$fitterWinN,userdata(fitname)=fitname		checkbox $(setVar+holdCBAppendStr) win=$fitterWinN,userdata(coefIndex)=num2str(i)	endforendfunction fits_lbAction(s) : ListboxControl	STRUCT WMListboxAction &s		Variable editFinished = s.eventcode == 7	variable rightClick = (s.eventmod & 2^0) && (s.eventmod & 2^4) && (s.eventcode == 1)	if (editFinished)		DFREF fitDFR = getPackageInstanceSubFoldDFREF(fits_getPackStr(),s.win,s.ctrlname)		//create subfolder		WAVE/T listwave = fitDFR:listwave				if (s.row == 1)	//edit of numCoefs			fits_updateCoefs(s.win,s.ctrlname)			return 0		endif				if (s.row == 3)	//edit of datawave			String dataWaveRef = listwave[3]			if (!strlen(dataWaveRef) || !waveExists($dataWaveRef))				return 0			endif			String prevDataWaveRef = GetUserData(s.win, s.ctrlname,"lastDataWaveRef")			if ( EqualWaves($prevDataWaveRef,$dataWaveRef,4 + 512) )		//equal waves based on scaling and dimension sizes?				return 0		//then do nothing			endif			listwave[4] = num2str(DimOffset($dataWaveRef,0))			listwave[10] = listwave[4]			Variable lenp = dimsize($dataWaveRef,0)			Variable delta = dimdelta($dataWaveRef,0)			listwave[5] = num2str((lenp-1)*delta)					listwave[11] = listwave[5]			listbox $s.ctrlname, win=$s.win, userdata(lastDataWaveRef) = dataWaveRef		//save this as the last data wave ref		endif				if ( (s.row >= 10) && (s.row <= 13) )		//model range and or display related -- update model			fits_showModel(s.win,s.ctrlname)		endif	endif			//endif for editing finished		if ( rightClick && (s.row == -1) )		//right click in title area		if ((s.eventmod & 2^1) != 0)		//shift down, run fit			fits_fit(s.win,s.ctrlname,1,1)		else			fits_showModel(s.win,s.ctrlname)		endif	endif		if ( rightClick && (s.row == 20) )		//right click in randomization factor row, do randomization		DFREF fitDFR = getPackageInstanceSubFoldDFREF(fits_getPackStr(),s.win,s.ctrlname)		//create subfolder		WAVE/T listwave = fitDFR:listwave		fits_randomizeCoefs(s.win,s.ctrlname,str2num(listwave[20]))	endif		return 0endfunction fits_setVarAction(s) 	STRUCT WMSetVariableAction &s		String fitname = GetUserData(s.win,s.ctrlname,"fitname")	DFREF fitDFR = getPackageInstanceSubFoldDFREF(fits_getPackStr(),s.win,fitname)		if (s.eventcode == 6)		//value change by dependency update		DFREF fitDFR = getPackageInstanceSubFoldDFREF(fits_getPackStr(),s.win,fitname)			WAVE/T listwave = fitDFR:listwave		String computeOnCoefWaveChange = listwave[9]		if (str2num(computeOnCoefWaveChange))			fits_showModel(s.win,fitname)		endif			Variable coefIndex = str2num(GetUserData(s.win,s.ctrlname,"coefIndex"))		endif		variable rightClick=  (s.eventmod & 2^0) && (s.eventmod & 2^4)	variable ctrlDown = s.eventmod & 2^3	if (rightClick)		//right click		DFREF fitterDFR = getPackageInstanceDFREF(fits_getPackStr(),s.win)			SVAR/Z fitList = fitterDFR:fitList		if (!Svar_exists(fitList))			Print "fits_setVarAction(): unexpected error, fitList does not exist in fitter GUI package data. aborting copy"		else			Variable fitListPos = whichlistitem(fitname,fitlist)			if (fitListPos < 0)				Print "fits_setVarAction(): unexpected error, fitname,",fitname," does not appear in fitter GUI package data fitList. copy aborting"			else				Variable copyFromFitListPos = fitListPos + (ctrlDown ? 1 : -1)		//do one to the right for ctrl down, one to left otherwise				Variable numFitListPositions = itemsinlist(fitlist)				if ( (copyFromFitListPos >= 0) && (copyFromFitListPos < numFitListPositions) )		//valid click, not trying to copy from before first or after last					Variable coefIndex0 = str2num(GetUserData(s.win,s.ctrlname,"coefIndex"))						if (!numtype(coefindex0) && (coefIndex0 > 0))						String targetFitName = stringfromlist(copyFromFitListPos,fitlist)						DFREF fit2DFR = getPackageInstanceSubFoldDFREF(fits_getPackStr(),s.win,targetFitName)							SVAR/Z coefSetVarList = fit2DFR:coefSetVarList						Variable numSetVars = itemsinlist(		coefSetVarList)						if (coefIndex0<numSetVars)							String setvar2name = stringfromlist(coefIndex0,coefSetVarList)							ControlInfo/W=$s.win $setvar2name							s.svwave[s.rowIndex][s.colIndex] = V_Value						endif					endif				endif			endif		endif	endif		return 0endfunction fits_conSetVarAction(s)	STRUCT WMSetVariableAction &s			if (s.eventcode == 6)		//value change by dependency update		Print "fits_conSetVarAction(): constraint changed, stored in",s.vName,"newVal",s.dval		String fitname = GetUserData(s.win,s.ctrlname,"fitname")		fits_updateConstraintsTextWave(s.win,fitname)		return 0		endif		return 0endfunction fits_constCBAction(s)  : CheckBoxControl	STRUCT WMCheckboxAction &s		if (s.eventcode == 2)	//mouse up, value likely changed		String fitname = GetUserData(s.win,s.ctrlname,"fitname")		DFREF fitDFR = getPackageInstanceSubFoldDFREF(fits_getPackStr(),s.win,fitname)		SVAR/Z fitConstantsString = fitDFR:fitConstantsString		if (!SVAR_Exists(fitConstantsString))			WAVE/T listwave = fitDFR:listwave			String coefWaveRef = listwave[2]			Variable numcoefs = dimsize($coefWaveREf,0)			numcoefs = numtype(numCoefs) ? 0 : numCoefs			String/G fitDFR:fitConstantsString = text_makeStringList("0", numCoefs, "") 			SVAR fitConstantsString = fitDFR:fitConstantsString		endif		Variable coefIndex = str2num(GetUserData(s.win,s.ctrlname,"coefIndex"))		//fitConstantsString[coefIndex] = num2str(s.checked)		fitConstantsString[coefIndex,coefIndex] = num2str(s.checked)		print "fitConstantsString",fitConstantsString		fits_updateConstraintsTextWave(s.win,fitname)	endif	return 0endfunction fits_updateConstraintsTextWave(fitterWinN,fitname)	String fitterWinN,fitname		DFREF fitDFR = getPackageInstanceSubFoldDFREF(fits_getPackStr(),fitterWinN,fitname)	WAVE/T listwave = fitDFR:listwave	String constraintsWaveRef = listwave[15]	WAVE/D constraintsWave = $constraintsWaveRef	SVAR/Z fitConstantsString = fitDFR:fitConstantsString	Variable possibleConstants = SVAR_exists(fitConstantsString)	Variable numCoefs = dimsizE(constraintsWave,0)	Variable numConstraintsPerCoef = dimsize(constraintsWave,1)	variable i,j,conVal,count=0	for (i=0;i<numCoefs;i+=1)		//skip coef if held constant	-- having constants and defining limits for them seems to throw a very quiet fit error		if (possibleConstants && stringmatch(fitConstantsString[i],"1") )			continue		endif		for (j=0;j<numConstraintsPerCoef;J+=1)			conVal = constraintsWave[i][j]			if (numtype(conval)==2)		//ignore nan for now				continue			endif						if (count == 0)				make/o/t/n=(1) fitDFR:constraintsTextWave/wave=conTWave			else				redimension/n=(count+1) conTWave			endif						if (j==0)				conTWave[count] = "K" + num2str(i) + " > " + num2str(conVal)							elseif (j==1)				conTWave[count] = "K" + num2str(i) + " < " + num2str(conVal)										//add more constraints with j == 2, etc.			endif			count +=1		endfor	endfor 	return 0		end//main fit function: stores path takenfunction fits_fit(fitterWinN,fitname,computeAfter,reportFitErr)	String fitterWinN	String fitname	Variable computeAfter	//pass true to compute and display after with fits_compute()	Variable reportFitErr	//report to command line. fit errors always report to listbox title		DFREF fitDFR = getPackageInstanceSubFoldDFREF(fits_getPackStr(),fitterWinN,fitname)	WAVE selwave = fitDFR:selwave	WAVE/T listwave = fitDFR:listwave	String coefWaveRef = listWave[2]	String dataWaveRef = listwave[3]	variable numCoefs = dimsize($coefWaveRef,0)	SVAR/Z fitConstantsString = fitDFR:fitConstantsString	if (!SVAR_Exists(fitConstantsString))			String/G fitDFR:fitConstantsString = text_makeStringList("0", numCoefs, "") 			SVAR fitConstantsString = fitDFR:fitConstantsString		endif	WAVE constraintsTextWave=fitDFR:constraintsTextWave	Variable/G x0 = str2num(listwave[8])		//sets a global in case used it fit (as it is for myexp)	Variable startX = str2num(listwave[4])	Variable endX = str2num(listwave[5])		Variable V_fitTol = str2num(listwave[21])		//variables input or output by curvefit and funcfit	variable V_FitNumIters	Variable V_FitOptions = 0		//don't set fit options so that progress is not tracked	Variable V_FitError = 0 //tell fit function that we want to handle errors, not Igor	String S_info		//ask for info about fit stored here	Variable V_fitQuitReason			//check for custom exponential fit, use Igor's fit to determine initial guesses if none set by user	String fitStr = listwave[0]	if (stringmatch(fitStr,"myExp"))		if ( (numcoefs == 3) || (numcoefs == 5) )			variable sumcoefs = sum($coefwaveref)			if (numtype(sumcoefs))	//if guesses contain nan inf, autogenerate guesses and fill coef wave (Igor's built in exponential fits do this well)				WAVE/D W_coef				if (numcoefs == 3)					curvefit/q/H=fitConstantsString/k={x0}/o exp_XOffset, $dataWaveRef(startX,endX)/C=constraintsTextWave 									else //numcoefs == 5					curvefit/q/H=fitConstantsString/k={x0}/o dblexp_XOffset, $dataWaveRef(startX,endX)/C=constraintsTextWave 				endif								if (V_fitError)					Print "fits_fit() error generating initial guesses with igor's built in function. Aborting. V_FitError",V_FitError,"V_fitQuitReason",V_fitQuitReason				else					Print "fits_fit() initial guess set by built in Igor exp function"					duplicate/o W_coef, $coefWaveRef				endif			endif		endif	endif		FUNCREF fits_protoFunc f = $fitStr	//reset fit variables	V_FitNumIters = nan	V_FitOptions = 2^3		//set bit 3 of V_fitoptions to store path taken, stored in M_iterates (row for each iter, col for each coef and a column for V_chisq)	V_FitError = 0 //tell fit function that we want to handle errors, not Igor	S_info	=""	//ask for info about fit stored here	V_fitQuitReason=nan	FuncFit/H=fitConstantsString/q f, $coefWaveRef,$dataWaveRef(startX,endX)/C=constraintsTextWave		//analyze / save fit	String fitInfo	if (strlen(S_info))		//sometimes stays null if fit error		fitInfo = replacestring(";",S_info,"|")		//make storable in lists that already uses , and ;	else		fitInfo = ""	endif	if (computeAfter)		fits_compute(fitterWinN,fitname)	endif	String chisq; sprintf chisq, "%.20e", V_chisq	listwave[16] = chisq	Double minChiSq = str2num(listwave[18])	minChiSq = fits_isReasonableChiSq(minChiSq) ? minChiSq : inf		//if the current min is not reasonable (usually bc not set, make sure the new one will be smaller and thus saved	if ( (V_chisq < minChiSq) && fits_isReasonableChiSq(V_chisq) )		listwave[18] = chisq		Duplicate/o $coefwaveref, fitDFR:fitChiSq_minCoefs	endif		//logging fit path	WAVE/D M_iterates		//generated with V_FitOptions bit 3 set, tracks fit path	M_iterates[0][dimsize(M_iterates,1)-1] = nan		//first chi sq is zero bc meaningless; don't let it iterfere with plot	WAVE/D/Z iterationHistory = fitDFR:iterationHistory	Variable currFitstartRow	if (!WaveExists(iterationHistory))		duplicate/o M_iterates, fitDFR:iterationHistory		WAVE/D iterationHistory =  fitDFR:iterationHistory		currFitstartRow = 0	else		currFitstartRow = dimsize(iterationHistory,0)		variable cols = dimsize(M_iterates,1)		Variable prevCols = dimsize(iterationHistory,1)		if (cols > prevCols)			redimension/n=(-1,cols) iterationHistory			iterationHistory[][cols-1] = iterationHistory[p][prevCols-1]		//move chi sq to end of each row so consistent 			iterationHistory[][prevCols-1,cols-2] = nan		//delete chi sq from there, save coef data		elseif (cols < prevCols)			redimension/n=(-1,prevCols) M_iterates			M_iterates[][prevCols-1] = M_iterates[p][cols-1]		//move chi sq to end of each row so consistent 			M_iterates[][cols-1,prevCols-2] = nan		//delete chi sq from there, save coef data		endif		concatenate/np=0 {M_iterates},iterationHistory	endif	String del=";"		//delimiter for note info for each fit	string histNote = num2str(currFitstartRow)+del+num2str(V_FitError)+del+fitInfo+del+num2str(V_FitTol)+del+num2str(V_npnts)+del+num2str(V_fitQuitReason)+del	note iterationHistory,histNote		//will automatically carriange return delimit 		WAVE/T titlewave = fitDFR:titlewave	if (V_FitError || V_fitQuitReason)		if (reportFitErr)			print "fits_fit() fit error likely occured. fit info:"			print "histnote  ",histnote			print "histnote format  ","currFitstartRow"+del+"V_FitError"+del+"fitInfo"+"V_FitTol"+del+"V_npnts"+del+"V_fitQuitReason"+del			print "constraintsTextWave:",constraintsTextWave		endif		//report error to title wave		titlewave[0] = fitname + ">Error:"+num2str(V_FitError)+"QuitReason:"+num2str(V_fitQuitReason)	else		//report no error in title wave		titlewave[0] = fitname	endif 	return V_chisqendfunction fits_resetHistory(fitterWinN,fitname)	String fitterWinN,fitname		DFREF fitDFR = getPackageInstanceSubFoldDFREF(fits_getPackStr(),fitterWinN,fitname)	WAVE/D/Z iterationHistory = fitDFR:iterationHistory	if (!WaveExists(iterationHistory))		return 0		//all set	endif	redimension/n=(1,-1) iterationHistory	iterationHistory = (q == dimsize(iterationHistory,1) -1) ? -inf : nan		//set all rows to nan except last which is -inf so that last can indicate start of a fit with nan	note/k iterationHistory		//if iteration history cannot be killed, now at least its in a position to start over unambiguously	killwaves/z iterationHistoryendfunction fits_randomizeCoefs(fitterWinN,fitname,randomizeByFactor)	String fitterWinN,fitname ; variable randomizeByFactor	DFREF fitDFR = getPackageInstanceSubFoldDFREF(fits_getPackStr(),fitterWinN,fitname)	WAVE/T listwave = fitDFR:listwave		String coefWaveRef = listwave[2]		WAVE/D/Z coefWave = $coefWaveRef		if (!WAveexists(coefwave))		print "fits_randomizeCoefs() coefwave",coefwaveref,"not found. aborting"		return 0	endif		Print "fits_randomizeCoefs() prev coefs:"	print/d coefwave		SVAR/Z fitConstantsString = fitDFR:fitConstantsString	variable constants = svar_exists(fitConstantsString) && strlen(fitConstantsString) && stringmatch(fitConstantsString,"*1*")	Variable factor = randomizeByFactor/2		//enoise gives range -num to num; so that's a range twice as large as the number itself already	String constraintsWaveRef = listwave[15]	WAVE/D constraintsWave = $constraintsWaveRef			if (constants)	//hold any constants as constant		coefwave = coefwave[p] + ( stringmatch(fitConstantsString[p],"1") ? 0 : (factor*enoise(coefwave[p])) )	else		coefwave = coefwave[p] + (factor*enoise(coefwave[p]))	endif	//make sure rand value is above minimum, if not truncate to minimum	coefwave = numtype(constraintsWave[p][0] == 2) ? coefwave[p] : ( max(constraintsWave[p][0],coefwave[p]) )	//make sure rand value is below maximum, if not truncate to maximum	coefwave = numtype(constraintsWave[p][1] == 2) ? coefwave[p] : ( min(constraintsWave[p][1],coefwave[p]) )end//automatically runs a number of fits from a range of starting values encompassing the limits set for each coef in the gui (low/high constraints)function fits_fitRange(fitterWinN,fitname,numTestPoints)	String fitterWinN,fitname ; variable numTestPoints	//number of points to test for each variable parameter	 -- should be at least two to get edges		if (numTestPoints < 2)		print "fits_fitRange() please test at least two values. aborting"		return 0	endif		DFREF fitDFR = getPackageInstanceSubFoldDFREF(fits_getPackStr(),fitterWinN,fitname)	WAVE/T listwave = fitDFR:listwave		String coefWaveRef = listwave[2]		WAVE/D/Z coefWave = $coefWaveRef	SVAR/Z fitConstantsString = fitDFR:fitConstantsString	String constraintsWaveRef = listwave[15]	WAVE/D constraintsWave = $constraintsWaveRef		duplicate/o coefwave, coefwave_BU			variable numCoefs = dimsize(coefwave,0)	variable constants = svar_exists(fitConstantsString) && strlen(fitConstantsString)		variable i, constCount = 0	make/o/d/n=(numCoefs) paramStepSizes	make/o/n=(numCoefs) precedingConstants	//need to track constants "seen" in order to keep an update view of the position of the varying coefs in the patternStr	for (i=0;i<numCoefs;i+=1)		if (constants && stringmatch(fitConstantsString[i],"1") )			paramStepSizes[i] = nan		//tracks which are constant by labeling their index nan here			constCount += 1		else					paramStepSizes[i] = (constraintsWave[i][1] - constraintsWave[i][0]) / (numTestPoints-1)		//e.g. 3 test points, first step at 0, then each step covers half the range			precedingConstants[i] = constCount		endif	endfor		String patternsStrs = text_getAllStrings(numCoefs-constCount,numTestPoints)	Variable j,numPatterns = itemsinlist(patternsStrs)	//should/will always be variableParamCount^numTestPoints	variable numConstantsPassed = 0		//need to track constants "seen" in order to keep an update view of the position of the varying coefs in the patternStr	make/o/d/n=(numPatterns,numCoefs) fits_fitRange_tests	variable lastFitChiSq = str2num(listwave[16])	variable bestFitFromRow = -1	double paramVal,chisq	Double minChiSq = ( !numtype(lastFitChiSq) && fits_isReasonableChiSq(lastFitChiSq) ) ? minChiSq : inf			//use last chi sq if valid	for (i=0;i<numPatterns;i+=1)		String patternStr = stringfromlist(i,patternsStrs)		SetDimLabel 0,i,$patternStr,fits_fitRange_tests 		for (j=0;j<numCoefs;j+=1)			if (constants && (numtype(paramStepSizes[j]) == 2) )				paramVal = coefwave[j]			else				paramVal = constraintsWave[j][0] + paramStepSizes[j]*str2num(patternStr[j-precedingConstants[j]])			endif			fits_fitRange_tests[i][j] = paramVal			coefwave[j] = paramVal		//set the actual coefwave for fitting to these values		endfor			chisq = fits_fit(fitterWinN,fitname,0,0)		if ( (chiSq < minChiSq) && fits_isReasonableChiSq(chiSq) )	//want chi sq above 0 but smallest seen			duplicate/o coefwave, coefwave_best			bestFitFromRow = i			minChiSq = chisq		endif 		Print/d "fits_fitRange() count",i,"coefs",coefwave,"minChiSq",minChiSq,"chisq",chisq	endfor		if (bestFitFromRow >= 0)		print "fits_fitRange() new best fit found from row in fits_fitRange_tests",bestFitFromRow		duplicate/o coefwave_best, coefwave	else		duplicate/o coefwave_BU,coefwave	endifendfunction fits_fitRand(fitterWinN,fitname,numTestPoints)	String fitterWinN,fitname ; variable numTestPoints	//number of points to test		if (numTestPoints < 1)		print "fits_fitRange() please test at least two values. aborting"		return 0	endif		DFREF fitDFR = getPackageInstanceSubFoldDFREF(fits_getPackStr(),fitterWinN,fitname)	WAVE/T listwave = fitDFR:listwave		String coefWaveRef = listwave[2]		WAVE/D/Z coefWave = $coefWaveRef	SVAR/Z fitConstantsString = fitDFR:fitConstantsString	String constraintsWaveRef = listwave[15]	WAVE/D constraintsWave = $constraintsWaveRef		duplicate/o coefwave, coefwave_BU			variable numCoefs = dimsize(coefwave,0)	variable constants = svar_exists(fitConstantsString) && strlen(fitConstantsString)		variable i, constCount = 0	make/o/d/n=(numCoefs) paramStepSizes	make/o/n=(numCoefs) precedingConstants	//need to track constants "seen" in order to keep an update view of the position of the varying coefs in the patternStr	for (i=0;i<numCoefs;i+=1)		if (constants && stringmatch(fitConstantsString[i],"1") )			paramStepSizes[i] = nan		//tracks which are constant by labeling their index nan here			constCount += 1		else					paramStepSizes[i] = (constraintsWave[i][1] - constraintsWave[i][0]) / (numTestPoints-1)		//e.g. 3 test points, first step at 0, then each step covers half the range			precedingConstants[i] = constCount		endif	endfor		String patternsStrs = text_getAllStrings(numCoefs-constCount,numTestPoints)	Variable j,numPatterns = itemsinlist(patternsStrs)	//should/will always be variableParamCount^numTestPoints	variable numConstantsPassed = 0		//need to track constants "seen" in order to keep an update view of the position of the varying coefs in the patternStr	make/o/d/n=(numPatterns,numCoefs) fits_fitRange_tests	variable lastFitChiSq = str2num(listwave[16])	variable bestFitFromRow = -1	double paramVal,chisq	Double minChiSq = ( !numtype(lastFitChiSq) && fits_isReasonableChiSq(lastFitChiSq) ) ? minChiSq : inf			//use last chi sq if valid	for (i=0;i<numPatterns;i+=1)		String patternStr = stringfromlist(i,patternsStrs)		SetDimLabel 0,i,$patternStr,fits_fitRange_tests 		for (j=0;j<numCoefs;j+=1)			if (constants && (numtype(paramStepSizes[j]) == 2) )				paramVal = coefwave[j]			else				paramVal = constraintsWave[j][0] + paramStepSizes[j]*str2num(patternStr[j-precedingConstants[j]])			endif			fits_fitRange_tests[i][j] = paramVal			coefwave[j] = paramVal		//set the actual coefwave for fitting to these values		endfor			chisq = fits_fit(fitterWinN,fitname,0,0)		if ( (chiSq < minChiSq) && fits_isReasonableChiSq(chiSq) )	//want chi sq above 0 but smallest seen			duplicate/o coefwave, coefwave_best			bestFitFromRow = i			minChiSq = chisq		endif 		Print/d "fits_fitRange() count",i,"coefs",coefwave,"minChiSq",minChiSq,"chisq",chisq	endfor		if (bestFitFromRow >= 0)		print "fits_fitRange() new best fit found from row in fits_fitRange_tests",bestFitFromRow		duplicate/o coefwave_best, coefwave	else		duplicate/o coefwave_BU,coefwave	endifendfunction/s text_getAllStrings(len,numVals)	Variable len,numVals		//see getStrings()		String out = ""	text_getStrings("",0,len,numVals,out) 	return outend//function basically allowing a variable number of nested for loops//pass getStrings("",0,len,numVals,outStr) to use, returns into outStr the strings of specified length len//of all possible patterns//iterates 0 through numVals-1 at each posistion 0 to pos - 1 //NOTE: TOTAL COUNT OF UNIQUE STRINGS is numVals^len . have checked this for large values.//NOTE: outstr is pass-by-reference, replace that line with print str + num2str(i) to simply print all the strings to command linefunction/s text_getStrings(str,pos,len,numVals,outStr)	string str	variable pos,len,numVals	string &outStr		variable i	if (pos < (len-1))		for (i=0;i<numVals;i+=1)			text_getStrings(str+num2str(i),pos+1,len,numVals,outStr)	//add each position to the string, then run through next set of possible positions		endfor	else		for (i=0;i<numVals;i+=1)			outStr += str + num2str(i) + ";"		//comment this out and uncomment print version to simply print to command line			//print str + num2str(i)		endfor	endifendfunction fits_compute(fitterWinN,fitname,[externalCoefWv])	String fitterWinN	String fitname	WAVE/D externalCoefWv		//optionally pass a coef wave to calc with, instead of the currently used one -- should be valid double precision wave	DFREF fitDFR = getPackageInstanceSubFoldDFREF(fits_getPackStr(),fitterWinN,fitname)	WAVE selwave = fitDFR:selwave	WAVE/T listwave = fitDFR:listwave		String fitStr = listwave[0];	Variable numCoefs = str2num(listwave[1])	String coefWaveRef = listwave[2]	String dataWaveRef = listwave[3]	String fitWaveREf = listWave[6]	String resWaveRef = listWave[14]	String absResWaveRef = listWave[23]	Variable/G x0 = str2num(listwave[8])	if (!strlen(dataWaveRef))		Print "fits_compute(): model ",fitterWinN,fitname," enter a data wave to fit in row 3. aborting."		return -inf	endif	if (!WaveExists($dataWaveRef))		print "fits_compute(): model ",fitterWinN,fitname, " dataRef entered in row 3 is not a wave that exists. aborting."		return -inf	endif		Variable startX = str2num(listwave[10])	Variable endX = str2num(listwave[11])		if (ParamIsDefault(externalCoefWv))		//normal, automated use		WAVE/Z/D coefWave = $coefWaveREf			if (!WaveExists(coefWave) || (dimsize(coefwave,0) != numCoefs))			fits_updateCoefs(fitterWinN,fitname)			WAVE/D coefWave = $coefWaveREf			endif	else		wave/d coefwave =externalCoefWv	endif		WAVE/D dataWave = $dataWaveREf	duplicate/o/r=(startX,endX) dataWave, $fitWaveRef/wave=fitwave	FUNCREF fits_protoFunc f = $fitStr	fitwave = f(coefWave,x)		//check for presence of residuals wave, generate if not present	if (strlen(absResWaveRef))		duplicate/o fitwave, $absResWaveRef/wave=absResWave		if (WaveExists(absResWave))			absResWave = fitwave(x)-dataWave(x)		endif	endif		if (strlen(resWaveRef))			duplicate/o fitwave, $resWaveref/wave=resWave		if (WaveExists(reswave))			if ( (strlen(absResWaveRef)>0) || waveexists(absResWave))		//use difference as calculated there, just square it				reswave = absResWave^2			else	//do full res square calculation					reswave = (fitwave(x)-dataWave(x))^2			endif		endif	endif		Double absChiSq = sum(absResWave)	String abschiSqStr ; sprintf abschiSqStr, "%.20e", absChiSq	listwave[24] = abschiSqStr	Double chiSq = sum(reswave)	String chisqStr; sprintf chisqStr, "%.20e", chiSq	listwave[17] = chisqStr	Double minChiSq = str2num(listwave[19])	minChiSq = fits_isReasonableChiSq(minChiSq) ? minChiSq : inf	if ( (chiSq < minChiSq) && fits_isReasonableChiSq(chiSq) )		listwave[19] = chisqStr		Duplicate/o coefWave, fitDFR:calcChiSq_minCoefs	endif			return chiSqend//sometimes fits return extremely small, like 1e-314 or 0 chiSq; this tries to help ignore them//could be problematic in fitting in a function where the fit is actually perfectfunction fits_isReasonableChiSq(chiSq)	Double chiSq		return !numtype(chiSq) && (chiSq > 1e-20)endfunction fitsG_calcChiSq(dataWv,modelCoefsWv,fitfunc,startx,endx)	WAVE/d dataWv,modelCoefsWv	String fitfunc		//e.x. myExp -- be sure to set any necessary globals like x0 ahead of time!	Variable startX,endX //for calc of residuals		FUNCREF fits_protoFunc f = $fitfunc	variable chiSq = 0,i, delta = dimdelta(dataWv,0)	for (i=startx;i<=endx;i+=delta)		chiSq += (datawv(i) - f(modelCoefsWv,i))^2  	endfor	return chisqendfunction fits_protoFunc(coefWave,x) : FitFunc	WAVE/D coefWave; Double xendfunction fits_showModel(fitterWinN,fitname)	String fitterWinN	String fitname			Variable computed = numtype(fits_compute(fitterWinN,fitname)) != 1		if (!computed)		return 0	endif		DFREF fitDFR = getPackageInstanceSubFoldDFREF(fits_getPackStr(),fitterWinN,fitname)	WAVE selwave = fitDFR:selwave	WAVE/T listwave = fitDFR:listwave		String dispWinN = listwave[7]	Variable newGraph = 0	if (!wintype(dispWinN))		display/k=1/n=$dispWinN;doupdate;		dispWinN = s_name		//s_name holding null string for some reason -- shouldnt be so, next if statement as a patch		if (!strlen(dispWinN))				dispWinN = winname(0,1)		endif		listwave[7] = dispWinN	else		vis_clearGraph(dispWinN)	endif		//implements a display of the fit range, then displays of any use selected ranges (position 10,11 in listwave)	String startXList = listwave[10] + ";" + listwave[12]	String endXList = listwave[11] + ";" + listwave[13]		String dataWaveRef = listwave[3]	String fitWaveREf = listWave[6]	String resWaveRef = listwave[14]	String absResWaveRef = listwave[23]	Variable plotResWave = waveexists($resWaveRef)	variable plotAbsResWave = waveexists($absResWaveRef)	variable graphSpacing = 0.02	variable i,num = min(itemsinlist(startxlist),itemsinlist(endxlist))	variable totalSpacing = graphSpacing * (num-1)	Variable totalGraphSpace = 1-totalSpacing	Variable spacePerGraph = totalGraphSpace / num	String bottomAxStr	Variable axmin,axmax, currs,curre	for (i=0;i<num;i+=1)		bottomAxStr = "B_"+num2str(i)		appendtograph/W=$dispWinN/B=$bottomAxStr $dataWaveRef		appendtograph/W=$dispWinN/B=$bottomAxStr/C=(0,0,0) $fitWaveRef		axmin = str2num(stringfromlist(i,startxlist))		axmax = str2num(stringfromlist(i,endxlist))		setaxis/W=$dispWinN $bottomAxStr,axmin,axmax				currs = i*(spacePerGraph+graphSpacing)		curre = currs + spacePerGraph		modifygraph/W=$dispWinN axisenab($bottomAxStr) = {currs,curre}				if (plotResWave)			appendtograph/W=$dispWinN/B=$bottomAxStr/L=L_res/C=(0,0,0) $resWaveRef		endif		if (plotAbsResWave)			appendtograph/W=$dispWinN/B=$bottomAxStr/L=L_absRes/C=(1,4,52428) $absResWaveRef		endif	endfor		setaxis/W=$dispWinN/A=2 left	if (plotResWave && plotAbsResWave)		modifygraph/W=$dispWinN axisenab(L_res)={0,0.19},axisenab(L_absRes)={0.21,0.4},axisenab(left)={0.415,1}		setaxis/W=$dispWinN/A=2 L_res		elseif (plotResWave)		modifygraph/W=$dispWinN axisenab(L_res)={0,0.3},axisenab(left)={0.32,1}		setaxis/W=$dispWinN/A=2 L_res	elseif (plotAbsReswave)		modifygraph/W=$dispWinN axisenab(L_absRes)={0,0.3},axisenab(left)={0.32,1}		setaxis/W=$dispWinN/A=2 L_absRes	endif	modifygraph/W=$dispWinN freepos=0,lblpos=50endfunction/S fits_printCoefs(fitterWinN,fitname)	String fitterWinN	String fitname			DFREF fitDFR = getPackageInstanceSubFoldDFREF(fits_getPackStr(),fitterWinN,fitname)	WAVE/T listwave = fitDFR:listwave	String coefWaveRef = listwave[2]	if (waveexists($coefwaveref))		wave coefwave = $coefwaveref		Print "fits_printCoefs() fitterWinN, ",fitterWinN,", fitname, ",fitname,", coefWaveRef, ",coefWaveRef," coefs: ",coefwave	else		Print "fits_printCoefs() fitterWinN, ",fitterWinN,", fitname, ",fitname,", coefWaveRef, ",coefWaveRef," coefs not printed, coef wave does not exist."	endif		return coefwaverefend//convert an exponential fit into a log fit -- should already have a least squares best fit that is adequate for the meanfunction fits_exp2log(fitterWinN,fitname)	String fitterWinN,fitname		DFREF fitDFR = getPackageInstanceSubFoldDFREF(fits_getPackStr(),fitterWinN,fitname)	WAVE/T listwave = fitDFR:listwave	end		//general for packagesfunction/DF getPackageDFREF(packageName)	String packageName		DFREF dfr = $("root:Packages:"+packageName)	if (DataFolderRefStatus(dfr) != 1)	// Data folder does not exist?		DFREF dfr = createPackageDF(packageName)	// Create package data folder	endif	return dfr	endfunction/DF createPackageDF(packageName)	//only called by getPackageDFREF	String packageName		NewDataFolder/o root:Packages	NewDataFolder/o $("root:Packages:"+packageName)		DFREF dfr = $("root:Packages:"+packageName)	return dfrendfunction/DF getPackageInstanceDFREF(packageName,instanceName)	String packageName,instanceName		DFREF dfr = getPackageDFREF(packageName)		DFREF instanceDFR = dfr:$instanceName	if (DataFolderRefStatus(instanceDFR) != 1)	// Data folder does not exist?		DFREF instanceDFR = createPackageInstanceDF(packageName,instanceName)	// Create package data folder	endif	return instanceDFRendfunction/DF createPackageInstanceDF(packageName,instanceName)	//only called by getPackageInstanceDFREF	String packageName,instanceName		DFREF dfr = getPackageDFREF(packageName)	newDataFolder/o dfr:$instanceName	DFREF instanceDFR = dfr:$instanceName	return instanceDFRendfunction/DF getPackageInstanceSubfoldDFREF(packageName,instanceName,subfolderName)	String packageName,instanceName,subfolderName		DFREF dfr = getPackageInstanceDFREF(packageName,instanceName)		DFREF subFolderDFR = dfr:$subfolderName	if (DataFolderRefStatus(subFolderDFR) != 1)	// Data folder does not exist?		DFREF subFolderDFR = createPackageInstanceSubfoldDF(packageName,instanceName,subfolderName)	// Create package data folder	endif	return subFolderDFRendfunction/DF createPackageInstanceSubfoldDF(packageName,instanceName,subfolderName)	//only called by getPackageInstanceDFREF	String packageName,instanceName,subfolderName		DFREF dfr = getPackageInstanceDFREF(packageName,instanceName)		newDataFolder/o dfr:$subfolderName	DFREF subFolderDFR = dfr:$subfolderName	return subFolderDFRendfunction numPackageInstanceOrSubfolder(packageName,instanceName)	String packageName		//packageName of interest	String instanceName		//package instance of interest or "" for the count of packages		if (!strlen(instanceName))		//count instances		DFREF dfr = getPackageDFREF(packageName)	else			//count subfolders in an instance		DFREF dfr = getPackageInstanceDFREF(packageName,instanceName)	endif		return countobjectsDFR(dfr,4)end//STILL NEEDS TROUBLESHOOTINGfunction mle_doOptExp(dataWv,col,layerWithMean,layerWithSEM,startX,endX,guessCoefs,coefsScaleWvRef,outputScaleVar)	WAVE/D dataWv	Variable col,layerWithMean,layerWithSEM,startX,endX	WAVE/D guessCoefs		//starting values for MLE curve fit (e.g., your best guesses)	STring	coefsScaleWvRef		//pass non-empty string containing reference to wave to be used with optimize/R flag	Double outputScaleVar			//see optimize/Y flag and use inf NaN to ignore		Variable startP = x2pnt(dataWv,startX)	Variable endP = x2pnt(dataWv,endX)	//make constants wave (though its point[2][0] is purposefully changed during optimization)	Duplicate/o/r=(startX,endX)[0] dataWv,mle_optExp_inputWv	Redimension/n=(-1,3) mle_optExp_inputWv	mle_optExp_inputWv[0][0]=floor( (dimsize(guessCoefs,0) - 1) / 2)		//holds # exps to fit	mle_optExp_inputWv[1][0]=startX			//	mle_optExp_inputWv[2][0]=0	//must be set to zero	mle_optExp_inputWv[][1] = dataWv(x)[col][layerWithMean]	mle_optExp_inputWv[][2] = dataWv(x)[col][layerWithSEM]		if (numtype(outputScaleVar) == 0)		if ( (strlen(coefsScaleWvRef)>0) && waveexists($coefsScaleWvRef) )			optimize/A=1/R=$coefsScaleWvRef/Y=(outputScaleVar)/X=guessCoefs mle_optExp, mle_optExp_inputWv		else			optimize/A=1/X=guessCoefs/Y=(outputScaleVar) mle_optExp, mle_optExp_inputWv		endif	else		//same as within if except no reference to /Y flag		if ( (strlen(coefsScaleWvRef)>0) && waveexists($coefsScaleWvRef) )			optimize/A=1/R=$coefsScaleWvRef/X=guessCoefs mle_optExp, mle_optExp_inputWv		else			optimize/A=1/X=guessCoefs mle_optExp, mle_optExp_inputWv		endif	endif	end//for use with built-in optimize function for maximal likelihood fitting of exponentialsfunction mle_optExp(w,wx)	WAVE/D w		//constants including y values (column 2) and y SEMs (column 3)	WAVE/D wx	//fit coefs wave	//w should have 3 columns, same number of rows as data to be fit!	//column 0 (fewer points than to fit, contains information and constants)	//w[0][0] -- numExps	(calculated as floor( (dimsize(wx,0) - 1) / 2) 	 -- calculating ahead saves computation time	//w[1][0] -- x0 (x offset) for exponential	//w[2][0] -- MUST be set to 0 BEFORE optimize is called, is set to 1 after first iteration		//column 1	//w[*][2] y values		//column 2	//w[*][2] y SEMs			Variable x0 = w[1][0]		Variable i,numExps = w[0][0]		//floor( (numFitCoefs - 1) / 2) 			if (w[2][0] == 0)		//check # iterations		duplicate/o/r=[*][0] w,mle_optExp_internalWv 		redimension/n=(-1) mle_optExp_internalWv		w[2][0]=1		//make sure this if isn't entered again	else		WAVE/D mle_optExp_internalWv	endif			//calculate y predicted	Variable currCoefIndex	mle_optExp_internalWv = wx[0]//set to first coef 	for (i=0;i<numExps;i+=1)		//then add the value of each exponential term		currCoefIndex = 2*i + 1		mle_optExp_internalWv += wx[currCoefIndex]*exp(-(x-x0)/wx[currCoefIndex+1])	endfor		duplicate/o mle_optExp_internalWv,mle_optExp_internalWv_copy		//calculate logLikelihoods (in place) -- likelihood of getting calculated y values given measured mean and SEM	//statsNormalPDF will return a smaller # if the predicted value is unlikely given the observed mean and SEM	//taking the log of this conserves the sign	//so we want to MAXIMIZE this function to get the MOST likely set of coefs	mle_optExp_internalWv = ln(StatsNormalPDF(mle_optExp_internalWv[p],w[p][1],w[p][2]))		variable whatever = 0//placeholder		return sum(mle_optExp_internalWv)endfunction/S fio_mergeTextFiles(matchStr,saveName)	String matchStr 		//match string for subfolders to consider (for example to avoid those that are already in the panel)	String saveName		//include extension e.g., "myfile.txt"	String filenamePreStr = "\\-------------------------------------------------\\\r\nORIGINAL FILE NAME: "	String filenamePostStr= "\r\n\\-------------------------------------------------\\\r\n"	NewPath/O/M="Select PARENT folder/directory (containing txt files)" temp; PathInfo temp	String parentPathStr = S_path	String filename	String/G loadList = ""	Variable i=0, totalABFs=0,refNum,out_refNum,len; String buffer, abfName, fileFullPath, abfNamesList		open/p=temp out_refNum as saveName	if (out_refNum == 0)		Print "fio_catTextFiles() failed to open output file. aborting"		return ""	endif		String fileNames = IndexedFile(temp, -1, ".txt")	Variable numFs = itemsinlist(fileNames)	for (i=0;i<numFs;i+=1)		filename = stringfromlist(i,fileNames)		if (stringmatch(fileName,saveName))			continue		endif		Print "fio_catTextFiles(): opening file",filename				if (stringmatch(filename, matchStr))	//load only matching files			fileFullPath = parentPathStr + filename			open/R/P=temp refNum as filename			if (refNum == 0)				continue			endif			fprintf out_refNum,"%s",filenamePreStr+filename+filenamePostStr+"\n"			do 				FReadLine refNum, buffer				len = strlen(buffer)				if (len == 0)					close refNum						break		// No more lines to be read				endif				fprintf out_refNum,"%s",buffer+"\n"			while(1)				endif			endfor		loadList = sortList(loadList, "\r")	close out_refNum	return loadListendfunction notes_multiFindHook(s)		//add a new version of find	STRUCT WMWinHookStruct &s		if ( ((s.eventMod & 2^3) == 0) || ((s.eventMod & 2^2) == 0) )		//must have CTRL AND ALT		return 0	endif		Variable shiftAlsoDown = (s.eventMod & 2^1) != 0		//search backwards with CTRL ALT SHIFT		String winN = ("FIND_"+s.winname)[0,31]		String multiFindHookStr = GetUserData(s.winname,"","multiFindHookStr")		if (stringmatch("F",s.keytext))//prompt to change string				prompt multiFindHookStr,"Multi find"		doprompt "Multifind",multiFindHookStr		if (V_flag)			return 1		endif			elseif (!stringmatch("D",s.keytext))		//only other condition is "G"				return 0		endif		if (!strlen(multiFindHookStr))		print "notes_multiFindHook(): no string, use CTRL + ALT + F to set"	else				notes_multiFind(multiFindHookStr,shiftAlsoDown)		setwindow $s.winname, userdata(multiFindHookStr)=multiFindHookStr	endif		return 1endfunction notes_multiFind(findStrings,backwardsNotForward)	String findStrings	Variable backwardsNotForward		variable numStrings = itemsinlist(findStrings)	string winN=winname(0,16)	//top notebook	GetSelection notebook, $winN, 1 //Sets V_startParagraph, V_startPos, V_endParagraph, V_endPos based on the selected text in the notebook.	//	print   "V_startParagraph",V_startParagraph, "V_startPos",V_startPos, "V_endParagraph",V_endParagraph, "V_endPos",V_endPos	Variable startPara=V_startParagraph,startPos=V_startPos,endPara=V_endParagraph,endPos=V_endPos	Variable count=0,i,para,pos,matchFound=0,foundPos,nearestFoundPos=inf,paraSearchStart,paraSearchOptions	String findStr,nearestFindStr	do //search paragraph by paragraph		para = startPara + count * (backwardsNotForward ? -1 : 1)		if (backwardsNotForward)			pos = count==0 ? startpos : 0		//start at beginning of current selection or at start of paragraph if not beginning		else			pos = count==0 ? endpos : 0   //start at end of current selection 		endif			V_flag = 0		//track for invalid positions		if (backwardsNotForward && (count==0)) //special case, search only beginning of paragraph			notebook $winN,selection={(para,0),(para,pos)}		else	//search from pos to start of next paragraph			notebook $winN,selection={(para,pos),(para+1,0)}		endif		if (V_flag)		//should be end of notebook			Print "notes_multiFind() no matches found"			notebook $winN,selection={(startPara,startPos),(endPara,endPos)}			break		endif		getselection notebook,$winN, 2		//get selected paragraph text				for (i=0;i<numStrings;i+=1)			//check for a match to any of the findStrings in this paragarph			findStr=stringfromlisT(i,findStrings)			paraSearchStart = backwardsNotForward ? inf : 0		//search from end for backwards, from start if forward			paraSearchOptions = backwardsNotForward ? 1 : 0		//search backwards if backwards, search forward if foward			foundPos=strsearch(S_Selection,findStr,paraSearchStart,paraSearchOptions)			if (foundPos >= 0)				if (matchFound)	//not first match					if (backwardsNotForward)	//nearest is highest position						if (foundPos>nearestFoundPos)							nearestFoundPos = foundPos							nearestFindStr=findStr						endif					else		//nearest is lowest position						if (foundPos<nearestFoundPos)							nearestFoundPos = foundPos							nearestFindStr=findStr						endif					endif				else		//first match					matchFound=1					nearestFoundPos=foundPos					nearestFindStr=findStr				endif			endif		endfor					if (matchFound)			notebook $winN,selection={(para,pos+nearestFoundPos),( para,pos+nearestFoundPos+strlen(nearestFindStr))},findtext={"",1}		endif				count+=1	while (!matchFound) endfunction gizmo_2dToXYZ(wv,xrow,yrow,zrow,outref)	WAVE wv	variable xrow,yrow,zrow	String outref		if ((xrow<0)||(yrow<0)||(zrow<0))		Print "gizmo_2dToXYZ() illegal range, aborting"		return 0	endif		duplicate/o/r=[xrow][] wv,$outref/wave=out	duplicate/o/r=[yrow][]/free wv, temp	concatenate/np=0/dl {temp},out	duplicate/o/r=[zrow][]/free wv, temp	concatenate/np=0/dl {temp},out		matrixtranspose outendfunction fit_linearChirp(w,x) : FitFunc	WAVE w	//contains tau	Variable x		NVAR/Z x0	if (!NVAR_Exists(x0))		Variable/G x0 = 0	endif		return w[0]+ w[1]*sin( w[2]+2*pi*(w[3]*(x-x0) + 0.5*w[4]*(x-x0)^2) )endfunction fit_expChirp(w,x) : FitFunc	WAVE w	//contains tau	Variable x		NVAR/Z x0	if (!NVAR_Exists(x0))		Variable/G x0 = 0	endif		return w[0]+ w[1]*sin( w[2]+ 2*pi*w[3]*(w[4]^((x-x0)-w[5]) - 1)/ln(w[4]) )endfunction VI_repsAndFamily2Site3_repeat(exWv,doDisplay)	WAVE exWv; variable doDisplay		String noteStr=note(exWv)	String rFam_S_fS=replacestring(",",stringbykey("rFam_S_fS",noteStr),";")	String sFam_S_fS=replacestring(",",stringbykey("sFam_S_fS",noteStr),";")	String rFam_P_fS=replacestring(",",stringbykey("rFam_P_fS",noteStr),";")	String sFam_P_fs=replacestring(",",stringbykey("sFam_P_fs",noteStr),";")	String rFam_S_fP=replacestring(",",stringbykey("rFam_S_fP",noteStr),";")	String sFam_S_fP=replacestring(",",stringbykey("sFam_S_fP",noteStr),";")	String rFam_P_fP=replacestring(",",stringbykey("rFam_P_fP",noteStr),";")	String sFam_P_fP=replacestring(",",stringbykey("sFam_P_fP",noteStr),";")	make/o/d/n=(4) VI_repsAndFamily2Site3_tem_S,VI_repsAndFamily2Site3_tem_P	String stepInfoStr_s=replacestring(",",stringbykey("stepInfoStr_s",noteStr),";")	String stepInfoStr_p=replacestring(",",stringbykey("stepInfoStr_p",noteStr),";")	VI_repsAndFamily2Site3_tem_S = str2num(stringfromlist(p,stepInfoStr_s))	VI_repsAndFamily2Site3_tem_P = str2num(stringfromlist(p,stepInfoStr_p))	String actCellName=stringbykey("actCellName",noteStr)	Variable numBridgeVals_proximal = NumberByKey("numBridgeVals_proximal", noteStr)	Variable numBridgeVals_distal = NumberByKey("numBridgeVals_distal", noteStr)	VI_repsAndFamily2Site3(rFam_S_fS,sFam_S_fS,rFam_P_fS,sFam_P_fs,rFam_S_fP,sFam_S_fP,rFam_P_fP,sFam_P_fP,VI_repsAndFamily2Site3_tem_S,VI_repsAndFamily2Site3_tem_P,actCellName,numBridgeVals_proximal,numBridgeVals_distal,doDisplay)end//stepInfoWaves: {testPulse_baselineStartX, step_baselineStartX, step_lastNegSweep, step_zeroCurrentSweep}. Pass NaN for all relevant values if any particular aspect is not present.//these all refer to the location that the stimulus is delivered FROM. analysis is performed at both sites in either casefunction/S VI_repsAndFamily2Site3(rFam_S_fS,sFam_S_fS,rFam_P_fS,sFam_P_fs,rFam_S_fP,sFam_S_fP,rFam_P_fP,sFam_P_fP,somaStepInfo,pedStepInfo,actCellName,numBridgeVals_proximal,numBridgeVals_distal,doDisplay)	String rFam_S_fS,sFam_S_fS,rFam_P_fS,sFam_P_fs,rFam_S_fP,sFam_S_fP,rFam_P_fP,sFam_P_fP	WAVE/D somaStepInfo, pedStepInfo			//pass as waves (can be declared and instantiated at function call)	Variable numBridgeVals_proximal,numBridgeVals_distal	//number of points included in bridge bal correction at each sight (zero has no effect on waves)	Variable doDisplay	//pace to auto display results with VI_disp_overlays_g	String actCellName		String exRef	if (numtype(somaStepInfo[1]))	//use ped		exRef = stringfromlist(0,rFam_P_fP)	else		exRef = stringfromlist(0,rFam_S_fS)	endif		String cellName = text_getInfoFromWaveName_S(StringFromList(0,exRef),0)	String fName = cellName + "_" + text_getInfoFromWaveName_S(StringFromList(0,exRef),1)	Variable cellFileNum = text_getInfoFromWaveName_V(StringFromList(0,exRef), 1)	if (strlen(actCellName) < 1)		actCellName = cellName	endif//	Print "rFam_S_fS:", rFam_S_fS, "sFam_S_fS:",sFam_S_fS,"rFam_P_fS:",rFam_P_fS,"sFam_P_fS:",sFam_P_fS//	Print "rFam_S_fP:", rFam_S_fP, "sFam_S_fP:",sFam_S_fP,"rFam_P_fP:",rFam_P_fP,"sFam_P_fP:",sFam_P_fP		//documentation for future additional and/or population analysis	String noteStr = ""		//key-word list for future / population analysis. saved with fio_stream_saveToStream in a row devoted to somatic file cell	String analysisSaveRefs = ""			//refs to save following analysis (param waves mostly)	String analysisStreamLabel	if (numtype(somaStepInfo[0]))		//no recording at soma at all.. use ped for naming		analysisStreamLabel = text_getInfoFromWaveName_S(StringFromLisT(0,rFam_P_fP), 10)		//get all from cell except channelStr	else									//rec from soma (and possibly also ped) .. use soma for naming		analysisStreamLabel = text_getInfoFromWaveName_S(StringFromLisT(0,rFam_S_fS), 10)		//get all from cell except channelStr	endif		//input info		noteStr+= "analysisStreamLabel:"+analysisStreamLabel+";"	noteStr+= "callingFunction:VI_repsAndFamily2Site;"	noteStr+= "rFam_S_fS:"+ReplaceString(";",rFam_S_fS,",")+";"	noteStr+= "sFam_S_fS:"+ReplaceString(";",sFam_S_fS,",")+";"	noteStr+= "rFam_P_fS:"+ReplaceString(";",rFam_P_fS,",")+";"	noteStr+= "sFam_P_fS:"+ReplaceString(";",sFam_P_fS,",")+";"	noteStr+= "rFam_S_fP:"+ReplaceString(";",rFam_S_fP,",")+";"	noteStr+= "sFam_S_fP:"+ReplaceString(";",sFam_S_fP,",")+";"	noteStr+= "rFam_P_fP:"+ReplaceString(";",rFam_P_fP,",")+";"	noteStr+= "sFam_P_fP:"+ReplaceString(";",sFam_P_fP,",")+";"	string stepInfoStr_s; sprintf stepInfoStr_s, "%.8f,%.8f,%.8f,%.8f", somaStepInfo[0], somaStepInfo[1], somaStepInfo[2], somaStepInfo[3]	string stepInfoStr_p; sprintf stepInfoStr_p, "%.8f,%.8f,%.8f,%.8f", pedStepInfo[0], pedStepInfo[1], pedStepInfo[2], pedStepInfo[3]	noteStr+= "stepInfoStr_s:"+stepInfoStr_s+";"	noteStr+= "stepInfoStr_p:"+stepInfoStr_p+";"	noteStr+= "fName:"+fName+";"	noteStr+= "cellName:"+cellName+";"	noteStr+= "cellFileNum:"+num2str(cellFileNum)+";"	noteStr+= "actCellName:"+actCellName+";"	noteStr+= "numBridgeVals_proximal:"+num2str(numBridgeVals_proximal)+";"	noteStr+= "numBridgeVals_distal:"+num2str(numBridgeVals_distal)+";"		//make output names	String rs_as = "_rs"		//rep steps (constant level)	String ts_as = "_ts"		//test steps (variable levels)	String at_S= "_S", at_P = "_P"	String fromS = "fS", fromP = "fP"	String diffsStr = "_dr"	String fDiffsStr = "_fr"	String stepInfo = "_vsi"			//v step info	String repStep_outRef_SfS = fName + rs_as + at_S + fromS, repStep_outRef_PfS = fName + rs_as + at_P + fromS	String testStep_outRef_SfS  = fName + ts_as + at_S + fromS, testStep_outRef_PfS  = fName + ts_as + at_P + fromS	String testSteps_outRef_diffs_fS =  fName + ts_as + diffsStr + fromS	String testSteps_outRef_fDiffs_fS =  fName + ts_as + fDiffsStr + fromS	String repStep_outRef_SfP = fName + rs_as + at_S + fromP, repStep_outRef_PfP = fName + rs_as + at_P + fromP	String testStep_outRef_SfP  = fName + ts_as + at_S + fromP, testStep_outRef_PfP  = fName + ts_as + at_P + fromP	String testSteps_outRef_diffs_fP =  fName + ts_as + diffsStr + fromP	String testSteps_outRef_fDiffs_fP =  fName + ts_as + fDiffsStr + fromP	String stepInfoRef = fName + stepInfo	Variable doBridgeBal_SfS,doBridgeBal_PfS,doBridgeBal_PfP,doBridgeBal_SfP	String reps_bridgeRef_SfS="",reps_bridgeRef_PfS="",reps_bridgeRef_PfP="",reps_bridgeRef_SfP=""	String steps_bridgeRef_SfS="",steps_bridgeRef_PfS="",steps_bridgeRef_PfP="",steps_bridgeRef_SfP=""	//expected position of different pieces of information in stepInfoWaves	Variable repStep_bsx = 0, testStep_bsx = 1, testStep_lastNegSweep=2, testStep_zeroCurrSweep=3		Variable reps_isNegativeGoing = 1		//assuming negative repSteps at present	noteStr += "reps_isNegativeGoing:"+num2str(reps_isNegativeGoing)+";"			//save info waves	Duplicate/O  pedStepInfo, pedStepInfoTemp	Redimension/N=(numpnts(pedStepInfoTemp)+1) pedStepInfoTemp	pedStepInfoTemp[numpnts(pedStepInfoTemp)-1] = cellFileNum	Concatenate/O {somaStepInfo,pedStepInfoTemp}, $stepInfoRef	analysisSaveRefs += stepInfoRef + ";"	noteStr += "stepInfoRef:"+stepInfoRef+";"	killwaves pedStepInfoTemp			//start analysis	Variable reps_fS=0,reps_fP=0,reps_PfS=0,reps_SfP=0,steps_fS=0,steps_fP=0,resp_PfS=0,resp_SfP=0;//tracks if stored info from eithe site, so that we know if from soma or from ped params waves should be saved	String outStr		//outStr is temporary, recs output of VI_stepFamily2site			//test steps first -- bridge balance done to traces at this stage	if (!numtype(somaStepInfo[testStep_bsx]))		//if there's a real number in there		steps_fS = 1		doBridgeBal_SfS=numBridgeVals_proximal		doBridgeBal_PfS=numBridgeVals_distal		outStr=VI_stepFamily2site(rFam_S_fS,rFam_P_fS,sFam_S_fS,somaStepInfo[testStep_bsx],0,somaStepInfo[testStep_lastNegSweep],somaStepInfo[testStep_zeroCurrSweep],testStep_outRef_SfS,testStep_outRef_PfS,doBridgeBal_SfS,doBridgeBal_PfS,cellName=cellName,cellFileNum=cellFileNum)		resp_PfS=str2num(stringfromlist(1,outStr))		//outStr is hasRespFromS;hasRespFromP;hasRespFromBoth;bridgeInfoRef_S;bridgeInfoRef_P		steps_bridgeRef_SfS=stringfromlist(3,outStr)		steps_bridgeRef_PfS=stringfromlist(4,outStr)				//save at soma		noteStr+="testStep_outRef_SfS:"+testStep_outRef_SfS+";steps_bridgeRef_SfS:"+steps_bridgeRef_SfS+";doBridgeBal_SfS:"+num2str(doBridgeBal_SfS)+";"		analysisSaveRefs+=testStep_outRef_SfS+";"+steps_bridgeRef_SfS+";"				if (resp_PfS)			//save at ped			noteStr+="testStep_outRef_PfS:"+testStep_outRef_PfS+";steps_bridgeRef_PfS:"+steps_bridgeRef_PfS+";doBridgeBal_PfS:"+num2str(doBridgeBal_PfS)+";"			analysisSaveRefs+=testStep_outRef_PfS+";"+steps_bridgeRef_PfS+";"						//calc difference wave			WAVE testSteps_atS = $testStep_outRef_SfS			WAVE testSteps_atP = $testStep_outRef_PfS			Duplicate/O testSteps_atS, $testSteps_outRef_diffs_fS/WAVE=diffs_fS, $testSteps_outRef_fDiffs_fS/WAVE=fDiffs_fS			diffs_fS = testSteps_atP - testSteps_atS  //change at distal from proximal			fDiffs_fS = testSteps_atP / testSteps_atS	//fold change at distal from proximal						//save difference wave			noteStr+= "testSteps_outRef_diffs_fS:"+testSteps_outRef_diffs_fS+";"			noteStr+= "testSteps_outRef_fDiffs_fS:"+testSteps_outRef_fDiffs_fS+";"						analysisSaveRefs+=testSteps_outRef_diffs_fS+";"			analysisSaveRefs+=testSteps_outRef_fDiffs_fS+";"		endif	endif		//get testSteps from ped?	if (!numtype(pedStepInfo[testStep_bsx]))		//if there's a real number in there		steps_fP = 1		doBridgeBal_PfP=numBridgeVals_proximal;doBridgeBal_SfP=numBridgeVals_distal		outStr = VI_stepFamily2site(rFam_S_fP, rFam_P_fP, sFam_P_fP,  pedStepInfo[testStep_bsx],  1,  pedStepInfo[testStep_lastNegSweep],  pedStepInfo[testStep_zeroCurrSweep], testStep_outRef_SfP,testStep_outRef_PfP,doBridgeBal_SfP,doBridgeBal_PfP,cellName=cellName, cellFileNum=cellFileNum)		resp_SfP=str2num(stringfromlist(0,outStr))		//outStr is hasRespFromS;hasRespFromP;hasRespFromBoth;bridgeInfoRef_S;bridgeInfoRef_P		steps_bridgeRef_SfP=stringfromlist(3,outStr)		steps_bridgeRef_PfP=stringfromlist(4,outStr)		//save at ped		noteStr+="testStep_outRef_PfP:"+testStep_outRef_PfP+";steps_bridgeRef_PfP:"+steps_bridgeRef_PfP+";doBridgeBal_PfP:"+num2str(doBridgeBal_PfP)+";"		analysisSaveRefs+=testStep_outRef_PfP+";"+steps_bridgeRef_PfP+";"				if (resp_SfP)			//save at ped			noteStr+="testStep_outRef_SfP:"+testStep_outRef_SfP+";steps_bridgeRef_SfP:"+steps_bridgeRef_SfP+";doBridgeBal_SfP:"+num2str(doBridgeBal_SfP)+";"			analysisSaveRefs+=testStep_outRef_SfP+";"+steps_bridgeRef_SfP+";"						//calc difference wave			WAVE testSteps_atS = $testStep_outRef_SfP			WAVE testSteps_atP = $testStep_outRef_PfP			Duplicate/O testSteps_atP, $testSteps_outRef_diffs_fP/WAVE=diffs_fP, $testSteps_outRef_fDiffs_fP/WAVE=fDiffs_fP			diffs_fP = testSteps_atS - testSteps_atP  //change at distal from proximal			fDiffs_fP = testSteps_atS / testSteps_atP	//fold change at distal from proximal						//save difference wave			noteStr+= "testSteps_outRef_diffs_fP:"+testSteps_outRef_diffs_fP+";"			noteStr+= "testSteps_outRef_fDiffs_fP:"+testSteps_outRef_fDiffs_fP+";"						analysisSaveRefs+=testSteps_outRef_diffs_fP+";"			analysisSaveRefs+=testSteps_outRef_fDiffs_fP+";"		endif	endif		noteStr += "steps_fromBoth:"+num2str(steps_fs && steps_fp)+";"	noteStr += "resp_fromBoth:"+num2str(resp_PfS && resp_SfP)+";"	noteStr += "somaOnly:"+num2str(steps_fs && !resp_PfS)+";"	noteStr += "pedOnly:"+num2str(steps_fP && !resp_SfP)+";"	noteStr += "somaStimOnly:"+num2str(resp_PfS && resp_SfP && !steps_fp)	+";"	//dual site but only steps from one site	noteStr += "pedStimOnly:"+num2str(resp_PfS && resp_SfP && !steps_fs)	+";"	//dual site from but only steps from one site	noteStr += "steps_fs:"+num2str(steps_fs)+";"	noteStr += "steps_fP:"+num2str(steps_fP)+";"	noteStr += "resp_PfS:"+num2str(resp_PfS)+";"	noteStr += "resp_SfP:"+num2str(resp_SfP)+";"		//get testPulse / repSteps from soma? -- 180427 removed bridge balance from here since handled during test step analysis	if (!numtype(somaStepInfo[repStep_bsx]))		//if there's a real number in there		reps_fS = 1		doBridgeBal_SfS=0		//bridge bal already done to traces best on step responses		doBridgeBal_PfS=0		outStr=VI_stepReps2Site(rFam_S_fS,rFam_P_fS,sFam_S_fS,reps_isNegativeGoing,somaStepInfo[repStep_bsx],0,repStep_outRef_SfS,repStep_outRef_PfS,0,0,0)		reps_PfS = str2num(stringfromlist(1,outStr))			reps_bridgeRef_SfS=stringfromlist(3,outstr)		reps_bridgeRef_PfS=stringfromlist(4,outstr)				//for saving		analysisSaveRefs+=repStep_outRef_SfS+";"+reps_bridgeRef_SfS+";"		noteStr+="repStep_outRef_SfS:"+repStep_outRef_SfS+";reps_bridgeRef_SfS:"+reps_bridgeRef_SfS+";"		if (reps_PfS)			analysisSaveRefs+=repStep_outRef_PfS+";"+reps_bridgeRef_PfS+";"			noteStr+="repStep_outRef_PfS:"+repStep_outRef_PfS+";reps_bridgeRef_PfS:"+reps_bridgeRef_PfS+";"		endif	endif		//get testPulse / repSteps from ped?  -- 180427 removed bridge balance from here since handled during test step analysis	if (!numtype(pedStepInfo[repStep_bsx]))		//if there's a real number in there		reps_fP = 1			doBridgeBal_PfP=0		//bridge bal already done to traces best on step responses		doBridgeBal_SfP=0		outStr=VI_stepReps2Site(rFam_S_fP,rFam_P_fP,sFam_P_fP,reps_isNegativeGoing,pedStepInfo[repStep_bsx],1,repStep_outRef_SfP,repStep_outRef_PfP,0,0,0)		reps_SfP = str2num(stringfromlist(0,outStr))			reps_bridgeRef_SfP=stringfromlist(3,outstr)		reps_bridgeRef_PfP=stringfromlist(4,outstr)				//for saving		analysisSaveRefs+=repStep_outRef_PfP+";"+reps_bridgeRef_PfP+";"		noteStr+="repStep_outRef_PfP:"+repStep_outRef_PfP+";reps_bridgeRef_PfP:"+reps_bridgeRef_PfP+";"		if (reps_SfP)			analysisSaveRefs+=repStep_outRef_SfP+";"+reps_bridgeRef_SfP+";"			noteStr+="repStep_outRef_SfP:"+repStep_outRef_SfP+";reps_bridgeRef_SfP:"+reps_bridgeRef_SfP+";"		endif		endif		noteStr+="reps_fS:"+num2str(reps_fS)+";"	noteStr+="reps_fP:"+num2str(reps_fP)+";"	noteStr+="reps_PfS:"+num2str(reps_PfS)+";"	noteStr+="reps_SfP:"+num2str(reps_SfP)+";"			//add notes	wave_note(analysisSaveRefs,noteStr,1,0)		//handle display option last	if (steps_fS)				if (doDisplay) 			if (resp_PfS)		//dual site				VI_disp_overlays_g(0, 1, testStep_outRef_SfS, testStep_outRef_PfS, rFam_S_fS,sFam_S_fS,rFam_P_fS,sFam_P_fS)				vi_disp_summaries_all($testStep_outRef_SfS,cellName)			else					//single site				vi_disp_summaries($testStep_outRef_SfS,$testStep_outRef_SfS,0,cellName+"_SfS","b")			endif		endif					endif	if (steps_fP)		if (doDisplay)			if (resp_SfP)				VI_disp_overlays_g(1, 1, testStep_outRef_SfP, testStep_outRef_PfP, rFam_S_fP,sFam_S_fP,rFam_P_fP,sFam_P_fP)				vi_disp_summaries_all($testStep_outRef_PfP,cellName)			else				vi_disp_summaries($testStep_outRef_PfP,$testStep_outRef_PfP,0,cellName+"_PfP","b")			endif		endif			endif		//	Print "noteStr",noteStr		return noteStrend	//VI_repsAndFamily2Site3function VI_repsAndFamily2s3_rep(viWv,startRow,numRows,doDisplay,vi_cc_summary,attemptReload,killAfter)	WAVE/T viWv	//index wave (e.g., vi_index, see finddimlabel for layout	Variable startRow		//first row to analyze in indexWv	Variable numRows		//numRows to analyze	Variable doDisplay	//for each.. do display?	String vi_cc_summary		//default for dissociated paired recs was "vi_cc_summary"	Variable attemptReload,killAfter		Variable forceReload=1		//NOTE EXPECTED COLUMN ORDER!!//	cellString;noteStr;rFam_S_fS;sFam_S_fS;rFam_P_fS;sFam_P_fS;rFam_S_fP;sFam_S_fP;rFam_P_fP;sFam_P_fP;"//	lblsByParamNum+="stepInfoStr_s;stepInfoStr_p;actCellName;numBridgeVals_proximal;numBridgeVals_distal;"	variable roLim=dimsize(viWv,0)	make/o/d/n=(4) somaStepInfo,pedStepInfo	String stepInfoStr_s,stepInfoStr_p,notestr,allWvs	variable i,ro,numBridgeVals_proximal,numBridgeVals_distal	for (i=0;i<numRows;i+=1)		ro = startrow+i		if (ro >=roLim)			break		endif		stepInfoStr_s=c2sc(viWv[ro][10])		stepInfoStr_p=c2sc(viWv[ro][11])		somaStepInfo[0,1]=str2num(stringfromlist(p,stepInfoStr_s))		pedStepInfo[0,1]=str2num(stringfromlist(p,stepInfoStr_p))		somaStepInfo[2,3]=round(str2num(stringfromlist(p,stepInfoStr_s)))		pedStepInfo[2,3]=round(str2num(stringfromlist(p,stepInfoStr_p)))		numBridgeVals_proximal=str2num(viWv[ro][13])		numBridgeVals_distal=str2num(viWv[ro][14])		if (attemptReload)			allWvs=c2sc(viWv[ro][2])+c2sc(viWv[ro][3])+c2sc(viWv[ro][4])+c2sc(viWv[ro][5])+c2sc(viWv[ro][6])+c2sc(viWv[ro][7])+c2sc(viWv[ro][8])+c2sc(viWv[ro][9])			if (igor_is64())				fd_loadAbfFrom32DuringExecution(allWvs,1,1)				else				da_fd_loadWavesFromWaveName(allWvs,0)			endif		endif		notestr=VI_repsAndFamily2Site3(c2sc(viWv[ro][2]),c2sc(viWv[ro][3]),c2sc(viWv[ro][4]),c2sc(viWv[ro][5]),c2sc(viWv[ro][6]),c2sc(viWv[ro][7]),c2sc(viWv[ro][8]),c2sc(viWv[ro][9]),somaStepInfo,pedStepInfo,viWv[ro][12],numBridgeVals_proximal,numBridgeVals_distal,doDisplay)		viWv[ro][1]=notestr				String moreInfo=""		if (killAfter)			Variable failures=killWavesInStrList(allWvs)			if (failures>0)				moreInfo="failed to kill n="+num2str(failures)			endif		endif				Print "VI_repsAndFamily2s3_rep() completed row",ro,moreInfo	endforendfunction VI_repsAndFamily2s3_sumReps(viWv,startRow,numRows,outREf)	WAVE/T viWv	//index wave (e.g., vi_index, see finddimlabel for layout	Variable startRow		//first row to analyze in indexWv	Variable numRows		//numRows to analyze	String outREf	//	String vi_cc_summary="vi_cc_sWv3"		string summaryAppendStr="_vis"		//for VI summary	variable roLim=dimsize(viWv,0); string summaryOutRef,fName	String stepInfoStr_s,stepInfoStr_p,notestr,diffParams_fS,diffParams_fP	variable i,ro,zeroSweep_fs,zeroSweep_fp	String cellLbl	for (i=0;i<numRows;i+=1)		ro = startrow+i		if (ro >=roLim)			break		endif		notestr = viWv[ro][1]		summaryOutRef=VI_repsAndFamily2s3_summary(noteStr)				viWv[ro][1] = ReplaceStringByKey("summaryRef", noteStr, summaryOutRef)				cellLbl=viWv[i][0]		Print "VI_repsAndFamily2s3_sumReps() completed row",ro,"cellLbl",cellLbl				if (i==0)			duplicate/o $summaryOutRef,$outREf/wave=out			Redimension/n=(-1,1) out		else			concatenate/np=1 {$summaryOutRef},out		endif		SetDimLabel 1,i,$cellLbl,out	endfor		matrixtranspose out	Print "VI_repsAndFamily2s3_sumReps() complete, outRef",nameofwave(out)end//sum total of what needs to be summarized://min and max SS, min and max peak//rest from average across steps//input from average across steps -- no weighting unlike a line fit, but better to use than test steps bc actually gets to a steady state//resistances from slope changes y (shows deg. attenuation)	//for Steady state	//for peaks//X intercept averages y	(shows lag)//thresholds -- handled by thresholdProps (shows lag)//TTPs	(lag)//widths (lag)function/S VI_repsAndFamily2s3_summary(noteStr)	String noteStr		//noteStr from VI_repsAndFamily2s3		string summaryAppendStr="_vis"		//for VI summary	String stepInfoStr_s=c2sc(stringbykey("stepInfoStr_s",notestr))	String stepInfoStr_p=c2sc(stringbykey("stepInfoStr_p",notestr))		Variable zeroSweep_fs=round(str2num(stringfromlist(3,stepInfoStr_s)))	Variable zeroSweep_fp=round(str2num(stringfromlist(3,stepInfoStr_p)))	String fName=stringbykey("fName",notestr)	String outRef=fname+summaryAppendStr	String paramsAtSoma_fS=stringbykey("testStep_outRef_SfS",notestr)	String paramsAtPed_fS=stringbykey("testStep_outRef_PfS",notestr)	String paramsAtPed_fP=stringbykey("testStep_outRef_PfP",notestr)	String paramsAtSoma_fP=stringbykey("testStep_outRef_SfP",notestr)	String diffParams_fS=stringbykey("testSteps_outRef_diffs_fS",notestr)	//note that zero sweeps are already excluded	String diffParams_fP=stringbykey("testSteps_outRef_diffs_fP",notestr)	String fDiffParams_fS=stringbykey("testSteps_outRef_fdiffs_fS",notestr)	String fDiffParams_fP=stringbykey("testSteps_outRef_fdiffs_fP",notestr)	WAVE p_sfs=$paramsAtSoma_fS,p_pfp=$paramsAtPed_fP	WAVE p_pfs=$paramsAtPed_fS,p_sfp=$paramsAtSoma_fP	WAVE d_fs=$diffParams_fS,d_fp=$diffParams_fP	WAVE f_fs=$fDiffParams_fs,f_fp=$fDiffParams_fP		//sort to make absolutely sure order of columns ascends with command size	Variable cr=FindDimLabel(p_sfs,0,"stim_ri_deltaMean" )		//cr is command row	Variable cols_fS = dimsize(p_sfs,1)	Variable cols_fP = dimsize(p_pfp,1)	matrixop/free/o sort_fs = subWaveR(p_sfs,cr,0,cols_fS)		//get command column from soma	matrixop/free/o sort_fp = subWaveR(p_pfp,cr,0,cols_fP)		//get command column from ped		matrixtranspose p_sfs;matrixtranspose p_pfs;matrixtranspose d_fs;matrixtranspose f_fs	matrixtranspose p_sfp;matrixtranspose p_pfp;matrixtranspose d_fp;matrixtranspose f_fp	//for compatibility with sortcolumns	sortcolumns keywaves={sort_fs},sortwaves={p_sfs,p_pfs,d_fs,f_fs}	sortcolumns keywaves={sort_fp},sortwaves={p_sfp,p_pfp,d_fp,f_fp}	matrixtranspose p_sfs;matrixtranspose p_pfs;matrixtranspose d_fs;matrixtranspose f_fs	matrixtranspose p_sfp;matrixtranspose p_pfp;matrixtranspose d_fp;matrixtranspose f_fp	//restore orientation		String lineFitParams = "resp_ssBaselineDiff;resp_peakBaselineDiff;resp_peakSSDiff;"	String paramLabelList = replacestring("resp_",lineFitParams,"")		//remove resp to save space	String winStartList="-inf;-inf;0;"	//calculated for all params IN PICOAMPS pA	String winEndList="inf;0;inf;"	String winLabelList="all;neg;pos;"		//LINE FITS FOR SLOPES		Variable numLineFits=itemsinlist(lineFitParams),numWins=itemsinlist(winStartList)	Variable numParamsPerWin=36			//counts all the jj additions 	Variable numWinsPerParam=numWins	Variable numParamsPerLineFit=numParamsPerWin*numWinsPerParam	variable totalLineFitParams=numParamsPerLineFit*numLineFits		variable i,ro,jj,numCols,startInd,winNum,winStart,winEnd,winStartCol,winEndCol,k,foundStart,foundEnd,cVal,sc,ec,foundFail	Double diff_M,diff_B,M_relS,B_relS,M_relP,B_relP	Double M_dP,M_fP,B_dP,B_fP,M_dS,M_fS,B_dS,B_fS	Double S_M,S_B,P_M,P_B	make/o/d/n=2/free lineCoefs	make/o/d/n=(totalLineFitParams) $outref/wave=out	string lb,winLb,actualLabel	for (i=0;i<numLineFits;i+=1)		actualLabel=stringfromlist(i,lineFitParams)	//used in finding the parameter's row in the sweep by sweep wave		numCols=dimsize(d_fs,1)		ro=FindDimLabel(p_sfs, 0,actualLabel)		for (winNum=0;winNum<numWins;winNum+=1)			winStart=str2num(stringfromlist(winNum,winStartList))*10^-12		//convert to pA			winEnd=str2num(stringfromlist(winNum,winEndList))*10^-12			winLb=stringfromlist(winNum,winLabelList)			lb=stringfromlist(i,paramLabelList)+"_"+winLb		//used in labeling the summary output params			//FOR SOMA			//find start and end columns			foundStart=0;foundEnd=0					for (k=0;k<cols_fs;k+=1)				cVal=p_sfs[cr][k]				if (!foundStart && (cVal >= winStart))	//initial threshold crossed -- assumes order!					foundStart=1						sc=k							endif 								if (!foundEnd && (cVal > winEnd) )					foundEnd=1					ec=k				endif			endfor			if (foundStart && !foundEnd)	//started but not ended, lastCol is really the last one				ec=cols_fs-1	//last col				foundFail=0			elseif (foundStart && foundEnd)		//found start and end, end needs to be adjusted to exclude the first column out of range				ec-=1				foundFail=0			else		//did not find start .. shouldn't happen, throw a warning				foundFail=1				Print "VI_repsAndFamily2s3_summary() foundFail for i",i,"winNum",winNum,"fName",fName,"wsStr","winStart",winStart,"winEnd",winEnd			endif				//end of window finding for soma										//difference wave			CurveFit/Q line, kwCWave=lineCoefs d_fs[ro][sc,ec]/X=p_sfs[cr][sc,ec]			diff_M=lineCoefs[1]			diff_B=lineCoefs[0]				//rel soma			CurveFit/Q line, kwCWave=lineCoefs p_sfs[ro][sc,ec]/X=p_sfs[cr][sc,ec]			S_M=lineCoefs[1]			S_B=lineCoefs[0]			M_relS=diff_M/S_M			B_relS=diff_B/S_B				//rel pedj			CurveFit/Q line, kwCWave=lineCoefs p_pfs[ro][sc,ec]/X=p_sfs[cr][sc,ec]			P_M=lineCoefs[1]			P_B=lineCoefs[0]					M_relP=diff_M/P_M			B_relP=diff_B/P_B				//(added later) rel each other -- at ped 			M_dP = P_M - S_M		//difference of slopes at ped			M_fP = P_M / S_M		//fold diff of slopes at ped			B_dP = P_B - S_B		//same for intercept 			B_fP = P_B / S_B		//same for intercept 				//(added later) rel each other -- at soma			M_dS = S_M - P_M		//difference of slopes at ped			M_fS = S_M / P_M		//fold diff of slopes at ped			B_dS = S_B - P_B		//same for intercept 			B_fS = S_B / P_B		//same for intercept 										print "lb",lb,"ro",ro,"diff_M",diff_M,"S_M",S_M,"P_M",P_M,"p_sfs",nameofwave(p_sfs),"p_pfs",nameofwave(p_pfs),"d_fs",nameofwave(d_fs)					startInd=(numParamsPerLineFit*i)+(numParamsPerWin*winNum)			jj=startInd			jj+=0;dl_assignAndLbl(out,jj,diff_M,lb+"_M_fS")	//slope			jj+=1;dl_assignAndLbl(out,jj,diff_B,lb+"_B_fS")	//offset			jj+=1;dl_assignAndLbl(out,jj,S_M,lb+"_S_M_fS")	//			jj+=1;dl_assignAndLbl(out,jj,S_B,lb+"_S_B_fS")	//			jj+=1;dl_assignAndLbl(out,jj,M_relS,lb+"_MrelS_fS")	//			jj+=1;dl_assignAndLbl(out,jj,B_relS,lb+"_BrelS_fS")	//			jj+=1;dl_assignAndLbl(out,jj,P_M,lb+"_P_M_fS")	//			jj+=1;dl_assignAndLbl(out,jj,P_B,lb+"_P_B_fS")	//					jj+=1;dl_assignAndLbl(out,jj,M_relP,lb+"_MrelP_fS")	//			jj+=1;dl_assignAndLbl(out,jj,B_relP,lb+"_BrelP_fS")	//at 10				//additions			jj+=1;dl_assignAndLbl(out,jj,M_dP,lb+"_M_dP_fS")	//slope difference ped - soma			jj+=1;dl_assignAndLbl(out,jj,M_fP,lb+"_M_fP_fS")	//slope fold diff ped / soma			jj+=1;dl_assignAndLbl(out,jj,B_dP,lb+"_B_dP_fS")	//same for B			jj+=1;dl_assignAndLbl(out,jj,B_dP,lb+"_B_fP_fS")			jj+=1;dl_assignAndLbl(out,jj,M_dS,lb+"_M_dS_fS")	//slope difference soma - ped			jj+=1;dl_assignAndLbl(out,jj,M_fS,lb+"_M_fS_fS") //slope fold diff soma / ped			jj+=1;dl_assignAndLbl(out,jj,B_dS,lb+"_B_dS_fS")	//same for b			jj+=1;dl_assignAndLbl(out,jj,B_dS,lb+"_B_fS_fS") //a 16						//FOR TERMINAL			//find start and end columns			foundStart=0;foundEnd=0					for (k=0;k<cols_fs;k+=1)				cVal=p_sfs[cr][k]				if (!foundStart && (cVal >= winStart))	//initial threshold crossed -- assumes order!					foundStart=1						sc=k							endif 								if (!foundEnd && (cVal > winEnd) )					foundEnd=1					ec=k				endif			endfor			if (foundStart && !foundEnd)	//started but not ended, lastCol is really the last one				ec=cols_fs-1	//last col				foundFail=0			elseif (foundStart && foundEnd)		//found start and end, end needs to be adjusted to exclude the first column out of range				ec-=1				foundFail=0			else		//did not find start .. shouldn't happen, throw a warning				foundFail=1				Print "VI_repsAndFamily2s3_summary() foundFail for i",i,"winNum",winNum,"fName",fName,"wsStr","winStart",winStart,"winEnd",winEnd			endif				//end of window finding for terminal						//difference wave			CurveFit/Q line, kwCWave=lineCoefs d_fp[ro][sc,ec]/X=p_pfp[cr][sc,ec]			diff_M=lineCoefs[1]			diff_B=lineCoefs[0]				//rel soma			CurveFit/Q line, kwCWave=lineCoefs p_sfp[ro][sc,ec]/X=p_pfp[cr][sc,ec]			S_M=lineCoefs[1]			S_B=lineCoefs[0]			M_relS=diff_M/S_M			B_relS=diff_B/S_B				//rel ped			CurveFit/Q line, kwCWave=lineCoefs p_pfp[ro][sc,ec]/X=p_pfp[cr][sc,ec]			P_M=lineCoefs[1]			P_B=lineCoefs[0]					M_relP=diff_M/P_M			B_relP=diff_B/P_B				//(added later) rel each other -- at ped			M_dP = P_M - S_M		//difference of slopes at ped			M_fP = P_M / S_M		//fold diff of slopes at ped			B_dP = P_B - S_B		//same for intercept 			B_fP = P_B / S_B		//same for intercept 				//(added later) rel each other -- at soma			M_dS = S_M - P_M		//difference of slopes at ped			M_fS = S_M / P_M		//fold diff of slopes at ped			B_dS = S_B - P_B		//same for intercept 			B_fS = S_B / P_B		//same for intercept 								jj+=1;dl_assignAndLbl(out,jj,diff_M,lb+"_M_fP")	//slope			jj+=1;dl_assignAndLbl(out,jj,diff_B,lb+"_B_fP")	//offset			jj+=1;dl_assignAndLbl(out,jj,S_M,lb+"_S_M_fP")	//			jj+=1;dl_assignAndLbl(out,jj,S_B,lb+"_S_B_fP")	//			jj+=1;dl_assignAndLbl(out,jj,M_relS,lb+"_MrelS_fP")	//			jj+=1;dl_assignAndLbl(out,jj,B_relS,lb+"_BrelS_fP")	//			jj+=1;dl_assignAndLbl(out,jj,P_M,lb+"_P_M_fP")	//			jj+=1;dl_assignAndLbl(out,jj,P_B,lb+"_P_B_fP")	//					jj+=1;dl_assignAndLbl(out,jj,M_relP,lb+"_MrelP_fP")	//			jj+=1;dl_assignAndLbl(out,jj,B_relP,lb+"_BrelP_fP")	//				//additions			jj+=1;dl_assignAndLbl(out,jj,M_dP,lb+"_M_dP_fP")	//slope difference ped - soma			jj+=1;dl_assignAndLbl(out,jj,M_fP,lb+"_M_fP_fP")	//slope fold diff ped / soma			jj+=1;dl_assignAndLbl(out,jj,B_dP,lb+"_B_dP_fP")	//same for B			jj+=1;dl_assignAndLbl(out,jj,B_dP,lb+"_B_fP_fP")			jj+=1;dl_assignAndLbl(out,jj,M_dS,lb+"_M_dS_fP")	//slope difference soma - ped			jj+=1;dl_assignAndLbl(out,jj,M_fS,lb+"_M_fS_fP") //slope fold diff soma / ped			jj+=1;dl_assignAndLbl(out,jj,B_dS,lb+"_B_dS_fP")	//same for b			jj+=1;dl_assignAndLbl(out,jj,B_dS,lb+"_B_fS_fP") //a 16					endfor	//wins	endfor	//params		//STATS ON OTHER PARAMS IN WINDOWS based on pA of stimulus current		//baseline voltage 20 ms	String statsList="resp_baselineAvgs2,base20ms,;"//0		//paired: actual dim label in original output params and new shorter name for output in summary	String statsListWins="-inf,inf,|;"		//semi colons pairs to statsList.. | between windows, commas between start and end of windows		//baseline volage 200 ms	statsList+="resp_baselineAvgs4,base200ms,;"//1	statsListWins+="-inf,inf,|;"		//SS input resistance 20 ms	statsList+="resp_Rins2,rin20ms,;"//2	statsListWins+="-inf,inf,|-inf,0,|0,inf,|;"		//SS input resistance 200 ms	statsList+="resp_Rins4,rin200ms,;"//3	statsListWins+="-inf,inf,|-inf,0,|0,inf,|;"		//timing related params: line fit crossings, threshold crossing, time to peak (TTP), half widths etc.	String timingWinListStr="-inf,inf,|-100,-50,|-100,-20,|-100,0,|-inf,0,|0,100,|50,100,|20,100,|0,inf,|;"		//line baseline crossing	statsList+="resp_lineBaselineCross_relStep,lbcrs;"	//4	statsListWins+=timingWinListStr			//TTP	statsList+="resp_timeToPeak,ttp;"	//5	statsListWins+=timingWinListStr					//threshold crossing 10% from baseline to peak	statsList+="resp_threshProps_3_pB_rDX,thrRX_p1_pB,;"//6	statsListWins+=timingWinListStr			//threshold crossing 10% from peak to SS	statsList+="resp_threshProps_3_ssB_fDX,thrFX_p1_pSS,;"		//7	statsListWins+=timingWinListStr					//threshold 10% width	statsList+="resp_threshProps_5_ssB_W,thrWX_p1,;"//8	statsListWins+=timingWinListStr			//threshold crossing 50% from baseline to peak	statsList+="resp_threshProps_5_pB_rDX,thrRX_p5_pB,;"//9	statsListWins+=timingWinListStr			//threshold crossing 50% from peak to SS	statsList+="resp_threshProps_5_ssB_fDX,thrFX_p5_pSS,;"		//10	statsListWins+=timingWinListStr					//threshold 50% width	statsList+="resp_threshProps_5_ssB_W,thrWX_p5,;"//11	statsListWins+=timingWinListStr				String paramStatsList="stim_fa_deltaMean;resp_peakBaselineDiff;resp_timeToPeak;resp_peakSSDiff"		statsList+="stim_fa_deltaMean,sDeAvg,;"//12	statsListWins+=timingWinListStr	statsList+="resp_peakBaselineDiff,rDePeakBase,;"//13	statsListWins+=timingWinListStr	statsList+="resp_peakSSDiff,rDePeakSS,;"//14	statsListWins+=timingWinListStr	statsList+="resp_ssBaselineDiff,rDeSSBase,;"//15	statsListWins+=timingWinListStr	statsList+="resp_troughVal,rTroughVal,;"//16	statsListWins+=timingWinListStr		//more timing: resp_mVcrossX_p01 etc.	statsList+="resp_mVcrossX_p01,resp_mVcrossX_p01,;"	statsListWins+=timingWinListStr			statsList+="resp_mVcrossX_p02,resp_mVcrossX_p02,;"	statsListWins+=timingWinListStr			statsList+="resp_mVcrossX_p05,resp_mVcrossX_p05,;"	statsListWins+=timingWinListStr			statsList+="resp_mVcrossX_p1,resp_mVcrossX_p1,;"	statsListWins+=timingWinListStr			statsList+="resp_mVcrossX_p2,resp_mVcrossX_p2,;"	statsListWins+=timingWinListStr			statsList+="resp_mVcrossX_p5,resp_mVcrossX_p5,;"	statsListWins+=timingWinListStr			statsList+="resp_mVcrossX_1,resp_mVcrossX_1,;"	statsListWins+=timingWinListStr			statsList+="resp_mVcrossX_2,resp_mVcrossX_2,;"	statsListWins+=timingWinListStr			statsList+="resp_mVcrossX_5,resp_mVcrossX_5,;"	Variable ws_we_tol = 1		//1 pA tolerance on all windows		Variable numStats=itemsinlist(statsList),j,ws,we,ws_adj,we_adj		//ws we win start win end	Variable count_fs,count_fp,pr,ii		//sc ec startCol endCol pr paramRow	Double pVal		//command value and parameter value	String sl_stats,sl_wins,sl_win,wsStr,weStr	//sl for sublist	String paramName,dlBase,dlWinBase	make/o/free/d/n=(cols_fs) temp_fs		//hold data	make/o/free/d/n=(cols_fp) temp_fp		numParamsPerWin=4+ (5+9+9+9+9)*2			Variable totalNumWins=floor(itemsinlist(statsListWins,",")/2)	Variable totalWinPArams=numParamsPerWin*totalNumWins	Variable winCount=0,windex,winStartIndex=dimsize(out,0)	Redimension/n=(winStartIndex+totalWinPArams) out	out[winStartIndex,]=nan	for (i=0;i<numStats;i+=1)		sl_stats=stringfromlist(i,statsList)		sl_wins=stringfromlist(i,statsListWins)		paramName=stringfromlist(0,sl_stats,",")		pr=FindDimLabel(p_sfs, 0, paramName )		//ASSUMES PARAMROW MATCHES AT FROM SOMA AND FROM PED		if (pr < 0)			print "VI_repsAndFamily2s3_summary() failed to find paramName",paramname,"i",i,"fname",fname			continue	//go to next param		endif		dlBase=stringfromlist(1,sl_stats,",") + "_"		numWins=itemsinlist(sl_wins,"|")		for (j=0;j<numWins;j+=1)			sl_win=stringfromlist(j,sl_wins,"|")			wsStr=stringfromlist(0,sl_win,",")			weStr=stringfromlist(1,sl_win,",")			ws=str2num(wsStr)		//min pA			we=str2num(weStr)		//max pA			dlWinBase=dlBase + replacestring("-",wsStr,"n") + "_" + replacestring("-",weStr,"n") + "_"									ws_adj = (ws - ws_we_tol) * 10 ^ -12		//add tolerance and change to pA like real data units			we_adj = (we + ws_we_tol) * 10 ^ -12				//FOR FROM SOMA			foundStart=0;foundEnd=0					for (k=0;k<cols_fs;k+=1)				cVal=p_sfs[cr][k]				if (!foundStart && (cVal >= ws_adj))	//initial threshold crossed -- assumes order!					foundStart=1						sc=k							endif 								if (!foundEnd && (cVal > we_adj) )					foundEnd=1					ec=k				endif			endfor						if (foundStart && !foundEnd)	//started but not ended, lastCol is really the last one				ec=cols_fs-1	//last col				foundFail=0			elseif (foundStart && foundEnd)		//found start and end, end needs to be adjusted to exclude the first column out of range				ec-=1				foundFail=0			else		//did not find start .. shouldn't happen, throw a warning				foundFail=1				Print "VI_repsAndFamily2s3_summary() foundFail for i",i,"j",j,"fName",fName,"wsStr",wsStr,"weStr",weStr,"ws",ws,"we",we,"ws_adj",ws_adj,"we_adj",we_adj			endif								windex = winStartIndex + winCount*numPAramsPerWin			//params for soma and ped -- bookkeeping			ii=windex; dl_assignAndLbl(out,ii,ws,dlWinBase+"ws_pA")				ii+=1; dl_assignAndLbl(out,ii,we,dlWinBase+"we_pA")			ii+=1; dl_assignAndLbl(out,ii,ws_adj,dlWinBase+"ws_adj")				ii+=1; dl_assignAndLbl(out,ii,we_adj,dlWinBase+"we_adj")	//4						//soma specific			ii+=1; dl_assignAndLbl(out,ii,sc,dlWinBase+"sc_FS")				ii+=1; dl_assignAndLbl(out,ii,ec,dlWinBase+"ec_FS")				ii+=1; dl_assignAndLbl(out,ii,foundStart,dlWinBase+"fsc_FS")				ii+=1; dl_assignAndLbl(out,ii,foundEnd,dlWinBase+"fec_FS")				ii+=1; dl_assignAndLbl(out,ii,foundFail,dlWinBase+"ff_FS")	//+5						//soma specific SOMA PARAMS			wavestats/RMD=[pr][sc,ec]/q p_sfs			ii+=1; dl_assignAndLbl(out,ii,V_Avg,dlWinBase+"avg_sFS")				ii+=1; dl_assignAndLbl(out,ii,V_sdev,dlWinBase+"sd_sFS")				ii+=1; dl_assignAndLbl(out,ii,V_sem,dlWinBase+"se_sFS")			ii+=1; dl_assignAndLbl(out,ii,V_npnts,dlWinBase+"np_sFS")				ii+=1; dl_assignAndLbl(out,ii,v_min,dlWinBase+"min_sFS")				ii+=1; dl_assignAndLbl(out,ii,v_minloc,dlWinBase+"mil_sFS")				ii+=1; dl_assignAndLbl(out,ii,V_max,dlWinBase+"max_sFS")				ii+=1; dl_assignAndLbl(out,ii,V_maxloc,dlWinBase+"mal_sFS")				ii+=1; dl_assignAndLbl(out,ii,V_sum,dlWinBase+"sum_sFS")	//+9				//soma specific for PED PARAMS			wavestats/RMD=[pr][sc,ec]/q p_pfs			ii+=1; dl_assignAndLbl(out,ii,V_Avg,dlWinBase+"avg_pFS")				ii+=1; dl_assignAndLbl(out,ii,V_sdev,dlWinBase+"sd_pFS")				ii+=1; dl_assignAndLbl(out,ii,V_sem,dlWinBase+"se_pFS")			ii+=1; dl_assignAndLbl(out,ii,V_npnts,dlWinBase+"np_pFS")				ii+=1; dl_assignAndLbl(out,ii,v_min,dlWinBase+"min_pFS")				ii+=1; dl_assignAndLbl(out,ii,v_minloc,dlWinBase+"mil_pFS")				ii+=1; dl_assignAndLbl(out,ii,V_max,dlWinBase+"max_pFS")				ii+=1; dl_assignAndLbl(out,ii,V_maxloc,dlWinBase+"mal_pFS")				ii+=1; dl_assignAndLbl(out,ii,V_sum,dlWinBase+"sum_pFS")	//+9							//soma specific for DIFF PARAMS			wavestats/RMD=[pr][sc,ec]/q d_fs			ii+=1; dl_assignAndLbl(out,ii,V_Avg,dlWinBase+"avg_dFS")				ii+=1; dl_assignAndLbl(out,ii,V_sdev,dlWinBase+"sd_dFS")				ii+=1; dl_assignAndLbl(out,ii,V_sem,dlWinBase+"se_dFS")			ii+=1; dl_assignAndLbl(out,ii,V_npnts,dlWinBase+"np_dFS")				ii+=1; dl_assignAndLbl(out,ii,v_min,dlWinBase+"min_dFS")				ii+=1; dl_assignAndLbl(out,ii,v_minloc,dlWinBase+"mil_dFS")				ii+=1; dl_assignAndLbl(out,ii,V_max,dlWinBase+"max_dFS")				ii+=1; dl_assignAndLbl(out,ii,V_maxloc,dlWinBase+"mal_dFS")				ii+=1; dl_assignAndLbl(out,ii,V_sum,dlWinBase+"sum_dFS")	//+9							//soma specific for FOLD DIFF PARAMS			wavestats/RMD=[pr][sc,ec]/q f_fs			ii+=1; dl_assignAndLbl(out,ii,V_Avg,dlWinBase+"avg_fFS")				ii+=1; dl_assignAndLbl(out,ii,V_sdev,dlWinBase+"sd_fFS")				ii+=1; dl_assignAndLbl(out,ii,V_sem,dlWinBase+"se_fFS")			ii+=1; dl_assignAndLbl(out,ii,V_npnts,dlWinBase+"np_fFS")				ii+=1; dl_assignAndLbl(out,ii,v_min,dlWinBase+"min_fFS")				ii+=1; dl_assignAndLbl(out,ii,v_minloc,dlWinBase+"mil_fFS")				ii+=1; dl_assignAndLbl(out,ii,V_max,dlWinBase+"max_fFS")				ii+=1; dl_assignAndLbl(out,ii,V_maxloc,dlWinBase+"mal_fFS")				ii+=1; dl_assignAndLbl(out,ii,V_sum,dlWinBase+"sum_fFS")	//+9								//FOR FROM PED			foundStart=0;foundEnd=0					for (k=0;k<cols_fp;k+=1)				cVal=p_pfp[cr][k]				if (!foundStart && (cVal >= ws_adj))	//initial threshold crossed -- assumes order!					foundStart=1						sc=k							endif 								if (!foundEnd && (cVal > we_adj) )					foundEnd=1					ec=k				endif			endfor						if (foundStart && !foundEnd)	//started but not ended, lastCol is really the last one				ec=cols_fp-1	//last col				foundFail=0			elseif (foundStart && foundEnd)		//found start and end, end needs to be adjusted to exclude the first column out of range				ec-=1				foundFail=0			else		//did not find start .. shouldn't happen, throw a warning				foundFail=1				Print "VI_repsAndFamily2s3_summary() foundFail for i",i,"j",j,"fName",fName			endif						//ped specific			ii+=1; dl_assignAndLbl(out,ii,sc,dlWinBase+"sc_FP")				ii+=1; dl_assignAndLbl(out,ii,ec,dlWinBase+"ec_FP")				ii+=1; dl_assignAndLbl(out,ii,foundStart,dlWinBase+"fsc_FP")				ii+=1; dl_assignAndLbl(out,ii,foundEnd,dlWinBase+"fec_FP")				ii+=1; dl_assignAndLbl(out,ii,foundFail,dlWinBase+"ff_FP")	//+5						//ped specific SOMA PARAMS			wavestats/RMD=[pr][sc,ec]/q p_sfp			ii+=1; dl_assignAndLbl(out,ii,V_Avg,dlWinBase+"avg_sFP")				ii+=1; dl_assignAndLbl(out,ii,V_sdev,dlWinBase+"sd_sFP")				ii+=1; dl_assignAndLbl(out,ii,V_sem,dlWinBase+"se_sFP")			ii+=1; dl_assignAndLbl(out,ii,V_npnts,dlWinBase+"np_sFP")				ii+=1; dl_assignAndLbl(out,ii,v_min,dlWinBase+"min_sFP")				ii+=1; dl_assignAndLbl(out,ii,v_minloc,dlWinBase+"mil_sFP")				ii+=1; dl_assignAndLbl(out,ii,V_max,dlWinBase+"max_sFP")				ii+=1; dl_assignAndLbl(out,ii,V_maxloc,dlWinBase+"mal_sFP")				ii+=1; dl_assignAndLbl(out,ii,V_sum,dlWinBase+"sum_sFP")	//+9				//ped specific for PED PARAMS			wavestats/RMD=[pr][sc,ec]/q p_pfp			ii+=1; dl_assignAndLbl(out,ii,V_Avg,dlWinBase+"avg_pFP")				ii+=1; dl_assignAndLbl(out,ii,V_sdev,dlWinBase+"sd_pFP")				ii+=1; dl_assignAndLbl(out,ii,V_sem,dlWinBase+"se_pFP")			ii+=1; dl_assignAndLbl(out,ii,V_npnts,dlWinBase+"np_pFP")				ii+=1; dl_assignAndLbl(out,ii,v_min,dlWinBase+"min_pFP")				ii+=1; dl_assignAndLbl(out,ii,v_minloc,dlWinBase+"mil_pFP")				ii+=1; dl_assignAndLbl(out,ii,V_max,dlWinBase+"max_pFP")				ii+=1; dl_assignAndLbl(out,ii,V_maxloc,dlWinBase+"mal_pFP")				ii+=1; dl_assignAndLbl(out,ii,V_sum,dlWinBase+"sum_pFP")	//+9						//ped specific for DIFF PARAMS			wavestats/RMD=[pr][sc,ec]/q d_FP			ii+=1; dl_assignAndLbl(out,ii,V_Avg,dlWinBase+"avg_dFP")				ii+=1; dl_assignAndLbl(out,ii,V_sdev,dlWinBase+"sd_dFP")				ii+=1; dl_assignAndLbl(out,ii,V_sem,dlWinBase+"se_dFP")			ii+=1; dl_assignAndLbl(out,ii,V_npnts,dlWinBase+"np_dFP")				ii+=1; dl_assignAndLbl(out,ii,v_min,dlWinBase+"min_dFP")				ii+=1; dl_assignAndLbl(out,ii,v_minloc,dlWinBase+"mil_dFP")				ii+=1; dl_assignAndLbl(out,ii,V_max,dlWinBase+"max_dFP")				ii+=1; dl_assignAndLbl(out,ii,V_maxloc,dlWinBase+"mal_dFP")				ii+=1; dl_assignAndLbl(out,ii,V_sum,dlWinBase+"sum_dFP")	//+9						//ped specific for FOLD DIFF PARAMS			wavestats/RMD=[pr][sc,ec]/q f_FP			ii+=1; dl_assignAndLbl(out,ii,V_Avg,dlWinBase+"avg_fFP")				ii+=1; dl_assignAndLbl(out,ii,V_sdev,dlWinBase+"sd_fFP")				ii+=1; dl_assignAndLbl(out,ii,V_sem,dlWinBase+"se_fFP")			ii+=1; dl_assignAndLbl(out,ii,V_npnts,dlWinBase+"np_fFP")				ii+=1; dl_assignAndLbl(out,ii,v_min,dlWinBase+"min_fFP")				ii+=1; dl_assignAndLbl(out,ii,v_minloc,dlWinBase+"mil_fFP")				ii+=1; dl_assignAndLbl(out,ii,V_max,dlWinBase+"max_fFP")				ii+=1; dl_assignAndLbl(out,ii,V_maxloc,dlWinBase+"mal_fFP")				ii+=1; dl_assignAndLbl(out,ii,V_sum,dlWinBase+"sum_fFP")	//+9											winCount+=1		endfor		endfor			return outRefendfunction wn_reps(wn_index,startRow,numRows,startFamIndex,maxNumInFam,doAll,doDisplay,ht)	WAVE/T wn_index		//index wv.. one row per cell		//setup eg	//ro=0;hS=0;hP=2;wn_index[ro][5]=gcl(hS);wn_index[ro][6]=gcl(hS+1);wn_index[ro][7]=gcl(hP);wn_index[ro][8]=gcl(hP+1);wn_index[ro][0]=stringfromlist(0,wn_index[ro][3],"_");print itemsinlist(wn_index[ro][3]);wn_index[ro][3]=num2str(hS);wn_index[ro][4]=num2str(hP)	Variable startRow,numRows,doDisplay	Variable startFamIndex	Variable maxNumInFam		//max number to do in family (limit independent of doAll, though setting doAll to zero could also reduce the number actually calculated	Variable doAll	//pass to analyze ever family member instead of just those specified in use columns	Variable ht	//analyze ht set		Variable reloadWaves=1	//direct reloadingfrom ABF in this instance of Igor.. not available on 64 bit!!!	Variable loadFromIgor32=0	//reloadWaves must equal 0 in this case!!!!!	if (loadFromIgor32)		reloadWaves=0	endif	Variable usePreviouslyLoadedIbws=1	Variable killAfterIgor32Load=0	Variable igor32TimeOutSecs=30	Variable igor32TimeOutTicks=igor32TimeOutSecs*60		Variable numBridgeCorrPnts=2		//these can be overridden		Variable StartX=10,LenX=35;		Variable CompRegStartX=StartX+LenX	Variable CompRegLenX=5		variable i,only_S,only_P; string cell,noteStr,sFam_S,rFam_S,rFam_P,sFam_P,r_S,s_S,r_P,s_P	String noteStr_S,noteStr_P	String altStartXList,altLenXList,altCompRegStartXList,altCompRegLenXList,stimRef,altStimList,altStim,usedAltStim,loadRef	Variable hs_S,hs_P,use_S,use_P,useBp_S,useBp_P,useB_S,useB_P,startTicks	Variable j,numInFam,rowInd	Variable altStartX,altLenX,altCompRegStartX,altCompRegLenX	Variable usedStartX,usedLenX,usedCompRegStartX,usedCompRegLenX	Variable from_S,maxNumInFamToDo,dualSite,famInd,fNum		String hts=selectstring(ht,"","_ht")		Variable numMainInFam=6,loadFail	make/o/i/free/n=(numMainInFam) mainList	rowInd=0	numRows=min(numRows,dimsize(wn_index,0))	for (i=0;i<numRows;i+=1)		rowInd=i+startRow		if (rowInd >= dimsize(wn_index,0))			break		endif		cell=wn_index[rowInd][%cell]		if (strlen(cell) < 1)			continue		endif		hs_S=str2num(wn_index[rowInd][%$("hs_S"+hts)])		hs_P=str2num(wn_index[rowInd][%$("hs_P"+hts)])		rFam_S=wn_index[rowInd][%$("rFam_S"+hts)]		sFam_S=wn_index[rowInd][%$("sFam_S"+hts)]		rFam_P=wn_index[rowInd][%$("rFAm_P"+hts)]		sFam_P=wn_index[rowInd][%$("sFam_P"+hts)]		altStartXList=wn_index[rowInd][%$("altStartXList"+hts)]		altLenXList=wn_index[rowInd][%$("altLenXList"+hts)]		altCompRegStartXList=wn_index[rowInd][%$("altCompRegStartXList"+hts)]		altCompRegLenXList=wn_index[rowInd][%$("altCompRegLenXList"+hts)]		use_S=str2num(wn_index[rowInd][%$("use_S"+hts)]);mainList[0]=use_S		use_P=str2num(wn_index[rowInd][%$("use_P"+hts)]);mainList[1]=use_P		useBp_S=str2num(wn_index[rowInd][%$("useBp_S"+hts)]);mainList[2]=useBp_S		useBp_P=str2num(wn_index[rowInd][%$("useBp_P"+hts)]);mainList[3]=useBp_P		useB_S=str2num(wn_index[rowInd][%$("useB_S"+hts)]);mainList[4]=useB_S		useB_P=str2num(wn_index[rowInd][%$("useB_P"+hts)]);mainList[5]=useB_P		altStimList=wn_index[rowInd][%$("altStimList"+hts)]				numInFam=max(itemsinlist(rFam_S),itemsinlist(rFam_P))		//could just be one site		maxNumInFamToDo = min(maxNumInFam,numInFam)				for (j=0;j<maxNumInFamToDo;j+=1)			famInd=j+startFamIndex						r_S=stringfromlist(famInd,rFam_S)			s_S=stringfromlist(famInd,sFam_S)			r_P=stringfromlist(famInd,rFam_P)			s_P=stringfromlist(famInd,sFam_P)							only_S = strlen(r_p) < 1			only_P = strlen(r_s) < 1			dualSite=!only_S && !only_p						if (!dualSite && (strlen(r_s) < 1) && (strlen(r_p) < 1))				continue			endif								findvalue/I=(famInd) mainList			if (V_value < 0)				if (!doAll)					continue						endif			endif						altStartX=str2num(stringfromlist(famInd,altStartXList))			altLenX=str2num(stringfromlist(famInd,altLenXList))			altCompRegStartX=str2num(stringfromlist(famInd,altCompRegStartXList))			altCompRegLenX=str2num(stringfromlist(famInd,altCompRegLenXList))			altStim=stringfromlist(j,altStimList)						usedStartX=!numtype(altStartX) ? altStartX : startX			usedLenX=!numtype(altLenX) ? altLenX : lenX			usedCompRegStartX=!numtype(altCompRegStartX) ? altCompRegStartX : compRegStartX			usedCompRegLenX=!numtype(altCompRegLenX) ? altCompRegLenX : compRegLenX						if ((strlen(s_S) > 0) && !WaveExists($s_S) && reloadWaves)				da_fd_loadWaveFromWaveName(s_S)			endif			if ((strlen(s_P) > 0) && !WaveExists($s_P) && reloadWaves)				da_fd_loadWaveFromWaveName(s_P)			endif						if (loadFromIgor32)		//SHOULD REPLACE THIS WITH fd_loadAbfFrom32DuringExecution()				if (dualSite)					loadRef=r_S+";"+r_P+";"+s_S+";"+s_P+";"				elseif (only_S)					loadRef=r_S+";"+s_S+";"				else					loadRef=r_P+";"+s_P+";"				endif				killwavesbyname(loadRef);doupdate;				fd_callLoadAbfAndStore(loadRef,1,1)				//fd_callLoadAbfAndStore_list(loadRef,usePreviouslyLoadedIbws,0)		//could use response at either soma or ped				startTicks=ticks				loadFail=1				do					if (wavesExist(loadRef))						Print "wn_reps() refs loaded"						loadFail=0						break					endif				while ( (ticks-startTicks) < igor32TimeOutTicks )								if (loadFail)					print "WN_REPS() --------LOAD FAIL!!! i,j,",i,j,"skipping"					continue				endif			endif						if (!WaveExists($s_S) && !WaveExists($s_S))				Print "SKIPPING ROW FILE",rowInd,famInd," WAVES COULD NOT BE LOADED LIKELY NEED TO REMAP"			endif									if (dualSite)	//then automatically determine stimulus site												if (!WaveExists($s_S) && reloadWaves)					da_fd_loadWaveFromWaveName(s_S)				endif				if (!WaveExists($s_P) && reloadWaves)					da_fd_loadWaveFromWaveName(s_P)				endif				from_S = variance($s_S,usedStartX,usedStartX+1) > variance ($s_P,usedStartX,usedStartX+1)			elseif (only_S)				from_s = 1						else						from_s = 0			endif						if (from_s)				stimRef=s_S			else				stimRef=s_P			endif						usedAltStim=""			if ( (strlen(altStim) > 0) )				if (waveexists($altStim))					usedAltStim=altStim				endif			endif			print "stimRef",stimRef,"r_S",r_S,"r_P",r_P,"!from_S",!from_S,"numBridgeCorrPnts",numBridgeCorrPnts,"usedCompRegStartX",usedCompRegStartX,"usedCompRegLenX",usedCompRegLenX,"usedAltStim",usedAltStim,"usedStartX",usedStartX,"usedLenX",usedLenX			noteStr=wn_main(stimRef,r_S,r_P,!from_S,numBridgeCorrPnts,usedCompRegStartX,usedCompRegLenX,usedAltStim,winStartX=usedStartX,winSizeX=usedLenX,suppressDisplay=!doDisplay,noReloads=!reloadWaves)			wn_index[rowInd][%$("noteStrList"+hts)]=ReplaceStringByKey(num2str(famInd),wn_index[rowInd][%$("noteStrList"+hts)],noteStr,"=","|")						if (loadFromIgor32 && killAfterIgor32Load)				killwavesbyname(loadRef)			endif			print "wn_reps() completed famInd",famInd,"row",rowInd		endfor		print "wn_reps() completed row",rowInd	endforend	//wn_repsfunction/S wn_reps_getList(wn_index,waveKey,useRepColRule,optionalRefWaveKey)	WAVE/T wn_index	//as for wn_reps()	String wavekey	//key for wavenote retrieval	String useRepColRule //which pre-selected instances to plot, e.g., use_S	String optionalRefWaveKey	//OPTIONALLY pass to first find ref list wave from wn analysis and then take wavekey ref from that.			//e.g., "refsListWv_S" for this param with keywave = "filterPower_FDSN"		Variable i,num=dimsize(wn_index,0)	Variable excludeCol=FindDimLabel(wn_index, 1, "excludeLeakAccessOrInstability" )	Variable useRepCol=finddimlabel(wn_index,1,useRepColRule)	Variable noteCol=FindDimLabel(wn_index, 1, "noteStrList" )	Variable isPeriphCol = FindDimLabel(wn_index, 1, "isPeriph" )	Variable cellCol = FindDimLabel(wn_index, 1, "cell" )	Variable noteAnatCellCol = FindDimLabel(wn_index, 1, "noteAnatCell" )	Variable finalCellNameCol = finddimlabel(wn_index,1,"finalCellName")		String notestr,fullNoteStr,repStr,ref,wref	Variable exclude,rep,isPeriph	String isPeriphList="",refList="",cellList="",noteAnatCellList="",finalCellNameList=""	for (i=0;i<num;i+=1)		fullNoteStr=wn_index[i][noteCol]		if (strlen(fullNoteStr) < 1)			continue		endif		exclude=str2num(wn_index[i][excludeCol])		if (exclude)			continue		endif		repStr=wn_index[i][useRepCol]		rep=str2num(repStr)		noteStr=StringByKey(repStr, fullNoteStr,"=","|")		if (strlen(optionalRefWaveKey) > 0)			wref=stringbykey(optionalRefWaveKey,noteStr)			WAVE/T wv=$wref			ref=wv[%$wavekey]		else			ref=stringbykey(waveKey,noteStr)		endif		//WAVE cs=getColorSet( isPeriph ? 3 : 2 )		//appendtograph/W=$winN/c=(cs[0],cs[1],cs[2],cs[3]) $ref		isPeriphList+=wn_index[i][isPeriphCol]+";"		refList+=ref+";"		cellList+=wn_index[i][cellCol]+";"		noteAnatCellList+=wn_index[i][noteAnatCellCol]+";"		finalCellNameList+=wn_index[i][finalCellNameCol]+";"	endfor		string out= "refList="+refList+"|isPeriphList="+isPeriphList+"|cellList="+cellList+"|noteAnatCellList="+noteAnatCellList+"|finalCellNameList="+finalCellNameList+"|"	return outendfunction/S wn_reps_overlayPlot(wn_index,waveKey,useRepColRule,winN,optionalRefWaveKey)	WAVE/T wn_index	//as for wn_reps()	String wavekey	//key for wavenote retrieval	String useRepColRule //which pre-selected instances to plot, e.g., use_S	String winN	String optionalRefWaveKey	//OPTIONALLY pass to first find ref list wave from wn analysis and then take wavekey ref from that.			//e.g., "refsListWv_S" for this param with keywave = "filterPower_FDSN"		if (!wintype(winN))		display/k=1/n=$winN		winN=s_name	endif		String lists=wn_reps_getList(wn_index,waveKey,useRepColRule,optionalRefWaveKey)	String refList=stringbykey("refList",lists,"=","|")	String isPeriphList=stringbykey("isPeriphList",lists,"=","|")		Variable i,num=itemsinlist(refList)		String notestr,fullNoteStr,repStr,ref,wref	Variable exclude,rep,isPeriph	for (i=0;i<num;i+=1)		ref=stringfromlist(i,refList)		isPeriph = str2num(stringfromlist(i,isPeriphList))		WAVE cs=getColorSet( isPeriph ? 3 : 2 )		appendtograph/W=$winN/c=(cs[0],cs[1],cs[2],cs[3]) $ref	endfor		return winNendfunction/S wn_reps_listKey(ro,wn_index,waveKey,ht)	Variable ro,ht		//high temp	WAVE/t wn_index	String wavekey //e.g. "filterPower_FDSN_fMainR"		String hts=selectstring(ht,"","_ht")	String notestr=wn_index[ro][%$("noteStrList"+hts)],curr,out=""	Variable num=itemsinlist(noteStr,"|"),i	for (i=0;i<num;i+=1)		curr=StringByKey(num2str(i),notestr,"=","|")		out+=stringbykey(wavekey,curr)+";"	endfor		return outendfunction wn_reps_getParamsWv(wn_index,outRef,useRepColRule)	WAVE/T wn_index; string outRef	String useRepColRule //which pre-selected instances to plot, e.g., use_S		string paramsRefList="paramsRef_fMainR;paramsRef_fSecR;diffsParamRef;fDiffsParamRef;"	Variable appendBeforeLblNotAfter=0	String paramOutAppend="_S;_P;_d;_f;"		Variable numParamsRefs=itemsinlist(paramsRefList)	make/o/t/n=(numParamsRefs)/free paramInfoLists,refLists,lbls	make/o/n=(numParamsRefs)/free lblLoop	make/o/n=(numParamsRefs) numLbls,lblStartIndexes	paramInfoLists=wn_reps_getList(wn_index,stringfromlist(p,paramsRefList),useRepColRule,"")	//sorted to avoid blanks and exclided cells	refLists=stringbykey("refList",paramInfoLists[p],"=","|")	Variable numRefs=itemsinlist(refLists[0])	String cellNames=stringbykey("finalCellNameList",paramInfoLists[0],"=","|"),cellName,currRefs	Variable i,j,count=0	for (i=0;i<numRefs;i+=1)		//concatenate along cols, label row by cell name		currRefs=""		for (j=0;j<numParamsRefs;j+=1)			currRefs+=Stringfromlist(i,refLists[j])+";"		endfor		if (!wavesexist(currRefs))			continue		//must have all expected refs (in the usual case this would be soma,ped,diff,fold diff.. so must be dual site)		endif		cellName=stringfromlist(i,cellNames)		concatenate/o/np=0 currRefs, singleRow		matrixtranspose singleRow		//append to main output wave		if (count==0)			Duplicate/o singleRow,$outref/wave=out			redimension/n=(1,-1) out			lbls[]=dl_getLblsAsList(stringfromlist(i,currRefs),0,0,inf)	//labels for each param wv			numLbls[]=itemsinlist(lbls[p])			lblStartIndexes[0]=0			lblStartIndexes[1,]=sum(numLbls,0, p-1)			lblLoop[]=dl_assignLblsFromList(out,1,lblStartIndexes[p],lbls[p],stringfromlist(p,paramOutAppend),appendBeforeLblNotAfter,reuseLast=0)		else			concatenate/np=0 {singleRow},out		endif		SetDimLabel 0,count,$cellName,out 				count+=1	endfor		killwaves/z singleRowendfunction/WAVE getColorSet(setNum)	variable setNum		Make/O/U/I/N=(4)/FREE out	Variable maxVal_rgb = 256	Variable bit8To16 = 256 - 1/256		switch (setNum)		case 0:		//somatic, black			out={0,0,0,maxVal_rgb}			break		case 1:		//terminal, red			out={146,0,0,maxVal_rgb}			break		case 2:		//foveal, blue			out={0,109,219,maxVal_rgb}				break		case 3:		//peripheral, brown			out={146,73,0,maxVal_rgb}			break	endswitch		out*=bit8To16		return outendfunction analysis_newCellParams_setBrkIn(indexWv,co,startX,exWaveRef)	WAVE/T indexWv	Variable co	Variable startX	//pass NaN to use csr	String exWaveRef	//pass "" to get from csr				Variable brkInInfoRow=finddimlabel(indexwv,0,"brkInInfo")		Variable time_x	Variable useCsr	if (numtype(startx) > 0)		time_x=xcsr(A)		useCsr=1	else		time_x=startx		useCsr=0	endif		String ref	if (useCsr)		ref = csrwave(A)	else		ref = exwaveref	endif				if ( (numtype(time_x) > 0) || (strlen(ref) < 1) )		Print "analysis_newCellParams_setBrkIn() use cursor A to select brk in time point! Aborting! (or failed due to bad input) useCsr=",usecsr		return 0	endif		//1 for fileNum, 2 for sweepNum, 3 for chStr	Variable fileNum = text_getinfofromwavename_V(ref,1)	Variable sweepNum = text_getinfofromwavename_V(ref,2)		String brkInRefNote=note($ref)	String fileTimeStr=stringbykey("FILE_TIME",brkInRefNote)	String sweepTimeStr=stringbykey("SWEEP_TIME",brkInRefNote)		String out="brkInTimeRelSweep:"+num2str(time_x)+";brkInSweepRef:"+ref+";brkInFileNum:"+num2str(fileNum)+";brkInSweepNum:"+num2str(sweepNum)+";"	out+="fileTimeStr:"+fileTimeStr+";sweepTimeStr:"+sweepTimeStr+";"	out+="|"+brkInRefNote+"|"		indexwv[brkInInfoRow][co]=outendfunction analysis_newCellParams(indexWv,co,outref,restart,killRawAfterUse)	WAVE/T indexWv; variable co		//column to analyze	String outref		//place to store output wave lists; created automatically if does not exist	variable restart		//restart column in output wave	Variable killRawAfterUse	//pass true to kill raw waves after		string usedWvList=""	String loadedWvList=""		//in case of re-loading waves, this keeps track for deletion at end 		Variable hs1cmdChunk=0	variable hs2cmdChunk=1	//check this	variable cmdOffsetPnts = 0	variable preStepLenX = 0.02		//might need to differ for each vctype .. adjusted slightly upwards with ceil for the scaling of the wave	Variable postStepLenX =0.1	Variable adjTimeBase = 1		//default to 1. see step_exciseAndNorm_avgI's parameter of the same name		Variable baselineSubLenX = 0.005		//in seconds, using 5 ms .. adjusted slightly upwards with ceil for the scaling of the wave		Double fitWinSize = 0.012		//fit win size for exp fits	String lbl=getdimlabel(indexwv,1,co)	String cellname = stringfromlist(0,lbl)	String actcellname = stringfromlist(1,lbl)	Variable hs_s = str2num(stringfromlist(2,lbl))	Variable hs_p = str2num(stringfromlist(3,lbl))	variable vctype = str2num(indexwv[28][co])	String hs1matchStr=indexwv[%hs1CmdMatchStr][co]	String hs2matchStr=indexwv[%hs2CmdMatchStr][co]	Variable rowsToCmd=14	variable i	String stepResponse_inds = "0,14;1,15;2,16;3,17;6,20;7,21;8,22;9,22;10,24;11,24;"		//positions with responses to analyze as steps, paired with the index of the VC CMD for that step																		//for VC responses, both indexes would be the same																		//for IC responses, the second index would be that of the simultaneous voltage clamp	String stepVCresp_inds = "2,0;3,1;6,0;7,1;8,0;10,1;"	//positions with wcVC step responses -- must also be in stepResponse_inds PLUS positions of relevant seals	String stepICresp_inds = "9,8;11,10;"						//positions with wcIC step responses, paired 	String ic0_inds = "12;13;"	String ic0_indSomaPedic0Pairs = "12,13;"								//ic0s that have soma and ped recorded simultaneously and so should be compared	make/o/t/n=14/free dls	i=0;dls[i]="ss";string sealVC_s = indexWv[i][co]	//step 0							ss	i+=1;dls[i]="sp";string  sealVC_p = indexWv[i][co]	//step 1						sp		i+=1;dls[i]="ws";string wcVC_seal_s = indexWv[i][co]	//step + VCresp 2		ws	i+=1;dls[i]="wp";string wcVC_seal_p = indexWv[i][co]	//step + VCresp 3		wp	i+=1;dls[i]="is";string wcIC_seal_s = indexWv[i][co]	//ic0 4					is	i+=1;dls[i]="ip";string wcIC_seal_p = indexWv[i][co]	//ic0 5 					ip	i+=1;dls[i]="wws";string wcVC_wcVC_s = indexWv[i][co]	//step + VCresp 6 		wws	i+=1;dls[i]="wwp";string wcVC_wcVC_p = indexWv[i][co]	//step + VCresp 7 		wwp	i+=1;dls[i]="wis";string wcVC_wcIC_s = indexWv[i][co]	//step + VCresp 8		wis	i+=1;dls[i]="iwp";string wcIC_wcVC_p = indexWv[i][co]	//step + ICresp 9		iwp	i+=1;dls[i]="wip";string wcVC_wcIC_p = indexWv[i][co]	//step + VCresp 10		wip	i+=1;dls[i]="iws";string wcIC_wcVC_s = indexWv[i][co]	//step + ICresp 11		iws	i+=1;dls[i]="iis";string wcIC_wcIC_s = indexWv[i][co]	//ic0 12					iis	i+=1;dls[i]="iip";string wcIC_wcIC_p = indexWv[i][co]	//ic0 13					iip	//none of these are (really) yet used		//doesnt yet handle adding new columns/rows from indexwv	if (waveexists($outref))		duplicate/o $outref,analysis_newCellParams_BU	endif		if (waveexists($outref)==0)		print "analysis_newCellParams() creating new outref",outref		duplicate/o/t indexwv,$outref/wave=out		out=""	else		wave/T out = $outref	endif	Variable rows=dimsize(indexwv,0),cols=dimsize(indexwv,1)	redimension/n=(rows,cols) out	if (restart)		//just restarts column		out[][co] = ""	endif		String stepStartEpochLists; Variable stimType	switch (vctype)		case 0:		//standard, single negative step			stepStartEpochLists = "1;|"			make/o/d stepWeightWv = {1}			stimType = 1		//unfortunately flipped!			break		case 1:			stepStartEpochLists = "2;4;6;8;|"			make/o/d stepWeightWv = {1,1,2,2}			stimType = 0			break					case 2:			stepStartEpochLists = "1;|2;4;6;8;|"			make/o/d stepWeightWv = { {1,nan,nan,nan} , {1,1,2,2} }			stimType=2			break					case 3:		//4 step version current July 2018			stepStartEpochLists = "1;3;5;7;|"			make/o/d stepWeightWv = {1,1,2,2}		//should be 2,2,1,1?			stimType = 0			break					default:		//Nan inf handling			Print "SET VCTYPE!!!!! ABORTING!!!!"			return 0	endswitch		String exref	if (strlen(wcVC_seal_s) > 0)		//use example from ped		exref = stringfromlist(0,wcVC_seal_s)	else		exref = stringfromlist(0,wcVC_seal_p)	endif		if (strlen(exref) < 1)		Print "analysis_newCellParams() indexwv",nameofwave(indexwv),"column",co,"failed to find an exRef! Help! Aborting"		return 0	endif		if (!igor_is64())		loadedWvList+=da_fd_loadWavesFromWaveName(exRef,1)+";"		usedWvList+=exref+";"	endif			Variable delta = dimdelta($exref,0),numRespRefs	variable baselineSubLenP = ceil(baselineSubLenX/delta)	variable preStepLenP = ceil(preStepLenX/delta)	String respTypeIndexList	preStepLenX=preStepLenP*delta		//bring this value into register with sampling rate		//basic step parameters  -- generalAvg (_ga) and esBasicParams (_pesb) are the main output parameter 	variable num,respInd,cmdInd,isHS1,isHS2,cmdChunk,fd_fileNum	string respRefs,cmdRefs,exCmdRef,outRefsList,basename,sublist,stepInfoRef,fName	num=itemsinlist(stepResponse_inds)	for (i=0;i<num;i+=1)		sublist=stringfromlist(i,stepResponse_inds)		respInd=str2num( stringfromlist(0,sublist,",") )		cmdInd = str2num( stringfromlist(1,sublist ,",") )		respRefs=indexwv[respInd][co]		cmdRefs=indexWv[cmdInd][co]		numRespRefs=itemsinlist(respRefs)				if (numRespRefs < 1)			continue		endif				print "i",i,"respRefs",respRefs,"numRespRefs",numRespRefs				if (vctype==2)			respTypeIndexList=stringfromlist(1,respRefs,"|")			respRefs=stringfromlist(0,respRefs,"|")		else			respTypeIndexList=text_makeStringList("0",numRespRefs,";")		endif		print "i",i,"respRefs",respRefs		loadedWvList+=da_fd_loadWavesFromWaveName(respRefs,1)+";"		usedWvList+=respRefs		loadedWvList+=da_fd_loadWavesFromWaveName(cmdRefs,1)+";"		usedWvList+=cmdRefs				exCmdRef=stringfromlist(0,cmdRefs)		isHS1 = stringmatch(exCmdRef,hs1matchStr)		isHS2 = stringmatch(exCmdRef,hs2matchStr)		if (!isHS1 && !isHS2)			print "analysis_newCellParams() responses at respInd",respInd,"cmdInd",cmdInd,"do not match a headstage. skipping."			Print "check refList or check hs1matchStr (",hs1matchStr,") or hs2matchStr (",hs2matchStr,")"			continue 		endif		fName = text_getInfoFromWaveName_S(exCmdRef, 9)		fd_fileNum=fd_getFIndexInFileInfoWave(fName)		stepInfoRef = fd_getEpochInfo(fd_fileNum,1)		if (dimsize($stepInfoRef,3) < 2)		//only one commanded channel, must be 0, otherwise could be either soma or ped			cmdChunk = 0		else				cmdChunk = isHS1 ? hs1cmdChunk : hs2cmdChunk		endif				basename=cellname+"_"+num2str(respInd)				outRefsList=step_exciseAndNorm_avgI(respRefs,respTypeIndexList,stepStartEpochLists,stepWeightWv,cmdChunk,baselineSubLenP,cmdOffsetPnts,preStepLenX,postStepLenX,basename,0,stimType,adjTimeBase)	//calc normed resps		print "i",i,"outRefsList",outRefsList						outRefsList=analysis_cellParams_ES_basic(outRefsList)			//input resistance analysis		print "i",i,"outRefsList",outRefsList					out[respInd][co] = outrefsList		//store info / results	endfor		Print "completed basic step params"		//VC step responses -- EsVcParams (_pesV) is the main parameter output	variable sealInd,ind; string outrefsList_resp,outRefsList_seal,additionalRefs,ref_resp,ref_seal	num=itemsinlist(stepVCresp_inds)	for (i=0;i<num;i+=1)		sublist=stringfromlist(i,stepVCresp_inds)		ind=str2num( stringfromlist(0,sublist,",") )		sealInd = str2num( stringfromlist(1,sublist ,",") )				outrefsList_resp=out[ind][co]		outRefsList_seal=out[sealInd][co]				print "i",i,"outRefsList_seal",outRefsList_seal		print "i",i,"outrefsList_resp",outrefsList_resp				if (itemsinlist(outrefsList_resp) < 1)			continue		endif				additionalRefs=analysis_cellParams_ES_VC(outrefsList_resp,outRefsList_seal,fitWinSize)			//wc vc analysis				out[ind][co] += additionalRefs	//store info / results	endfor		//IC step responses -- icParamsRef (_ip) is the main output parameter	num=itemsinlist(stepICresp_inds)	Variable ic_ind,vc_ind; string outrefslist_ic,outrefslist_vc	for (i=0;i<num;i+=1)		sublist=stringfromlist(i,stepICresp_inds)		ic_ind=str2num( stringfromlist(0,sublist,",") )		vc_ind=str2num( stringfromlist(1,sublist ,",") )		//not used currently but could correlate				outrefsList_ic=out[ic_ind][co]		outRefsList_vc=out[vc_ind][co]		//not used currently but could correlate				if (itemsinlist(outrefsList_ic) < 1)			continue		endif				//ic analysis		basename=cellname+"_"+num2str(ic_ind)		additionalRefs=analysis_icParams_ES(baseName,outrefsList_ic)				out[ic_ind][co]+=additionalRefs	endfor		//IC0 responses -- ic0_params (_i0) is the main output parameter	num=itemsinlist(ic0_inds); variable startx,endx; string list,ref,startxStr,endxstr	for (i=0;i<num;i+=1)		ind=str2num(stringfromlist(i,ic0_inds))				list=indexwv[ind][co]				if (itemsinlist(list) < 1)			continue		endif				ref=stringfromlist(0,list)		startxStr=stringfromlist(1,list)		endxstr=stringfromlist(2,list)		startx=str2num(startxstr)		endx=str2num(endxstr)				loadedWvList+=da_fd_loadWavesFromWaveName(ref,1)+";"		usedWvList+=ref				basename=cellname+"_"+num2str(respInd)				outRefsList=analysis_ic0_simple(ref,startx,endx,baseName)		out[ind][co]=outRefsList	endfor			//2 site ic0 comparisons, ic0_2sParams (_i02s) is the main output parameter	num=itemsinlist(ic0_indSomaPedic0Pairs)	Variable soma_ind,ped_ind	String refs_s,refs_p	for (i=0;i<num;i+=1)		sublist=stringfromlist(i,ic0_indSomaPedic0Pairs)		soma_ind=str2num( stringfromlist(0,sublist,",") )		ped_ind=str2num( stringfromlist(1,sublist ,",") )		//not used currently but could correlate				refs_S=out[soma_ind][co]		refs_P=out[ped_ind][co]				if ( (itemsinlist(refs_S) < 1) || (itemsinlist(refs_P) < 1) )			continue		endif					outRefsList=analysis_ic0_twoSite(refs_S,refs_P)		out[soma_ind][co]+=outRefsList	endfor		if (killRawAfterUse)		print "killing",usedWvList		killWavesByName(usedWvList)	endifend		//analysis_newCellPArams()function/s analysis_newCellPArams_summary(mainOutputWv,indexwv,outRef)	WAVE/T indexwv		//as passed to analysis_newCellPArams	WAVE/T mainOutputWv //as maintained by analysis_newCellPArams	String outRef		Variable numCells=dimsize(mainOutputWv,1)	Variable numConditions=14		//set in analysis_newCellPArams and must match how indexwv is arranged	Variable numAdditionalParams=1 //other stuff we are going to throw in	Variable esBasic_numParams=312 //_pesb waves	Variable vc_numParams=2509 //_pesV waves	Variable icS_numParams=311 //_ip waves	Variable ic0_numParams=1277 //_i0 waves	Variable ic2s_numParams=2597 //_i02s waves	make/o/free/n=(numConditions) startIndices	startIndices[0] = numConditions	 + numAdditionalParams	//starts after total condition params are stored, has esBasicParams	startIndices[1] = startIndices[0] + esBasic_numParams		//has esBasicParams	startIndices[2] = startIndices[1]  + esBasic_numParams		//has esBasicParams + vc_numParams	startIndices[3] = startIndices[2]  + esBasic_numParams	+ vc_numParams	//has esBasicParams + vc_numParams	startIndices[4] = startIndices[3]  + esBasic_numParams	+ vc_numParams	//has nothing	startIndices[5] = startIndices[4]		//has nothing	startIndices[6] = startIndices[5]  	//starts where 3 left off, has esBasicParams + vc_numParams	startIndices[7] = startIndices[6]  +  esBasic_numParams + vc_numParams //has esBasicParams + vc_numParams	startIndices[8] = startIndices[7]  +  esBasic_numParams + vc_numParams	//has esBasicParams + vc_numParams	startIndices[9] = startIndices[8]  +  esBasic_numParams + vc_numParams	//has esBasicParams + icStep params	startIndices[10] = startIndices[9]  + esBasic_numParams + icS_numParams	//has esBasicParams + vc_numParams	startIndices[11] = startIndices[10]  + esBasic_numParams + vc_numParams	//has esBasicParams + icStepParams	startIndices[12] = startIndices[11]  + esBasic_numParams + icS_numParams		//has ic0 params + ic2s params	startIndices[13] = startIndices[12]  + ic0_numParams + ic2s_numParams		//has ic0 params		Variable outRows = startIndices[13] + ic0_numParams		make/o/d/n=(outRows,numCells) $outref/wave=out; out=nan	dl_lblsToLbls(nameofwave(indexwv),1,0,inf,outref,1,0,"",0)			//parameter types	//esBasic (_pesb) from analysis_icParams_ES(): run for any step that was excised and averaged. output labels:		// ssE/psE (soma/ped seal vc)		// swE/pwE (soma/ped wc other sealed)		// sDE/pDE (soma/ped dual wc vc) 		// sUE/pUE (vcSoma icPed)		// pXE/sXE (vcPed icSoma)	//EsVcParams (_pesV) from analysis_cellParams_ES_VC(): any voltage clamp ste presponse. output labels: 		// swV/pwV (soma/ped wc other sealed)		// sDV/pDV (soma/ped dual wc)		// sUV (vcSoma icPed)		// pXV (vcPed icSoma)	//icSPars / icParamsRef (_ip) from analysis_icParams_ES(): any ic response while another site undergoes as VC step. output labels:		// pUI (vcSoma icPed)		// sXI (vcPed icSoma)	//ic0Pars (_i0) from analysis_ic0_simple(): ic0 parameters		// sI0 (icSoma)		// pI0 (icPed)	//ic2sPars (_i02s) from analysis_ic0_twoSite(): ic0 2 site simultaneous params		// sI2 (icSoma icPed)					Variable vcType,hs_s,hs_p	String lbl,cellname,actcellname,info	String esBasic_seal_S,esBasic_seal_P		//for rows 0-1: soma-ped seal params stored in esBasicParams key	String esBasic_w_S,esBasic_w_P,vcPars_w_S,vcPars_w_P		//for rows 2-3: soma-ped VC other site sealed stored in esBasicParams and esVcParams key				//rows 4-5:soma-ped IC other site sealed, no analysis done for now beyond excised params, stored in outRef_params key	string esBasic_ww_S,esBasic_ww_P,vcPars_ww_S,vcPars_ww_P	 //for rows 6-7: soma-ped VC other site VC, stored in esBasicParams and esVcParams	string esBasic_wi_S,vcPars_wi_S,esBasic_iw_P,icSPars_iw_P	//for rows 8-9: soma VC ped IC, soma has esBasicParams and esVcParams, ped has esBasicParams and icParamsRef	string esBasic_wi_P,vcPars_wi_P,esBasic_iw_S,icSPars_iw_S	//for rows 10-11: ped VC soma IC, ped has esBasicParams and esVCParams,  soma has esBasicParams and icParamsRef	String ic0Pars_S,ic0Pars_P,ic2sPars		//12-13: soma-ped IC params has ic0_params and ic0_s2Params at soma (just difference and fold diff of the two)		//collect standard parameters	Variable i,num=dimsize(mainOutputWv,1),ind,si,np,waveSTatus	String al	for (i=0;i<num;i+=1)		vcType=str2num(indexwv[28][i])		lbl=getdimlabel(indexwv,1,i)		cellname = stringfromlist(0,lbl)		actcellname = stringfromlist(1,lbl)		hs_s = str2num(stringfromlist(2,lbl))		hs_p = str2num(stringfromlist(3,lbl))				out[0,numConditions-1][i]= (strlen(indexwv[p][i]) > 0)*2^0 + (strlen(indexwv[p+numConditions][i]) > 0)*2^1			//bitwise is there something in the data row and something in the command row		out[numConditions][i]=vctype;SetDimLabel 0,numConditions,$"vctype",out				//0-1 gather seal params -- esBasicParams always contains original excised step params		ind=0;si=startIndices[ind];al="ssE_"		//soma seal esBasic		info=mainOutputWv[ind][i]		//soma seal		esBasic_seal_S=stringbykey("esBasicParams",info)		waveStatus= strlen(esBasic_seal_S) == 0 ? 0 : (2^0)+(waveexists($esBasic_seal_S)*2^1)		//checking length before exists in case null string check on waveexists is an error		if (waveStatus >= 3)					wave pars=$esBasic_seal_S;np=dimsize(pars,0)			out[si,si+np-1][i]=pars[p-si];dl_lblsToLbls(esBasic_seal_S,0,0,np,outref,0,si,al,1)		else			out[si][i]=waveStatus			//Print "missed ind",ind,"info",info		endif							ind=1;si=startIndices[ind];al="psE_"		//ped seal esBasic		info=mainOutputWv[ind][i]		//ped seal		esBasic_seal_P=stringbykey("esBasicParams",info)			waveStatus= strlen(esBasic_seal_P) == 0 ? 0 : (2^0)+(waveexists($esBasic_seal_P)*2^1)		//checking length before exists in case null string check on waveexists is an error		if (waveStatus >= 3)					wave pars=$esBasic_seal_P;np=dimsize(pars,0)			out[si,si+np-1][i]=pars[p-si];dl_lblsToLbls(esBasic_seal_P,0,0,np,outref,0,si,al,1)		else			out[si][i]=waveStatus			//Print "missed ind",ind,"info",info		endif							//2-3 gather VC with second site sealed params 		ind=2;si=startIndices[ind];al="swE_"		//soma wc only esBasic		info=mainOutputWv[ind][i]		//at soma: soma VC ped sealed		esBasic_w_S=stringbykey("esBasicParams",info)		//vc wholeCell soma -- esBasicParams		waveStatus= strlen(esBasic_w_S) == 0 ? 0 : (2^0)+(waveexists($esBasic_w_S)*2^1)		//checking length before exists in case null string check on waveexists is an error		if (waveStatus >= 3)					wave pars=$esBasic_w_S;np=dimsize(pars,0)			out[si,si+np-1][i]=pars[p-si];dl_lblsToLbls(esBasic_w_S,0,0,np,outref,0,si,al,1)				else			out[si][i]=waveStatus			//Print "missed ind",ind,"info",info		endif							si+=np;al="swV_"		//soma wc only VC params		vcPars_w_S=stringbykey("EsVcParams",info)				//vc wholeCell soma -- vcParams		waveStatus= strlen(vcPars_w_S) == 0 ? 0 : (2^0)+(waveexists($vcPars_w_S)*2^1)		//checking length before exists in case null string check on waveexists is an error		if (waveStatus >= 3)					wave pars=$vcPars_w_S;np=dimsize(pars,0)			out[si,si+np-1][i]=pars[p-si];dl_lblsToLbls(vcPars_w_S,0,0,np,outref,0,si,al,1)						else			out[si][i]=waveStatus			//Print "missed ind",ind,"info",info		endif							ind=3;si=startIndices[ind];al="pwE_"		//ped wc only esBasic		info=mainOutputWv[ind][i]		//at ped: ped VC soma sealed		esBasic_w_P=stringbykey("esBasicParams",info)		//as above from ped		waveStatus= strlen(esBasic_w_P) == 0 ? 0 : (2^0)+(waveexists($esBasic_w_P)*2^1)		//checking length before exists in case null string check on waveexists is an error		if (waveStatus >= 3)					wave pars=$esBasic_w_P;np=dimsize(pars,0)			out[si,si+np-1][i]=pars[p-si];dl_lblsToLbls(esBasic_w_P,0,0,np,outref,0,si,al,1)					else			out[si][i]=waveStatus			//Print "missed ind",ind,"info",info		endif								si+=np;al="pwV_"		//ped wc only VC params		vcPars_w_P=stringbykey("EsVcParams",info)				waveStatus= strlen(vcPars_w_P) == 0 ? 0 : (2^0)+(waveexists($vcPars_w_P)*2^1)		//checking length before exists in case null string check on waveexists is an error		if (waveStatus >= 3)					wave pars=$vcPars_w_P;np=dimsize(pars,0)			out[si,si+np-1][i]=pars[p-si];dl_lblsToLbls(vcPars_w_P,0,0,np,outref,0,si,al,1)			else			out[si][i]=waveStatus			//Print "missed ind",ind,"info",info		endif								//4-5 nothing for now				//6-7 gather simultaneous VC data		ind=6;si=startIndices[ind];al="sDE_"		//soma dual VC, esBasic	.. just choosing D to repsent dual VC		info=mainOutputWv[ind][i]		//at soma: VC with ped VC		esBasic_ww_S=stringbykey("esBasicParams",info)		//vc wholeCell soma (while wc vc ped) -- esBasicParams		waveStatus= strlen(esBasic_ww_S) == 0 ? 0 : (2^0)+(waveexists($esBasic_ww_S)*2^1)		//checking length before exists in case null string check on waveexists is an error		if (waveStatus >= 3)					wave pars=$esBasic_ww_S;np=dimsize(pars,0)			out[si,si+np-1][i]=pars[p-si];dl_lblsToLbls(esBasic_ww_S,0,0,np,outref,0,si,al,1)				else			out[si][i]=waveStatus			//Print "missed ind",ind,"info",info		endif						si+=np;al="sDV_"			//soma dual VC, VC params		vcPars_ww_S=stringbykey("EsVcParams",info)				//vc wholeCell soma (wwhile wc vc ped) -- vcParams		waveStatus= strlen(vcPars_ww_S) == 0 ? 0 : (2^0)+(waveexists($vcPars_ww_S)*2^1)		//checking length before exists in case null string check on waveexists is an error		if (waveStatus >= 3)					wave pars=$vcPars_ww_S;np=dimsize(pars,0)			out[si,si+np-1][i]=pars[p-si];dl_lblsToLbls(vcPars_ww_S,0,0,np,outref,0,si,al,1)				else			out[si][i]=waveStatus			//Print "missed ind",ind,"info",info		endif						ind=7;si=startIndices[ind];al="pDE_"	//ped dual VC, esBasic aparams		info=mainOutputWv[ind][i]		//at ped: VC with soma VC		esBasic_ww_P=stringbykey("esBasicParams",info)		//as above from ped		waveStatus= strlen(esBasic_ww_P) == 0 ? 0 : (2^0)+(waveexists($esBasic_ww_P)*2^1)		//checking length before exists in case null string check on waveexists is an error		if (waveStatus >= 3)					wave pars=$esBasic_ww_P;np=dimsize(pars,0)			out[si,si+np-1][i]=pars[p-si];dl_lblsToLbls(esBasic_ww_P,0,0,np,outref,0,si,al,1)			else			out[si][i]=waveStatus			//Print "missed ind",ind,"info",info		endif					si+=np;al="pDV_"		//ped dual VC, vcParams		vcPars_ww_P=stringbykey("EsVcParams",info)				waveStatus= strlen(vcPars_ww_P) == 0 ? 0 : (2^0)+(waveexists($vcPars_ww_P)*2^1)		//checking length before exists in case null string check on waveexists is an error		if (waveStatus >= 3)					wave pars=$vcPars_ww_P;np=dimsize(pars,0)			out[si,si+np-1][i]=pars[p-si];dl_lblsToLbls(vcPars_ww_P,0,0,np,outref,0,si,al,1)			else			out[si][i]=waveStatus			//Print "missed ind",ind,"info",info		endif									//8-9 gather VC-IC from soma		ind=8;si=startIndices[ind];al="sUE_"		//soma VC ped IC, chooinsg U to designate, esBasicPArams at soma		info=mainOutputWv[ind][i]		//at soma: vc wholeCell soma (while ic ped) 		esBasic_wi_S=stringbykey("esBasicParams",info)		//vc wholeCell soma (while ic ped) -- esBasicParams at soma		waveStatus= strlen(esBasic_wi_S) == 0 ? 0 : (2^0)+(waveexists($esBasic_wi_S)*2^1)		//checking length before exists in case null string check on waveexists is an error		if (waveStatus >= 3)					wave pars=$esBasic_wi_S;np=dimsize(pars,0)			out[si,si+np-1][i]=pars[p-si];dl_lblsToLbls(esBasic_wi_S,0,0,np,outref,0,si,al,1)			else			out[si][i]=waveStatus			//Print "missed ind",ind,"info",info		endif							si+=np;al="sUV_"		//soma VC ped IC, chooinsg U to designate, vcParams		vcPars_wi_S=stringbykey("EsVcParams",info)				//vc wholeCell soma (while ic ped) -- vcParams at soma		waveStatus= strlen(vcPars_wi_S) == 0 ? 0 : (2^0)+(waveexists($vcPars_wi_S)*2^1)		//checking length before exists in case null string check on waveexists is an error		if (waveStatus >= 3)					wave pars=$vcPars_wi_S;np=dimsize(pars,0)			out[si,si+np-1][i]=pars[p-si];dl_lblsToLbls(vcPars_wi_S,0,0,np,outref,0,si,al,1)					else			out[si][i]=waveStatus			//Print "missed ind",ind,"info",info		endif							ind=9;si=startIndices[ind];al="pUE_"		//soma VC ped IC, chooinsg U to designate, esBasicPArams at ped		info=mainOutputWv[ind][i]		//at ped: vc wholeCell soma (while ic ped) 		esBasic_iw_P=stringbykey("esBasicParams",info)		//vc wholeCell soma (while ic ped) -- esBasicParams at ped		waveStatus= strlen(esBasic_iw_P) == 0 ? 0 : (2^0)+(waveexists($esBasic_iw_P)*2^1)		//checking length before exists in case null string check on waveexists is an error		if (waveStatus >= 3)					wave pars=$esBasic_iw_P;np=dimsize(pars,0)			out[si,si+np-1][i]=pars[p-si];dl_lblsToLbls(esBasic_iw_P,0,0,np,outref,0,si,al,1)				else			out[si][i]=waveStatus			//Print "missed ind",ind,"info",info		endif						si+=np;al="pUI_"				//soma VC ped IC, chooinsg U to designate, icStepParams at ped		icSPars_iw_P=stringbykey("icParamsRef",info)				//vc wholeCell soma (while ic ped) -- icParams at ped			waveStatus= strlen(icSPars_iw_P) == 0 ? 0 : (2^0)+(waveexists($icSPars_iw_P)*2^1)		//checking length before exists in case null string check on waveexists is an error		if (waveStatus >= 3)					wave pars=$icSPars_iw_P;np=dimsize(pars,0)			out[si,si+np-1][i]=pars[p-si];dl_lblsToLbls(icSPars_iw_P,0,0,np,outref,0,si,al,1)						else			out[si][i]=waveStatus			//Print "missed ind",ind,"info",info		endif					//10-11 gather VC-IC from soma		ind=10;si=startIndices[ind];al="pXE_"		//ped VC soma IC, chooinsg X to designate, esBasicPArams ped		info=mainOutputWv[ind][i]		//at ped: vc wholeCell ped (while ic soma) 		esBasic_wi_P=stringbykey("esBasicParams",info)		//vc wholeCell ped (while ic soma) -- esBasicParams at ped		waveStatus= strlen(esBasic_wi_P) == 0 ? 0 : (2^0)+(waveexists($esBasic_wi_P)*2^1)		//checking length before exists in case null string check on waveexists is an error		if (waveStatus >= 3)					wave pars=$esBasic_wi_P;np=dimsize(pars,0)			out[si,si+np-1][i]=pars[p-si];dl_lblsToLbls(esBasic_wi_P,0,0,np,outref,0,si,al,1)						else			out[si][i]=waveStatus			//Print "missed ind",ind,"info",info		endif						si+=np;al="pXV_"					//ped VC soma IC, chooinsg X to designate, vcParams ped		vcPars_wi_P=stringbykey("EsVcParams",info)				//vc wholeCell ped (while ic soma) -- vcParams at ped		waveStatus= strlen(vcPars_wi_P) == 0 ? 0 : (2^0)+(waveexists($vcPars_wi_P)*2^1)		//checking length before exists in case null string check on waveexists is an error		if (waveStatus >= 3)					wave pars=$vcPars_wi_P;np=dimsize(pars,0)			out[si,si+np-1][i]=pars[p-si];dl_lblsToLbls(vcPars_wi_P,0,0,np,outref,0,si,al,1)						else			out[si][i]=waveStatus			//Print "missed ind",ind,"info",info		endif									ind=11;si=startIndices[ind];al="sXE_"		//ped VC soma IC, chooinsg X to designate, esBasicPArams soma			info=mainOutputWv[ind][i]		//at soma: vc wholeCell ped (while ic soma) 		esBasic_iw_S=stringbykey("esBasicParams",info)		//vc wholeCell ped (while ic soma) -- esBasicParams at ped		waveStatus= strlen(esBasic_iw_S) == 0 ? 0 : (2^0)+(waveexists($esBasic_iw_S)*2^1)		//checking length before exists in case null string check on waveexists is an error		if (waveStatus >= 3)					wave pars=$esBasic_iw_S;np=dimsize(pars,0)			out[si,si+np-1][i]=pars[p-si];dl_lblsToLbls(esBasic_iw_S,0,0,np,outref,0,si,al,1)					else			out[si][i]=waveStatus			//Print "missed ind",ind,"info",info		endif							si+=np;al="sXI_"			//ped VC soma IC, chooinsg X to designate, icStepParams soma			icSPars_iw_S=stringbykey("icParamsRef",info)				//vc wholeCell ped (while ic soma) -- icParams at ped			waveStatus= strlen(icSPars_iw_S) == 0 ? 0 : (2^0)+(waveexists($icSPars_iw_S)*2^1)		//checking length before exists in case null string check on waveexists is an error		if (waveStatus >= 3)					wave pars=$icSPars_iw_S;np=dimsize(pars,0)			out[si,si+np-1][i]=pars[p-si];dl_lblsToLbls(icSPars_iw_S,0,0,np,outref,0,si,al,1)					else			out[si][i]=waveStatus			//Print "missed ind",ind,"info",info		endif							//12-13 ic at either site possibly simultaneously		ind=12;si=startIndices[ind];al="sI0_"			//IC I0 pars at soma		info=mainOutputWv[ind][i]		//at soma: ic, possibly with ped ic too		ic0Pars_S=stringbykey("ic0_params",info)		waveStatus= strlen(ic0Pars_S) == 0 ? 0 : (2^0)+(waveexists($ic0Pars_S)*2^1)		//checking length before exists in case null string check on waveexists is an error		if (waveStatus >= 3)					wave pars=$ic0Pars_S;np=dimsize(pars,0)			out[si,si+np-1][i]=pars[p-si];dl_lblsToLbls(ic0Pars_S,0,0,np,outref,0,si,al,1)						else			out[si][i]=waveStatus			//Print "missed ind",ind,"info",info		endif						si+=np;al="sI2_"			//IC dual site params		ic2sPars=stringbykey("ic0_2sParams",info) 		waveStatus= strlen(ic2sPars) == 0 ? 0 : (2^0)+(waveexists($ic2sPars)*2^1)		//checking length before exists in case null string check on waveexists is an error		if (waveStatus >= 3)					wave pars=$ic2sPars;np=dimsize(pars,0)			out[si,si+np-1][i]=pars[p-si];dl_lblsToLbls(ic2sPars,0,0,np,outref,0,si,al,1)				else			out[si][i]=waveStatus			//Print "missed ind",ind,"info",info		endif						ind=13;si=startIndices[ind];al="pI0_"			info=mainOutputWv[ind][i]		//at ped: ic, possibly with ped ic too			ic0Pars_P=stringbykey("ic0_params",info)				waveStatus= strlen(ic0Pars_P) == 0 ? 0 : (2^0)+(waveexists($ic0Pars_P)*2^1)		//checking length before exists in case null string check on waveexists is an error		if (waveStatus >= 3)					wave pars=$ic0Pars_P;np=dimsize(pars,0)			out[si,si+np-1][i]=pars[p-si];dl_lblsToLbls(ic0Pars_P,0,0,np,outref,0,si,al,1)				else			out[si][i]=waveStatus			//Print "missed ind",ind,"info",info		endif						//CHECK IF CONDITIONS FOR BOTH??	endforendfunction/s analysis_newCellPArams_summary_combWithOther(summaryWv,otherWv,outRef,appendStrForOtherLbls,appendBeforeNotAfter)	WAVE summaryWv,otherWv	String outRef	String appendStrForOtherLbls	Variable appendBeforeNotAfter		Variable numSummaryParams=dimsize(summaryWv,0)	Variable numOtherParams=dimsize(otherWv,0)	variable totalRows=numSummaryParams+numOtherParams	Duplicate/o summaryWv,$outref/wave=out	redimension/n=(totalRows,-1) out	out[numSummaryParams,]=nan	dl_lblsToLbls(nameofwave(otherWv),0,0,inf,outRef,0,numSummaryParams,appendStrForOtherLbls,appendBeforeNotAfter)			Variable num=dimsize(summaryWv,1),i,otherCol	String actCellName,lbl,missing=""	for (i=0;i<num;i+=1)		lbl=getdimlabel(summaryWv,1,i)		actCellName=stringfromlist(1,lbl)		otherCol=finddimlabel(otherWv,1,actCellName)		if (otherCol>=0)			out[numSummaryParams,][i]=otherWv[p-numSummaryParams][otherCol]				else			missing+=actCellName+";"		endif		endfor	print "missing num",itemsinlist(missing),"missing",missing	return missingendfunction/s analysis_newCellParams_getInfo(indexwv,infoName)	WAVE/T indexwv		String infoName		//options include: cellName,actCellName,hs_s,hs_p (for col labels) .. retrieves label data across cols							//and all row labels .. retrieves WAVE data for that row across cols		String dlInfoList = "cellName;actCellName;hs_s;hs_p;"		Variable lblIndex = whichlistitem(infoName,dlInfoList)	String lbl,out=""	variable i,numCols=dimsize(indexwv,1),lblRow	if (lblIndex < 0)			//not in col label, is a row label		lblRow=FindDimLabel(indexwv, 0, infoName )		if (lblRow < 0)			Print "analysis_newCellParams_getInfo() infoName",infoName,"not found in column labels or row labels, returning empty string"			return ""		endif				for (i=0;i<numCols;i+=1)			out+=indexwv[lblRow][i]+";"		endfor	else		//col label not col data		for (i=0;i<numCols;i+=1)			lbl=getdimlabel(indexwv,1,i)			out+=stringfromlist(lblIndex,lbl)+";"		endfor	endif		return out	end//order is all params for unsubtracted (n_) and then subtracted (s_) (dim labels)function/s analysis_cellParams_ES_VC(refList_resp,refList_seal,fitWinSize)	String refList_resp,refList_seal		//refList_resp and refList_seal have keys as returned by step_exciseAndNorm_avgI() FOLLOWED BY analysis_cellParams_ES_basic	Double fitWinSize	//window length for exp fits		//load calculation params and response	String baseName_resp = stringbykey("outRef_base",refList_resp)	String outRef = baseName_resp + "_pesV"		//params ES VC without seal subtraction	String prevExps_nw=outRef+"_PE_nw",prevExps_w=outRef+"_PE_w"		//previous exponential fits, if any, for main capacitance transient	String outExpRef_nw=outRef+"_OE_nw",outExpRef_w=outRef+"_OE_w"		//place to store final exponential fits for main capacitance transient, nonweighted and weighted by seWv			//outputs overwrite previous after fitting is complete in order to set up next round		String outRef_canonical_w=stringbykey("outRef_canonical_w",refList_resp)	WAVE grandAvg=$outRef_canonical_w	Variable avgCol = FindDimLabel(grandAvg, 1, "avg" )	Variable semCol = FindDimLabel(grandAvg, 1, "sem" )	Variable offset=dimoffset(grandAvg,0),delta=dimdelta(grandAvg,0)	make/o/d/n=(1) cpEsVc_avgTemp,cpEsVc_semTemp	matrixop/o cpEsVc_avgTemp = col(grandAvg,avgCol)	matrixop/o cpEsVc_semTemp = col(grandAvg,semCol)	setscale/p x,offset,delta,"s",cpEsVc_avgTemp,cpEsVc_semTemp	String esBasicParams_resp=stringbykey("esBasicParams",refList_resp)		//where to store outputs -- THESE ARE ACTUALLY JUST TEMPS AT PRESENT	String EsVcParams_noSealSub = "pesV_TEMP"		//params ES VC without seal subtraction	String EsVcParams_sealSub = "pesVs_TEMP"	//params ES VC with seal subtraction		//run		analysis_cellParams_ES_VC_cap("cpEsVc_avgTemp","cpEsVc_semTemp",esBasicParams_resp,fitWinSize,EsVcParams_noSealSub,prevExps_nw,prevExps_w,outExpRef_nw,outExpRef_w,nan)	//and for seal,if any	String sealSubbedRespRef = baseName_resp + "_esVS"		//es vc subtraction	String sealSubbedRespSEMRef = baseName_resp + "_esVSE"		//es vc subtraction standard error	Variable hasSeal=itemsinlist(refList_seal) > 0	String outRef_canonical_w_seal=""	if (hasSeal)		outRef_canonical_w_seal = stringbykey("outRef_canonical_w",refList_seal)		WAVE/D grandAvg_seal = $outRef_canonical_w_seal		make/o/d/n=(1) cpEsVc_avgTemp_seal,cpEsVc_semTemp_seal		matrixop/o cpEsVc_avgTemp_seal = col(grandAvg_seal,avgCol)		matrixop/o cpEsVc_semTemp_seal = col(grandAvg_seal,semCol)				setscale/p x,offset,delta,"s",cpEsVc_avgTemp_seal,cpEsVc_semTemp_seal				//do subtraction for capacitance analysis with seal sub		duplicate/o cpEsVc_avgTemp,$sealSubbedRespRef/wave=sealSubbedResp, $sealSubbedRespSEMRef/wave=sealSubbedSEM		sealSubbedResp-=cpEsVc_avgTemp_seal				//we should be able to propagate uncertainty for SEMs like SDs. for subtraction, the SD of the result is sqrt(SD1^2 + SD2^2)		//for SEM, the result's is sqrt(SEM1^2 + SEM2^2). We assume the errors are uncorrelated, which seems fine		sealSubbedSEM = sqrt(cpEsVc_semTemp^2 + cpEsVc_semTemp_seal^2)						analysis_cellParams_ES_VC_cap(nameofwave(sealSubbedResp),nameofwave(sealSubbedSEM),esBasicParams_resp,fitWinSize,EsVcParams_sealSub,"","","","",2)//prev and output exps are blank because mono and double exps currently do not ever involve user guided fitting	else		//make a placeholder, fill with nans		duplicate/o $EsVcParams_noSealSub,$EsVcParams_sealSub/wave=esVcParams_sealSubWv		esVcParams_sealSubWv=nan	endif		//prepare to get sweep-by-sweep cap measurement from integral; needs parameters determined in analysis_cellParams_ES_VC_cap	WAVE/D EsVcParams_noSealSubWv=$EsVcParams_noSealSub		//MAKE SURE THESE ARE STORED!!LAST STEP STILL TO DO -- think this is ok?	Double fitStartX = EsVcParams_noSealSubWv[%fitStartX]	Double integration_estTimeToSS = EsVcParams_noSealSubWv[%integration_estTimeToSS]	Double integration_ssAvgLen = EsVcParams_noSealSubWv[%integration_ssAvgLen]	Double assumedSpecificCap = EsVcParams_noSealSubWv[%assumedSpecificCap]	Double dv = EsVcParams_noSealSubWv[%dv]		String outRef_all_resp = stringbykey("outRef_all",refList_resp)	String outref_params_resp = stringbykey("outref_params",refList_resp)	WAVE/D allWv_resp = $outRef_all_resp	WAVE/D params_resp=$outref_params_resp	Variable weightsRow_resp=FindDimLabel(params_resp, 0, "weight" )	Variable reps_resp = dimsize(params_resp,1)	matrixop/o/free weights_resp = subRange(params_resp,weightsRow_resp,weightsRow_resp,0,reps_resp-1)	matrixtranspose weights_resp;redimension/n=(-1) weights_resp		analysis_ES_integrateCapReps(allWv_resp,weights_resp,fitStartX,fitStartX+integration_estTimeToSS,integration_estTimeToSS,integration_estTimeToSS+integration_estTimeToSS,assumedSpecificCap,dv,"cpRepsEsVcTemp_resp")	WAVE/D cpRepsEsVcTemp_resp		Double respSealCapDiff=nan,respSealCapDiffSEM=nan,respSealCapDiffSD=nan	if (hasSeal)		String outRef_all_seal = stringbykey("outRef_all",refList_seal)		String outRef_params_seal = stringbykey("outref_params",refList_seal)		WAVE/D allWv_Seal = $outRef_all_seal		WAVE/D params_seal = $outRef_params_seal		Variable weightsRow_seal=FindDimLabel(params_seal, 0, "weight" )		Variable reps_seal=dimsize(params_seal,1)		matrixop/o/free weights_resp = subRange(params_seal,weightsRow_seal,weightsRow_seal,0,reps_seal-1)		matrixtranspose weights_resp;redimension/n=(-1) weights_resp		analysis_ES_integrateCapReps(allWv_Seal,weights_resp,fitStartX,fitStartX+integration_estTimeToSS,integration_estTimeToSS,integration_estTimeToSS+integration_estTimeToSS,assumedSpecificCap,dv,"cpRepsEsVcTemp_seal")		WAVE/D cpRepsEsVcTemp_seal		Double respCap = cpRepsEsVcTemp_resp[%avg]		Double respSEM = cpRepsEsVcTemp_resp[%SEM]		Double respSD = cpRepsEsVcTemp_resp[%sdev]		Double sealCap = cpRepsEsVcTemp_seal[%avg]		Double sealSEM = cpRepsEsVcTemp_seal[%SEM]		Double sealSD = cpRepsEsVcTemp_seal[%sdev]			//wavestats		respSealCapDiff=respCap-sealCap		respSealCapDiffSEM=sqrt(respSEM^2 + sealSEM^2)		respSealCapDiffSD=sqrt(respSD^2 + sealSD^2)	else		duplicate/o cpRepsEsVcTemp_resp,cpRepsEsVcTemp_seal		//use as placeholder	endif		String capRepAppendStr="ECR"		//for ES cap reps	String respCapRepAppendStr=capRepAppendStr+"r"+"_"	String sealCapRepAppendStr=capRepAppendStr+"c"+"_"	String sealSubCapRepAppendStr=capRepAppendStr+"s"+"_"		dl_appendToLbls(cpRepsEsVcTemp_resp,0,respCapRepAppendStr,1,0,inf)	dl_appendToLbls(cpRepsEsVcTemp_seal,0,sealCapRepAppendStr,1,0,inf)		Variable numParams_CapRepDiff = 3,i	make/o/d/n=(numParams_CapRepDiff) EsCapRepDiffParamsTemp	i=0;dl_assignAndLbl(EsCapRepDiffParamsTemp, i, respSealCapDiff, sealSubCapRepAppendStr+"respSealCapDiff")	i+=1;dl_assignAndLbl(EsCapRepDiffParamsTemp, i, respSealCapDiffSEM, sealSubCapRepAppendStr+"respSealCapDiffSEM")	i+=1;dl_assignAndLbl(EsCapRepDiffParamsTemp, i, respSealCapDiffSD, sealSubCapRepAppendStr+"respSealCapDiffSD")	concatenate/np=0/dl {cpRepsEsVcTemp_resp,cpRepsEsVcTemp_seal},EsCapRepDiffParamsTemp		dl_appendToLbls($EsVcParams_noSealSub,0,"n_",1,0,inf)	dl_appendToLbls($EsVcParams_sealSub,0,"s_",1,0,inf)	concatenate/o/dl/np=0 {EsCapRepDiffParamsTemp,cpRepsEsVcTemp_resp,cpRepsEsVcTemp_seal,$EsVcParams_noSealSub,$EsVcParams_sealSub},$outRef	refList_resp+="hasSeal:"+num2str(hasSeal)+";EsVcParams:"+outRef+";"	refList_resp+="sealSubbedRespRef:"+sealSubbedRespRef+";sealSubbedRespSEMRef:"+sealSubbedRespSEMRef+";"	refList_resp+="prevExps_nw:"+prevExps_nw+";prevExps_w:"+prevExps_w+";outExpRef_nw:"+outExpRef_nw+";outExpRef_w:"+outExpRef_w+";"		wave savenw=$outExpRef_nw	print/D "outExpRef_nw",savenw	wave savew=$outExpRef_w	print/D "outExpRef_w",savew		//store previous for next use	duplicate/o $outExpRef_nw,$prevExps_nw	duplicate/o $outExpRef_w,$prevExps_w		return refList_respend	//analysis_cellParams_ES_VC()//calculate basic parameters for a step excised and normalized by step_exciseAndNorm_avgI()function/s analysis_cellParams_ES_basic(refList)		//refList has keys as returned by step_exciseAndNorm_avgI	String refList			//windows to analyze--window SIZE is as sit by baseline avg size for step_exciseAndNorm_avgI()	String resWinStartXs=".005;.0075;.01;.0125;.015;.02;.03;.05;.075;.1;.125;.15;.175;.2;.3;.4;.5;.75;1;"	String thresholdProps=".005;.01;.05;.1;.2;0.25;"+num2str((1/exp(1)))+";0.5;"	Variable resWinStartXForThresh=2	//which resWin to use for threshold calculations		variable numResParams = 10,numThreshParams=5,numOtherParams=15	variable numResWins = itemsinlist(resWinStartXs)	variable totalNumResParams = numResWins*numResParams	Variable numBelowHalfThresholds=itemsinlist(thresholdProps)	Variable numAboveHalfThresholds=numBelowHalfThresholds		//going to make all have a mirror above half (1-below half threshold)	Variable totalNumThresholds=numBelowHalfThresholds+numAboveHalfThresholds	Variable totalNumThreshParams=totalNumThresholds*numThreshParams	Variable totalNumNewParams=numOtherParams+totalNumResParams+totalNumThreshParams		variable step_startx=0	Variable thresholdSearchLenX = 0.25 //limit search to e.g 250 ms	variable i	for (i=0;i<numBelowHalfThresholds;i+=1)	//calculate 1-threshold too		thresholdProps+=num2str(1-str2num(stringfromlist(i,thresholdProps))) + ";"	endfor	String paramsRef = stringbykey("outref_params",refList)	String baseName = stringbykey("outRef_base",refList)	String esBasicParams = basename + "_pesb"	//params ES basic	WAVE/D params=$paramsRef		//average params across sweeps, with each column for each distinct step in an epoch .. not weighted	variable numInputParams = dimsize(params,0)	Variable reps=dimsize(params,1)	Variable weightsRow=FindDimLabel(params, 0, "weight" )	matrixop/o/free weights = subRange(params,weightsRow,weightsRow,0,reps-1)	matrixtranspose weights;redimension/n=(-1) weights	String outref_canonical_w = stringbykey("outref_canonical_w",refList)	WAVE/D weightedstatsWv = $outref_canonical_w	Variable avgCol=finddimlabel(weightedstatsWv,1,"avg")	matrixop/o/free resp=col(weightedstatsWv,avgCol)	redimension/n=(-1) resp	setscale/p x,dimoffset(weightedstatsWv,0),dimdelta(weightedstatsWv,0),WaveUnits(weightedstatsWv,0),resp		//get parameters for all steps (the "grand" parameters)	Matrixop/o/free scaledParams = scaleCols(params,weights)	Double weightsum = sum(weights)	make/o/d/n=1 $esBasicParams/wave=out	matrixop/o out = sumrows(params)/weightSum		//calculate weighted average params	dl_lblsToLbls(paramsRef,0,0,inf,nameofwave(out),0,0,"",0)		variable avgLenX = out[%baselineSubLenX]	variable respLen_X = out[%respLen_X]	variable startx,endx,outInd	double avg,res_respDivStim,avg_inv,threshMaxVal,outMinusIn_frac,inMinusOut_frac,outMinusIn,inMinusOut	Double avg_nonNorm, avg_inv_nonNorm	redimension/n=(numInputParams+totalNumNewParams) out	string dls="esb_"		//dim label start	String dla	//dim label append string	Double dv=params[%cmd_range][0]	for (i=0;i<numResWins;i+=1)		startx = str2num(stringfromlist(i,resWinStartXs))		endx = startx + avgLenX		if (endx> respLen_X)			avg=nan;avg_inv=nan;			else			avg = mean(resp,startx,endx)	//RESP IS ALREADY baseline subtracted (so delta from zero) NORMALIZED BY DIVIDING BY THE STIMULUS, so this is CONDUCTANCE for VC			avg_inv = 1/avg			avg_nonNorm *= dv			//back to raw average current for VC			avg_inv_nonNorm = 1 / avg_nonNorm			//inverse current for what it's worth		endif 		outMinusIn_frac = avg - 1		//kind of a fractional change		inMinusOut_frac = 1 - avg		outMinusIn = outMinusIn_frac * dv		//return to absolute values, useful for Iclamp		inMinusOut = inMinusOut_frac * dv				dla = "_" + num2str(i)		outInd = numInputParams +numOtherParams + i*numResParams	//update numResParams if this changes		outInd+=0;out[outInd]=startx;setdimlabel 0,outInd,$(dls+"startx"+dla),out		outInd+=1;out[outInd]=endx;setdimlabel 0,outInd,$(dls+"endx"+dla),out		outInd+=1;out[outInd]=avg;setdimlabel 0,outInd,$(dls+"avg"+dla),out					//for VC, equiv to SS conductance because voltage command has been divded out		outInd+=1;out[outInd]=avg_inv;setdimlabel 0,outInd,$(dls+"avg_inv"+dla),out		//for VC, equiv to SS current		outInd+=1;out[outInd]=avg_nonNorm;setdimlabel 0,outInd,$(dls+"avg_nonNorm"+dla),out		outInd+=1;out[outInd]=avg_inv_nonNorm;setdimlabel 0,outInd,$(dls+"avg_inv_nonNorm"+dla),out		outInd+=1;out[outInd]=outMinusIn_frac;setdimlabel 0,outInd,$(dls+"outMinusIn_frac"+dla),out		outInd+=1;out[outInd]=inMinusOut_frac;setdimlabel 0,outInd,$(dls+"inMinusOut_frac"+dla),out		outInd+=1;out[outInd]=outMinusIn;setdimlabel 0,outInd,$(dls+"outMinusIn"+dla),out		outInd+=1;out[outInd]=inMinusOut;setdimlabel 0,outInd,$(dls+"inMinusOut"+dla),out				if (i==resWinStartXForThresh)			threshMaxVal = avg		endif	endfor		if (stringmatch(baseName,"*9"))		print "Blah"	endif		String threshStr; Double threshProp,thresh	Variable threshFound, threshAbsX,threshRelStepStartX	for (i=0;i<totalNumThresholds;i+=1)		threshStr = stringfromlist(i,thresholdProps)		threshProp = str2num(threshStr)		thresh = threshMaxVal * threshProp		findlevel/q/r=(step_startx,thresholdSearchLenX)/EDGE=1 resp,thresh		threshFound=!V_flag		threshAbsX=V_levelX		threshRelStepStartX=threshAbsX-step_startx				dla = "_" + num2str(i)		outInd=numInputParams+numOtherParams+totalNumResParams+i*numThreshParams	//if this changes update numThreshParams		outInd+=0;out[outInd]=threshProp;setdimlabel 0,outInd,$(dls+"threshProp"+dla),out		outInd+=1;out[outInd]=thresh;setdimlabel 0,outInd,$(dls+"thresh"+dla),out		outInd+=1;out[outInd]=threshFound;setdimlabel 0,outInd,$(dls+"threshFound"+dla),out		outInd+=1;out[outInd]=threshAbsX;setdimlabel 0,outInd,$(dls+"threshAbsX"+dla),out		outInd+=1;out[outInd]=threshRelStepStartX;setdimlabel 0,outInd,$(dls+"threshRelStepStartX"+dla),out	endfor		//assign otherparams update numOtherParams if number changes	i=numInputParams;out[i]=threshProp;setdimlabel 0,i,$(dls+"threshProp"),out	i+=1;out[i]=numInputParams;setdimlabel 0,i,$(dls+"numInputParams"),out	i+=1;out[i]=numResParams;setdimlabel 0,i,$(dls+"numResParams"),out	i+=1;out[i]=numThreshParams;setdimlabel 0,i,$(dls+"numThreshParams"),out	i+=1;out[i]=numOtherParams;setdimlabel 0,i,$(dls+"numOtherParams"),out		i+=1;out[i]=totalNumResParams;setdimlabel 0,i,$(dls+"totalNumResParams"),out	i+=1;out[i]=numBelowHalfThresholds;setdimlabel 0,i,$(dls+"numBelowHalfThresholds"),out	i+=1;out[i]=numAboveHalfThresholds;setdimlabel 0,i,$(dls+"numAboveHalfThresholds"),out	i+=1;out[i]=totalNumThresholds;setdimlabel 0,i,$(dls+"totalNumThresholds"),out	i+=1;out[i]=totalNumThreshParams;setdimlabel 0,i,$(dls+"totalNumThreshParams"),out	i+=1;out[i]=totalNumNewParams;setdimlabel 0,i,$(dls+"totalNumNewParams"),out		i+=1;out[i]=step_startx;setdimlabel 0,i,$(dls+"step_startx"),out	i+=1;out[i]=thresholdSearchLenX;setdimlabel 0,i,$(dls+"thresholdSearchLenX"),out	i+=1;out[i]=resWinStartXForThresh;setdimlabel 0,i,$(dls+"resWinStartXForThresh"),out	i+=1;out[i]=threshMaxVal;setdimlabel 0,i,$(dls+"threshMaxVal"),out	i+=1;out[i]=weightsum;setdimlabel 0,i,$(dls+"weightsum"),out		//15		return refList + "esBasicParams:"+esBasicParams+";"end//MOST UP TO 	DATE (and stream-lined) CAPACITANCE TRANSIENT ANALYSIS AS OF 2/8/18. intended for use after step_exciseAndNorm_avgI//params out order is params for unweighted (n_) and then weighted (w_) (dim labels)//NEED TO ADD BEFOREHAND THE PARAMS CALCULATED HERE!!! BUT STILL FIGURE OUT IF ORDERING OK ON OUTPUTSfunction/S analysis_cellParams_ES_VC_cap(respRef,semRef,esBasicParams,fitWinSize,outRef,n_prevExps,w_prevExps,n_outExpRef,w_outExpRef,forceMaxNumFits)	String	respRef		//a normalized baseline subtracted capacitance transient as generated by step_exciseAndNorm_avgI()	String semRef		//the SEM for that wave from step_exciseAndNorm_avgI()'s subfunction step_exciseAndNorm_avgI_g()	String esBasicParams 		//as generated by analysis_cellParams_ES_basic()	Variable fitWinSize	String outRef	Variable forceMaxNumFits		//optionally pass to limit maxNumFits .. useful for seal fits	String n_prevExps,w_prevExps //for unweighted and weighted exp fits, respectively, any previous fit coefs (as generated by analysis_cellParams_ES_VC_cf)	String n_outExpRef,w_outExpRef		//place to store output exps		Variable defaultNumFits = 4		Double assumedSpecificCap = 0.01 			//pF / um^2 conversion to F / m ^ 2: 1 F / 10^12 pF * 10^6 um / m * 10^6 um / m = x pF/um^2 = F/ m ^ 2	Variable numFits= (numtype(forceMaxNumFits) > 0) ? defaultNumFits : forceMaxNumFits	Double integration_estTimeToSS = 0.006	//estimated time to reach steady state for numerical integration of cap transient -- don't want to have Ih cut into this	Double integration_ssAvgLen = 0.001	variable resWinStartXForThresh=2	String esParamsLblForNoModelSSRin="esb_avg_inv_"+num2str(resWinStartXForThresh)	//what epoch to take SS from when not fitting	String esParamsLbLForNoModelGin="esb_avg_" + num2str(resWinStartXForThresh)	String esParamsLbLForNoModelCurr="esb_avg_nonNorm_" + num2str(resWinStartXForThresh)		WAVE/D esParams = $esBasicParams	WAVE/D resp = $respRef		Double stepStartX=0		//always true for ES (excised sweeps)	Double dv=esParams[%cmd_range] 	Variable ssRin_noModel_esParamsRow=FindDimLabel(esParams,0,esParamsLblForNoModelSSRin)	Variable Gin_noModel_esParamsRow=FindDimLabel(esParams,0,esParamsLbLForNoModelGin)	Variable current_noModel_esParamsRow=FindDimLabel(esParams,0,esParamsLbLForNoModelCurr)	Double ssRin_noModel = esParams[ssRin_noModel_esParamsRow]	Double ssConductance_noModel = esParams[Gin_noModel_esParamsRow]		//avg comes before avg_inv NOTE: this is equal to current in response to 1V input	Double ssCurrent_noModel =dv/ssRin_noModel		//or esParams[current_noModel_esParamsRow]	WaveStats/Q/R=(stepStartX,integration_estTimeToSS)	resp	//search for peak of transient, assume peak must be by the presumed steady-state time for integration analysis	Double peakLoc = V_maxloc	Double peakVal = V_max		Double accessR_noModel=1/peakVal 		//dv is 1 for the current peak val 	double memR_noModel=(1-(accessR_noModel*ssConductance_noModel))/ssConductance_noModel	//from Neher paper but note that 1=V and condutance is current in response to 1V		Double fitStartX = peakLoc	Double fitEndX = peakLoc + fitWinSize		//store parameters	Variable numParams = 20,ii	make/o/d/n=(numParams) $outRef/wave=out	ii=0;;dl_assignAndLbl(out, ii, numParams, "VCWC_START_numParams")	ii+=1;dl_assignAndLbl(out, ii, fitWinSize, "fitWinSize")	ii+=1;dl_assignAndLbl(out, ii, numFits, "numFits")	ii+=1;dl_assignAndLbl(out, ii, integration_estTimeToSS, "integration_estTimeToSS")	ii+=1;dl_assignAndLbl(out, ii, integration_ssAvgLen, "integration_ssAvgLen")		ii+=1;dl_assignAndLbl(out, ii, stepStartX, "stepStartX")	ii+=1;dl_assignAndLbl(out, ii, ssRin_noModel_esParamsRow, "ssRin_noModel_row")	ii+=1;dl_assignAndLbl(out, ii, Gin_noModel_esParamsRow, "Ginin_noModel_row")	ii+=1;dl_assignAndLbl(out, ii, ssRin_noModel, "ssRin_noModel")	ii+=1;dl_assignAndLbl(out, ii, ssConductance_noModel, "ssConductance_noModel")		ii+=1;dl_assignAndLbl(out, ii, ssCurrent_noModel, "ssCurrent_noModel")	ii+=1;dl_assignAndLbl(out, ii, peakLoc, "peakLoc")	ii+=1;dl_assignAndLbl(out, ii, peakVal, "peakVal")	ii+=1;dl_assignAndLbl(out, ii, accessR_noModel, "accessR_noModel")	ii+=1;dl_assignAndLbl(out, ii, memR_noModel, "memR_noModel")	ii+=1;dl_assignAndLbl(out, ii, fitStartX, "fitStartX")	ii+=1;dl_assignAndLbl(out, ii, fitendX, "fitendX")	ii+=1;dl_assignAndLbl(out, ii, assumedSpecificCap, "assumedSpecificCap")	ii+=1;dl_assignAndLbl(out, ii, dv, "dv")		ii+=1;dl_assignAndLbl(out, ii, nan, "VCWC_END_PARAMS_FITNEXT")	//20		//run integration time course analysis 	analysis_ES_integrateCap($respRef,semRef,fitStartX,fitStartX+integration_estTimeToSS,integration_estTimeToSS,integration_estTimeToSS+integration_ssAvgLen,assumedSpecificCap,dv,"analysis_esVcCfTemp")		dl_appendToLbls($"analysis_esVcCfTemp",0,"in_",1,0,inf)		concatenate/dl/np=0 {$"analysis_esVcCfTemp"},out		analysis_cellParams_ES_VC_cf(resp,fitStartX,fitEndX,dv,assumedSpecificCap,defaultNumFits,numFits,"analysis_esVcCfTemp",templateCoefsRef=n_prevExps,allFinalCoefsRef=n_outExpRef)//,noUserGuidance=1)	dl_appendToLbls($"analysis_esVcCfTemp",0,"n_",1,0,inf)		//n_ for no weight	concatenate/dl/np=0 {$"analysis_esVcCfTemp"},out		analysis_cellParams_ES_VC_cf(resp,fitStartX,fitEndX,dv,assumedSpecificCap,defaultNumFits,numFits,"analysis_esVcCfTemp",SEwv=$semRef,templateCoefsRef=w_prevExps,allFinalCoefsRef=w_outExpRef)//,noUserGuidance=1)		//ADD CALL WITH SEwv	dl_appendToLbls($"analysis_esVcCfTemp",0,"w_",1,0,inf)		//w_ for weight	concatenate/dl/np=0 {$"analysis_esVcCfTemp"},out			return outRef	//add capacitance transient integration based on 	analysis_capTransIntegration_lh	end	//analysis_cellParams_ES_VC_cap()function analysis_cellParams_ES_VC_cf(wv,fitStartX,fitEndX,dv,assumedSpecificCap,numFits,forceMaxNumFits,outRef,[SEwv,allFinalCoefsRef,templateCoefsRef,noUserGuidance,forceUserGuidance])		//cf for capfit	WAVE/D wv, SEwv		//latter optional standard error wave for fitting with weights.. currently needs same length as wv	Double fitStartX,fitEndX	Double dv		//voltage command size, used for calculating parameters	Variable numFits					//standard is 4	Variable forceMaxNumFits		//actual num fits computed .. use numFits to keep output parameter number constant across many fits, use this to limit actual number performed case by case	String outRef			//store all fit params	Double assumedSpecificCap //= 0.01 			//pF / um^2 conversion to F / m ^ 2: 1 F / 10^12 pF * 10^6 um / m * 10^6 um / m = x pF/um^2 = F/ m ^ 2			//these parameters are useful for implementing user-guided fitting	String allFinalCoefsRef	//pass to get a return of all final coefs, column by column	String templateCoefsRef	//pass to override autogenerated fit guesses and start with these instead -- only affects higher order (3exp+) fits for now	Variable noUserGuidance	//pass to override user guidance on higher order fit failures (3exp+)	Variable forceUserGuidance	//pass to force user guideance no matter what -- normally user guidance is only sought if an error occurs in fitting 		Variable ftest_pcrit = 0.05		Variable numFTestChiStats=16		//must agree with stats_ftestChi_simple	Variable fitStartP = x2pnt(wv,fitStartX) 	Variable fitEndP = x2pnt(wv,fitEndX)	Variable fitPnts = fitendP-fitstartP	Variable hasWeightWv	if (!ParamIsDefault(SEwv))		duplicate/o/d SEwv, weightWvTemp		hasWeightWv=1	else		duplicate/o/d wv, weightWvTemp		weightWvTemp = 1 		//equal weights		hasWeightWv=0	endif		variable/g x0=fitStartX		//for fitting procedure		variable i,j,k,numExps,nas	Double amp_sum,proportion,amp_new,tau_oldMin,tau_oldMax,tau_oldRange,tau_newMin,tau_newMax,tau_newRange,tau_new	Double ssres_sim	,ssres_cpx	Variable oldNumParams,newAmpIndex,newTauIndex,RF,V_FitError,V_fitQuitReason,numCoefs,startIndex,componentDataStartInd,compInd,ii	Double V_chisq		//residuals, or chi sq values for fitting with weight	double iSS_equivGss,ssRin,iPeak_equivGpeak,rPeak_equivRa,Rmem_tot,iSS_real,iPeak_real	double Ra_csum,q_csum,q_peak_cSum,cap_cSum,cap_peak_cSum=0,sa_cSum,sa_peak_cSum,sph_dia_cSum,sph_dia_peak_cSum	double tau_cIndex,amp_cIndex,tau_c,amp_c,Ra_c,iPeak_c,Ra_peak_c,amp_real_c,iPeak_real_c,q_c,q_peak_c,cap_c,cap_peak_c,sa_c,sa_peak_c,sph_dia_c,sph_dia_peak_c		Double Ra_c_fr,q_c_fr,q_peak_c_frcap_c_fr,cap_c_fr,cap_peak_c_fr,q_peak_c_fr	Variable f_bestModel=0, chi_bestModel = 0	String dlStart,dlComp,lblstr	//calculate the size of the output params wave -- goes in order actual wave	Variable numOverallParams = 30		//confirmed overall params		//params per fit	Variable numPreFitParams = 1	//confirmed	Variable numCoefsPerFit = 2*numFits + 1		//confirmed coefs for each fit really max / worst case .. all but highest will have fewer	Variable numNonStatsFitParams = 29			//confirmed non-stats params for each fit	//numFTestChiStats is the stats param for each fit	Variable numPostFitParams = 1	//confirmed	Variable numNonCompFitPars = numPreFitParams + numCoefsPerFit +numNonStatsFitParams +  numFTestChiStats	+numPostFitParams	Variable numParamsPerComponent = 19	//confirmed -- numParamsPerComponent per fit	Variable numComponentParamsPerFit = 	numParamsPerComponent * numFits		//again really max num components .. all but highest order will have fewer	Variable totalParamsPerFit = numNonCompFitPars + numComponentParamsPerFit	//total output params	Variable numParams = numOverallParams + totalParamsPerFit * numFits		make/o/d/n=(numParams) $outref/wave=out		//related to using and storing previous (user guided) fits	String guidedFitWinN="userGuidedMyExp"	Variable fitsAlreadyMAtch,prevCoefsToUse	Variable userGuesses=ParamIsDefault(noUserGuidance) || !noUserGuidance	Variable passedGuessCoefs=!ParamIsDefault(templateCoefsRef) && (strlen(templateCoefsRef) > 0) && waveexists($templateCoefsRef)	if (passedGuessCoefs)		WAVE/d templateCoefs=$templateCoefsRef	endif		Variable returnFinalCoefs=!Paramisdefault(allFinalCoefsRef) && (strlen(allFinalCoefsRef) > 0)	if (returnFinalCoefs )		make/o/n=(numCoefsPerFit,numFits)/d	$allFinalCoefsRef/wave=finalCoefsWv	//rows for up to max num coefs, cols for each fit	else		make/o/n=(numCoefsPerFit,numFits)/d/free finalCoefsWv	endif	for (i=0;i<numFits;i+=1)		numExps = i+1		numCoefs = 2*numExps+1		dlStart = "cf_"+num2str(i) + "_"			startIndex = numOverallParams + totalParamsPerFit * i		componentDataStartInd = startIndex+numNonCompFitPars		V_FitError=0	//set to zero so that errors are ignored for handling by us		if (numExps == 1)			make/o/d/n=(1+2*numExps) coefs;coefs=nan;make/o/d/n=1 W_fitConstants	//gets started here						if (i < forceMaxNumFits)				Curvefit/W=2/N=1/Q=1 exp_XOffset, kwCWave=coefs, wv[fitStartP, fitendP]/C=analysis_expFit_getConstaints(wv,dimsize(coefs,0),fitStartP,fitEndP)/W=weightWvTemp[fitStartP, fitendP]				ssres_cpx = V_chisq			endif		elseif (numExps == 2)			Duplicate/O coefs, coefs_last				//putting this at end instead? ssres_sim = V_chisq			Make/O/D/N=(1 + 2*numExps) coefs;coefs=nan			if (i < forceMaxNumFits)				Curvefit/W=2/N=1/Q=1 dblexp_XOffset, kwCWave=coefs, wv[fitStartP, fitendP]/C=analysis_expFit_getConstaints(wv,dimsize(coefs,0),fitStartP,fitEndP)/W=weightWvTemp[fitStartP, fitendP]			endif			ssres_cpx = V_chisq		else  //numExps > 3			if (numExps == 3)				make/o/d/n=(numexps-1) newAmps,newTaus			else				Redimension/N=(numExps-1) newAmps,newTaus			endif					Duplicate/O coefs, coefs_last		//this is already sorted fastest to slowest tau			//putting this at end instead? ssres_sim = V_chisq						oldNumParams=dimsize(coefs,0)			newAmpIndex = oldNumParams			newTauIndex = oldNumParams+1			redimension/n=(oldNumParams+2) coefs						//pick an amplitude for the new component, pretty arbitrary			prevCoefsToUse=0		//assume prev guesses arent available, then check if they are			if (passedGuessCoefs)				duplicate/o/free/d/r=[0,numCoefs-1][i] templateCoefs,lastCoefs				redimension/n=(-1) lastCoefs								if (numtype(sum(lastCoefs)) == 0)		//as long as all the values are not nan/inf in coefs, go ahead and use them					coefs=lastCoefs					prevCoefsToUse=1				else					Print "last coefs rejected!!!"				endif			endif						if (!prevCoefsToUse)							newAmps = coefs_last[1+2*p]				newTaus = coefs_last[2+2*p]				proportion = 1/numExps		//if amplitude was evenly distributed across all components, what proportion of the total would one component have?				amp_sum = sum(newAmps)				amp_new = amp_sum/numExps	//give new guess the proportion of the amplitude it would have if all parts were equal							newAmps *= (numExps-1)/numExps					//scale down the remaining amplitudes to make room for that one				coefs[1,newAmpIndex-1;2] = newAmps[(p-1)/2]	//transfer rescaled amplitudes to new coef wave (initial guesses)				coefs[newAmpIndex] = amp_new									//pick a tau for the new component, also arbitrary				tau_oldMin = newTaus[0]				tau_oldMax = newTaus[dimsize(newTaus,0)-1]				tau_oldRange = tau_oldMax-tau_oldMin				tau_newMin = tau_oldMin/2				tau_newMax = tau_oldMax*2				tau_newRange = tau_newMax-tau_newMin				tau_new = tau_newMin + tau_newRange * 0.5		//put new tau squarely in the middle				newTaus = tau_newMin + tau_newRange * ( (newTaus[p]-tau_oldMin) / tau_oldRange )		//redistribute old taus across new range in proportion to their original value				coefs[2,newTauIndex-1;2] = newTaus[(p-2)/2]				coefs[newTauIndex] = tau_new					//Print "analysis_cellparams_es_vc_cap() on wave",nameofwave(wv),"numExps",numExps						endif						if (i < forceMaxNumFits)				FuncFit/NTHR=0/W=2/N=1/Q=1 myExp, coefs, wv[fitStartP, fitendP]/C=analysis_expFit_getConstaints(wv,dimsize(coefs,0),fitStartP,fitEndP)/W=weightWvTemp[fitStartP, fitendP]						ssres_cpx = V_chisq								if (forceUserGuidance || (userGuesses && (V_FitError > 0)) )					fitsAlreadyMAtch = EqualWaves(coefs, lastCoefs ,1,1e-13) && (numtype(sum(coefs) == 0)) 	//the numtype checks that real values exist in coefs					if (!fitsAlreadyMatch)						Print "analysis_cellParams_ES_VC_cf() fit had error V_FitError=",V_fitError,"seeking user guidance (starts from original guesses)"						duplicate/o coefs,coefwave;						analysis_labelExpCoefWave(coefwave)						fit_getUserFit_main(coefwave,wv,x0,fitStartX,fitEndX,"myExp",guidedFitWinN,weightWv=weightWvTemp)						ssres_cpx = V_chisq						duplicate/o coefwave,coefs					endif				endif			endif		endif						//FOR FITS OF ANY SIZE				RF = V_FitError > 0		if (RF)			Print "analysis_cellParams_ES_VC_cf(): fit rejection. numExps=",numExps,"V_fitQuitReason",V_fitQuitReason,"V_FitError",V_FitError//," saved as",(nameofwave(wv) + "fitFail_"+num2str(i))," and follows:"			Print/d coefs		//	Duplicate/O coefs, $(nameofwave(wv) + "fitFail_"+num2str(i))		endif			analysis_sortExpCoefWave(coefs)	//rearrange coefs so that exponentials are ordered from fastest (smallest tau) to slowest		print "final coefs i==",i, coefs				iSS_equivGss = coefs[0]		//steady current of fit, normalized (and thus conductance)		ssRin = 1/iSS_equivGss			//steady resistance of fit		iPeak_equivGpeak = myExp(coefs,fitStartX)		//peak capacitance current of fit, normalized (and thus conductance)		rPeak_equivRa = 1/iPeak_equivGpeak					//access resistance of fit (resistance at peak of transient)		Rmem_tot = (1-(rPeak_equivRa*iSS_equivGss))/iSS_equivGss		//membrane resistance from simple single compartment model				iSS_real = iSS_equivGss * dv		iPeak_real = iPeak_equivGpeak * dv		Ra_csum=0;q_csum=0;q_peak_cSum=0;cap_cSum=0;cap_peak_cSum=0;sa_cSum=0;sa_peak_cSum=0;sph_dia_cSum=0;sph_dia_peak_cSum=0		for (j=0;j<numExps;j+=1)		//component analysis part 2			tau_cIndex = 2 + 2*j		//order is y0 + amp0 + tau0 + amp1 + tau1 ...			amp_cIndex = 1 + 2*j							tau_c = coefs[tau_cIndex]			amp_c = coefs[amp_cIndex]					Ra_c = 1 / amp_c; Ra_csum+=Ra_c;			iPeak_c = iSS_equivGss + amp_c			Ra_peak_c = 1 / iPeak_c						amp_real_c = amp_c * dv			iPeak_real_c = iPeak_c * dv						q_c = tau_c * amp_real_c;q_csum+=q_c		//Jonas method -- not sure if it's right to exclude the SS component though, so doing it both ways			q_peak_c = tau_c * iPeak_real_c;q_peak_cSum+=q_peak_c		//peak includes that component						cap_c = q_c / dv	;cap_cSum+=cap_c	//dv actually cancels out but leaving for clarity			cap_peak_c = q_peak_c / dv; cap_peak_cSum+= cap_peak_c						sa_c = cap_c / assumedSpecificCap;sa_cSum+=sa_c			//units of m^2 [F/ (F/m^2) = m^2]			sa_peak_c = cap_peak_c / assumedSpecificCap;sa_peak_cSum+=sa_peak_c							sph_dia_c = 2*sqrt(sa_c/4/pi)	;sph_dia_cSum+=sph_dia_c;	//surface area to sphere diameter ( from SA = 4*pi(d/2)^2 )			sph_dia_peak_c = 2*sqrt(sa_peak_c/4/pi);sph_dia_peak_cSum+=sph_dia_peak_c			endfor //end component analysis part 1						for (j=0;j<numFits;j+=1)	//component analysis part 2-- compute fractional versions -- but do for all so labels can be assigned			if (j<numExps)		//still in range for this fit							tau_cIndex = 2 + 2*j		//order is y0 + amp0 + tau0 + amp1 + tau1 ...				amp_cIndex = 1 + 2*j									tau_c = coefs[tau_cIndex]				amp_c = coefs[amp_cIndex]							Ra_c = 1 / amp_c; Ra_c_fr = Ra_c / Ra_csum				iPeak_c = iSS_equivGss + amp_c				Ra_peak_c = 1 / iPeak_c								amp_real_c = amp_c * dv				iPeak_real_c = iPeak_c * dv								q_c = tau_c * amp_real_c;q_c_fr = q_c / q_csum	//Jonas method -- not sure if it's right to exclude the SS component though, so doing it both ways				q_peak_c = tau_c * iPeak_real_c;q_peak_c_fr = q_peak_c/ q_peak_cSum	//peak includes that component								cap_c = q_c / dv	;cap_c_fr = cap_c / cap_cSum//dv actually cancels out but leaving for clarity				cap_peak_c = q_peak_c / dv; cap_peak_c_fr = cap_peak_c / cap_peak_cSum								sa_c = cap_c / assumedSpecificCap			//units of m^2 [F/ (F/m^2) = m^2]				sa_peak_c = cap_peak_c / assumedSpecificCap									sph_dia_c = 2*sqrt(sa_c/4/pi)		//surface area to sphere diameter ( from SA = 4*pi(d/2)^2 )				sph_dia_peak_c = 2*sqrt(sa_peak_c/4/pi)									nas=0			else				nas=1		//no assigning values, assign nan			endif					compInd =  componentDataStartInd + j*numParamsPerComponent			dlComp=dlStart+"co"+num2str(j) + "_"			dl_assignAndLbl(out,compInd,nas ? nan : tau_c,dlComp+"tau_c")			compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : amp_c,dlComp+"amp_c")			compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : Ra_c,dlComp+"Ra_c")			compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : iPeak_c,dlComp+"iPeak_c")			compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : Ra_peak_c,dlComp+"Ra_peak_c")						compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : amp_real_c,dlComp+"amp_real_c")			compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : iPeak_real_c,dlComp+"iPeak_real_c")			compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : q_c,dlComp+"q_c")			compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : q_peak_c,dlComp+"q_peak_c")			compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : cap_c,dlComp+"cap_c")						compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : cap_peak_c,dlComp+"cap_peak_c")			compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : sa_c,dlComp+"sa_c")			compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : sa_peak_c,dlComp+"sa_peak_c")			compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : sph_dia_peak_c,dlComp+"sph_dia_peak_c")			compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : Ra_c_fr,dlComp+"Ra_c_fr")						compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : q_c_fr,dlComp+"q_c_fr")			compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : q_peak_c_fr,dlComp+"q_peak_c_fr")			compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : cap_c_fr,dlComp+"cap_c_fr")			compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : cap_peak_c_fr,dlComp+"cap_peak_c_fr")		//19			//store all the subtotals! Including coefs!		endfor			//FOR HIGHER ORDER FITS -- test against others 		if (i>0)			//note: ssres_sim will have been appopriately set in previous iteration			stats_ftestChi_simple(ssres_sim,ssres_cpx,dimsize(coefs_last,0),dimsize(coefs,0),fitPnts,"analysis_ftestCapFitTemp",ftest_pcrit)			WAVE/D ftest = $	"analysis_ftestCapFitTemp"			//save it!			if (ftest[%f_acceptComplex])				f_bestModel = i			endif					if (ftest[%chi_acceptComplex])				chi_bestModel = i			endif		else			//get a placeholder hopefully			stats_ftestChi_simple(nan,nan,nan,nan,nan,"analysis_ftestCapFitTemp",nan)			WAVE/D ftest = $	"analysis_ftestCapFitTemp"			ftest=nan		endif				//pre-fit params spacer length stored in numPreFitParams		ii=startIndex		setdimlabel 0,ii,$(dlStart+"FITPARAMS_START"),out; out[ii]=nan				//assign and label coefs		ii=startIndex + numPreFitParams		for (k=0;k<numCoefsPerFit;k+=1)			lblstr=dlStart+"coef_"+num2str(k)+"_"			if (k==0)				lblstr+="y0"			else				if (mod(k,2))		//odd					lblstr+="amp"+num2str(floor(k/2))				else					lblstr+="tau"+num2str(floor((k-1)/2))				endif			endif			SetDimLabel 0,ii+k,$lblstr,out 			out[ii+k]=nan		//set to nan for now so only rows with actual coef values in this fit have a value		endfor		out[ii,ii+numCoefs-1] = coefs[p-ii]	//only assign the coefs that actually present for this fit			//assign and label fit-specific params	-- if #s change update numNonStatsFitParams			ii=startIndex+numPreFitParams+numCoefsPerFit					dl_assignAndLbl(out,ii,i,dlStart+"fitNum")		//if more values are added here must update numNonStatsFitParams		ii+=1;dl_assignAndLbl(out,ii,numExps,dlStart+"numExps")		ii+=1;dl_assignAndLbl(out,ii,numCoefs,dlStart+"numCoefs")		ii+=1;dl_assignAndLbl(out,ii,V_fitQuitReason,dlStart+"V_fitQuitReason")		ii+=1;dl_assignAndLbl(out,ii,V_FitError,dlStart+"V_FitError")				ii+=1;dl_assignAndLbl(out,ii,V_FitError & 2^1,dlStart+"SingularMat")		ii+=1;dl_assignAndLbl(out,ii,V_FitError & 2^2,dlStart+"OutOfMem")		ii+=1;dl_assignAndLbl(out,ii,V_FitError & 2^3,dlStart+"ReturnedNaNInf")		ii+=1;dl_assignAndLbl(out,ii,V_FitError & 2^4,dlStart+"FuncRequestedStop")		ii+=1;dl_assignAndLbl(out,ii,V_FitError & 2^5,dlStart+"ReentrantFittingS")	//second fit started during first				ii+=1;dl_assignAndLbl(out,ii,V_fitQuitReason==1,dlStart+"IterLimit")	//iteration limit		ii+=1;dl_assignAndLbl(out,ii,V_fitQuitReason==2,dlStart+"UserAbort")	//user abort		ii+=1;dl_assignAndLbl(out,ii,V_fitQuitReason==3,dlStart+"IterLimitWOChi")	//"the limit of passes without decreasing chi-square was reached"		ii+=1;dl_assignAndLbl(out,ii,iSS_equivGss,dlStart+"iSS_equivGss")		ii+=1;dl_assignAndLbl(out,ii,ssRin,dlStart+"ssRin")				ii+=1;dl_assignAndLbl(out,ii,iPeak_equivGpeak,dlStart+"iPeak_equivGpeak")		ii+=1;dl_assignAndLbl(out,ii,rPeak_equivRa,dlStart+"rPeak_equivRa")		ii+=1;dl_assignAndLbl(out,ii,Rmem_tot,dlStart+"Rmem_tot")		ii+=1;dl_assignAndLbl(out,ii,iSS_real,dlStart+"iSS_real")		ii+=1;dl_assignAndLbl(out,ii,iPeak_real,dlStart+"iPeak_real")				ii+=1;dl_assignAndLbl(out,ii,Ra_csum,dlStart+"Ra_csum")		ii+=1;dl_assignAndLbl(out,ii,q_csum,dlStart+"q_csum")		ii+=1;dl_assignAndLbl(out,ii,q_peak_cSum,dlStart+"q_peak_cSum")		ii+=1;dl_assignAndLbl(out,ii,cap_cSum,dlStart+"cap_cSum")		ii+=1;dl_assignAndLbl(out,ii,cap_peak_cSum,dlStart+"cap_peak_cSum")				ii+=1;dl_assignAndLbl(out,ii,sa_cSum,dlStart+"sa_cSum")		ii+=1;dl_assignAndLbl(out,ii,sa_peak_cSum,dlStart+"sa_peak_cSum")		ii+=1;dl_assignAndLbl(out,ii,sph_dia_cSum,dlStart+"sph_dia_cSum")		ii+=1;dl_assignAndLbl(out,ii,sph_dia_peak_cSum,dlStart+"sph_dia_peak_cSum")	//29				//assign stats		ii=startIndex+numPreFitParams+numCoefsPerFit+numNonStatsFitParams		out[ii,ii+numFTestChiStats-1] = ftest[p-ii]		dl_lblsToLbls(nameofwave(ftest),0,0,inf,nameofwave(out),0,ii,dlStart+"stats_",1)				//post-fit params spacer, length stored in numPostFitParams		ii=startIndex+numPreFitParams+numCoefsPerFit+numNonStatsFitParams+numFTestChiStats		setdimlabel 0,ii,$(dlStart+"COMPONENTPARAMS_START"),out;out[ii]=nan				//store final coefs in easily accessible format		setdimlabel 1,i,$("fit_"+num2str(i)),finalCoefsWv		finalCoefsWv[0,numcoefs-1][i] = coefs[p]		if (dimsize(finalCoefsWv,0) > numcoefs)			finalCoefsWv[numcoefs,][i] = nan		endif				ssres_sim=ssres_cpx	endfor //end fits loop		//general params start at begining of wave -- starts from 0 add more change numOverallParams	ii=0;dl_assignAndLbl(out,ii,NaN,"cf_"+"OVERALL_MULTI-EXPFIT_START")	ii+=1;dl_assignAndLbl(out,ii,assumedSpecificCap,"cf_"+"assumedSpecificCap")	ii+=1;dl_assignAndLbl(out,ii,ftest_pcrit,"cf_"+"ftest_pcrit")	ii+=1;dl_assignAndLbl(out,ii,numFTestChiStats,"cf_"+"numFTestChiStats")	ii+=1;dl_assignAndLbl(out,ii,fitStartX,"cf_"+"fitStartX")	ii+=1;dl_assignAndLbl(out,ii,fitEndX,"cf_"+"fitEndX")	ii+=1;dl_assignAndLbl(out,ii,fitStartP,"cf_"+"fitStartP")	ii+=1;dl_assignAndLbl(out,ii,fitEndP,"cf_"+"fitEndP")	ii+=1;dl_assignAndLbl(out,ii,numFits,"cf_"+"numFits")	ii+=1;dl_assignAndLbl(out,ii,fitPnts,"cf_"+"fitPnts")	ii+=1;dl_assignAndLbl(out,ii,hasWeightWv,"cf_"+"hasWeightWv")	ii+=1;dl_assignAndLbl(out,ii,x0,"cf_"+"x0")	ii+=1;dl_assignAndLbl(out,ii,numPreFitParams,"cf_"+"numPreFitParams")	ii+=1;dl_assignAndLbl(out,ii,numOverallParams,"cf_"+"numOverallParams")	ii+=1;dl_assignAndLbl(out,ii,numCoefsPerFit,"cf_"+"numCoefsPerFit")	ii+=1;dl_assignAndLbl(out,ii,numNonStatsFitParams,"cf_"+"numNonStatsFitParams")	ii+=1;dl_assignAndLbl(out,ii,numPostFitParams,"cf_"+"numPostFitParams")	ii+=1;dl_assignAndLbl(out,ii,numNonCompFitPars,"cf_"+"numNonCompFitPars")	ii+=1;dl_assignAndLbl(out,ii,numParamsPerComponent,"cf_"+"numParamsPerComponent")	ii+=1;dl_assignAndLbl(out,ii,numComponentParamsPerFit,"cf_"+"numComponentParamsPerFit")		ii+=1;dl_assignAndLbl(out,ii,totalParamsPerFit,"cf_"+"totalParamsPerFit")	ii+=1;dl_assignAndLbl(out,ii,numParams,"cf_"+"numParams")	ii+=1;dl_assignAndLbl(out,ii,f_bestModel,"cf_"+"f_bestModel")	ii+=1;dl_assignAndLbl(out,ii,chi_bestModel,"cf_"+"chi_bestModel")		//24		//add more info on best model		Variable f_bestModel_numExps = f_bestModel+1	Variable best_numCoefs = 1+2*f_bestModel_numExps	Variable best_slowTauCoefWvInd = best_numCoefs - 1	Variable best_slowAmpPos = best_numCoefs - 2	Variable best_slowTau = finalCoefsWv[best_slowTauCoefWvInd][f_bestModel]	Variable best_slowAmp = finalCoefsWv[best_slowAmpPos][f_bestModel]		ii+=1;dl_assignAndLbl(out,ii,f_bestModel_numExps,"cf_"+"f_bestModel_numExps")		//25		ii+=1;dl_assignAndLbl(out,ii,best_numCoefs,"cf_"+"best_numCoefs")	ii+=1;dl_assignAndLbl(out,ii,best_slowTauCoefWvInd,"cf_"+"best_slowTauCoefWvInd")	ii+=1;dl_assignAndLbl(out,ii,best_slowAmpPos,"cf_"+"best_slowAmpPos")	ii+=1;dl_assignAndLbl(out,ii,best_slowTau,"cf_"+"best_slowTau")	ii+=1;dl_assignAndLbl(out,ii,best_slowAmp,"cf_"+"best_slowAmp")			//30endfunction analysis_ES_integrateCapReps(allWv,weightWv,startX,endX,baselineStartX,baselineEndX,assumedSpecificCap,dv,outRef)	WAVE/D allWv			//e.g., wave containing all waves output by step_exciseAndNorm_avgI()	WAVE/D weightWv		//weight wave from step_exciseAndNorm_avgI()	Variable startX,endX	//range for integration	Variable baselineStartX,baselineEndX		//steady state current shouldn't be integrated, so choose region to measure mean and subtract. Perhaps from endX to 1 ms after would be good	Double assumedSpecificCap,dv	//assumed specific capacitance in SI units F/m^2 (equiv. pF / um2 anyway) and voltage command step size in V for calculating actual values	String outRef		Variable reps=dimsize(allWv,1)	Variable numRepsWithDupsFromWeight = sum(weightWv) * reps	make/o/d/n=(numRepsWithDupsFromWeight) allCaps	allCaps=nan		Double ssMean,cap,grandCap=0	make/o/d/n=1/free noDC_int	variable i,j,weight,averageDenominator=0,pnts,allCapsInd=0	for (i=0;i<reps;i+=1)		weight=weightWv[i]		duplicate/o/free/r=(startx,endx)[i] allWv,noDC		redimension/n=(-1) noDC		ssMean=mean(noDC,baselineStartX,baselineEndX)		noDC-=ssMean		integrate/t noDC/D=noDC_int		if (i==0)			pnts=dimsize(noDC_int,0)		endif		cap = noDC[pnts-1]		allCaps[allCapsInd,allCapsInd+weight-1] = cap		//add integer amount proportional to weight		allCapsInd += weight	endfor		wavestats/q/w allCaps	wave/D M_wavestats	duplicate/o M_wavestats,$outRef/wave=out	Redimension/n=(-1) outend//assumes transient has been normalized to a unit (1V) stepfunction/S analysis_ES_integrateCap(respWv,semRef,startX,endX,steadyStartX,steadyEndX,assumedSpecificCap,dv,outRef,[notNormalized,removeSemStats])	WAVE/D respWv			//e.g., mean column from grand average output by step_exciseAndNorm_avgI()	String semRef			//same for sem column, just pass for a rough estimate	Variable startX,endX	//range for integration	Variable steadyStartX,steadyEndX		//steady state current shouldn't be integrated, so choose region to measure mean and subtract. Perhaps from endX to 1 ms after would be good	Double assumedSpecificCap,dv	//assumed specific capacitance in SI units F/m^2 (equiv. pF / um2 anyway) and voltage command step size in V for calculating actual values	String outRef	Variable notNormalized		//optionally pass not normalized for analysis of raw data rather than normalized to 1V stimulus		Variable removeSemStats	//optionally pass to remove SEM stat rows which are otherwise included even when no semRef is passed and therefore they are returned NaN									//this will remove their rows entirely (regardless of whether semRef is passed)		Double ssMean		if (dimsize(respWv,1) < 2)		Duplicate/o/free/r=(startX,endX) respWv,noDC	else		Variable avgCol = finddimlabel(respWv,1,"avg")		duplicate/o/free/r=(startX,endX)[avgCol] respWv,noDC	endif	ssMean= mean(noDC,steadyStartX,steadyEndX)	noDC -= ssMean		//subtract SS		make/o/d/n=1 noDC_int	integrate/t noDC/D=noDC_int		variable pnts = dimsize(noDC_int,0)	Double unit_charge,charge,cap,sa_mSq,sa_umSq,sph_dia_m,sph_dia_um	Variable preNormalized=PAramIsDefault(notNormalized) || !notNormalized	if (preNormalized)		unit_charge = noDC_int[pnts-1]			charge = unit_charge * dv			cap = unit_charge		//equal to unit cap because Q=CV --> C = Q/V and V=1 for unit charge so C=Q	else		charge = noDC_int[pnts-1]			unit_charge = charge / dv		cap = unit_charge	endif		sa_mSq = cap / assumedSpecificCap		//sa in meters, since cap is in F	sa_umSq = sa_mSq * 10^12	sph_dia_m = 2*sqrt(sa_mSq/4/pi)	sph_dia_um = 2*sqrt(sa_umSq/4/pi)		//really still need to include the SEM of the average that was steady subtracted too.. though it should be small in comparison	//this is probably imperfect and not necessary	Double unit_charge_sem=nan,charge_sem=nan,cap_sem=nan,sa_mSq_sem=nan,sa_umSq_sem=nan,sph_dia_m_sem=nan,sph_dia_um_sem=nan	if (strlen(semRef))		WAVE/D semWv=$semRef		duplicate/o/free/r=(startx,endx) semWv,semWvIntReg		matrixop/o/free unit_charge_semWv = sqrt(sumSqr(semWvIntReg)))	//based on added independent errors..may not be right and only doing to compare to direct measurement trace by trace		unit_charge_sem = unit_charge_semWv[0]		charge_sem = unit_charge_sem * dv		//multiplication ok		cap_sem = unit_charge_sem		sa_mSq_sem = cap_sem / assumedSpecificCap		//multiplication ok		sa_umSq_sem = sa_mSq_sem * 10^12				//multiplication ok		sph_dia_m_sem = 2*sqrt(sa_umSq_sem/4/pi)		//multiplication ok, sqrt is more complicated would have to translate e.g. an estimate on wikipedia		sph_dia_um_sem = 2*sqrt(sph_dia_m_sem/4/pi)	endif		Variable returnSemParams = ParamIsdefault(removeSemStats) || !removeSemStats	Variable numNonSemParams = 16	Variable numSemParams = 7	Variable numParams= numNonSemParams + (returnSemParams ? numSemParams : 0),ii	make/o/d/n=(numPArams) $outref/wave=out	ii=0;dl_assignAndLbl(out, ii, numParams, "INTCAPSTART_numParams")		ii+=1;;dl_assignAndLbl(out, ii, startX, "startX")	ii+=1;dl_assignAndLbl(out, ii, endX, "endX")	ii+=1;dl_assignAndLbl(out, ii, steadyStartX, "steadyStartX")	ii+=1;dl_assignAndLbl(out, ii, steadyEndX, "steadyEndX")		ii+=1;dl_assignAndLbl(out, ii, assumedSpecificCap, "assumedSpecificCap")	ii+=1;dl_assignAndLbl(out, ii, dv, "dv")	ii+=1;dl_assignAndLbl(out, ii, ssMean, "ssMean")	ii+=1;dl_assignAndLbl(out, ii, pnts, "pnts")	ii+=1;dl_assignAndLbl(out, ii, unit_charge, "unit_charge")		ii+=1;dl_assignAndLbl(out, ii, charge, "charge")	ii+=1;dl_assignAndLbl(out, ii, cap, "cap")	ii+=1;dl_assignAndLbl(out, ii, sa_mSq, "sa_mSq")	ii+=1;dl_assignAndLbl(out, ii, sa_umSq, "sa_umSq")	ii+=1;dl_assignAndLbl(out, ii, sph_dia_m, "sph_dia_m")		ii+=1;dl_assignAndLbl(out, ii, sph_dia_um, "sph_dia_um")	//16		if (returnSemParams)		ii+=1;dl_assignAndLbl(out, ii, unit_charge_sem, "unit_charge_sem")		ii+=1;dl_assignAndLbl(out, ii, charge_sem, "charge_sem")		ii+=1;dl_assignAndLbl(out, ii, cap_sem, "cap_sem")		ii+=1;dl_assignAndLbl(out, ii, sa_mSq_sem, "sa_mSq_sem")				ii+=1;dl_assignAndLbl(out, ii, sa_umSq_sem, "sa_umSq_sem")		ii+=1;dl_assignAndLbl(out, ii, sph_dia_m_sem, "sph_dia_m_sem")		ii+=1;dl_assignAndLbl(out, ii, sph_dia_um_sem, "sph_dia_um_sem")	//23	endif		return outRefendfunction/S list_allStrings_fromKeyedList(list,itemsNotKeys)	String list	Variable itemsNotKeys		//0 returns keys, 1 returns items		variable i,num=itemsinlist(list); string out="",temp	for (i=0;i<num;i+=1)		temp = stringfromlist(i,list)		out+=stringfromlist(itemsNotKeys,temp,":")+";"	endfor		return outendfunction/s list_keepOrRemoveWaves(list,removeNotKeep)	String list	Variable removeNotKeep		//1 to return the list after removing any valid wave references, 0 to return the list after removing anything that is not a valid wave ref	String out ="",ref	String waves = wavelist("*",";","")	variable i,num=itemsinlist(list),isWv	if (removeNotKeep)	//remove		for (i=0;i<num;i+=1)			ref=stringfromlist(i,list)			isWv = WhichListItem(ref, waves) >=0			if (!isWv)				out+= ref +";"			endif		endfor	else		//keep		for (i=0;i<num;i+=1)			ref=stringfromlist(i,list)			isWv = WhichListItem(ref, waves) >=0			if (isWv)				out+= ref +";"			endif		endfor	endif		return outend//ADD THRESHOLD CROSSING LEVELS TO BASIC ES PARAMS//Based on analysis_cellParams_ic -- calculate params for IC step responses recor//SS change already calculated .. mostly need single, double, triple fits//thresholds and relative levels analyzed in esBasicPAramsfunction/s analysis_icParams_ES(baseName,refList_ic)	String baseName,refList_ic		string esBasicParams = stringbykey("esBasicParams",refList_ic)	WAVE/D esParams = $esBasicParams	String outRef_grandAvg = stringbykey("outRef_grandAvg",refList_ic)	WAVE/D/Z grandAvg = $outRef_grandAvg	if (!WaveExists(GrandAvg))		print "FAILURE grandAvg not found!!! outRef_grandAvg",outRef_grandAvg,"baseName",baseName,"refList_ic",refList_ic	endif	Variable offset=dimoffset(grandAvg,0),delta=dimdelta(grandAvg,0)	Variable avgCol = FindDimLabel(grandAvg, 1, "avg" )	Variable semCol = FindDimLabel(grandAvg, 1, "sem" )	matrixop/o/free cp_ic_avgTemp = col(grandAvg,avgCol)	matrixop/o/free cp_ic_semTemp = col(grandAvg,semCol)			setscale/p x,offset,delta,"s",cp_ic_avgTemp,cp_ic_semTemp		String icPAramsRef = baseName + "_ip"		//ic params		Variable expFitLenX=0.01	Variable numExpFits=3	Variable resWinStartXForThresh=2	//what window of ssRin measure from esBasic to use	Variable propNumForLinearFitStart=2	//what proportion number from esBasic params to use in relative line and exp fit starts	VAriable propNumForLinearFitEnd=3	String esParamsLblForNoModelInvAvg="esb_avg_inv_" + num2str(resWinStartXForThresh)	//what epoch to take SS from when not fitting	String esParamsLbLForNoModelAvg="esb_avg_" + num2str(resWinStartXForThresh)	String esPAramsLblForPropSt="esb_threshProp_"+num2str(propNumForLinearFitStart)	String esPAramsLblForThreshStX="esb_threshAbsX_"+num2str(propNumForLinearFitStart)	String esPAramsLblForPropEnd="esb_threshProp_"+num2str(propNumForLinearFitEnd)	String esPAramsLblForThreshEndX="esb_threshAbsX_"+num2str(propNumForLinearFitEnd)			Double stepStartX=0,baseline_Mean=0		//always true for ES (excised sweeps)	Variable invAvg_noModel_esParamsRow=FindDimLabel(esParams,0,esParamsLblForNoModelInvAvg)	Variable avg_noModel_esParamsRow=FindDimLabel(esParams,0,esParamsLbLForNoModelAvg)		//same as average current over the level	Variable esPAramsLblForPropStRow=FindDimLabel(esParams,0,esPAramsLblForPropSt)	Variable esPAramsLblForThreshStXRow=FindDimLabel(esParams,0,esPAramsLblForThreshStX)	Variable esPAramsLblForPropEndRow=FindDimLabel(esParams,0,esPAramsLblForPropEnd)	Variable esPAramsLblForThreshEndXRow=FindDimLabel(esParams,0,esPAramsLblForThreshEndX)	Double invAvg=esParams[invAvg_noModel_esParamsRow]	Double avg=esParams[avg_noModel_esParamsRow]	Double threshPropSt=esParams[esPAramsLblForPropStRow]	Double threshAbsStX=esParams[esPAramsLblForThreshStXRow]	Double threshPropEnd=esParams[esPAramsLblForPropEndRow]	Double threshAbsEndX=esParams[esPAramsLblForThreshEndXRow]				//start and end time for linear fit (lFit) at absolute time from t0--fit a line to the rising phase and extrapolate back to baseline crossing		//for fixed time after t0	Variable lFitStartDelayX_fixed = 0.0003		Variable lFitLenX_fixed = 0.001	Double lFitStartX_fixed = stepStartX + lFitStartDelayX_fixed				//thresholdTimes_peakToBase_Rise[lineStartProp]	Double lFitEndX_fixed = lFitStartX_fixed + lFitLenX_fixed			// thresholdTimes_peakToBase_Rise[lineEndProp]		analysis_fitRisingPhaseLine(cp_ic_avgTemp,lFitStartX_fixed,lFitEndX_fixed,baseline_mean,stepStartX,"cp_ic_line_fixed_temp",0, "",0)	WAVE/D cp_ic_line_fixed_temp	dl_replaceLblSubstring("line_","fln_",cp_ic_line_fixed_temp,0,0,inf)		//fln == fixed line fit		Print "threshAbsStX",threshAbsStX,"threshAbsEndX",threshAbsEndX	analysis_fitRisingPhaseLine(cp_ic_avgTemp,threshAbsStX,threshAbsEndX,baseline_mean,stepStartX,"cp_ic_line_prop_temp",0,"",0)		WAVE/D cp_ic_line_prop_temp	dl_replaceLblSubstring("line_","pln_",cp_ic_line_prop_temp,0,0,inf)		//pln == proportional line fit	//fit weighted and unweighted		Variable expFitEndX=stepStartX + expFitLenX	Double dv=esparams[%cmd_range]	analysis_multiExp(cp_ic_avgTemp,stepStartX,expFitEndX,dv,numExpFits,"cp_ic_exp_ufit_temp")	WAVE/D cp_ic_exp_ufit_temp	dl_replaceLblSubstring("uf_","cf_",cp_ic_exp_ufit_temp,0,0,inf)		//uf unweighted fit		analysis_multiExp(cp_ic_avgTemp,stepStartX,expFitEndX,dv,numExpFits,"cp_ic_exp_wfit_temp",SeWv=cp_ic_semTemp)	WAVE/D cp_ic_exp_wfit_temp	dl_replaceLblSubstring("wf_","cf_",cp_ic_exp_wfit_temp,0,0,inf)		//wf weighted fit		Variable numParams=15,ii	make/o/d/n=(numParams) $icPAramsRef/wave=out	ii=0;dl_assignAndLbl(out, ii, expFitLenX, "expFitLenX")	ii+=1;dl_assignAndLbl(out, ii, numExpFits, "numExpFits")	ii+=1;dl_assignAndLbl(out, ii, resWinStartXForThresh, "resWinStartXForThresh")	ii+=1;dl_assignAndLbl(out, ii, propNumForLinearFitStart, "propNumForLinearFitStart")	ii+=1;dl_assignAndLbl(out, ii, propNumForLinearFitEnd, "propNumForLinearFitEnd")		ii+=1;dl_assignAndLbl(out, ii, stepStartX, "stepStartX")	ii+=1;dl_assignAndLbl(out, ii, baseline_Mean, "baseline_Mean")	ii+=1;dl_assignAndLbl(out, ii, threshPropSt, "threshPropSt")	ii+=1;dl_assignAndLbl(out, ii, threshAbsStX, "threshAbsStX")	ii+=1;dl_assignAndLbl(out, ii, threshPropEnd, "threshPropEnd")		ii+=1;dl_assignAndLbl(out, ii, threshAbsEndX, "threshAbsEndX")	ii+=1;dl_assignAndLbl(out, ii, lFitStartDelayX_fixed, "lFitStartDelayX_fixed")	ii+=1;dl_assignAndLbl(out, ii, lFitLenX_fixed, "lFitLenX_fixed")	ii+=1;dl_assignAndLbl(out, ii, lFitStartX_fixed, "lFitStartX_fixed")	ii+=1;dl_assignAndLbl(out, ii, lFitEndX_fixed, "lFitEndX_fixed")	//15		concatenate/dl/np=0 {cp_ic_line_fixed_temp,cp_ic_line_prop_temp,cp_ic_exp_ufit_temp,cp_ic_exp_wfit_temp},out		return "icParamsRef:"+icParamsRef+";"end	//analysis_icParams_ES()function analysis_multiExp(wv,fitStartX,fitEndX,dv,numFits,outRef,[SEwv])		WAVE/D wv, SEwv		//latter optional standard error wave for fitting with weights.. currently needs same length as wv	Double fitStartX,fitEndX	Double dv		//voltage command size, used for calculating parameters	Variable numFits	String outRef			//store all fit params		String labelPreAppendStr="cf_"		Variable ftest_pcrit = 0.05		Variable numFTestChiStats=16		//must agree with stats_ftestChi_simple	Variable fitStartP = x2pnt(wv,fitStartX)	Variable fitEndP = x2pnt(wv,fitEndX)	Variable fitPnts = fitendP-fitstartP	Variable hasWeightWv	if (!ParamIsDefault(SEwv))		duplicate/o/d SEwv, weightWvTemp		hasWeightWv=1	else		duplicate/o/d wv, weightWvTemp		weightWvTemp = 1 		//equal weights		hasWeightWv=0	endif		variable/g x0=fitStartX		//for fitting procedure		variable i,j,k,numExps,nas	Double amp_sum,proportion,amp_new,tau_oldMin,tau_oldMax,tau_oldRange,tau_newMin,tau_newMax,tau_newRange,tau_new	Double ssres_sim	,ssres_cpx	Variable oldNumParams,newAmpIndex,newTauIndex,RF,V_FitError,V_fitQuitReason,numCoefs,startIndex,componentDataStartInd,compInd,ii	Double V_chisq		//residuals, or chi sq values for fitting with weight	Variable f_bestModel=0, chi_bestModel = 0	String dlStart,dlComp,lblstr	//calculate the size of the output params wave -- goes in order actual wave	Variable numOverallParams = 23		//confirmed overall params		//params per fit	Variable numPreFitParams = 1	//confirmed	Variable numCoefsPerFit = 2*numFits + 1		//confirmed coefs for each fit really max / worst case .. all but highest will have fewer	Variable numNonStatsFitParams = 13			//confirmed non-stats params for each fit	//numFTestChiStats is the stats param for each fit	Variable numPostFitParams = 1	//confirmed	Variable numNonCompFitPars = numPreFitParams + numCoefsPerFit +numNonStatsFitParams +  numFTestChiStats	+numPostFitParams	Variable numParamsPerComponent = 0	//at present zero, but if params per component (other than exponential params) would be liked, add. see analysis_cellParams_ES_VC_cf	Variable numComponentParamsPerFit = 	numParamsPerComponent * numFits		//again really max num components .. all but highest order will have fewer	Variable totalParamsPerFit = numNonCompFitPars + numComponentParamsPerFit	//total output params	Variable numParams = numOverallParams + totalParamsPerFit * numFits		make/o/d/n=(numParams) $outref/wave=out	for (i=0;i<numFits;i+=1)		numExps = i+1		dlStart = labelPreAppendStr+num2str(i) + "_"			startIndex = numOverallParams + totalParamsPerFit * i		componentDataStartInd = startIndex+numNonCompFitPars		V_FitError=0	//set to zero so that errors are ignored for handling by us		if (numExps == 1)			make/o/d/n=(1+2*numExps) coefs;coefs=nan;make/o/d/n=1 W_fitConstants	//gets started here						Curvefit/W=2/N=1/Q=1 exp_XOffset, kwCWave=coefs, wv[fitStartP, fitendP]/C=analysis_expFit_getConstaints(wv,dimsize(coefs,0),fitStartP,fitEndP)/W=weightWvTemp[fitStartP, fitendP]		elseif (numExps == 2)			Duplicate/O coefs, coefs_last				ssres_sim = V_chisq			Make/O/D/N=(1 + 2*numExps) coefs;coefs=nan			Curvefit/W=2/N=1/Q=1 dblexp_XOffset, kwCWave=coefs, wv[fitStartP, fitendP]/C=analysis_expFit_getConstaints(wv,dimsize(coefs,0),fitStartP,fitEndP)/W=weightWvTemp[fitStartP, fitendP]			ssres_cpx = V_chisq		else  //numExps > 3			if (numExps == 3)				make/o/d/n=(numexps-1) newAmps,newTaus			else				Redimension/N=(numExps-1) newAmps,newTaus			endif					Duplicate/O coefs, coefs_last		//this is already sorted fastest to slowest tau			ssres_sim = V_chisq						oldNumParams=dimsize(coefs,0)			newAmpIndex = oldNumParams			newTauIndex = oldNumParams+1			redimension/n=(oldNumParams+2) coefs						//pick an amplitude for the new component, pretty arbitrary			newAmps = coefs_last[1+2*p]			newTaus = coefs_last[2+2*p]			proportion = 1/numExps		//if amplitude was evenly distributed across all components, what proportion of the total would one component have?			amp_sum = sum(newAmps)			amp_new = amp_sum/numExps	//give new guess the proportion of the amplitude it would have if all parts were equal						newAmps *= (numExps-1)/numExps					//scale down the remaining amplitudes to make room for that one			coefs[1,newAmpIndex-1;2] = newAmps[(p-1)/2]	//transfer rescaled amplitudes to new coef wave (initial guesses)			coefs[newAmpIndex] = amp_new							//pick a tau for the new component, also arbitrary			tau_oldMin = newTaus[0]			tau_oldMax = newTaus[dimsize(newTaus,0)-1]			tau_oldRange = tau_oldMax-tau_oldMin			tau_newMin = tau_oldMin/2			tau_newMax = tau_oldMax*2			tau_newRange = tau_newMax-tau_newMin			tau_new = tau_newMin + tau_newRange * 0.5		//put new tau squarely in the middle			newTaus = tau_newMin + tau_newRange * ( (newTaus[p]-tau_oldMin) / tau_oldRange )		//redistribute old taus across new range in proportion to their original value			coefs[2,newTauIndex-1;2] = newTaus[(p-2)/2]			coefs[newTauIndex] = tau_new				//Print "analysis_cellparams_es_vc_cap() on wave",nameofwave(wv),"numExps",numExps						FuncFit/NTHR=0/W=2/N=1/Q=1 myExp, coefs, wv[fitStartP, fitendP]/C=analysis_expFit_getConstaints(wv,dimsize(coefs,0),fitStartP,fitEndP)/W=weightWvTemp[fitStartP, fitendP]					ssres_cpx = V_chisq		endif						//FOR FITS OF ANY SIZE				RF = V_FitError > 0		if (RF)			Print "analysis_multiExp(): fit rejection. numExps=",numExps,"V_fitQuitReason",V_fitQuitReason,"V_FitError",V_FitError//," saved as",(nameofwave(wv) + "fitFail_"+num2str(i))," and follows:"			Print/d coefs		//	Duplicate/O coefs, $(nameofwave(wv) + "fitFail_"+num2str(i))		endif			analysis_sortExpCoefWave(coefs)	//rearrange coefs so that exponentials are ordered from fastest (smallest tau) to slowest		numCoefs = DimSize(coefs,0)				//FOR HIGHER ORDER FITS -- test against others		if (i>0)			stats_ftestChi_simple(ssres_sim,ssres_cpx,dimsize(coefs_last,0),dimsize(coefs,0),fitPnts,"analysis_ftestCapFitTemp",ftest_pcrit)			WAVE/D ftest = $	"analysis_ftestCapFitTemp"			//save it!			if (ftest[%f_acceptComplex])				f_bestModel = i			endif					if (ftest[%chi_acceptComplex])				chi_bestModel = i			endif		else			//get a placeholder hopefully			stats_ftestChi_simple(nan,nan,nan,nan,nan,"analysis_ftestCapFitTemp",nan)			WAVE/D ftest = $	"analysis_ftestCapFitTemp"			ftest=nan		endif				//pre-fit params spacer length stored in numPreFitParams		ii=startIndex		setdimlabel 0,ii,$(dlStart+"FITPARAMS_START"),out				//assign and label coefs		ii=startIndex + numPreFitParams		for (k=0;k<numCoefsPerFit;k+=1)			lblstr=dlStart+"coef_"+num2str(k)+"_"			if (k==0)				lblstr+="y0"			else				if (mod(k,2))		//odd					lblstr=dlStart+"coef_"+"amp"+num2str(floor(k/2))				else					lblstr=dlStart+"coef_"+"tau"+num2str(floor((k-1)/2))				endif			endif			SetDimLabel 0,ii+k,$lblstr,out 		endfor				ii=startIndex + numPreFitParams		out[ii,ii+numCoefs-1] = coefs[p-ii]	//only assign the coefs that actually present for this fit			//assign and label fit-specific params	-- if #s change update numNonStatsFitParams			ii=startIndex+numPreFitParams+numCoefsPerFit			dl_assignAndLbl(out,ii,i,dlStart+"fitNum")		//if more values are added here must update numNonStatsFitParams		ii+=1;dl_assignAndLbl(out,ii,numExps,dlStart+"numExps")		ii+=1;dl_assignAndLbl(out,ii,numCoefs,dlStart+"numCoefs")		ii+=1;dl_assignAndLbl(out,ii,V_fitQuitReason,dlStart+"V_fitQuitReason")		ii+=1;dl_assignAndLbl(out,ii,V_FitError,dlStart+"V_FitError")				ii+=1;dl_assignAndLbl(out,ii,V_FitError & 2^1,dlStart+"SingularMat")		ii+=1;dl_assignAndLbl(out,ii,V_FitError & 2^2,dlStart+"OutOfMem")		ii+=1;dl_assignAndLbl(out,ii,V_FitError & 2^3,dlStart+"ReturnedNaNInf")		ii+=1;dl_assignAndLbl(out,ii,V_FitError & 2^4,dlStart+"FuncRequestedStop")		ii+=1;dl_assignAndLbl(out,ii,V_FitError & 2^5,dlStart+"ReentrantFittingS")	//second fit started during first				ii+=1;dl_assignAndLbl(out,ii,V_fitQuitReason==1,dlStart+"IterLimit")	//iteration limit		ii+=1;dl_assignAndLbl(out,ii,V_fitQuitReason==2,dlStart+"UserAbort")	//user abort		ii+=1;dl_assignAndLbl(out,ii,V_fitQuitReason==3,dlStart+"IterLimitWOChi")	//"the limit of passes without decreasing chi-square was reached"												//13 now		//assign stats		ii=startIndex+numPreFitParams+numCoefsPerFit+numNonStatsFitParams		out[ii,ii+numFTestChiStats-1] = ftest[p-ii]		dl_lblsToLbls(nameofwave(ftest),0,0,inf,nameofwave(out),0,ii,dlStart+"stats_",1)				//post-fit params spacer, length stored in numPostFitParams		ii=startIndex+numPreFitParams+numCoefsPerFit+numNonStatsFitParams+numFTestChiStats		setdimlabel 0,ii,$(dlStart+"COMPONENTPARAMS_START"),out		endfor //end fits loop		//general params start at begining of wave -- starts from 0 add more change numOverallParams	ii=0;dl_assignAndLbl(out,ii,NaN,labelPreAppendStr+"OVERALL_MULTI-EXPFIT_START")	ii+=1;dl_assignAndLbl(out,ii,ftest_pcrit,labelPreAppendStr+"ftest_pcrit")	ii+=1;dl_assignAndLbl(out,ii,numFTestChiStats,labelPreAppendStr+"numFTestChiStats")	ii+=1;dl_assignAndLbl(out,ii,fitStartX,labelPreAppendStr+"fitStartX")	ii+=1;dl_assignAndLbl(out,ii,fitEndX,labelPreAppendStr+"fitEndX")		ii+=1;dl_assignAndLbl(out,ii,fitStartP,labelPreAppendStr+"fitStartP")	ii+=1;dl_assignAndLbl(out,ii,fitEndP,labelPreAppendStr+"fitEndP")	ii+=1;dl_assignAndLbl(out,ii,numFits,labelPreAppendStr+"numFits")	ii+=1;dl_assignAndLbl(out,ii,fitPnts,labelPreAppendStr+"fitPnts")	ii+=1;dl_assignAndLbl(out,ii,hasWeightWv,labelPreAppendStr+"hasWeightWv")		ii+=1;dl_assignAndLbl(out,ii,x0,labelPreAppendStr+"x0")	ii+=1;dl_assignAndLbl(out,ii,numPreFitParams,labelPreAppendStr+"numPreFitParams")	ii+=1;dl_assignAndLbl(out,ii,numOverallParams,labelPreAppendStr+"numOverallParams")	ii+=1;dl_assignAndLbl(out,ii,numCoefsPerFit,labelPreAppendStr+"numCoefsPerFit")	ii+=1;dl_assignAndLbl(out,ii,numNonStatsFitParams,labelPreAppendStr+"numNonStatsFitParams")		ii+=1;dl_assignAndLbl(out,ii,numPostFitParams,labelPreAppendStr+"numPostFitParams")	ii+=1;dl_assignAndLbl(out,ii,numNonCompFitPars,labelPreAppendStr+"numNonCompFitPars")	ii+=1;dl_assignAndLbl(out,ii,numParamsPerComponent,labelPreAppendStr+"numParamsPerComponent")	ii+=1;dl_assignAndLbl(out,ii,numComponentParamsPerFit,labelPreAppendStr+"numComponentParamsPerFit")	ii+=1;dl_assignAndLbl(out,ii,totalParamsPerFit,labelPreAppendStr+"totalParamsPerFit")		ii+=1;dl_assignAndLbl(out,ii,numParams,labelPreAppendStr+"numParams")	ii+=1;dl_assignAndLbl(out,ii,f_bestModel,labelPreAppendStr+"f_bestModel")	ii+=1;dl_assignAndLbl(out,ii,chi_bestModel,labelPreAppendStr+"chi_bestModel")		//23end//run after analysis_ic0_simple at two locations that are in need of comparison (e.g., soma and terminal)function/s analysis_ic0_twoSite(refList_S,refList_P)			String refList_S,refList_P	//reflits generated by analysis_ic0_simple	String ac_windowKind=""		//window function for autocorrelation analysis, if any	String baseName_S = stringbykey("ic0_basename",refList_S)	//saves based on basename at soma	String ref_S = stringbykey("ic0_ref",refList_S)	String startx_s_str =  stringbykey("ic0_startx",refList_S)	String endx_s_str =  stringbykey("ic0_endx",refList_S)	Variable startx_s = str2num(startx_s_str)	Variable endx_s = str2num(endx_s_str)	STring ic0_params_S = stringbykey("ic0_params",refList_S)	String ic0_power_S = stringbykey("ic0_power",refList_S)	String ref_P = stringbykey("ic0_ref",refList_P)	String startx_P_str =  stringbykey("ic0_startx",refList_P)	String endx_P_str =  stringbykey("ic0_endx",refList_P)	Variable startx_P = str2num(startx_P_str)	Variable endx_P = str2num(endx_P_str)	STring ic0_params_P = stringbykey("ic0_params",refList_P)	String ic0_power_P = stringbykey("ic0_power",refList_P)		Variable binSizeX=str2num(stringbykey("ic0_binSizeX",refList_S))	Variable binStartSpacingX=str2num(stringbykey("ic0_binStartSpacingX",refList_S))		String ic0_2sParams = basename_S + "_i02s"		//2 site params	string ic0_power_D = basename_S + "_i0pd"		//power spectrum fold diff	string ic0_power_F = basename_S + "_i0pf"		//power spectrum fold diff	String ic0_auto = basename_S + "_i0a"			//autocorrelation (time domain)	String ic0_auto_FD = basename_S + "_i0af"			//autocorrelation frequency domain		//calculate difference waves for params and power	WAVE/D params_S = $ic0_params_S, power_S = $ic0_power_S	WAVE/D params_P = $ic0_params_P, power_P = $ic0_power_P	Duplicate/o params_S,ic0_params_D_temp,ic0_params_F_temp	Duplicate/o power_S,$ic0_power_D/wave=power_D,$ic0_power_F/wave=power_F	ic0_params_D_temp=params_p-params_s	ic0_params_F_temp=params_p/params_s	power_d=power_p-power_s	power_f=power_p/power_s			//label params	dl_appendToLbls(ic0_params_D_temp,0,"D_",1,0,inf)	dl_appendToLbls(ic0_params_F_temp,0,"F_",1,0,inf)		//calculate autocorrelation	Variable acStartX=max(startx_s,startx_P)	Variable acEndX=min(endx_s,endx_p)		analysis_avgPowerSpectraOrCross(ref_P,ic0_auto_FD,ac_windowKind,acStartX,acEndX,binSizeX,binStartSpacingX,0,subEachRep=1,inWave2Ref=ref_S,tdOutputRef=ic0_auto)	WAVE/D ic0_autoWv=$ic0_auto	analysis_autocorrelationStats(ic0_autoWv, "ic0_autoParams_temp")	WAVE ic0_autoParams_temp	dl_appendToLbls(ic0_autoParams_temp,0,"A_",1,-inf,inf)			concatenate/dl/np=0/o {ic0_params_D_temp,ic0_params_F_temp,ic0_autoParams_temp}, $ic0_2sParams		String outRefList = "ic0_2sParams:"+ic0_2sParams+";ic0_power_D:"+ic0_power_D+";ic0_power_F:"+ic0_power_F+";ic0_auto:"+ic0_auto+";ic0_auto_FD:"+ic0_auto_FD+";"		String refs=list_keepOrRemoveWaves(list_allStrings_fromKeyedList(outRefList,1),0)	wave_note(refs,outRefList,1,1)		return outRefListendfunction/S analysis_ic0_simple(ref,startx,endx,baseName)	String ref,baseName	Variable startx,endx		String windowKind=""	Variable binSizeX=1	Variable binStartSpacingX=0.3		String ic0_params = baseName + "_i0"	String ic0_power = baseName + "_i0p"	String ic0_mag = baseName + "_i0m"	duplicate/o/r=(startx,endx) $ref, ic0_simple_temp		wavestats/q/w ic0_simple_temp	WAVE/d M_wavestats	duplicate/o M_wavestats, $ic0_params/wave=params	Variable origNumPArams = dimsize(params,0)		analysis_avgPowerSpectraOrCross("ic0_simple_temp",ic0_power,windowKind,startX,endX,binSizeX,binStartSpacingX,0,subEachRep=1)	Duplicate/o $ic0_power,$ic0_mag/wave=mag	mag = sqrt(mag)		ic0_simple_temp-=V_avg	String myCorr3ParamsRefs="paramsOutRef:"+ic0_params+";stimFromWinNDCSN:;respWaveNoDC:ic0_simple_temp;filter_TD:;respPower_FD:"+ic0_power+";filterPhase_FD:;filter_TDSN:;"	myCorr3ParamsRefs+="filterMag_FDSN:"+ic0_mag+";"	wn_myCorr3Params_v2("",keyedRefList=myCorr3ParamsRefs,skipFilter=1,skipPhase=1)		String outRefList="ic0_params:"+ic0_params+";ic0_power:"+ic0_power+";ic0_baseName:"+baseName+";ic0_ref:"+ref+";ic0_startx:"+num2str(startx)+";ic0_endx:"+num2str(endx)+";"	outrefList+="ic0_binSizeX:"+num2str(binSizeX)+";ic0_binStartSpacingX:"+num2str(binStartSpacingX)+";ic0_windowKind:"+windowKind+";"		String refs=list_keepOrRemoveWaves(list_allStrings_fromKeyedList(outRefList,1),0)	wave_note(refs,outRefList,1,1)		return outrefListendfunction simpleBaselineAvg(list,bsx,bse,outRef)	String list,outRef	Variable bsx,bse		variable i,num=itemsinlist(list)	Double avgBaseline = 0,avg	string ref=stringfromlist(0,list)	Duplicate/o $ref,$outRef/wave=out	out=0	for (i=0;i<num;i+=1)		ref=stringfromlist(i,list)		duplicate/o/free $ref, wvtemp		avg=mean(wvtemp,bsx,bse)		avgBaseline+=avg		wvtemp-=avg		out+=wvTemp	endfor	out/=num	avgBaseline/=1	print/d "avgBaseline",avgBaseline	note/nocr out, "simpleBaselineAvg_avgBaseline:"+num2str(avgBaseline)+";avgBaseline_num:"+num2str(num)+";avgBaseline_list:"+replacestring(";",list,",")+";avgBaseline_bsx:"+num2str(bsx)+";avgBaseline_bse:"+num2str(bse)+";"end//function hooktest(s)		//set to all fd displays (general puropse)//	STRUCT WMWinHookStruct &s//	//	print s.eventcode,s.eventmod//	//end//takes in a 4 color wave with dim labels//sets traces containing the dim label string to the column in that rowfunction disp_catsAndSymsToTraces(winN,catRGBWv) 	WAVE catRGBWv	//e.g. from disp_fovPer_catToRGB	String winN	//"" should default to top		String traces=TraceNameList(winN, ";", 1)		Variable i,num=dimsize(catRGBWv,0)	String lb,matchStr,matchTraces,matchTrace	Variable numMatches,j	for (i=0;i<num;i+=1)		lb=getdimlabel(catRGBWv,0,i)		matchStr="*" + lb + "*"		matchTraces=ListMatch(traces, matchStr)		numMatches=itemsinlist(matchTraces)		for (j=0;j<numMatches;j+=1)			matchTrace=stringfromlist(j,matchTraces)			Modifygraph/W=$winN rgb($matchTrace)=(catRGBWv[i][0],catRGBWv[i][1],catRGBWv[i][2],catRGBWv[i][3])		endfor	endfor	endfunction wave_removeNaNCols(wv,outref)	String outRef	WAVE wv		Variable cols=dimsize(wv,1)	Variable rows=dimsize(wv,0)	Variable noNaN,count=0,nanCount=0	Variable i	string lb,nanColList=""	duplicate/o wv, $outRef/wave=out	out=nan	for (i=0;i<cols;i+=1)		matrixop/o/free col=subWaveR(wv,0,i,rows)				if (i==0)			print dimsize(col,0),dimsize(col,1)		endif				noNaN = numtype(sum(col)) == 0		if (noNaN)			lb=getdimlabel(wv,1,i)			out[][count]=col[p][0]			SetDimLabel 1,count,$lb,out			count+=1		else			nanColList+=num2str(i)+","+lb+";"			nanCount+=1		endif	endfor		redimension/n=(-1,count) out		print "wave_removeNaNCols(): NaNCount",nanCount//,"nanColList",nanColListendfunction/WAVE wave_removeNaNRows(wv,outRef)	WAVE wv; String outRef		if (strlen(outRef)<1)		duplicate/o/free wv,out	else		duplicate/o wv,$outref/wave=out	endif		Variable i,rows=dimsize(out,0),j,cols=dimsize(out,1)	for (i=rows-1;i>=0;i-=1)		for (j=0;j<cols;j+=1)			if (numtype(wv[i][j]))				Deletepoints/M=0 i,1,out				break			endif		endfor		endfor		return outendtracing_segToMask(winN,segNum)	String winN	Variable segNum		String tracedWaveName = tracing_getTracedWvNmFromWinN(winN)	String indexWvRef = tracing_getTracingIndexWaveRef(tracedwaveName)	WAVE/T indexWv = $indexWvRef		String segName=indexWv[segNum]	endfunction tracing_fluor2D_intROI(traceWinN,fluorN,startPnt,maxCCPnt,negDir,euclidDistPix,euclidStepSizePix,outRef,micronsPerPixel,doDisplay,skipAnalysis,summaryRo,summaryCo,subrangeInfoWv,[forcedROIRef])	String traceWinN		//window with tracing..assumes ROI is being traced and autoradius has been run	String fluorN		//fluorescence trace to integrate	Variable startPnt	//pnt EXACTLY AT start of ROI .. integration will begin here, but two points need to trail behind	Variable maxCCPnt	//last point allowed..doesnt matter if approaching from below or above numerically	Variable negDir		//can be before or ahead of startPnt	Double euclidDistPix,euclidStepSizePix	//pixel step size	String outRef		//holds results .. values for each slice, cumualtive values, average radius at slice	Double micronsPerPixel		//only used to scale outputs to pixel space	Variable doDisplay	Variable skipAnalysis	Variable summaryRo,summaryCo	//just automatically stick it in results for bookkeeping	WAVE subrangeInfoWv		//row,col for start and ro col for end of region to even consider	String forcedROIRef		//isntead of using ROI from tracing, force a different roi wave (helps avoid counting curling proximal axon segs near terminal)		String tracedWaveName = tracing_getTracedWvNmFromWinN(traceWinN)	String combinedSegRef = tracing_getCombinedSegref(tracedWaveName)	String radiusInfoRef = combinedSegRef+"_rad"	WAVE/D ccWv=$combinedSegRef	WAVE/D ccRad=$radiusInfoRef	if (!PAramIsDefault(forcedROIRef))		duplicate/o $forcedROIRef,myROIOverlayTemp0;	else		duplicate/o $tracedWAveName,myROIOverlayTemp0;	endif	redimension/n=(-1,-1) myROIOverlayTemp0	//need a copy of this, the ROI wave, to subtract counted areas to avoid double counting	duplicate/o myROIOverlayTemp0,myROIOverlayTemp1,usedROITemp	if (skipAnalysis)		wave/D out=$outRef		WAVE holderWv	else			Variable cc, step,endpnt		if (negDir)			step=-1			endpnt=0		else			step=1			endpnt=dimsize(ccwv,0)-1		endif		Variable xLocRow=FindDimLabel(ccWv, 1, "xPixLoc" )		Variable yLocRow=FindDimLabel(ccWv, 1, "yPixLoc" )		Variable radRow=FindDimLabel(ccWv, 1, "radiusPix" )		Variable mRow=finddimlabel(ccRad,1,"m")		Variable yIntRow=finddimlabel(ccRad,1,"yint")				print "xLocRow",xLocRow,"yLocRow",yLocRow,"radRow",radRow,"mRow",mRow,"yIntRow",yIntRow,"combinedSegRef",combinedSegRef,"radiusInfoRef",radiusInfoRef		Double xStart=ccwv[startPnt-2*step][xLocRow],yStart=ccwv[startPnt-2*step][yLocRow]				StartPnt+=step	//need to iterate one so that the first point is always left of the line of interest		Double xx0=ccwv[startPnt-step][xLocRow],yy0=ccwv[startPnt-step][yLocRow]	//fist iteration distance will evaluate to zero		Double m0=ccRad[startPnt-step][mRow]		Double rad0=ccwv[startPnt-step][radRow]		Double ccDeltaDist		//incremental distance from last to next ccPnt		Double ccDistToLast=0		//path length to last cc pnt		Double ccDistToNext		//path length to next cc pnt		Double intDistRelLast	//path length between last cc pnt and current loc of integration		Double intDist=0	//integrated path length so far				Duplicate/o $fluorN,$"fluor2d_intRoi_temp"/wave=sumWv,holderWv		//sumWv is the wave to sum, holderWv is a temp for calculation		Make/o/d/n=(6) paramsHolderWvTemp				Variable numSteps=floor((euclidDistPix/euclidStepSizePix))		Variable stepCount=0		make/o/d/n=(numSteps,7*2) $outRef/wave=out		SetDimLabel 1,0,fluor_avg,out		SetDimLabel 1,1,fluor_sum,out		SetDimLabel 1,2,fluor_pnts,out		SetDimLabel 1,3,fluor_var,out		SetDimLabel 1,4,fluor_min,out		SetDimLabel 1,5,fluor_max,out		SetDimLabel 1,6,rad_avg,out		dl_lblsToLbls(outRef,1,0,7,outRef,1,7,"_int",0)		setscale/p x,0,euclidStepSizePix*micronsPerPixel,"p",out			Double distToStep0=0		Double distToStop1		Double totalDist=0		Double deltaDist,xx1,yy1,rad1,m1,propPastLast,weight0,weight1		Double xAtInt,yAtInt,m_avg,yint_avg,rad_avg		Double stepDist,currDist=0			for (cc=startPnt;cc!=endpnt;cc+=step)			if (cc==maxCCPnt)				break			endif			xx1=ccwv[cc][xLocRow]			yy1=ccwv[cc][yLocRow]			rad1=ccwv[cc][radRow]			m1=ccRad[cc][mRow]			ccDeltaDist = sqrt( (xx1-xx0)^2 + (yy1-yy0)^2 )			ccDistToNext = ccDistToLast + ccDeltaDist			do 	//weight proportional to how far between each point we sit				intDistRelLast = intDist - ccDistToLast				propPastLast = intDistRelLast / ccDeltaDist				if ( (propPastLast > 1) || (stepCount >= numSteps))					break		//iterate ccPnt to get between the points that bound this intDist				endif								weight0 = 1- propPastLast		//e.g. if 25% thru this is 75%				weight1 = propPastLast			//and this is 25%, add to one								xAtInt=xx0*weight0+xx1*weight1				yAtInt=yy0*weight0+yy1*weight1				m_avg=m0*weight0 + m1*weight1					yint_avg=yAtInt-m_avg*xAtInt	//find y intercept for the line with average slope that crosses through these x,y coords				rad_avg=(rad0*weight0+rad1*weight1)*micronsPerPixel	//average radius in pixels then convert to microns								tracing_roiLineBisect(myROIOverlayTemp0,$fluorN,m_avg,yint_avg,xStart,yStart,holderWv,paramsHolderWvTemp,usedROITemp,subrangeInfoWv)				out[stepCount][0]=paramsHolderWvTemp[0]		//avearge holderWv pixels (most useful)				out[stepCount][1]=paramsHolderWvTemp[1]		//sum holderWv pixels				out[stepCount][2]=paramsHolderWvTemp[2]		//pnts holderWv pixels				out[stepCount][3]=paramsHolderWvTemp[3]		//variance holderWv pixels				out[stepCount][4]=paramsHolderWvTemp[4]		//min holderWv pixels				out[stepCount][5]=paramsHolderWvTemp[5]		//max holderWv pixels								out[stepCount][6]=rad_avg		//store average radius				//integrate cumulative for intensity and radius -- easier for calculating average				if (stepCount == 0)					out[stepCount][7,]=out[stepCount][q-7]//0				else					out[stepCount][7,]=out[stepCount-1][q]+out[stepCount][q-7]		//integrate				endif				myROIOverlayTemp0-=usedROITemp		//don't want to double count any pixels								if (stepCount == 0)					duplicate/o holderWv,myHolderTemp					redimension/n=(-1,-1,1) myHolderTemp				else					concatenate/np=2  {holderWv},myHolderTemp				endif				//print "cc",cc,"intDist",intDist,"ccDistToLast",ccDistToLast,"ccDeltaDist",ccDeltaDist,"intDistRelLast",intDistRelLast,"propPastLast",propPastLast,"weight0",weight0,"weight1",weight1,"ccDistToNext",ccDistToNext,"m0",m0,"m1",m1,"m_avg",m_avg,"yint_avg",yint_avg,"xx0",xx0,"xx1",xx1,"xAtInt",xAtInt,"yy0",yy0,"yy1",yy1,"yAtInt",yAtInt				print "cc",cc,"intDist",intDist,"ccDistToLast",ccDistToLast,"ccDeltaDist",ccDeltaDist,"intDistRelLast",intDistRelLast,"propPastLast",propPastLast,"weight0",weight0,"weight1",weight1,"ccDistToNext",ccDistToNext,"rad0",rad0,"rad1",rad1,"rad_avg",rad_avg				intDist+=euclidStepSizePix				stepCount+=1			while ( stepCount < numSteps )		//break if we reach next ccPnt or reach end of distance						if (stepCount >= numSteps)		//make sure we break out of this loop too				break			endif						//prepare for next pnt			xx0=xx1;yy0=yy1;m0=m1;rad0=rad1;ccDistToLast=ccDistToNext		endfor				if (cc == endPnt)			Print "Hit last ccPnt!!"		endif				if (stepCount != numSteps)		//finished "prematurely"			redimension/n=(stepCount-1,-1) out		endif	endif //end skip analysis		if (doDisplay)		display/k=1 out[][7]; String win=s_name; appendtograph/l=left1/w=$win out[][0]; appendtograph/r/w=$win out[][6];modifygraph/w=$win freepos=0,lblpos=50;modifygraph/w=$win freepos(left1)=40		ModifyGraph/w=$win rgb(euclid#1)=(0,0,0),rgb(euclid#2)=(1,12815,52428)		Label/w=$win right "\\K(1,12815,52428)Radius (μm)";Label/w=$win bottom "Path distance (μm)\\u#2"				newimage/k=1 myHolderTemp;win=S_name;bringtotop(win);doupdate;Execute/P/Q/Z "WMAppend3DImageSlider()";doupdate;	//use macro to append slider		appendimage/w=$win $fluorN		appendimage/w=$win myROIOverlayTemp1		make/u/i/n=(2,4)/o myScreen;myScreen=0;myscreen[0][3]=.5*2^16;myscreen[1][3]=0///black and almost opaque at values of zero and black but transparent at values of 1		ModifyImage/w=$win myROIOverlayTemp1 cindex= myScreen		ModifyImage/w=$win myHolderTemp minRGB=NaN,maxRGB=NaN, ctab= {1,2201,Red,0}		//ReorderImages/w=$win myHolderTemp,{$fluorN,$tracedWAveName}		//String cmd="ReorderImages/w="+win+" myHolderTemp,{"+fluorN+","+"myROIOverlayTemp1};ModifyImage/w="+win+"myHolderTemp minRGB=NaN,maxRGB=NaN, ctab= {1,2201,Red,0}"		//execute/p/q/z cmd		PRint "run: ","ReorderImages/w="+win+" myHolderTemp,{"+fluorN+","+"myROIOverlayTemp1};ModifyImage/w="+win+" myHolderTemp minRGB=NaN,maxRGB=NaN, ctab= {1,2201,Red,0}"	//error and doesnt all take in commands even macro somehow			endif		Variable finalStepCount=dimsize(out,0)	String paramsRef=outRef+"_P"	Variable numParams=18	make/o/d/n=(numParams) $paramsref/wave=outp	Variable pedWinStart=0, pedWinEnd=6,axWinStart=pedWinEnd, axWinEnd=8// pedWinEnd=8,axWinStart=pedWinEnd, axWinEnd=13	axWinEnd=min(finalStepCount,axWinEnd)	Variable axWinStart_P=x2pnt(out, axWinStart),axWinEnd_P=x2pnt(out, axWinEnd),pedWinStart_P=x2pnt(out, pedWinStart),pedWinEnd_P=x2pnt(out, pedWinEnd)		matrixop/o/free region=subrange(out,pedWinStart_P,pedWinEnd_P,0,0)		//average fluorescence	Double pedFluor_avg=mean(region)	Variable pedWin_pnts=dimsize(region,0)	matrixop/o/free region=subrange(out,pedWinStart_P,pedWinEnd_P,6,6)		//average fluorescence	Double pedRad_avg=mean(region)	Double pedMin=wavemin(region)	Double pedMax=wavemax(region)	matrixop/o/free region=subrange(out,axWinStart_P,axWinEnd_P,0,0)		//average fluorescence	Double axFluor_avg=mean(region)	Variable axWin_pnts=dimsize(region,0)	matrixop/o/free region=subrange(out,axWinStart_P,axWinEnd_P,6,6)		//average fluorescence	Double axRad_avg=mean(region)	Double axMin=wavemin(region)	Double axMax=wavemax(region)		Variable ii	ii=0;dl_assignAndLbl(outp, ii, axWinStart, "axWinStart")	ii+=1;dl_assignAndLbl(outp, ii, axWinEnd, "axWinEnd")	ii+=1;dl_assignAndLbl(outp, ii, axWinStart_P, "axWinStart_P")	ii+=1;dl_assignAndLbl(outp, ii, axWinEnd_P, "axWinEnd_P")	ii+=1;dl_assignAndLbl(outp, ii, pedWinStart, "pedWinStart")		ii+=1;dl_assignAndLbl(outp, ii, pedWinEnd, "pedWinEnd")	ii+=1;dl_assignAndLbl(outp, ii, pedWinStart_P, "pedWinStart_P")	ii+=1;dl_assignAndLbl(outp, ii, pedWinEnd_P, "pedWinEnd_P")	ii+=1;dl_assignAndLbl(outp, ii, pedWin_pnts, "pedWin_pnts")	ii+=1;dl_assignAndLbl(outp, ii, pedFluor_avg, "pedFluor_avg")		ii+=1;dl_assignAndLbl(outp, ii, pedRad_avg, "pedRad_avg")	ii+=1;dl_assignAndLbl(outp, ii, axWin_pnts, "axWin_pnts")	ii+=1;dl_assignAndLbl(outp, ii, axFluor_avg, "axFluor_avg")	ii+=1;dl_assignAndLbl(outp, ii, axRad_avg, "axRad_avg")		ii+=1;dl_assignAndLbl(outp, ii, pedMin, "pedMin")		ii+=1;dl_assignAndLbl(outp, ii, pedMax, "pedMax")	ii+=1;dl_assignAndLbl(outp, ii, axMin, "axMin")	ii+=1;dl_assignAndLbl(outp, ii, axMax, "axMax")//18		if (!numtype(summaryRo) && !numtype(summaryCo))		WAVE ctbp2results		ctbp2results[summaryRo][summaryCo,summaryCo+numParams-1] = outp[q-summaryCo]	endif		redimension/n=4 subrangeinfowv	redimension/n=(numParams+4) outp	outp[numparams,]=subrangeinfowv[p-numparams]		if (doDisplay)		edit/k=1 outp.ld	endifend//SUGGESTED UTILITY: IF YOU WANT TO INTEGRATE ACROSS sumWV, SUBTRACT THE OUTPUT WAVE BEFORE CALLING NEXT//THAT WAY NO PIXEL IS DOUBLE COUNTEDfunction tracing_roiLineBisect(roiWv,sumWv,m,yint,px,py,holderWv,paramsWv,usedROIWave,subrangeInfoWv)	WAVE roiWv		//wave specifying region of interest as 1, non region of interest as zero	WAVE sumWv		//wave to integrate all points on side of line of px,py	Double m,yint		//line equation	Double px,py			//position of a point on the side of the line to keep	WAVE holderWv		//for looping, ideally pre-isntantiate	WAVE/d paramsWv		//for looping, ideally pre-instantiated	WAVE usedROIWave	WAVE subrangeInfoWv		//row,col for start and ro col for end of region to even consider		Variable startCol,startRow	Variable endCol,endRow	if (dimsize(subrangeinfowv,0) < 4)		startRow=0		startCol=0		endRow=dimsize(roiWv,0)-1		endCol=dimsize(roiWv,1)-1	else		startRow=subrangeinfowv[0]		startCol=subrangeinfowv[1]		endRow=subrangeinfowv[2]-1		endCol=subrangeinfowv[3]-1		endif		if (!WaveExists(holderWv))		duplicate/o sumWv,holderWv;	endif	if (!waveExists(usedROIWave))		duplicate/o roiWv,usedROIWave	endif		duplicate/o/free/r=(*) holderWv,countWv		//one row long count wave	redimension/n=(-1) countWv	countWv=0		Double lineXValAtPntY = (py-yint)/m	Variable pointOnRight = lineXValAtPntY < px	Variable correctSideValue = 1	Variable wrongSideValue = 0	Variable rightValue = pointOnRight ? correctSideValue : wrongSideValue	Variable leftValue = pointOnRight ? wrongSideValue : correctSideValue	//print "pointOnRight",pointOnRight,"correctSideValue",correctSideValue,"wrongSideValue",wrongSideValue,"rightValue",rightValue,"leftValue",leftValue	Variable rows=dimsize(roiWv,0)		//rows increase along horizontal	Variable cols=dimsize(roiWv,1),yScale=dimdelta(roiWv,1)		//cols increase along vertical	variable xx=0,yy=yscale*startCol		holderWv=wrongSideValue	usedROIWave=0		variable i,j	Double currLineXValAtPntY	Double count=0,value,currCount	for (j=startCol;j<endCol;j+=1)		currLineXValAtPntY = (yy-yint)/m		countWv[startRow,endRow]= (x<currLineXValAtPntY ? leftValue : rightValue) * roiWv[p][j]		currCount=sum(countWv,startRow,endRow)		//only pay attention to points that were considered		usedROIWave[startRow,endRow][j]=countwv[p]		if (currCount>0)			holderWv[startRow,endRow][j]= countWv[p] * sumWv[p][j]// * roiWv[p][j]			count += currCount		endif				yy+=yScale	endfor		if (!WaveExists(paramsWv))		make/o/d/n=(6) paramsWv	endif			Double total=sum(holderWv)	Double avg = (count == 0) ? 0 : total/count	paramsWv[1] = total	paramsWv[0] = avg	paramsWv[2] = count	paramsWv[3] = variance(holderWv)	paramsWv[4] = wavemin(holderWv)		//THINK these are multidimensional ok if you don't care about position	paramsWv[5] = wavemax(holderWv)		return paramsWv[0]endfunction/S fd_annotationWin(winN,numParams,stopUpdating)	String winN	Variable numParams	Variable stopUpdating//pass true to end updates		String mainref="fda_"+winN		String fd_annotationWinList=GetUserData("filePanel", "", "fd_annotationWinList" )	if (strlen(fd_annotationWinList) < 1)		fd_annotationWinList=""	endif		//handling of stopUpdating requests	if (stopUpdating)		//simply remove window from fd_annotationWinList		fd_annotationWinList=removefromlist(winN,fd_annotationWinList)		setwindow filePanel, userdata(fd_annotationWinList)=fd_annotationWinList		return ""	endif	WAVE/T fileInfoWave		duplicate/o/r=[][2] fileInfoWave,$mainref		redimension/n=(-1,numParams+1) $mainRef		if (wintype(winN)==0)		edit/k=1/n=$winN $mainRef.ld		winN=s_name	elseif (wintype(winN) != 2)		//another window by this name that is not a table		print "fd_annotationWin(): Warning! window of name already exists, pass a new winN"		return ""		else //table already exists		if (itemsinlist(wavelist(mainref,";","WIN:"+winN)) < 1)			appendtotable/w=$winN $mainRef.ld		endif	endif			if (whichlistitem(winN,fd_annotationWinList) < 0)		fd_annotationWinList+=winN+";"		setwindow filePanel, userdata(fd_annotationWinList)=fd_annotationWinList 	endif		setwindow $winN,userdata(mainref)=mainref		return mainrefendfunction fd_annotationWinHook(s) : ListBoxControl	STRUCT WMListBoxAction &s		if (s.eventcode != 4)	//only continue for selection		return 0	endif			NVAR/Z numOfPrimaryFile		WAVE/T fileInfoWave	Variable numFiles=dimsize(fileInfoWave,0),numRows		//used to check for number of files	String mainRef		String fd_annotationWinList=GetUserData(s.win, "", "fd_annotationWinList" )	Variable num=itemsinlist(fd_annotationWinList),i,moveToRow	String winN	for (i=0;i<num;i+=1)		winN=stringfromlist(i,fd_annotationWinList)		if (winType(winN) != 2)	//must be a table			continue		endif				//check for row mismatch		mainref = GetUserData(winN,"","mainref")		numRows=dimsize($mainRef,0)		if (numRows < numFiles)			WAVE/T mainwv=$mainRef			redimension/n=(numFiles,-1) mainwv			mainwv[numRows,][%filename]=fileInfoWave[p][2]			dl_lblsToLbls("fileInfoWave",0,numRows,inf,mainRef,0,numRows,"",0)						Print "fd_annotationWinHook() increasing lengh of",mainRef		endif				moveToRow = max(numOfPrimaryFile-5,0)		//move to the fifth point from the actual row, or to zero if there arent 5 before		Modifytable/W=$winN topleftcell  = (moveToRow,0)		modifytable/W=$winN selection=(numOfPrimaryFile,0,numOfPrimaryFile,1,numOfPrimaryFile,0)	endforend//for use in conjuction with an index wave as for analysis_flash_mainfunction/S analysis_flash_main_storeData(indWv,killOptions)	WAVE/T indWv	Variable killOptions		//0 for no killing, 1 for kill if possible, 2 for kill and prompt windows containing		//list of rows in indwv to store	String lbls = "flashAvgWvs;flashFitwvs;flashRepsWvs;"		//these are the _FAs,_FFs,_FRs	Variable i,j,numLbls=itemsinlist(lbls),cols=dimsize(indwv,1)	make/o/n=(3)/free lblRows=finddimlabel(indWv,0,stringfromlist(p,lbls))		pathinfo flash_main_path	if (!V_flag)		newpath flash_main_path	endif	String list=""	for (i=0;i<cols;i+=1)		for (j=0;j<numLbls;j+=1)			list+=indwv[lblRows[j]][i]		endfor	endfor		Variable numSaves=itemsinlist(list)	String finalList="",missing="",ref	for (i=0;i<numSaves;i+=1)		ref = stringfromlist(1,stringfromlist(i,list),":")		if (!waveExists($ref))			missing+=ref+";"		endif		finalList+=ref+";"	endfor		numSaves=itemsinlist(list)		//should be unnecessary	print "analysis_flash_main_storeData() saving waves, num=",numSaves,"missing",itemsinlist(missing)	//save/b/c/o/p=flash_main_path finalList		if (killOptions)		if (killOptions==1)			killWavesByName(finalList)		elseif (killOptions==2)			killWavesByName(finalList,userPromptedWindowKilling=1)		endif	endif	return missingendfunction analysis_flash_main(indWv,startCol,numCols,startFlash,maxNumFlashes,forceRedoAvg,forceRedoFit,userGuidedFitting,icNotVc)	WAVE/T indWv	variable startCol,numCols	Variable startFlash,maxNumFlashes	Variable forceRedoAvg	//force redoing excise and averaging of light flashes (time intensive). If zero and analysis output waves exist, averaging is skipped	Variable forceRedoFit	//force fitting restart. 0 to use pre-set coefs, if any, 1 to use previous but refit, 2 to start from scratch with initial guesses	Variable userGuidedFitting			//pass true to get user guided fitting, zero to let computer work from standard guesses	Variable icNotVc			//run analysis in current clamp (ic_) not voltage clamp		Variable colWithOneFlashResp=0		//column zero or whatever is here must have one flash response		//default pulse analysis settings	Double pulseThreshold=3,pulseRises=1	Double dcSubLenX=0.005	//0.001	Double dcSubStartX=-dcSubLenX	String LP_FIR_info=	"50;1000;101;" //"200;1000;101;"	Variable loadWvOptions=1*2^0 + 0*2^1		//bitwise 0 to attempt reload, 1 to force reload	Variable killWvsAfter=0	 	String wideAppendStr="W"	String lpAppendStr="L"	String statsAppendStr = "S"	String fitAppendStr="F",fitRef		make/o/d/free/n=(4) catParams		//temporary wave for passing to flash analysis function so that all stats can be stored together	SetDimLabel 0,0,OD0,catParams	SetDimLabel 0,1,OD1,catParams	SetDimLabel 0,2,cw,catParams	SetDimLabel 0,3,fwhm,catParams		Variable col		Variable i,numFiles,j,flash,totalNumFlashes,numFlashes	String cellName	String respList,lightCmdList,cmdList,tempList,pulseSearchStartXList,pulseSearchEndXList,lpList	String firstODList,secondODList,cwList,fwhmList,flashDurList,calWvRef	String flashParamsRef,flashAvgRef,flashFitRef,flashRepRef	String forcedPulseTimesList,pulseSearchStartXListOrPulseTimesStr	Variable hasForcedPulseTimes	Double phPerUmSqPerS,prePulseAvgDur,postPulseAvgDur,avgLenX	Double firstOD,secondOD,cw,fwhm,flashDur,pulseSearchStartX	Variable coefsStartRow,savedCoefsAvailable		String las=selectstring(icNotVc,"","ic_")		//label append str, blank for vc, "ic_" for ic	string oas=selectstring(icNotVc,"","_ic")		//output append str, blank for vc		for (i=0;i<numCols;i+=1)		col=startcol+i				if (col >= dimsize(indWv,1))			break		endif				totalNumFlashes=itemsinlist(indWv[%$(las+"resps")][col])		numFlashes = min(totalNumFlashes,maxNumFlashes)		cellName=GetDimLabel(indwv, 1, col )				if (strlen(cellName) < 1)			print "analysis_flash_main() on col",col,"skipping column because cellName in column dim label is not set"			continue		endif				if (totalNumFlashes < 1)			print "skipping col",col,"no flash reps .. moves on to analysis_flash_combAndSummaryParams() which will create a mostly dummy wave"		else			print "starting col",col		endif				for (j=0;j<numFlashes;j+=1)			flash=startFlash+j			if (flash>=totalNumFlashes)				continue			endif					//items needed for generating flash avg			respList=c2sc(stringfromlist(flash,indWv[%$(las+"resps")][col]))			if (!icNotVc)	//actually not used for anything even in VC				lpList=c2sc(stringfromlist(flash,indWv[%$(las+"LPs")][col]))			endif			lightCmdList=c2sc(stringfromlist(flash,indWv[%$(las+"lightCmds")][col]))			cmdList=c2sc(stringfromlist(flash,indWv[%$(las+"cmds")][col]))			tempList=c2sc(stringfromlist(flash,indWv[%$(las+"temps")][col]))						pulseSearchStartXList=c2sc(text_stringFromList_trunc(flash,indWv[%$(las+"pulseSearchStartXs")][col]))			pulseSearchEndXList=c2sc(text_stringFromList_trunc(flash,indWv[%$(las+"pulseSearchEndXs")][col]))			forcedPulseTimesList=c2sc(text_stringFromList_trunc(flash,indWv[%$(las+"forcePulseTimes")][col]))		//see analysis_pulseTimedAvg_L optional parameter forcePulseTimingStr for a descirption. Ranges of one or more sweeps that all go into a single flash average can have their own start time			hasForcedPulseTimes=itemsinlist(forcedPulseTimesList)>0						prePulseAvgDur=str2num( text_stringFromList_trunc(flash,indWv[%$(las+"preDurs")][col]) )			postPulseAvgDur=str2num( text_stringFromList_trunc(flash,indWv[%$(las+"postDurs")][col]) )			avgLenX=prePulseAvgDur+postPulseAvgDur								//items needed for analyzing flash (sensitivity etc)			firstOD=str2num( text_stringFromList_trunc(flash,indWv[%$(las+"firstODs")][col]) )			secondOD=str2num( text_stringFromList_trunc(flash,indWv[%$(las+"secondODs")][col]) )			cw=str2num( text_stringFromList_trunc(flash,indWv[%$(las+"CWs")][col]) )			fwhm=str2num( text_stringFromList_trunc(flash,indWv[%$(las+"FWHMs")][col]) )			flashDur=str2num( text_stringFromList_trunc(flash,indWv[%$(las+"flashDurs")][col]) )			calWvRef=text_stringFromList_trunc(flash,indWv[%$(las+"calWvs")][col])							//references into which flash average and stats will be stored			flashAvgRef=cellName+oas+"_FA"+num2str(flash)		//where to store this flash avg			indWv[%$(las+"flashAvgWvs")][col]=ReplaceStringByKey(num2str(flash),indWv[%$(las+"flashAvgWvs")][col],flashAvgRef)			flashParamsRef=cellName+oas+"_FP"+num2str(flash)	//where to srore parameters for this flashAvg			indWv[%$(las+"flashParamWvs")][col]=ReplaceStringByKey(num2str(flash),indWv[%$(las+"flashParamWvs")][col],flashParamsRef)			flashFitRef=cellName+oas+"_FF"+num2str(flash)	//where to srore fit for this flashAvg			indWv[%$(las+"flashFitwvs")][col]=ReplaceStringByKey(num2str(flash),indWv[%$(las+"flashFitwvs")][col],flashFitRef)					flashRepRef=cellName+oas+"_FR"+num2str(flash)	//where to srore flash reps for this wave			indWv[%$(las+"flashRepsWvs")][col]=ReplaceStringByKey(num2str(flash),indWv[%$(las+"flashRepsWvs")][col],flashRepRef)											if (forceRedoAvg || !waveexists($flashAvgRef) || !Waveexists($flashRepRef))				if (hasForcedPulseTimes)					analysis_pulseTimedAvg_L(respList,lightCmdList,flashAvgRef,flashRepRef,pulseThreshold,pulseRises,pulseSearchStartXList,pulseSearchEndXList,prePulseAvgDur,avgLenX,dcSubStartX,dcSubLenX,LP_FIR_info=LP_FIR_info,loadWvOptions=loadWvOptions,killAfter=killWvsAfter,forcePulseTimingStr=forcedPulseTimesList)				else					analysis_pulseTimedAvg_L(respList,lightCmdList,flashAvgRef,flashRepRef,pulseThreshold,pulseRises,pulseSearchStartXList,pulseSearchEndXList,prePulseAvgDur,avgLenX,dcSubStartX,dcSubLenX,LP_FIR_info=LP_FIR_info,loadWvOptions=loadWvOptions,killAfter=killWvsAfter)				endif			endif								//get stats on flash intensity/dur/wavelength			phPerUmSqPerS=flash_getCalVal(calWvRef,cw,firstOD,secondOD)			catParams={firstOD,secondOD,cw,fwhm}								//compute additional stats, using old calculations if possible			if (WaveExists($flashParamsRef))				make/o/d/free/n=5 lastCoefs				wave lastStats=$flashParamsRef				coefsStartRow=FindDimLabel(lastStats, 0, "cone_C0" )								if (coefsStartRow < 0)					savedCoefsAvailable = 0				else					savedCoefsAvailable = 1					lastCoefs[]=lastStats[coefsStartRow+p]				endif				endif						//extract average column for analysis			Variable avgCol=FindDimLabel($flashAvgRef, 1, "avg" )			Duplicate/o/r=[][avgCol] $flashAvgRef,flashAvgTemp			redimension/n=(-1) flashAvgTemp						pulseSearchStartX=str2num(stringfromlist(0,pulseSearchStartXList))			if (icNotVc)	//at the moment no fitting, once fitting function is honed for IC can handle as for vc				analysis_flash_g("flashAvgTemp","cone_ic",0,pulseSearchStartX,flashParamsRef,flashFitRef,1,flashDur,phPerUmSqPerS,cw,userGuidedFitting,catParams=catParams)			else		//vc				if (savedCoefsAvailable && (forceRedoFit != 2) )		//two cases to handle if true:					if (forceRedoFit == 1) 	//forceRedoFit == 1, do fit but start from old fit guess						analysis_flash_g("flashAvgTemp","cone",0,pulseSearchStartX,flashParamsRef,flashFitRef,1,flashDur,phPerUmSqPerS,cw,userGuidedFitting,initguessWv=lastCoefs,catParams=catParams)					else //forceRedoFit == 0 (or something other than 1 or 2), procede without fitting						analysis_flash_g("flashAvgTemp","cone",0,pulseSearchStartX,flashParamsRef,flashFitRef,1,flashDur,phPerUmSqPerS,cw,0,initguessWv=lastCoefs,catParams=catParams,useInitGuessWv=1)					endif				else	//do a new fit either because no old coefs available or user passed forceRedoFit == 2 requesting totally new					analysis_flash_g("flashAvgTemp","cone",0,pulseSearchStartX,flashParamsRef,flashFitRef,1,flashDur,phPerUmSqPerS,cw,userGuidedFitting,catParams=catParams)				endif			endif								String noteStr="analysis_flash_g_ref:"+flashParamsRef+";analysis_flash_g_fit:"+flashFitRef+";analysis_flash_flashRef:"+flashAvgRef+";analysis_flash_repRef:"+flashRepRef+";"			notestr+="flashInfo_od0:"+num2str(firstOD)+";flashInfo_od1:"+num2str(secondOD)+";flashInfo_tOD:"+num2str(firstOD+secondOD)			notestr+=";flashInfo_wl:"+num2str(cw)+";flashInfo_fwhm:"+num2str(fwhm)+";flashInfo_durS:"+num2str(flashDur)+";flashInfo_phPerUmSq:"+num2str(phPerUmSqPerS*flashDur)+";flashInfo_phPerUmSqPerS:"+num2str(phPerUmSqPerS)+";"			note/nocr $flashAvgRef,noteStr			if (!icNotVc)				note/nocr $flashFitRef,noteStr			endif			note/nocr $flashParamsRef,noteStr			note/nocr $flashRepRef,noteStr		 		 		endfor				analysis_flash_combAndSummaryParams(indWv,col,oas,totalNumFlashes == 0 ? colWithOneFlashResp : NaN)			endfor			killwaves/Z $"flashAvgTemp"end	//analysis_flash_main//for use with analysis_flash_main() outputsfunction analysis_flash_disp(indWv,col,dispWinN,new,clearOld,icNotVc,sameLeftAx,colorOptions,plotReps,plotFits,tnsFromODs,allNoBgOrBgOnly,[forceLeftBaseName,indWvTableName])	WAVE/T indWv	String dispWinN	Variable col,new,clearOld	Variable icNotVc	Variable sameLeftAx	Variable colorOptions		//0 for all black, 1 for varied	Variable plotReps	Variable plotFits			//ignored for IC at present, fits for ic are never plotted	VAriable tnsFromODs		//pass 1 for trace names from ODs. pass 2 for trace colors unique to OD combinations 	String forceLeftBaseName		//force a base name for left axes; if sameLeftAx is passed true, then sets left ax name	Variable allNoBgOrBgOnly	//0 to plot all flash reps, 1 for those without a background only, 2 for those with a background only	String indWvTableName		//optionally pass a table name displaying the index wave to set the column selection to the currently displayed column			//currently the indWv must be the left-most wave in the table		Variable opac=0.8	Variable repOpac = 0.1	variable fitOpac=1	Variable axSpace=0	Variable labelFontSize=8	String labelFontText="\\Z" + selectString(labelFontSize > 9,"0","")+num2str(labelFontSize)	colortab2wave Rainbow16; wave M_colors; Variable cto=0,cm=16		//first color too light, use color table offset cto			Variable dispWinNamePassed = strlen(dispWinN) > 0		if (!dispWinNamePassed)		dispWinN=getdimlabel(indWv,1,col)	endif		if (new)		display/k=1/n=$dispWinN as (num2str(col)+":"+getdimlabel(indWv,1,col)+" ("+dispWinN+")")		dispWinN=S_name		modifygraph/w=$dispWinN height=72*7,width=72*6;doupdate;		modifygraph/w=$dispWinN height=0,width=0	elseif (clearOld)		vis_clearGraph(dispWinN)	endif		//for automated user change of columns	if (dispWinNamePassed)		setwindow $dispWinN, hook(analysis_flash_disp_hook)=analysis_flash_disp_hook		String callInfo=""		callInfo=replacestringbykey("indWvRef",callInfo,nameofwave(indWv))		callInfo=replacestringbykey("colStr",callInfo,num2str(col))		callInfo=replacestringbykey("dispWinN",callInfo,dispWinN)		callInfo=replacestringbykey("icNotVcStr",callInfo,num2str(icNotVc))		callInfo=replacestringbykey("sameLeftAxStr",callInfo,num2str(sameLeftAx))		callInfo=replacestringbykey("colorOptionsStr",callInfo,num2str(colorOptions))		callInfo=replacestringbykey("plotRepsStr",callInfo,num2str(plotReps))		callInfo=replacestringbykey("plotFitsStr",callInfo,num2str(plotFits))		callInfo=replacestringbykey("tnsFromODsStr",callInfo,num2str(tnsFromODs))		callInfo=replacestringbykey("allNoBgOrBgOnlyStr",callInfo,num2str(allNoBgOrBgOnly))		callInfo=replacestringbykey("forceLeftBaseName",callInfo,selectstring(ParamIsDefault(forceLeftBaseName),forceLeftBaseName,""))		callInfo=replacestringbykey("indWvTableName",callInfo,selectstring(ParamIsDefault(indWvTableName),indWvTableName,""))		setwindow $dispWinN, userdata(callInfo)=callInfo	endif		String las=selectstring(icNotVc,"","ic_")		//label append str, blank for vc "ic_" for ic		Variable j,i,numFlashes=itemsinlist(indWv[%$(las+"resps")][col]),axStart,axEnd,statsExist,ci		//ci color index	string cellName=GetDimLabel(indwv, 1, col ),totalODStr,cwStr,tagN,tn,appendedtraces,trace,tags=""	String axAppendStr,leftAxN,disp,stats,fit,reps,ns,sensStr,sensitivityList=""		//keeps list of dispWvs with their dim flash sensitivity	Variable spaceRange=(numFlashes-1)*axSpace	Variable totalAxRange=1-spaceRange	Variable axRange = totalAxRange/numFlashes	Variable firstOd,secondOD,cw,totalOD,statsExisted	String bgInfo,bgInfoStrs	Variable hasBg,numAppended,labelPos,mostSens=nan,largest=nan	Double sensitivity_raw,amp_raw,phPerUmSq,maxSens=-inf,maxAmp=-inf		Variable mayHaveBg=finddimlabel(indWv,0,"bgInfo")>=0	if (mayHaveBg)		bgInfoStrs=indWv[%bgInfo][col]	endif		//for OD coloring, check if window has previous OD color displays:	String odVals=getuserdata(dispWinN,"","odVals")	if (clearOld)		ODVals=""	endif		if (!paramIsDefault(forceLeftBaseName) && (strlen(forceLeftBaseName) < 1))		forceLeftBaseName = "left"	endif		for (j=0;j<numFlashes;j+=1)		disp=stringbykey(num2str(j),indWv[%$(las+"flashAvgWvs")][col])		if (sameLeftAx)			leftAxN=selectstring(!PAramISDefault(forceLeftBaseName),"left",forceLeftBaseName)			axStart=0			axEnd=1		else			leftAxN=selectstring(!PAramISDefault(forceLeftBaseName),"left",forceLeftBaseName)+"_"+num2str(j)			axStart = j*axRange			axend = axStart+axRange-axSpace		endif				if (WaveExists($disp))			if (allNoBgOrBgOnly > 0)			//one of the other				bgInfo=replacestring(",",stringbykey(num2str(j),bgInfoStrs),";")				hasBg=itemsinlist(bgInfo)>0				if (allNoBgOrBgOnly==1)					if (hasBg)						continue					endif				else	//==2					if (!hasBg)						continue					endif				endif			endif							ns=note($disp)			fit=stringbykey("analysis_flash_g_fit",ns)			stats=stringbykey("analysis_flash_g_ref",ns)			if (j>0)				statsExisted=statsExist			endif			statsExist=waveexists($stats) 			if (statsExist)				wave statswv=$stats			elseif (statsExisted)				print "analysis_flash_disp() stats missing for j",j			endif			reps=stringbykey("analysis_flash_repRef",ns)			if (plotReps)				appendedtraces=c2sc(stringbykey("appendedtraces",disp_columns($reps,dispWinN,0,0,leftAxN,0,inf,0,inf)))				numAppended=itemsinlist(appendedTraces)				for (i=0;i<numAppended;i+=1)					trace=stringfromlist(i,appendedTraces)					modifygraph rgb($trace)=(0,0,0,repOpac*(-1+2^16))				endfor			endif						if (tnsFromODs && statsExist)				firstOD=statsWv[%OD0]				secondOD=statsWv[%OD1]				totalOD=firstOD+secondOD				totalODStr=replacestring(".",num2str(totalOD),"p")				cwStr=replacestring(".",num2str(statsWv[%cw]),"p")				tn="CW"+cwStr+"OD"+totalODstr+selectstring(icNotVC,"","_ic_")+"avg"+num2str(j)			else				tn=disp			endif						if (colorOptions)				if ( (tnsFromODs==2) && statsExist)		//colors based on OD values					ci = whichListItem(totalODStr,odVals)					if (ci < 0)						ci=itemsinlisT(odVals)						odVals+=totalODstr+";"					endif				else					ci=j				endif				appendtograph/w=$dispWinN/l=$leftAxN/c=(M_colors[cto+mod(ci,cm)][0],M_colors[cto+mod(ci,cm)][1],M_colors[cto+mod(ci,cm)][2],opac*(-1+2^16)) $disp[][%avg]/tn=$tn			else				appendtograph/w=$dispWinN/l=$leftAxN/c=(0,0,0,opac*(-1+2^16)) $disp[][%avg]/tn=$tn			endif						if (waveexists($fit) && !icNotVc && plotFits)				appendtograph/w=$dispWinN/l=$leftAxN/c=(65535,0,52428,fitOpac*(-1+2^16)) $fit			endif			modifygraph/w=$dispWinN axisenab($leftAxN)={axStart,AxEnd}			if (statsExist && !sameLeftAx)				if (j==0)					doupdate;getaxis/q/W=$dispWinN bottom					labelPos = V_max-0.0001		//place label at the end of the axis					modifygraph/W=$dispWinN axisenab(bottom)={0,0.6}									endif				sensitivity_raw = statswv[%sensitivity_raw]				amp_raw = statswv[%flashFit_amp_raw]				phPerUmSq = statswv[%phPerUmSq]				sprintf sensStr, " \\f05%f (%2.1e) A:%2.1e",sensitivity_raw*10^12,phPerUmSq,amp_raw*10^12	//convert to pA				tagN=replacestring("avg",tn,"_")				tag/n=$tagN/b=1/f=0/c/i=0/A=LC/L=1/g=(0,0,0,39321) $tn,labelPos,labelFontText+tagN+sensStr				tags+=tagN+";"				if (sensitivity_Raw > maxSens)					maxSens=sensitivity_Raw					mostSens = j				endif				if (amp_raw > maxAmp)					maxAmp=amp_raw					largest = j				endif							endif				endif	endfor		modifygraph/w=$dispWinN freePos=0,lblpos=50	if (colorOptions && (tnsFromODs==2) && statsExist)		setwindow $dispWinN, userdata(odVals)=odVals	endif		if (numtype(mostSens)==0)		tagN = stringfromlist(mostSens,tags)		tag/n=$tagN/c/g=(0,0,65535,39321)			//most sensitive BLUE	endif	if (numtype(largest)==0)		tagN = stringfromlist(largest,tags)		tag/n=$tagN/c/g=(65535,0,0,39321)		//largest RED	endif		if (numFlashes > 0)		label/w=$dispWinN bottom , (num2str(col)+":"+getdimlabel(indWv,1,col))	endifend		function analysis_flash_disp_hook(s)	STRUCT WMWinHookStruct &s		if (s.eventcode != 11)		return 0	endif		Variable leftArrow = s.specialKeyCode == 100	Variable rightArrow = s.specialKeyCode == 101		if (!leftArrow && !rightArrow)		return 0	endif		String callInfo = getuserdata(s.winName,"","callInfo")	String indWvRef=stringbykey("indWvRef",callInfo)	Variable col=numberbykey("colStr",callInfo)	String dispWinN=stringbykey("dispWinN",callInfo)	Variable icNotVc=numberbykey("icNotVcStr",callInfo)	Variable sameLeftAx=numberbykey("sameLeftAxStr",callInfo)	Variable colorOptions=numberbykey("colorOptionsStr",callInfo)	Variable plotReps=numberbykey("plotRepsStr",callInfo)	Variable plotFits=numberbykey("plotFitsStr",callInfo)	Variable tnsFromODs=numberbykey("tnsFromODsStr",callInfo)	Variable allNoBgOrBgOnly=numberbykey("allNoBgOrBgOnlyStr",callInfo)	String forceLeftBaseName=stringbykey("forceLeftBaseName",callInfo)	String indWvTableName=stringbykey("indWvTableName",callInfo)		WAVE/T indWv=$indWvRef	Variable numCols = dimsize(indWv,1)		if (leftArrow)		col-=1		if (col < 0)			col = numCols-1		endif	endif		if (rightArrow)		col+=1		if (col >= numCols)			col = 0		endif	endif		analysis_flash_disp(indWv,col,dispWinN,0,1,icNotVc,sameLeftAx,colorOptions,plotReps,plotFits,tnsFromODs,allNoBgOrBgOnly,forceLeftBaseName=forceLeftBaseName,indWvTableName=indWvTableName)		if ((strlen(indWvTableName) > 0) && (wintype(indWvTableName) == 2) )		Variable actualTableCol=col+1	//because label counts. Remove +1 if not showing label column		modifytable selection=(0,actualTableCol,inf,actualTableCol,-1,actualTableCol),topleftcell=(-1,actualTableCol > 5 ? actualTableCol -5 : 0)///elements=(-1, (actualTableCol > 5 ? actualTableCol -5 : 0), -1, -1 )	endif		return 1end//for use with analysis_flash_main() outputsfunction/S analysis_flash_combAndSummaryParams(indWv,col,outputLabelAppendStr,getDummybyCol)	WAVE/T indWv	Variable col	STring outputLabelAppendStr		//oas in main function. differentiates vc and ic combined params wave names at present	Variable getDummybyCol				//generate a dummy wave with mostly nan data, must pass a column that has at least one flash rep		Variable doDummy = numtype(getDummybyCol) == 0	Variable origCol = col	if (doDummy)		col = getDummybyCol		//generate params by col	endif		//list any numerical parameters that can be carried over from indWv	String paramsLblsFromIndWv="highTemp;untested;indForSensitivity;indForSaturation;indForDimmestResp;minimallyResponsive;unusuallySlow;noOsOnApproach;"		Variable j,i,numFlashes=itemsinlist(indWv[%resps][col])	string paramsRef,paramsRefs="",cellName		if (doDummy)		String standInCombRef=indwv[%combinedFlashParams][col]		WAVE/D comb = $standInCombRef		cellName = GetDimLabel(indwv, 1, origCol )	else		//combined params:		for (i=0;i<numFlashes;i+=1)			paramsRef=stringbykey(num2str(i),indWv[%flashParamWvs][col])				if (waveexists($paramsRef))				paramsRefs+=paramsRef+";"			endif		endfor				cellName = GetDimLabel(indwv, 1, col )		String combinedFlashParams=cellName+outputLabelAppendStr+"_cFP"+num2str(col)		indwv[%combinedFlashParams][col]=combinedFlashParams		concatenate/D/DL/np=1/o paramsRefs,$combinedFlashParams/wave=comb	endif		//summary params:	String flashSummary=cellName+outputLabelAppendStr+"_cFS"+num2str(doDummy ? origCol : col)	indwv[%flashSummary][doDummy ? origCol : col]=flashSummary		//goals:	//for any given flash response of interest (which is held in a single column in combined wave), grab:	//all parameters as in the column and append parameters based on the cone type expected		//flash responses of interest:	//largest response	//most sensitive 544 response or leaving blue blank for now though could normalize 442, 460, and 500 activation to same as 544 for green and red cones (90% or something)	//grab parameters for response picked out as most sensitive	//same for response picked out as saturating	//same for response picked out as smallest		String indWvTypeStrs="blue;green;red;"		//types as should be typed into indWv	String receptorNames="sCone;mCone;lCone;"	//receptor names as in analysis_flash_g ORDER MUST MATCH indWvTypeStrs	String receptorName=""	String typeStr = indWv[%type_rgb][col]	Variable shouldHaveType = strlen(typeStr) > 0	Variable hasType = 0,type	if (shouldHaveType)		type = whichlistitem(typeStr,indWvTypeStrs)		if (type < 0)			print "type expected in col",col,"but does not match an expected typeStr, typo? proceeding as if no type"		else			hasType = 1			receptorName=stringfromlist(type,receptorNames)		endif	endif		String dlAppendStr	Variable numParamsPerFlash_orig = dimsize(comb,0)	Variable numParamsAddedToEachParam=2 //num params to follow, original col, 	Variable numParamsPerFlash_final = numParamsPerFlash_orig + numParamsAddedToEachParam	Variable receptorSpecificParamsStartInd		//first for max	dlAppendStr="max_"	Variable ampRow=finddimlabel(comb,0,"sensitivity_raw")	wavestats/rmd=[ampRow][]/Q comb	Variable maxCol=V_maxColLoc		duplicate/o/r=[][maxCol] comb,$flashSummary/wave=out	redimension/n=(-1) out	analysis_flash_combAndSummaryParams_appendRSpecific(out,receptorName)	if (doDummy)		out=nan //all flash values will be set to nan	endif	Variable numAddedParamsPerFlash=3	insertpoints 0,numAddedParamsPerFlash,out	dl_assignandlbl(out,0,numParamsPerFlash_final,"START_numParams")	dl_assignandlbl(out,1,maxCol,"fromCombCol")	dl_assignandlbl(out,2,1,"hasData")	dl_appendToLbls(out,0,dlAppendStr,1,0,numParamsPerFlash_final-1)			//add requested info from wave name	Variable numParamsFromIndWv=itemsinlist(paramsLblsFromIndWv)	insertpoints 0,numParamsFromIndWv,out	out[0,numParamsFromIndWv-1]=nan	String lbl	for (i=0;i<numParamsFromIndWv;i+=1)		lbl=stringfromlist(i,paramsLblsFromIndWv)		dl_assignandlbl(out,i,str2num(indwv[%$lbl][doDummy ? origCol : col]),lbl)	endfor		if (numtype(out[%highTemp])!=0)		out[%highTemp]=0	endif			//now others	String flashes="",flashAppendStrs=""		//sensivity	flashes+=indwv[%indForSensitivity][col]+";"	flashAppendStrs+="sens_"+";"		//saturation	flashes+=indwv[%indForSaturation][col]+";"	flashAppendStrs+="sat_"+";"				//dimmest	flashes+=indwv[%indForDimmestResp][col]+";"	flashAppendStrs+="dim_"+";"			Variable numAddFlashes=itemsinlist(flashes),flash,hasData	for (i=0;i<numAddFlashes;i+=1)		flash = str2num(stringfromlist(i,flashes))		dlAppendStr=stringfromlist(i,flashAppendStrs)		hasData = numtype(flash) == 0		if (doDummy)			hasDAta = 0		//all flash values will be set to nan		endif		if (hasData)			duplicate/o/free/r=[][flash] comb,temp			redimension/n=(-1) temp			analysis_flash_combAndSummaryParams_appendRSpecific(temp,receptorName)		else			duplicate/o/free/r=[][0] comb,temp			redimension/n=(-1) temp			analysis_flash_combAndSummaryParams_appendRSpecific(temp,receptorName)			temp=nan		endif		insertpoints 0,numAddedParamsPerFlash,temp		dl_assignandlbl(temp,0,numParamsPerFlash_final,"START_numParams")		dl_assignandlbl(temp,1,flash,"fromCombCol")		dl_assignandlbl(temp,2,hasData,"hasData")		dl_appendToLbls(temp,0,dlAppendStr,1,0,numParamsPerFlash_final-1)				concatenate/dl/np=0 {temp},out	endforend//returns NaN if receptor type is ""function analysis_flash_combAndSummaryParams_appendRSpecific(wv,receptorName)	WAVE wv; String receptorName		Variable returnNaNs = strlen(receptorName) < 1	if (returnNaNs)		receptorName="sCone"		//just need a dumy to find out how many to return	endif	String startAppendStr="_lambda"		//parameter that starts a receptor specific set of parameters from flash_analysis_g	String endAppendStr="_rSPerR"	Variable receptorSpecificParamsStartInd = finddimlabel(wv,0,receptorName+startAppendStr)	Variable receptorSpecificParamEndInd = finddimlabel(wv,0,receptorName+endAppendStr)		duplicate/o/free/r=[receptorSpecificParamsStartInd,receptorSpecificParamEndInd] wv,temp		//worth duplicating even when no receptor is known because we want the dimension labels	redimension/n=(-1) temp	dl_replaceLblSubstring(receptorName+"_","",temp,0,0,inf)		Variable numAdditionalParams=2	Variable numOrigParams=dimsize(temp,0)	redimension/n=(numOrigParams+numAdditionalParams) temp	setdimlabel 0,numOrigParams+0,amp_adj,temp	setdimlabel 0,numOrigParams+1,sensitivity_adj,temp	if (returnNaNs)		temp=NaN	else		//calculate adjusted amplitude and sensitivty as if flash had been at lambda max		Double relActivation = temp[%relActivation]		Double amp_adj = wv[%flashFit_amp_raw]*(1/relActivation)		Double sensitivity_adj = wv[%sensitivity_raw]*(1/relActivation)		temp[%amp_adj]=amp_adj		temp[%sensitivity_adj]=sensitivity_adj	endif	Concatenate/DL/NP=0  {temp}, wv	endfunction analysis_Flash_storeKillReps(indWv,pathStr,killEvenInWin,rowLabel)	WAVE/T indWv	String pathStr	Variable killEvenInWin		//0 to kill only non displayed, 1 to kill displayed after asking user, 2 to kill displayed windows no matter what	String rowLabel		//row label containing reps or other wave info like flash fits		if (strlen(rowLabel) < 1)		rowLabel = "flashRepsWvs"	endif	pathinfo $pathStr	if (!V_flag)		NewPath/M="Where to store file data (select same folder for loading)"/O $pathStr	endif		Variable promptUserBeforeKill = killEvenInWin < 2		Variable i,j,k,numCols=dimsize(indWv,1),numFlashes,numRepWaves	String cellName,repsList,allRepsList,repRef		for (i=0;i<numCols;i+=1)		cellName=GetDimLabel(indwv, 1, i)		allRepsList=indWv[%$rowLabel][i]		numFlashes=itemsinlist(allRepsList)				for (j=0;j<numFlashes;j+=1)			repsList=replaceString(",",stringbykey(num2str(j),allRepsList),";")			numRepWaves=itemsinlist(repsList)		//should just be one multidimension wave but just in case			for (k=0;k<numRepWaves;k+=1)				repRef=stringfromlist(k,repsList)				if(!waveExists($repRef))					continue				endif				save/c/o/p=$pathStr $repRef				if (killEvenInWin)					disp_killWinsWithWave(repRef,promptUserBeforeKill,1)				else					killwaves/z $repREf				endif			endfor		endfor	endforend//returns string from list but truncates index so if a number beyind length of list is passed, last item is returned instead of emptyfunction/s text_stringFromList_trunc(index,str)	String str	Variable index		Variable num=itemsinlist(str)		if (index >= num)		return stringfromlist(num-1,str)	elseif (index < 0)		return stringfromlist(0,str)	else		return stringfromlist(index,str)		endifend//replaced by analysis_flash_mainfunction fd_flashes(winN,actFileNamesList,settingsWv,skipSettings,forceRedoFit,userGuidedFitting,[forcePostPulseDur])	STring winN	String actFileNamesList		//pass "" to use default for each list item, ordered as fileList selections	WAVE settingsWv			//for cols 1 on, any value that differs from default	Variable skipSettings //pass to ignore settingsWv parameter and use those already in the table	Variable forceRedoFit	//force fitting restart. 0 to use pre-set coefs, if any, 1 to use previous but refit, 2 to start from scratch with initial guesses	Variable userGuidedFitting			//pass true to get user guided fitting, zero to let computer work from standard guesses	Variable forcePostPulseDur			//pass to force a post pulse dur other than 1.45 s		Make/free defaults={3,0,500,10,2.5,3,0.3,560,10,2.5,0,1,2,3,4,5}		//ends at cal wvs	String lbls="fileName;pulseSearchStartXList;pulseSearchEndXList;b0_OD0;b0_OD1;b0_cw;b0_fwhm;b0_dur;b1_OD0;b1_OD1;b1_cw;b1_fwhm;b1_dur;wide_ch;lp_ch;cmd_ch;b0_ch;b1_ch;temp_ch;b0_calWv;b1_calWv;W0_ref;W0_stats;W0_fit;L0_ref;W1_ref;L1_ref;W1_stats;W1_fit;"		String ref	if (wintype(winN) != 2)		ref=fd_annotationWin(winN,30,0)		if (wavetype($ref) < 1)			Print "fd_flashes() initialization failed! window not found."		endif				dl_assignLblsFromList($ref,1,0,lbls,"",0)	else		ref=GetUserData(winN, "", "mainref" )	endif	Variable numSettings=dimsize(defaults,0)	Variable numInputSettings=dimsize(settingsWv,0)	if (numInputSettings < numSettings)		redimension/n=(numSettings) settingsWv		settingsWv[numInputSettings,]=nan	endif	make/o/t/free/n=(numSettings) settings	settings = num2str(numtype(settingswv[p]) ? defaults[p] : settingsWv[p] )		Double postPulseDur = 1.45	//usually 1.45	if (!paramIsDefault(forcePostPulseDur) && !numtype(forcePostPulseDur))		postPulseDur=forcePostPulseDur	endif		//ref=analysis_pulseTimedAvg(gcl(0),gcl(3),"",3,1,0.002,inf,0.01,avgLenX,dcSubStartX,dcSubLenX,LP_IIR_Freq_order="500;8;");		//default pulse analysis settings	Double pulseThreshold=3,pulseTimeFromRisingPhase=1,pulseSearchStartX,pulseSearchEndX,prePulseAvgDur=0.2,avgLenX=postPulseDur+prePulseAvgDur,dcSubStartX=-0.001,dcSubLenX=0.001	//String LP_IIR_Freq_order="500;8;"	String LP_FIR_info="250;1000;101;" 	 	String wideAppendStr="W"	String lpAppendStr="L"	String statsAppendStr = "S",statsRef	String fitAppendStr="F",fitRef		make/o/d/free/n=(4) catParams		//temporary wave for passing to flash analysis function so that all stats can be stored together	SetDimLabel 0,0,OD0,catParams	SetDimLabel 0,1,OD1,catParams	SetDimLabel 0,2,cw,catParams	SetDimLabel 0,3,fwhm,catParams	WAVE fileSelListByNums	WAVE/T flashWv=$ref	Variable i,num=dimsize(fileSelListByNums,0),row	String fileName,outref,actFileName,calWvRef,noteStr,pulseSearchStartXList,pulseSearchEndXList	String wide_resps,lp_resps,b0_pulses,b1_pulses,pulseRef	Double phPerUmSqPerS,avgPulseWidth	Variable b0_ch,b1_ch,temp_ch,wide_ch,lp_ch,cmd_ch,hasWide,hasLP,hasB0,hasB1,j,numPulseRefs,pulseBaseline,pulseFound,od0,od1,cw,fwhm,coefsStartRow,savedCoefsAvailable	for (i=0;i<num;i+=1)		row=fileSelListByNums[i]		if (!skipSettings)			flashWv[row][1,numSettings]=settings[q-1]		//transfer settings		endif		actFileName=stringfromlist(i,actFileNamesList)		if (strlen(actFileName) < 1)			actFileName=text_getInfoFromWaveName_S(flashWv[row][0],9)		endif		SetDimLabel 0,row,$actFileName,flashWv		wide_ch=str2num(flashWv[row][%wide_ch])		lp_ch=str2num(flashWv[row][%lp_ch])		cmd_ch=str2num(flashWv[row][%cmd_ch])		b0_ch=str2num(flashWv[row][%b0_ch])		b1_ch=str2num(flashWv[row][%b1_ch])		temp_ch=str2num(flashWv[row][%temp_ch])		pulseSearchStartXList=flashWv[row][%pulseSearchStartXList]		pulseSearchEndXList=flashWv[row][%pulseSearchEndXList]				wide_resps=fd_getFileChanSweepNames(row, wide_ch,0);		lp_resps=fd_getFileChanSweepNames(row, lp_ch,0);		b0_pulses=fd_getFileChanSweepNames(row, b0_ch,0);		b1_pulses=fd_getFileChanSweepNames(row, b1_ch,0);				hasWide=itemsinlist(wide_resps) > 0		hasLP=itemsinlist(lp_resps) > 0				hasB0=!numtype(b0_ch) && itemsinlist(b0_pulses) > 0		hasB1=!numtype(b1_ch) && itemsinlist(b1_pulses) > 0				//pre-scan for pulses		if (hasB0)			numPulseRefs=itemsinlist(b0_pulses)			pulseFound=0			for (j=0;j<numPulseRefs;j+=1)				pulseRef=stringfromlist(j,b0_pulses)				pulseBaseline=mean($pulseRef,0,pulseSearchStartX)				FindLevel/Q/EDGE=1 $pulseRef, pulseBaseline+pulseThreshold				if (V_flag==0)					pulseFound=1					break				endif			endfor			hasB0=pulseFound		endif				if (hasB1)			numPulseRefs=itemsinlist(b1_pulses)			pulseFound=0			for (j=0;j<numPulseRefs;j+=1)				pulseRef=stringfromlist(j,b1_pulses)				pulseBaseline=mean($pulseRef,0,pulseSearchStartX)				FindLevel/Q/EDGE=1 $pulseRef, pulseBaseline+pulseThreshold				if (V_flag==0)					pulseFound=1					break				endif			endfor			hasB1=pulseFound		endif				if (hasWide)			if (hasB0)				outref=analysis_pulseTimedAvg_L(wide_resps,b0_pulses,actFileName+"W0",actFileName+"R0",pulseThreshold,pulseTimeFromRisingPhase,pulseSearchStartXList,pulseSearchEndXList,prePulseAvgDur,avgLenX,dcSubStartX,dcSubLenX,LP_FIR_info=LP_FIR_info)				flashWv[row][%W0_ref]=outRef								//WIDE RESPONSES GET ADDITIONAL ANALYSIS				statsRef=outRef+statsAppendStr				fitRef=outRef+fitAppendStr				calWvRef=flashWv[row][%b0_calWv]				cw=str2num(flashWv[row][%b0_cw])				fwhm=str2num(flashWv[row][%b0_fwhm])				od0=str2num(flashWv[row][%b0_od0])				od1=str2num(flashWv[row][%b0_od1])				if (WaveType($calWvreF) && !numtype(od0) && !numtype(od0) && !numtype(cw))					noteStr=note($outRef)					avgPulseWidth=str2num(flashWv[row][%b0_dur])*0.001					phPerUmSqPerS=flash_getCalVal(calWvRef,cw,od0,od1)				else					phPerUmSqPerS=nan				endif									catParams[0]=od0				catParams[1]=od1				catParams[2]=cw				catParams[3]=fwhm								if (WaveExists($statsRef))					make/o/d/free/n=5 lastCoefs					wave lastStats=$statsRef					coefsStartRow=FindDimLabel(lastStats, 0, "cone_C0" )					if (coefsStartRow < 0)						savedCoefsAvailable = 0					else						savedCoefsAvailable = 1						lastCoefs[]=lastStats[coefsStartRow+p]					endif				endif								if (savedCoefsAvailable && (forceRedoFit != 2) )		//two cases to handle if true:					if (forceRedoFit == 1) 	//forceRedoFit == 1, do fit but start from old fit guess						analysis_flash_g(outRef,"cone",0,pulseSearchStartX,statsRef,fitRef,1,avgPulseWidth,phPerUmSqPerS,cw,userGuidedFitting,initguessWv=lastCoefs,catParams=catParams)					else //forceRedoFit == 0 (or something other than 1 or 2), procede without fitting						analysis_flash_g(outRef,"cone",0,pulseSearchStartX,statsRef,fitRef,1,avgPulseWidth,phPerUmSqPerS,cw,0,initguessWv=lastCoefs,catParams=catParams)					endif				else	//do a new fit either because no old coefs available or user passed forceRedoFit == 2 requesting totally new					analysis_flash_g(outRef,"cone",0,pulseSearchStartX,statsRef,fitRef,1,avgPulseWidth,phPerUmSqPerS,cw,userGuidedFitting,catParams=catParams)				endif												note/nocr $outRef, "analysis_flash_g_ref:"+statsRef+";analysis_flash_g_fit:"+fitref+";"				flashWv[row][%W0_stats]=statsref				flashWv[row][%W0_fit]=fitRef			else				flashWv[row][%W0_ref]=""				flashWv[row][%W0_stats]=""				flashWv[row][%W0_fit]=""			endif						if (hasB1)				outref=analysis_pulseTimedAvg_L(wide_resps,b1_pulses,actFileName+"W1",actFileName+"R1",pulseThreshold,pulseTimeFromRisingPhase,pulseSearchStartXList,pulseSearchEndXList,prePulseAvgDur,avgLenX,dcSubStartX,dcSubLenX,LP_FIR_info=LP_FIR_info)				flashWv[row][%W1_ref]=outRef								//WIDE RESPONSES GET ADDITIONAL ANALYSIS				statsRef=outRef+statsAppendStr				fitRef=outRef+fitAppendStr				calWvRef=flashWv[row][%b1_calWv]				cw=str2num(flashWv[row][%b1_cw])				fwhm=str2num(flashWv[row][%b1_fwhm])				od0=str2num(flashWv[row][%b1_od0])				od1=str2num(flashWv[row][%b1_od1])				if (WaveType($calWvreF) && !numtype(od0) && !numtype(od0) && !numtype(cw))					noteStr=note($outRef)					avgPulseWidth=str2num(flashWv[row][%b1_dur])*0.001					phPerUmSqPerS=flash_getCalVal(calWvRef,cw,od0,od1)				else					phPerUmSqPerS=nan				endif									catParams[0]=od0				catParams[1]=od1				catParams[2]=cw				catParams[3]=fwhm								if (WaveExists($statsRef))					make/o/d/free/n=5 lastCoefs					wave lastStats=$statsRef					coefsStartRow=FindDimLabel(lastStats, 0, "cone_C0" )					if (coefsStartRow < 0)						savedCoefsAvailable = 0					else						savedCoefsAvailable = 1								lastCoefs[]=lastStats[coefsStartRow+p]					endif				endif								if (savedCoefsAvailable && (forceRedoFit != 2) )		//two cases to handle if true:					if (forceRedoFit == 1) 	//forceRedoFit == 1, do fit but start from old fit guess						analysis_flash_g(outRef,"cone",0,pulseSearchStartX,statsRef,fitRef,1,avgPulseWidth,phPerUmSqPerS,cw,userGuidedFitting,initguessWv=lastCoefs,catParams=catParams)					else //forceRedoFit == 0 (or something other than 1 or 2), procede without fitting						analysis_flash_g(outRef,"cone",0,pulseSearchStartX,statsRef,fitRef,1,avgPulseWidth,phPerUmSqPerS,cw,0,initguessWv=lastCoefs,catParams=catParams,useInitGuessWv=1)					endif				else	//do a new fit either because no old coefs available or user passed forceRedoFit == 2 requesting totally new					analysis_flash_g(outRef,"cone",0,pulseSearchStartX,statsRef,fitRef,1,avgPulseWidth,phPerUmSqPerS,cw,userGuidedFitting,catParams=catParams)				endif								note/nocr $outRef, "analysis_flash_g_ref:"+statsRef+";analysis_flash_g_fit:"+fitref+";"				flashWv[row][%W1_stats]=statsref				flashWv[row][%W1_fit]=fitRef			else				flashWv[row][%W1_ref]=""				flashWv[row][%W1_stats]=""				flashWv[row][%W1_fit]=""			endif		endif						if (hasLP)			if (hasB0)				outref=analysis_pulseTimedAvg_L(lp_resps,b0_pulses,actFileName+"L0",actFileName+"LR0",pulseThreshold,pulseTimeFromRisingPhase,pulseSearchStartXList,pulseSearchEndXList,prePulseAvgDur,avgLenX,dcSubStartX,dcSubLenX)				flashWv[row][%L0_ref]=outRef			else				flashWv[row][%L0_ref]=""			endif						if (hasB1)				outref=analysis_pulseTimedAvg_L(lp_resps,b1_pulses,actFileName+"L1",actFileName+"LR1",pulseThreshold,pulseTimeFromRisingPhase,pulseSearchStartXList,pulseSearchEndXList,prePulseAvgDur,avgLenX,dcSubStartX,dcSubLenX)				flashWv[row][%L1_ref]=outRef			else				flashWv[row][%L1_ref]=""			endif		endif			endfor		string rowsList=getuserdata(winN,"","rowsList")	//store completed rows	endfunction fd_flashes_dispSel(flashWinN,dispWinN,new,clearOld)	String flashWinN,dispWinN	Variable new,clearOld		Variable opac=0.8	variable fitOpac=0.5	Variable labelPos=0.6		if (new)		display/k=1/n=$dispWinN		dispWinN=S_name	elseif (clearOld)		vis_clearGraph(dispWinN)	endif		String ref=GetUserData(flashWinN, "", "mainref" )	WAVE fileSelListByNums	WAVE/T flashWv=$ref	Variable col_b0=FindDimLabel($ref, 1, "w0_ref"),col_b1=FindDimLabel($ref, 1, "w1_ref")	Variable i,num=dimsize(fileSelListByNums,0),row		String disp,stats,fit,ns,sensStr,sensitivityList=""		//keeps list of dispWvs with their dim flash sensitivity	colortab2wave dbz21; wave M_colors; Variable cto=1		//first color too light, use color table offset cto	String dispCols=num2str(col_b0)+";"+num2str(col_b1)+";",axAppendStr	Variable j,dispCol,numDispCols=itemsinlist(dispcols)	Variable hasB0=0,hasB1=0	for (i=0;i<num;i+=1)		row=fileSelListByNums[i]		for (j=0;j<numDispCols;j+=1)			dispCol=str2num(stringfromlist(j,dispCols))			disp=flashWv[row][dispCol]			axAppendStr="_b"+num2str(j)			if (waveexists($disp))				appendtograph/w=$dispWinN/l=$("left"+axAppendstr)/b=$("bottom"+axAppendStr)/c=(M_colors[cto+i][0],M_colors[cto+i][1],M_colors[cto+i][2],opac*2^16) $disp								ns=note($disp)				fit=stringbykey("analysis_flash_g_fit",ns)				stats=stringbykey("analysis_flash_g_ref",ns)				if (waveexists($fit))					appendtograph/w=$dispWinN/l=$("left"+axAppendstr)/b=$("bottom"+axAppendStr)/c=(0,0,0,fitOpac*2^16) $fit				endif				if (waveexists($stats))					wave statswv=$stats					sprintf sensStr, " \\f05%f (%2.1e)",statswv[%sensitivity]*10^12,	statswv[%phPerUmSq]	//convert to pA					sensitivityList+=disp+":"+sensStr+";"				endif								hasB0 = (j==0) || hasB0				hasB1 = (j==1) || hasB1			endif		endfor	endfor		Variable hasBoth = hasB0 && hasB1	String labelFontText	if (hasBoth)		setaxis/A/N=1 left_b0		setaxis/A/N=1 left_b1		ModifyGraph/w=$dispWinN axisEnab(bottom_b0)={0,0.48},axisEnab(bottom_b1)={0.52,1},freePos=0,lblpos=50		doupdate/w=$dispWinN		getaxis/w=$dispWinN/q bottom_b1;		ModifyGraph/w=$dispWinN freePos(left_b1)={V_min,bottom_b1}		disp_offsetTraces(dispWinN,"!*F",0,0,"left_b0","bottom_b0",labelPos,rideAlongAppendStr="F")		//alter range for only the actual responses (!*F match) and then translate the *Fs by same amount as their counterparts		labelFontText=disp_offsetTraces(dispWinN,"!*F",0,0,"left_b1","bottom_b1",labelPos,rideAlongAppendStr="F")		doupdate;		disp_matchAxisScaling_1win("left*",winN=dispWinN)	else		String appendStr = "_b" + num2str(hasB1)		modifygraph/w=$dispWinN freePos=0,lblpos=50		doupdate/w=$dispWinN		labelFontText=disp_offsetTraces(dispWinN,"!*F",0,0,"left"+appendStr,"bottom"+appendStr,labelPos,rideAlongAppendStr="F")		//alter range for only the actual responses (!*F match) and then translate the *Fs by same amount as their counterparts	endif		num=itemsinlist(sensitivityList)	String tn,listItem	for (i=0;i<num;i+=1)		listItem=stringfromlist(i,sensitivityList)		tn=stringfromlist(0,listItem,":")		sensStr=stringfromlist(1,listItem,":")		tag/n=$tn/b=1/f=0/l=0/c $tn,labelPos,labelFontText+tn+sensStr	endforendfunction/S flashes_getFinalSummaries(flashWv,minAmplitude,outref)	WAVE/T flashWv	Variable minAmplitude		//min amplitude to analyze flashes	String outref		if (numtype(minAmplitude))		minAmplitude = 3*10^12	endif		variable i,num=dimsize(flashWv,0)	Variable cellStartCol=FindDimLabel(flashWv, 1, "cellStartRow" )	Variable cellEndCol=FindDimLabel(flashWv, 1, "cellEndRow" )	Variable cellNameCol=FindDimLabel(flashWv, 1, "cellName" )	Variable typeCol=FindDimLabel(flashWv, 1, "determinedType" )	Variable combinedWvCol=FindDimLabel(flashWv, 1, "combinedWv" )	Variable isPeriphCol=FindDimLabel(flashWv, 1, "isPeripheral" )	Variable possiblyStainedCol=finddimlabel(flashWv,1,"possibly stained")	print "cellStartCol","cellEndCol","cellNameCol","typeCol","combinedWvCol","isPeriphCol","possiblyStainedCol"	String cellName,type,combinedRef	Variable startRow,endrow,isPeriph,possiblyStained	Variable additionalParams=6,prevRows,ii		String maxStimList	Variable summaryCreated	String ref,outRefs="",cellNameList=""	Variable outType,hasResp		for (i=0;i<num;i+=1)		type=flashWv[i][typeCol]				if ( (strlen(type) < 1) )			continue		endif				cellName=flashWv[i][cellNameCol]		combinedRef=flashWv[i][combinedWvCol]				if ( (strlen(cellName) < 1) || (strlen(combinedRef) < 1) )			continue		endif				WAVE/Z combinedWv=$combinedRef				if (!WaveExists(combinedWv))			Print "flashes_getFinalSummaries() failed to find combinedRef",combinedRef,"i",i,"cellName",cellName			continue		endif				strswitch (type)			case "blue":				maxStimList="442;"				outType=1				break			case "green":				maxStimList="500;560;"				outType=2				break			case "red":				maxStimList="560;"				outType=3				break			case "rodOnlyR":				maxStimList="500;"				outType=-1				break			case "noR":				outType=0				continue		endswitch				if (WhichListItem(cellName,cellNameList) >= 0)			continue		else			cellNameList+=cellName+";"		endif				ref=cellName + "_flashSumS"		//flash summary of summaries?				summaryCreated = flashes_getFinalSummary(combinedWv,maxStimList,minAmplitude,ref)		if (summaryCreated)			outRefs+=ref+";"			startRow=str2num(flashWv[i][cellStartCol])			endRow=str2num(flashWv[i][cellEndCol])			isPeriph=str2num(flashWv[i][isPeriphCol])			possiblyStained=str2num(flashWv[i][possiblyStainedcol])			hasResp=1			//outType			WAVE wv=$ref			prevRows=dimsize(wv,0)			redimension/n=(prevRows+additionalParams,-1) wv			ii=prevRows;dl_assignAndLbl(wv, ii, hasResp, "hasResp")			ii+=1;dl_assignAndLbl(wv, ii, i, "fileIndexWaveStartRow")			ii+=1;dl_assignAndLbl(wv, ii, startRow, "startRow")			ii+=1;dl_assignAndLbl(wv, ii, endRow, "endRow")			ii+=1;dl_assignAndLbl(wv, ii, isPeriph, "isPeriph")			ii+=1;dl_assignAndLbl(wv, ii, possiblyStained, "possiblyStained")		endif	endfor		print "outRefs",outRefs	concatenate/dl/np=1/o outRefs,$outref			return outRefsend//need to get a summary for each cone: response or not; maximal sensitivity (or 0); type (or nan); maximal response height; function flashes_getFinalSummary(cWv,maxStimList,minAmplitude,outRef)	WAVE cWv//combinedWv	String maxStimList		//list of tested wavelengths that would be considered maximal for this cell type	Variable minAmplitude	//min amplitude to analyze flash responses	String outRef	Variable lambdaTol=8	Variable phPerUmSq_r = finddimlabel(cWv,0,"phPerUmSq")	Variable sens_r =  finddimlabel(cWv,0,"sensitivity")	Variable cw_r = finddimlabel(cWv,0,"cw")	Variable amp_r = finddimlabel(cWv,0,"flashFit_amp")	String cwStr		Variable i,cols=dimsize(cWv,1)	//find column of max sensitivity that is for a stimulus in maxStimList	Double maxSens=-inf,sens,maxSensCol=-1,cw,amp	for (i=0;i<cols;i+=1)		cw=cWv[cw_r][i]		cwStr=num2str(cw)		if (WhichListItem(cwStr, maxStimList) < 0)			continue		//not in maxStimList		endif				amp=cWv[amp_r][i]		if (amp < minAmplitude)			continue		endif				sens = cWv[sens_r][i]		if (sens > maxsens)			maxSensCol=i			maxSens=sens		endif	endfor		if (maxSensCol < 0)		Print "flashes_getFinalSummary() failed to find a maxSensCol combinedWv",nameofwave(cWv)		return 0	endif		duplicate/o/r=[][maxSensCol] cWv, $outRef/wave=out	SetDimLabel 1,0,$stringfromlist(0,nameofwave(cWv),"_"),out 	return 1endfunction/S disp_offsetTraces(winN,traceListOrMatchStr,xAxNotYAx,padProportion,offsetAxName,otherAxName,labelPos[rideAlongAppendStr])	String winN	STring traceListOrMatchStr		//list of traces to offset from one another	Variable xAxNotYAx		//whether to offset vertically (pass 0), by y range, or horizontally, by x range	Variable padProportion		//proportional of total range (sum of all individual ranges) that will be dedicated to padding, final range is original total + padding	STring offsetAxName			//name of axis along whose range waves will be distributed	String otherAxName			//name of other axis, used to determine range shown in window	Variable labelPos			//pass to label traces (via Tag), or INF for no labels (NaN is a valid position option valid and so is passed)	String rideAlongAppendStr	//pass to offset other traces that are matches to the main trace name with this append str (mainTraceName+rideAlongAppendStr) gives a strmatch to the ride along wave(s)		Variable labelFontSize=8		if (strlen(winN) < 1)		winN = winname(0,1)	endif		String traces=TraceNameList(winN, ";", 1 )	traces=disp_traceList(winN,traceListOrMatchStr,offsetAxName,xAxNotYAx)	String refs="",finalTraces="",ref,tn		getaxis/q/w=$winN $otherAxName	Variable axMin=V_min,axMax=V_max,range,totalRange=0	variable i,num=itemsinlist(traces),wmin,wmax	make/o/d/n=(num)/free stXs,endXs,ranges	for (i=0;i<num;i+=1)		tn=stringfromlist(i,traces)		ref=nameofwave(TraceNameToWaveRef(winN, tn))		if (waveexists($ref) && (numtype(sum($ref,axMin,axMax)) ==0) )		//causes issues if waves have nans in range, these are not scaled			refs+=ref+";"			finalTraces+=tn+";"					wmin=wavemin($ref,axMin,axMax);stXs[i]=wmin			wmax=wavemax($ref,axMin,axMax);endXs[i]=wmax			range=wmax-wmin;ranges[i]=range			totalRange+=range		endif	endfor		Variable totalPadding=totalRange*padProportion	Variable padIncrement= (num > 1) ? ( totalPadding / (num-1) ) : 0	Variable totalOffset=0		//first trace needs no offset	String riders,rider	Variable numRiders,j	num=itemsinlist(finalTraces)		String labelFontText="\\K(0,0,0,39321)\\Z" + selectString(labelFontSize > 9,"0","")+num2str(labelFontSize)	if (xAxNotYAx)		//offset to x axis			for (i=0;i<num;i+=1)				tn=stringfromlist(i,finalTraces)			modifygraph/w=$winN offset($tn)={totalOffset,0}						if (numtype(labelPos) != 1)				tag/n=$tn/k		//checks in case tag of this name already present and deletes if so				tag/n=$tn/b=1/f=0/l=0 $tn,labelPos,labelFontText+tn			endif						if (!ParamIsdefault(rideAlongAppendStr))				riders=ListMatch(TraceNameList(winN, ";", 1 ), tn+rideAlongAppendStr)				numRiders=itemsinlist(riders)				for (j=0;j<numRiders;j+=1)					rider=stringfromlist(j,riders)					modifygraph/W=$winN offset($rider)={totalOffset,0}				endfor			endif		endfor				totalOffset+=ranges[i]+padIncrement			else			for (i=0;i<num;i+=1)				tn=stringfromlist(i,finalTraces)			modifygraph/w=$winN offset($tn)={0,totalOffset}						if (numtype(labelPos) != 1)				tag/n=$tn/k		//checks in case tag of this name already present and deletes if so				tag/n=$tn/b=1/f=0/l=0 $tn,labelPos,labelFontText+tn			endif						if (!ParamIsdefault(rideAlongAppendStr))				riders=ListMatch(TraceNameList(winN, ";", 1 ), tn+rideAlongAppendStr)				numRiders=itemsinlist(riders)				for (j=0;j<numRiders;j+=1)					rider=stringfromlist(j,riders)					modifygraph/W=$winN offset($rider)={0,totalOffset}				endfor			endif						totalOffset+=ranges[i]+padIncrement		endfor				endif		return labelFontText		//in case of other modifications outside functionendfunction disp_hideAxis(axMatchStrList,numWins)	String axMatchStrList	Variable numWins		string winN	String axes	Variable winNum		if (numWins < 1)		numWins = 1	endif		for (winNum=0;winNum < numWins;winNum+=1)		winN=winname(winNum,1)		if (strlen(winN) < 1)			break		endif		axes=axislist(winN)		String matchingAxes=text_ListMatchStrList(axes,axMatchStrList)		Variable i,num=itemsinlist(matchingAxes)		String axName		for (i=0;i<num;i+=1)			axName=stringfromlist(i,matchingAxes)			ModifyGraph/W=$winN tick($axName)=3,noLabel($axName)=2,axRGB($axName)=(65535,65535,65535,0),axThick($axName)=0		endfor	endforendfunction/S disp_traceList(winN,traceListOrMatchStr,axisListOrMatchStr,xAxNotYAx)	STring winN	String traceListOrMatchStr	String axisListOrMatchStr	variable xAxNotYAx		if (strlen(winN) < 1)		winN = winname(0,1)	endif		String axisKey = selectstring(xAxNotYAx,"YAXIS","XAXIS")	String traces=TraceNameList(winN, ";", 1 )	traces=text_ListMatchStrList(traces,traceListOrMatchStr)	variable i,num=itemsinlist(traces)	String info,tn,axisName	String matchingTraces=""	for (i=0;i<num;i+=1)		tn=stringfromlist(i,traces)		info=TraceInfo(winN, tn, 0)		axisName=StringByKey(axisKey, info)				if (itemsinlist(text_ListMatchStrList(axisName,axisListOrMatchStr)) > 0)			matchingTraces+=tn+";"		endif	endfor			return matchingTracesendfunction udt_posToODs(wv,posCol,odVals)	WAVE wv	Variable posCol		//column containing positions to convert based on odVals	WAVE odVals		variable i,num=dimsize(wv,0)	duplicate/o wv,udt_posToODs_BU	wv[][posCol] = odVals[wv[p][q]]end//need to rewrite: assume ordered so all of a wavelength are grouped. assume a fixed offset row into first row containing wavelength is unattenuated for OD0 bench 0 and another offset for OD1//if both are unattenated, return this//if one is unattenuated, find its value and return that//if both are unattenuated, find the more attenuating one and calculate its fractional attenuation from its uW/unattenuated uW//return the power through the less attenuating * its fractional attenuationfunction/D flash_getCalVal(calWvref,cw,oda,odb[report])	String calWvRef		//must be grouped by wavelength: all rows of one center wavelength (cw) must be contiguous	Double cw,oda,odb	Variable report		//optionally pass and pass true to print to cmd line (default is no)		WAVE/Z calWv=$calWvRef	if (!waveexists(calWv))		return nan	endif		if (numtype(cw+oda+odb)!=0)		//one or more nan		return nan	endif	variable i,calRows=dimsize(calwv,0)	Double cw_tol=0.4	Double odTol=0.0025		//figure no one is using an od lower than this		matrixop/free/o cws=col(calwv,0);redimension/n=(-1) cws		//find start of cw	findvalue/T=(cw_tol)/V=(cw)/Z cws	Variable firstCwRow=V_value		if (firstCwRow < 0)		Print "flash_getCalVal FAILED calWv FAILED TO FIND cw in CALVAL",nameofwave(calWv),"cw",cw,"oda",oda,"odb",odb		return nan	endif		//find end of cw	matrixop/free/o cws=reverseCol(cws,0);redimension/n=(-1) cws	findvalue/T=(cw_tol)/V=(cw)/Z cws	if (v_Value < 0)		Print "flash_getCalVal FAILED calWv FAILED TO FIND cw in CALVAL, when looking in reverse (this should never happen!)",nameofwave(calWv),"cw",cw,"oda",oda,"odb",odb		//never should happen bc if no cw of this value it would have returned on the first search		return nan	endif		Variable lastCwRow=calRows-1-v_Value		Variable odaIsAttenuated = oda >= odTol	Variable odbIsAttenuated = odb >= odTol	Variable bothAttenuated = odaIsAttenuated && odbIsAttenuated	Variable neitherAttenuated=!bothAttenuated	Variable odaOnlyAttenuated = odaIsAttenuated && !odbIsAttenuated	Variable odbOnlyAttenuated = odbIsAttenuated && !odaIsAttenuated		Double findVal; Variable findCol,zeroCol	if (odaOnlyAttenuated || odbOnlyAttenuated)		//simplest case: all attenuation is set by one filter or the other, only need look at the attenuated one's output		findVal = odaIsAttenuated ? oda : odb		findCol = odaIsAttenuated ? 1 : 2		zeroCol = odaIsAttenuated ? 2 : 1		for (i=firstCwRow;i<=lastCwRow;i+=1)			if (  ( abs(calWv[i][findCol]-findVal) < odTol )  &&  ( calWv[i][zeroCol] < odTol )  ) 				return calWv[i][3]			endif		endfor					//after looping, if haven't already returned, then we've failed!		Print "flash_getCalVal FAILED calWv FAILED TO FIND single OD with other site attenuated in CALVAL",nameofwave(calWv),"cw",cw,"oda",oda,"odb",odb,"searched for ODA (0 or 1)?",odaIsAttenuated		return nan			endif		//either neither is attenuated or both are; in either case find the unattenuated row	Variable unattenuatedRow=nan	Double unattenuatedVal	for (i=firstCwRow;i<=lastCwRow;i+=1)		if (  ( calWv[i][1] < odTol )  &&  ( calWv[i][2] < odTol )  ) 			unattenuatedRow=i			unattenuatedVal=calWv[unattenuatedRow][3]						if (neitherAttenuated)				return unattenuatedVal			endif						break		//no need to keep searching		endif	endfor			if (numtype(unattenuatedRow))		//failed to find unattenuated		Print "flash_getCalVal FAILED calWv failed to find TOTALLY UNATTENUATED ROW in CALVAL",nameofwave(calWv),"cw",cw,"oda",oda,"odb",odb		return nan	endif		//last remaining case: both attenuated.. find both values	Variable odaRow=nan,odbRow=nan,found=0	for (i=firstCwRow;i<=lastCwRow;i+=1)		if (  ( abs(calWv[i][1]-oda) < odTol )  &&   ( calWv[i][2] < odTol )  ) 		//oda at value and odb unattenuated			odaRow=i			found+=1		endif				if (  ( abs(calWv[i][2]-odb) < odTol )  &&   ( calWv[i][1] < odTol )  ) 		//odb at value and oda unattenuated			odbRow=i			found+=1		endif						if (found > 1)			break		endif	endfor				if (numtype(odaRow))		//failed to find unattenuated		Print "flash_getCalVal FAILED calWv failed to find odaRow in CALVAL",nameofwave(calWv),"cw",cw,"oda",oda,"odb",odb		return nan	endif		if (numtype(odbRow))		//failed to find unattenuated		Print "flash_getCalVal FAILED FAILED calWv failed to find odbRow in CALVAL",nameofwave(calWv),"cw",cw,"oda",oda,"odb",odb		return nan	endif				//calculate transmittance 	Double odaTransmittance=calwv[odaRow][3] / unattenuatedVal	Double odbTransmittance=calwv[odbRow][3] / unattenuatedVal	Double totalTransmittance=odaTransmittance*odbTransmittance	double totalOD=-log(totalTransmittance)		if (!ParamIsDefault(report) && report)		Print/d "flash_getCalVal in calval",nameofwave(calWv),"cw",cw,"oda",oda,"odb",odb,"totalOD",totalOD	endif		return unattenuatedVal * odaTransmittance * odbTransmittanceendfunction shutter_cal(ad0_list,outRef)	String ad0_list		//list of AD0 sweeps, find other sweeps as listed below	String outRef		Variable updateCmdLineFreq=200	String durList=Replacestring(",","0,0.1,0.25,0.5,1,1.5,2.5,3,5,7.5,10,12.5,15,25,",";")	Variable numDurs=itemsinlist(durList)	Variable numReps = 3		//each duration is repeated for 3 sweeps, then it is all looped through again	Variable numSweepsPerSet=numDurs*numReps	Variable numSweeps=itemsinlist(ad0_list)	Variable numSets=numSweeps/numSweepsPerSet	Variable totalNumReps=numSets*numReps			Variable numPArams=42	//want parameters along rows and each replicate for a test along columns	//each test along layer	make/o/d/n=(numPArams,totalNumReps,numDurs) $outRef/wave=out;out=nan	dl_assignLblsFromList(out,2,0,durList,"dur_",1)	dl_lblByInd(outRef,1,"rep_",1)			Variable ch_udt=0	Variable ch_bCmd=1		//bench cmd	Variable ch_bEff	=2	//bench efference copy 	Variable ch_diode=3		Variable udtIntByTimeX=0.025215		//time where integration has always started	Variable udtIntEndForSlope=0.03803	Variable udtLastIntTimeX=0.086375		//safe final point before integration ends for any rep	Variable effCopyOnOffThreshold=3			//use e.g. 3 for 0 off 5 on, use e.g., -2 for -5 off 0 on		Variable cmdStartP = 7376		//precheck this.. start pnt of bench cmd			String udtWvs=Replacestring("_AD0",ad0_list,"_AD"+num2str(ch_udt))	String bCmdWvs=Replacestring("_AD0",ad0_list,"_AD"+num2str(ch_bCmd))	String bEffWvs=Replacestring("_AD0",ad0_list,"_AD"+num2str(ch_bEff))	String diodeWvs=Replacestring("_AD0",ad0_list,"_AD"+num2str(ch_diode))		Variable dur,durNum,setRepNum,i,isFirst,setNum,setOffset,durRepNum	String udtRef,bCmdRef,bEffRef,diodeRef	for (i=0;i<numSweeps;i+=1)		setNum=floor(i/numSweepsPerSet)		setOffset=i-setNum*numSweepsPerSet		durNum=floor(setOffset/numReps)		setRepNum=mod(setOffset,numReps)		durRepNum=numReps*setNum + setRepNum		dur=str2num(stringfromlist(durNum,durList))						udtRef=stringfromlist(i,udtWvs)		bCmdRef=stringfromlist(i,bCmdWvs)		bEffRef=stringfromlist(i,bEffWvs)		diodeRef=stringfromlist(i,diodeWvs)		String refs=udtRef+";"+bCmdRef+";"+bEffRef+";"+diodeRef+";"				isFirst= i==0				da_fd_loadWavesFromWaveName(refs,1)		shutter_calQuant(dur,$udtRef,$bCmdRef,$bEffRef,$diodeRef,udtIntByTimeX,udtIntEndForSlope,udtLastIntTimeX,effCopyOnOffThreshold,cmdStartP,out,durNum,durRepNum,isFirst)		killWavesByName(refs)				if ( (mod(i,updateCmdLineFreq)==0) && (i!=0))			Print "shutter_cal at num",i		endif	endfor		String outRef_repAvgs=outRef+"_repAvgs"	String outRef_durc=outRef+"_durc"	//durc for duration combined	//calculate stats (e.g. avg) across reps of the same duration	matrixop/o/free trtemp=transposevol(out,5)		//make reps row-by-row and params col-by-col to get per column stats across reps	wavestats/pcst/q trtemp	WAVE M_wavestats	Make/o/d/n=1 $outRef_repAvgs/wave=refAvg	matrixop/o refAvg=transposevol(M_wavestats,5)	dl_lblsToLbls(outRef,0,0,inf,outRef_repAvgs,0,0,"",0)		//re-label parameters	dl_lblsToLbls("M_WaveStats",0,0,inf,outRef_repAvgs,1,0,"",0)		//copy labels for stats for each parameter	dl_lblsToLbls(outRef,2,0,inf,outRef_repAvgs,2,0,"",0)		//re-label durations		//make wave with all durations combined across a single layer	wave_catLayersAlongCols(out,outRef_durc)		//durc for duration combinedend//wv1 is udtWvfunction shutter_calQuant(dur,udt,cmdCopWv,bEffWv,diodeWv,udtIntByTimeX,udtIntEndForSlopeX,udtLastIntTimeX,effCopyOnOffThreshold,cmdStartP,outWv,durNum,repNum,doLbls)	Variable dur,durNum,repNum	WAVE/D udt,cmdCopWv,bEffWv,diodeWv	Variable udtIntByTimeX,udtIntEndForSlopeX,udtLastIntTimeX,effCopyOnOffThreshold,cmdStartP		//start and end for line slope fit and baseline for diode	wave outWv	Variable doLbls		Variable avgWins=0.001		//baseline subtract (integrating so it's a slope)	make/o/d/free/n=2 coefs	CurveFit/M=2/W=0/Q line, kwCWave=coefs, udt[x2pnt(udt,udtIntByTimex),x2pnt(udt,udtIntEndForSlopeX)]/D	Double udtlineOffset=coefs[0]	Double udtlineSlope=coefs[1]	Variable udtAvgStartX=udtLastIntTimeX-avgWins		duplicate/o/r=(udtAvgStartX,udtLastIntTimeX) udt,udtTemp	udtTemp-=(udtlineOffset+udtlineSlope*X)	Double udtAvg=mean(udtTemp,udtAvgStartX,udtLastIntTimeX)		//next for the cmdCopy wave, just check that the step has started	Variable cmdTimingOK = cmdCopWv[cmdStartP] > 3	Variable udtIntEndForSlopeP=x2pnt(udt, udtIntEndForSlopeX) 	Variable udtAvgStartP=x2pnt(udt, udtAvgStartX)		//next for the eff copy wave, calculate its sum throughout the integration window		Double effSum=sum(bEffWv,udtIntEndForSlopeX,udtAvgStartX)	Double effArea=area(bEffWv,udtIntEndForSlopeX,udtAvgStartX)	Variable effSumRange=udtAvgStartX-udtIntEndForSlopeX	Variable effSumPnts=udtAvgStartP-udtIntEndForSlopeP		make/o/d/n=0 risingLevels,fallingLevels	Variable cmdStartX=pnt2x(bEffWv,cmdStartP)	FindLevels/D=risingLevels/EDGE=1/Q/R=(cmdStartX,udtLastIntTimeX) bEffWv, effCopyOnOffThreshold	Variable effNoRising= V_flag==2	FindLevels/D=fallingLevels/EDGE=2/Q/R=(cmdStartX,udtLastIntTimeX) bEffWv, effCopyOnOffThreshold	Variable effNoFalling = V_flag==2		Variable effNumRiseLevels=dimsize(risingLevels,0)	Variable effNumFallLEvels=dimsize(fallingLevels,0)	Variable effnFallnRiseDiff=effNumFallLEvels-effNumRiseLevels	Variable effnFallnRiseMismatch= effnFallnRiseDiff!=0		Variable effStartX=nan,effEndX=nan	if (!effNoRising)		effStartX=risingLevels[0]	endif	if (!effNoFalling)		effEndX=fallingLEvels[effNumFallLEvels-1]	endif		Double effWidthX=effEndX-effStartX		//finally for diode wave	Variable diodeBaselineEndX=udtIntEndForSlopeX	VAriable diodeBaselineStartX=diodeBaselineEndX-avgWins	Double diodeBaseline=mean(diodeWv,diodeBaselineEndX,diodeBaselineStartX)	Variable diodeStartX=diodeBaselineEndX	Variable diodeEndX=udtAvgStartX	Variable diodeStartP=x2pnt(diodeWv,diodeStartX)	Variable diodeEndP=x2pnt(diodeWv,diodeEndX)	duplicate/o/r=(diodeStartX,udtAvgStartX) diodeWv,diodeTemp	diodeTemp-=diodeBaseline	Double diodeSum=sum(diodeTemp)	Double diodeArea=area(diodeTemp)	Variable diodeSumRange=diodeEndX-diodeStartX	Variable diodeSumPnts=diodeEndP-diodeStartP		wavestats/q diodeTemp	Double diodePeakLocX=V_minloc	Double diodePeakValX=V_min	Double diodeHalfMaxVal = diodePeakValX * 0.5	FindLevel/EDGE=2/Q diodeTemp, diodeHalfMaxVal 		//find approach to peak.. falling as it is negative-going	Variable diodeFindRisingFail=V_flag	Double diodeRisingX=V_levelx	FindLevel/EDGE=1/Q diodeTemp, diodeHalfMaxVal 		//find decay time after peak.. rising as it is positive-going	Variable diodeFindFallingFail=V_flag	Double diodeFallingX=V_levelx		Double diodeFWHM=diodeFallingX-diodeRisingX	Variable diodeUnexpectedORder=diodeFWHM < 0		if (doLbls)		string lbls="dur;udtlineOffset;udtlineSlope;udtAvgStartX;udtAvg;cmdTimingOK;udtIntEndForSlopeP;udtAvgStartP;effSum;effArea;effSumRange;effSumPnts;cmdStartX;effNoRising;effNoFalling;"		lbls+="effNumRiseLevels;effNumFallLEvels;effnFallnRiseDiff;effnFallnRiseMismatch;effStartX;effEndX;diodeBaselineEndX;diodeBaselineStartX;diodeBaseline;"		lbls+="iodeStartX;diodeEndX;diodeStartP;diodeEndP;diodeSum;diodeArea;diodeSumRange;diodeSumPnts;diodePeakLocX;diodePeakValX;diodeHalfMaxVal;"		lbls+="diodeFindRisingFail;diodeRisingX;diodeFindFallingFail;diodeFallingX;diodeFWHM;diodeUnexpectedORder;effWidthX"				dl_assignLblsFromList(outwv,0,0,lbls,"",0)		//loops through the list of labels and assigns that to the dimension of interest (rows)	endif			variable i	i=0;outwv[i][repNum][durNum]=dur	i+=1;outwv[i][repNum][durNum]=udtlineOffset	i+=1;outwv[i][repNum][durNum] = udtlineSlope	i+=1;outwv[i][repNum][durNum] = udtAvgStartX	i+=1;outwv[i][repNum][durNum] = udtAvg	i+=1;outwv[i][repNum][durNum] = cmdTimingOK	i+=1;outwv[i][repNum][durNum] = udtIntEndForSlopeP	i+=1;outwv[i][repNum][durNum] = udtAvgStartP	i+=1;outwv[i][repNum][durNum] = effSum	i+=1;outwv[i][repNum][durNum] = effArea	i+=1;outwv[i][repNum][durNum] = effSumRange  	i+=1;outwv[i][repNum][durNum] = effSumPnts	i+=1;outwv[i][repNum][durNum] = cmdStartX	i+=1;outwv[i][repNum][durNum] = effNoRising	i+=1;outwv[i][repNum][durNum] = effNoFalling	i+=1;outwv[i][repNum][durNum] = effNumRiseLevels  	i+=1;outwv[i][repNum][durNum] = effNumFallLEvels	i+=1;outwv[i][repNum][durNum] = effnFallnRiseDiff	i+=1;outwv[i][repNum][durNum] = effnFallnRiseMismatch	i+=1;outwv[i][repNum][durNum] = effStartX	i+=1;outwv[i][repNum][durNum] = effEndX  	i+=1;outwv[i][repNum][durNum] = diodeBaselineEndX	i+=1;outwv[i][repNum][durNum] = diodeBaselineStartX	i+=1;outwv[i][repNum][durNum] = diodeBaseline	i+=1;outwv[i][repNum][durNum] = diodeStartX	i+=1;outwv[i][repNum][durNum] = diodeEndX  	i+=1;outwv[i][repNum][durNum] = diodeStartP	i+=1;outwv[i][repNum][durNum] = diodeEndP	i+=1;outwv[i][repNum][durNum] = diodeSum	i+=1;outwv[i][repNum][durNum] = diodeArea	i+=1;outwv[i][repNum][durNum] = diodeSumRange  	i+=1;outwv[i][repNum][durNum] = diodeSumPnts	i+=1;outwv[i][repNum][durNum] = diodePeakLocX	i+=1;outwv[i][repNum][durNum] = diodePeakValX	i+=1;outwv[i][repNum][durNum] = diodeHalfMaxVal	i+=1;outwv[i][repNum][durNum] = diodeFindRisingFail  	i+=1;outwv[i][repNum][durNum] = diodeRisingX	i+=1;outwv[i][repNum][durNum] = diodeFindFallingFail	i+=1;outwv[i][repNum][durNum] = diodeFallingX	i+=1;outwv[i][repNum][durNum] = diodeFWHM	i+=1;outwv[i][repNum][durNum] = diodeUnexpectedORder		i+=1;outwv[i][repNum][durNum] = effWidthXendfunction shutter_cal_dispRuns(repWv,yParam,xPAram,winN,axN)	wave repWv	String yParam,xPAram,winN,axN		if (strlen(winN) < 1)		winN=winname(0,1)	endif		if (strlen(axN) < 1)		axN="left"	endif		Variable rightAx=stringmatch(axN,"R*")		Variable yRow=FindDimLabel(repWv, 0, yParam )	Variable xRow=FindDimLabel(repWv, 0, xParam )		if ( (xRow < 0) || (yRow < 0) )		print "shutter_cal_dispRuns() failed to find a param either yParam",yParam,"yRow",yRow,"xParam",xParam,"xRow",xRow		return 0	endif 		variable i,num=dimsize(repWv,2)	STring tn	for (i=0;i<num;i+=1)		tn=yParam + "_"+ num2str(i)		if (rightAx)			appendtograph/W=$winN/R=$axN repWv[yRow][][i]/tn=$tn vs repWv[xRow][][i]		else			appendtograph/W=$winN/L=$axN repWv[yRow][][i]/tn=$tn vs repWv[xRow][][i]		endif	endforendfunction saveLocalVariables()	//ideally from a non-root folder made for this function (which feels like a lot of work!)	Variable/G aaa_aName=1,aaa_anotherName=10,aaa_oneMoreName=100,aaa_yetAnotherName=1000		String variables=VariableList("aaa_*", ";", 4 ) //get the variables, using a match string to avoid variables not of interest	print "variables",variables	Variable i,numVars=itemsinlist(variables)	make/o/d/n=(numVars) outwv	String lbl,varN,cmd,assignFormat="outwv[%u]=%s",killFormat="killvariables/z %s"	for (i=0;i<numVars;i+=1)		varN=Stringfromlist(i,variables)		sprintf cmd, assignFormat ,i,varN		Execute cmd		lbl=replacestring("aaa_",varN,"")		SetDimLabel 0,i,$lbl,outwv 				sprintf cmd, killFormat,varN		Execute cmd	endfor		edit/k=1 outwv.ldendfunction wave_catLayersAlongCols(wv,outRef)	WAVE wv; string outRef		Variable i,layers=dimsize(Wv,2)	Duplicate/r=[*][*][0] wv,$outref/wave=out	for (i=1;i<layers;i+=1)		duplicate/o/free/r=[*][*][i] wv, temp		concatenate/np=1/dl {temp},out	endfor	end//From igor exchange aclight snippet post http://www.igorexchange.com/node/366//**// Calculates the intersection of two 1D integer waves.  You might use this to determine// common indices in two destWaves created by the Extract/INDX operation.//// @param wave1// 	First 1D integer wave.// @param wave2// 	Second 1D integer wave.// @param resultWave// 	A wave where the result will be stored.  This wave will be overwritten if it already contains// 	any data.  The function will change the this to an integer wave if it is not already.//*Function data_intersect_waves(wave1, wave2, resultWave)	WAVE wave1	WAVE wave2	WAVE resultWave 	Variable wave1Rows = DimSize(wave1, 0)	Variable wave2Rows = DimSize(wave2, 0)	Variable longRows, shortRows	if (wave1Rows > wave2Rows)		Duplicate/O wave1, longWave		WAVE shortWave = wave2		longRows = wave1Rows		shortRows = wave2Rows	else		Duplicate/O wave2, longWave		WAVE shortWave = wave1		longRows = wave2Rows		shortRows = wave1Rows	endif 	// Sort values in longWave	Sort longWave, longWave	Redimension/I/N=(0) resultWave 	Variable n, numOutRows, longWaveRow	For (n=0; n<shortRows; n+=1)		longWaveRow = BinarySearch(longWave, shortWave[n])		if ((longWaveRow) >= 0 && longWave[longWaveRow] == shortWave[n])			Redimension/N=(numOutRows + 1) resultWave			resultWave[numOutRows] = shortWave[n]			numOutRows += 1		endif	EndFor	KillWaves/Z longWaveEndfunction fitwhatever(wv,coefwave,fitNameStr)	WAVE wv,coefwave	String fitNameSTr		FUNCREF fits_protoFunc f = $fitNameStr	FuncFit f, coefwave,wvend function vi_displayList(vi_index,cat_R,catSymWv,xEndStr,yEndStr,lbl,winN)	WAve/t vi_index	WAVE cat_R,catSymWv		//contains rgba colors for each wave.. one of the parameters for disp_plotRep_2Dsym()	string xEndStr,yEndStr,lbl,winN		//e.g.,"_ts_SfS","_ts_drfS","resp_timeToPeak",""		variable origRefListRow=2		//could be any		if (strlen(winN) < 1)		winN = lbl+yEndStr	endif		if (strlen(winN) > 31)		print "vi_displayList() winN too long! aborting. enter winN manually! winN=",winN,"len=",strlen(winN)		return 0	endif		if (!wintype(winN))		display/k=1/n=$winN		winN=S_name	endif		String cellName=stringfromlist(0,stringfromlist(0,vi_index[0][origRefListRow]),"_")	String ext=stringfromlist(1,stringfromlist(0,vi_index[0][origRefListRow]),"_")		//get file number	String ref=cellName + "_" + ext 	String xref=ref+xEndStr,yref	Variable yRow=FindDimLabel($xref, 0, lbl)	Variable xRow=FindDimLabel($xref, 0, "stim_ri_deltaMean")	Variable i,num=dimsize(cat_R,0)	for (i=0;i<num;i+=1)		cellName=stringfromlist(0,stringfromlist(0,vi_index[i][origRefListRow]),"_")		ext=stringfromlist(1,stringfromlist(0,vi_index[i][origRefListRow]),"_")		//get file number		ref=cellName + "_" + ext 		yref=ref+yEndStr		xref=ref+xEndStr		AppendToGraph/w=$winN/c=(cat_R[i][0],cat_R[i][1],cat_R[i][2],cat_R[i][3]) $yref[yRow][*] vs $xref[xRow][*]		modifygraph/w=$winN marker($yref)=catSymWv[i]	endfor	ModifyGraph/w=$winN mode=4,fsize=16	Label/w=$winN left, (lbl+"\\u#2")	Label/w=$winN bottom, "Current (pA)\\u#2"endfunction wavesModifiedSince(waves,sinceDateTime)	String waves		//list of waves to check modification status	Double sinceDateTime		//time in secs since Igor's arbitrary date as returned by datetime or moddate(wv)		Variable i,num=itemsinlist(waves)	STring ref	for (i=0;i<num;i+=1)		ref = stringfromlist(i,waves)		if (moddate($ref) > sinceDateTime)			return 1		endif	endfor		return 0	end//PROCEDURES FOR BRINGING ABFs into IGOR64 WITH the ABF LOADER. Must Also open a filePanel with the//same fileInfoWave etc. in igor 32. more than one instance each of igor 32 or 64 running could very easily lead to issues!!!strconstant ksOutputFolder="Desktop"	//expect a standard one recognized by SpecialDirPathstrconstant ksOutputSubfolder = "teststuff" //must exist in ksOutputFolder//first use, start by opening 64 from 32 and 32 from 64 (might take going in both directions)function fd_openFromScript([newInstance])	Variable newInstance		Variable doNewInstance = !ParamIsdefault(newInstance) && newInstance		Variable is64=igor_is64()	if (is64)		executeIgorScript_doCmd("Variable qqqqq=64;killvariables/z qqqqq",32,newInstance=doNewInstance)	else		executeIgorScript_doCmd("Variable qqqqq=64;killvariables/z qqqqq",64,newInstance=doNewInstance)	endifendfunction igor_isMac()	String info = igorinfo(2)	return stringmatch(info,"Mac*")		endfunction igor_is64()	String info = igorinfo(0)	String kind = StringByKey("IGORKIND", info)	return stringmatch(kind,"*64*")	endstatic constant fd_loadAbfDuringExecutionTimeOut_minutes=10function/S fd_loadAbfFrom32DuringExecution(fd_fileNumOrWaveNameList,skipLoadIfIbwExists,waveNamesNotFileNums,[justRequestedWvs])	String fd_fileNumOrWaveNameList		//list of file nums to load, handled recursively	Variable skipLoadIfIbwExists,waveNamesNotFileNums		Variable justRequestedWvs		//optional and only matters when fd_fileNumOrWaveNameList is a list of waves: pass true to load ONLY listed waves. default otherwise is to load all waves in the same file that are selected in file panel		Variable doJustRequestedWvs=!ParamIsDefault(justRequestedWvs) && justRequestedWvs	String wavesToLoad=fd_callLoadAbfAndStore(fd_fileNumOrWaveNameList,skipLoadIfIbwExists,waveNamesNotFileNums,justRequestedWvs=doJustRequestedWvs)	SVAR soughtList //waves to load, populated in fd_callLoadAbfAndStore and depopulated as the waves are loaded by fd_loadWin32Ibws	Variable loadFail=1	Variable timeOutTicks=fd_loadAbfDuringExecutionTimeOut_minutes*60*60	Variable reportTicks = 60*10		//report every 10 seconds		if (itemsinlist(wavesToLoad) < 1)		return ""	endif		print "fd_loadAbfFrom32DuringExecution() running. Abort if you get impatient or something goes wrong! Times out after min=",fd_loadAbfDuringExecutionTimeOut_minutes	String/G callString=wavesToLoad	Variable elapsedTicks,startTicks=ticks,lastReportTicks = startTicks,loopTime	do		//wait in this loop til waves are loaded		if (itemsinlist(soughtList)==0)		//these are cleared by loading function fd_loadWin32Ibws as they are loaded by it			Print "fd_loadAbfFrom32DuringExecution() completed. num waves loaded",itemsinlist(wavesToLoad)			loadFail=0			break		endif				loopTime=ticks		elapsedTicks = loopTime-startTicks				if ( (loopTime - lastReportTicks) > reportTicks)			Print "fd_loadAbfFrom32DuringExecution() Still waiting at elapsed seconds",elapsedTicks/60,"waiting on",soughtList			lastReportTicks = loopTime		endif	while ( elapsedTicks < timeOutTicks )		if (loadFail)		print "fd_loadAbfFrom32DuringExecution() load fail on ",fd_fileNumOrWaveNameList	endif	return wavesToLoadend//starts here in 64function/S fd_callLoadAbfAndStore(fd_fileNumOrWaveNameList,skipLoadIfIbwExists,waveNamesNotFileNums,[justRequestedWvs])	String fd_fileNumOrWaveNameList		//list of file nums to load, handled recursively	Variable skipLoadIfIbwExists,waveNamesNotFileNums//	Variable forceReload		//note: does so by killing pre-existing waves!		--removed because redundent with skipLoadIfIbwExists	Variable justRequestedWvs		//optional and only matters when fd_fileNumOrWaveNameList is a list of waves: pass true to load ONLY listed waves. default otherwise is to load all waves in the same file that are selected in file panel			//convert wave names to fileNums if needed	String fileNumList="",name,numStr	String wavesForEachFileNum="",wavesForFile		//only used for if waveNamesNotFileNums is true	Variable numInputs=itemsinlist(fd_fileNumOrWaveNameList),numFiles,i,num	if (waveNamesNotFileNums)		for (i=0;i<numInputs;i+=1)			name=stringfromlist(i,fd_fileNumOrWaveNameList)			num = fd_getFIndexInFileInfoWave(text_getInfoFromWaveName_S(name, 9))			if ( (num<0) || (numtype(num) >0) )				continue			endif			numStr=num2str(num)			if (WhichListItem(numStr,fileNumList) < 0)		//avoid duplicate file nums				fileNumList+=numStr+";"			endif			wavesForFile=stringbykey(numStr,wavesForEachFileNum)			wavesForFile+=name+","			wavesForEachFileNum=ReplaceStringByKey(numStr,wavesForEachFileNum,wavesForFile)		endfor		numFiles=itemsinlist(fileNumList)	else		fileNumList=fd_fileNumOrWaveNameList		numFiles=numInputs	endif		//generate channel selection (bit) list for each file	String toLoad="",fileSelBitList="",file	variable j,numForFile	for (i=0;i<numFiles;i+=1)		numStr=stringfromlist(i,fileNumList)		num=str2num(numStr)			if (ParamIsDefault(justRequestedWvs) || !justRequestedWvs)		//default is to use file panel wave selections			wavesForFile=fd_getFileSweepNames(str2num(numStr),1)		//get selected wave names based on channel selections in file info wave (a bit roundabout since we then get chan selelection key from this, but allows to check for pre-existing if needed		else			wavesForFile=replacestring(",",stringbykey(numStr,wavesForEachFileNum),";")		endif		if (skipLoadIfIbwExists)		//do not include existent from load list			numForFile=itemsinlist(wavesForFile)			for (j=0;j<numForFile;j+=1)				file=stringfromlist(j,wavesForFile)				if (!waveexists($file))					toLoad+=wavesForFile					fileSelBitList+=num2str(fd_getChanSelectionBitwise(num,waveNameList=wavesForFile))+";"		//convert each wave list to a bit list based on channel specifications				endif			endfor		else								//include in load list either way			toLoad+=wavesForFile			fileSelBitList+=num2str(fd_getChanSelectionBitwise(num,waveNameList=wavesForFile))+";"		//convert each wave list to a bit list based on channel specifications		endif	endfor		if (itemsinlist(toLoad) < 1)		return ""	endif	string/G soughtList = toLoad		//replace semicolons with commas and remove trailing comma if necessary, as required for literal wave decleration	//cant pass a string list because quotes seem to be a pain in the ass, if not impossible, with print to command line	String fileNumListCommas=replacestring(";",fileNumList,",")	String chanBitListCommas=replacestring(";",fileSelBitList,",")	Variable lastCharPos=strlen(fileNumListCommas)-1	if (stringmatch(fileNumListCommas[lastCharPos],","))		fileNumListCommas=fileNumListCommas[0,lastCharPos-1]	endif	lastCharPos=strlen(chanBitListCommas)-1	if (stringmatch(chanBitListCommas[lastCharPos],","))		chanBitListCommas=chanBitListCommas[0,lastCharPos-1]	endif	String fileWavePassStr="{"+fileNumListCommas+"}"	string chanBitWavePAssSTr="{"+chanBitListCommas+"}"		String cmd="fd_loadAndStore("+fileWavePassStr+","+chanBitWavePAssSTr+")"	executeIgorScript_doCmd(cmd,32)		//runs in 32		return toLoadend//to run in 32function fd_loadAndStore(fileNumWv,chanBitWv)	WAVE fileNumWv,chanBitWv		String stackList = GetRTStackInfo(0)	if (itemsinlist(listmatch(stackList,"fd_loadAndStore")) >1) 		print "new fd_loadAndStore() call while fd_loadAndStore() has not finished executing. aborting new call. This is a bug that is likely detrimental to wave loading in Igor 64."		return NaN	endif		Variable numFiles=dimsize(fileNumWv,0)		String toLoad="",sweeps	Variable i,fileNum,chanBitVar	for (i=0;i<numFiles;i+=1)		fileNum=fileNumWv[i]		chanBitVar=chanBitWv[i]		fd_setChanSelsBitwise(fileNum,chanBitVar)		//update file chan selections based on bitwise input		sweeps=fd_getFileSweepNames(fileNum,1)		toLoad+=sweeps	endfor		//get list of target waves	Variable numWavesToLoad=itemsinlist(toLoad)	//check path exists, create if not	String outputPath = SpecialDirPath(ksOutputFolder,0,0,0) + ksOutputSubfolder + ":"	String symbolicPathName =  ksOutputSubfolder + "_sym"	PathInfo $symbolicPathName	if  (!V_flag || !stringmatch(s_path,outputPath))		Print "making new path"		newpath/Q $symbolicPathName, outputPath	endif		String loaded="",files	Variable numLoaded=0	for (i=0;i<numFiles;i+=1)		fileNum=fileNumWv[i]		files=fd_loadfile(fileNum,bypassLoadCheck=1)		loaded+=files		numLoaded+=itemsinlist(loaded)		save/c/o/p=$symbolicPathName/b files		killwavesbyname(files)	endfor		print "fd_loadAndStore() loaded",loaded,"of",numWavesToLoad//,"(loadedlist:",loaded,")","(of to toLoad:"+toLoad+")"		String cmdStr = "fd_loadWin32Ibws()"		//runs in 64	executeIgorScript_doCmd(cmdStr,64)	end//runs in 64function fd_loadWin32Ibws()	String outputPath = SpecialDirPath(ksOutputFolder,0,0,0) + ksOutputSubfolder + ":"		String symbolicPathName =  ksOutputSubfolder + "_sym"	PathInfo $symbolicPathName	if  (!V_flag || !stringmatch(s_path,outputPath))		Print "making new path"		newpath/Q $symbolicPathName, outputPath	endif			SVAR soughtList	String loadList=soughtList	 //	ControlInfo/W=filePanel fd_overwriteOnLoadCB// 	Variable forceOverwrite = V_value	String files = indexedfile($symbolicPathName,-1,".ibw"),loadFails=""	Variable i,maxNum=itemsinlist(files),attempts=0	String file,wname,loadedWvs=""	for (i=0;i<maxNum;i+=1)		file=stringfromlist(i,files)		wname=stringfromlist(0,file,".")	//	if (forceOverwrite || !WaveExists($wname))		if (WhichListItem(wname,loadList) < 0)		//skip files that aren't sought			continue		endif		attempts+=1		loadwave/h/w/q/o/p=$symbolicPathName file				if (V_flag==0)			loadFails+=wname+";"		else			loadedWvs+=s_wavenames			soughtList = removefromlist(loadedWvs,soughtList)		endif	//	endif	endfor	print "fd_loadWin32Ibws() loadedWvs num",itemsinlist(loadedWvs)	if (itemsinlist(loadFails))		print "fd_loadWin32Ibws() wave failures N=",itemsinlist(loadFails),"of attempts", attempts,"failList:",loadFails	endif		fd_updateSweepsDisplay()endfunction disp_scaleBar_2ax(axis0,startProp0,scaleSize0,axis1,startProp1,scaleSize1,lineThick,winN)	String axis0		//first axis	Variable startProp0,scaleSize0 //starting proportion for line (offset into axis) and actual scale	String axis1	Variable startProp1,scaleSize1	//same for axis 1	Variable  lineThick; string winN		if (strlen(axis0) < 1)		axis0="bottom"	endif	if (strlen(axis1) < 1)		axis1="left"	endif		if (strlen(winN) < 1)		winN=winname(0,1)	endif		if (numtype(lineThick))		lineThick=2	endif		disp_scaleBar(axis0,startProp0,scaleSize0,lineThick,axis1,startProp1,winN)	disp_scaleBar(axis1,startProp1,scaleSize1,lineThick,axis0,startProp0,winN)endfunction disp_scaleBar(axis,startProp,scaleSize,lineThick,orthoAxis,orthoProp,winN)	String axis	Variable startProp	//how far into axis range before it starts (its offset)	Variable scaleSize		//size to make it -- pass a negative value to scale by proporton. negative values should probably range from -1 <= scaleSize < 0, though negative values beyond -1 are allowed	Variable lineThick		//thickness of line	String orthoAxis		//orthoganl axis position	Variable orthoProp		//how far along that axis to place it	String winN		//window or "" for top		Variable niceRounding = 1		//by default the scale bar size is going to be rounded if scaleByProportion is being used, set to zero to turn this off	Variable scaleByProportion=scaleSize < 0		if (strlen(winN) < 1)		winN=winname(0,1)	endif		if (numtype(lineThick))		lineThick=2	endif		String info=AxisInfo(winN, axis)	String axType=stringbykey("axtype",info)	Variable isY = stringmatch(axType,"left") || stringmatch(axType,"right")		String orthoAxInfo=axisinfo(winN,orthoAxis)	Variable hasOrtho=itemsinlist(orthoAxInfo) > 0	getaxis/q/W=$winN $axis	Variable range = v_max - v_min	Variable startval = v_min + startProp*range		if (scaleByProportion)		Variable prop=scaleSize * -1		scaleSize = range *prop		if (niceRounding)			scaleSize=num_niceRounding(scaleSize)		endif				print "disp_scaleBar() picked a scale bar size for axis",axis,"of",scaleSize,"(proportion",prop,selectstring(niceRounding,"","after rounding"),")"	endif		Variable endval=startval + scaleSize	if (hasOrtho)		getaxis/q/w=$winN $orthoAxis		Variable orthoRange=V_max-V_min		Variable orthoPos=v_min + orthoProp*orthoRange		if (isY)			setdrawenv/w=$winN ycoord=$axis,xcoord=$orthoAxis,lineThick=lineThick			drawline/w=$winN orthoPos,startval,orthoPos,endval		else			setdrawenv/w=$winN xcoord=$axis,ycoord=$orthoAxis,lineThick=lineThick			drawline/w=$winN startVal,orthoPos,endval,orthoPos		endif	endifendfunction num_niceRounding(num)	Double num		return num_roundToSigDigs(num,1)end//based on the java code below found at https://stackoverflow.com/questions/202302/rounding-to-an-arbitrary-number-of-significant-digitsfunction num_roundToSigDigs(num,sigDigs)	Double num; Variable sigDigs		if (num==0)		return 0	endif		Double d = ceil(log(abs(num)))	Double power = round(sigDigs - round(d))	Double magnitude = 10^power	Double shifted = round(num*magnitude)	return shifted / magnitude	//	public static double roundToSignificantFigures(double num, int n) {//    if(num == 0) {//        return 0;//    }////    final double d = Math.ceil(Math.log10(num < 0 ? -num: num));//    final int power = n - (int) d;////    final double magnitude = Math.pow(10, power);//    final long shifted = Math.round(num*magnitude);//    return shifted/magnitude;//}//endendfunction disp_widthHeight(width,height[n])	Variable width,height	Variable n		Variable i,num; string list	if (ParamIsDefault(n))		num=1		list=winname(0,1)	else		list=WinList("*", ";", "" )		num=n	endif		String winN	for (i=0;i<num;i+=1)		winN=stringfromlist(i,list)		modifygraph/w=$winN width=72*width,height=72*height	endfor	end//stats averaged across rows -- note that NaNs are okfunction/WAVE wave_colStats(wv,startRow,endRow,startCol,endCol,outRef,[list,listRepsOutRef,residualsOutRef,snrSignalWv,signalResRef,bsx,bex,normalize,normalityTest,normIgnoreZero])	WAVE wv; Variable startRow,endRow,startCol,endCol	string outRef	String residualsOutRef		//optionally pass a ref to store average-subtracted residuals for each column 	WAVE snrSignalWv				//optionally pass an snr signal wave to calculate SNR using this as well as using average	String signalResRef			//optionally pass a ref to store snrSIgnalWv-subtracted residuals for each column. REQUIRES snrSignalWv	String list					//optionally pass a list of waves that will each be treated as a column	String listRepsOutRef		//optionally pass a place to save the result of concatenating list reps	Variable bsx,bex			//optionally specify a baseline average window 	Variable normalize		//pass to normalize each wave to its peak before averaging	Variable normalityTest	//pass to check for normality within each row (normality of residuals)	Variable normIgnoreZero		//ignore DC in normalize==1, helpful for ignoring DC in power spectra		Variable doNormalization = !paramisdefault(normalize) && normalize		Variable doBasesub = !PAramIsDefault(bsx) && !ParamIsDefault(bex)	Variable doNormality=!PAramIsDefault(normalityTest) && normalityTest	Variable numNormalityStats = 6		//must match stats_ksNormalityTest output #rows			if (!ParamISDefault(list))		concatenate/o/np=1/dl/free list,tempWv		WAVE wv=tempWv	endif			if (!PAramIsDefault(listRepsOutRef) && (strlen(listRepsOutRef)>0) )		duplicate/o wv,$listRepsOutRef	endif		String removeStats="numNaNs;numInfs;startLayer;endLayer;startChunk;endChunk;startCol;endCol;startRow;endRow;maxLayerLoc;minLayerLoc;minChunkLoc;maxChunkLoc;minColLoc;maxColLoc;"		wavestats/w/r=[0,1]/q wv;WAVE M_wavestats; variable numstats=dimsize(m_wavestats,0)	endrow = min(dimsize(wv,0),endrow)	if (strlen(outref)>0)		duplicate/o/r=[startrow,endrow-1][0] wv,$outref/wave=out	else		duplicate/o/r=[startrow,endrow-1][0]/free wv,out	endif	redimension/n=(-1,numstats) out	dl_lblsToLbls("m_wavestats",0,0,inf,"",1,0,"",0,forceToWv=out)			variable i,j,rowcount=0	Double grandAvg=0		variable cols=dimsize(wv,1)		String bsAvgRef="wave_colStats_bsa"	if (doBaseSub)		duplicate/o wv,$bsAvgRef/wave=wv		for (i=0;i<cols;i+=1)			wavestats/rmd=(bsx,bex)[i]/q/m=1 wv			wv[][i] -= V_Avg		endfor	endif		String normAvgRef="wave_colStats_norm"	Variable start = (!ParamIsDefault(normIgnoreZero) && normIgnoreZero) ? 1 : 0	if (doNormalization)		duplicate/o wv,$normAvgRef/wave=wv		for (i=0;i<cols;i+=1)			wavestats/rmd=[start,*][i]/q/m=1 wv			wv[][i] /= V_max		endfor		duplicate/o wv,checkwv	endif			if (doNormality)		redimension/n=(-1,numStats+numNormalityStats) out	endif		for (i=startrow;i<endrow;i+=1)		wavestats/rmd=[i][startcol,endcol]/q/w wv		out[i-startRow][0,numStats-1]=m_wavestats[q]			grandAvg+=V_avg				if (doNormality)			duplicate/o/free/r=[i][startCol,endCol] wv, trTemp			matrixtranspose trTemp			redimension/n=(-1) trTemp			wavetransform/O zapnans,trTemp			WAVE normalityWv= stats_ksNormalityTest(trTemp , 0.05,"")			if (i==startRow)				dl_lblsToLbls("",0,0,numNormalityStats,"",1,numStats,"normality_",1,forceToWv=out,forceFromWv=normalityWv)			endif						out[i-startRow][numStats,]=normalityWv[q-numStats]		endif				rowcount+=1	endfor	grandAvg/=rowcount		Variable lblCol,numToRemove=itemsinlist(removeStats); string lbl	for (i=0;i<numToRemove;i+=1)		lbl=stringfromlist(i,removeStats)		lblCol=finddimlabel(out,1,lbl)		if (lblCol > -1)			DeletePoints/M=1 lblCol, 1, out		endif	endfor		numstats=dimsize(out,1)	redimension/n=(-1,numStats+4) out	setdimlabel 1,numStats,avgNoDC,out	setdimlabel 1,numstats+1,sqAvgNoDC,out	setdimlabel 1,numStats+2,var,out	setdimlabel 1,numStats+3,snr,out	out[][%avgNoDC]=out[p][%avg] - grandAvg		//avgNoDC_orSignal		out[][%sqAvgNoDC]=out[p][%avgNoDC]^2	out[][%var]=out[p][%sdev]^2				//variance no DC	out[][%snr]=out[p][%sqAvgNoDC] / out[p][%var]	Variable hasSnrWv=!ParamIsDefault(snrSignalWv) && waveexists(snrSignalWv)	if (hasSnrWv)		//calculate residuals of reps from signal				if (!ParamIsDefault(signalResRef) && (strlen(signalResRef)>0))		//store residuals			duplicate/o wv,$signalResRef/wave=res_sig		else			duplicate/o/free wv,res_sig		endif		res_sig = wv[p][q] - snrSignalWv[p]		Variable numCols=dimsize(res_sig,1)		matrixop/o/free signalResSumSquares= sumrows(powR(res_sig,2))		signalResSumSquares/=numCols						//baseline subtract signal		Double signalMean=mean(snrSignalWv)				Variable prevCols=dimsize(out,1)		redimension/n=(-1,prevCols+5) out		setdimlabel 1,prevCols,signalVal,out		setdimlabel 1,prevCols+1,signalValNoDC,out		setdimlabel 1,prevCols+2,sqSignalValNoDC,out		setdimlabel 1,prevCols+3,sumSqResFromSignal,out		setdimlabel 1,prevCols+4,snr_relSignal,out						out[][%signalVal]=snrSignalWv[p]		out[][%signalValNoDC]=snrSignalWv[p]-signalMean		out[][%sqSignalValNoDC]=out[p][%signalValNoDC]^2		out[][%sumSqResFromSignal]=signalResSumSquares[p][0]		out[][%snr_relSignal]=out[p][%sqSignalValNoDC]/out[p][%sumSqResFromSignal]	endif			if (!ParamIsDefault(residualsOutRef) && (strlen(residualsOutRef)>0))		duplicate/o wv,$residualsOutRef/wave=res		res = wv[p][q] - out[p][%avg]	endif		if (!ParamIsDefault(signalResRef) && (strlen(signalResRef)>0))		if (hasSnrWV)			duplicate/o wv,$signalResRef/wave=res_sig			res_sig = wv[p][q] - snrSignalWv[p]			endif	endif		if (doBaseSub)		killwaves/Z $bsAvgRef	endif		return outendfunction wave_keepUsedRowsAndLblsOnly(wv,outRef)	wave/t wv; string outRef	wave allowedCols //e.g. {0} to ignore whether first col is filled		Variable i,rows=dimsize(wv,0),cols=dimsize(wv,1),count=0,isUsed	make/o/free/n=(cols) multiplier,summed 	//multiplier sets to zero indexes that can be empty, summed will be summed to see if indexes are filled	multiplier = 1	multiplier[allowedCols] = 0			for (i=0;i<rows;i+=1)		summed = strlen(wv[i][p]) > 0	//get all data cols		summed *= multiplier		isUsed = sum(summed) > 0		if (isUsed)			if (count == 0)		//first row, just copy over				duplicate/o/r=[i][] wv,$outref/wave=out			else				duplicate/o/free/r=[i][] wv, temp				concatenate/dl/np=0 {temp},out			endif			count+=1		endif		endfor	print "wave_keepUsedRowsAndLblsOnly count",countend//copy rows from one fromWv to toWv (overwriting those rows in toWv)//copying only rows that have the same value in matchCol//combine with wave_keepUsedRowsAndLblsOnly() for just matching "used" rowsfunction wave_transferRowsByMatchingCol(fromWv,toWv,matchCol,outRef)	WAVE/t fromWv,toWv	Variable matchCol	String outRef		//can be "" to act on toWv directly			if (strlen(outRef) > 0)		duplicate/o/t toWv,$outRef/wave=finalOutWv	else		WAVE/t finalOutWv = toWv	endif		Variable i,rows_to=dimsize(toWv,0),count=0	duplicate/o/free/r=[][matchCol] fromWv,matchWave	//search wave	redimension/n=(-1) matchWave	string matchstr	for (i=0;i<rows_to;i+=1)		matchstr=toWv[i][matchCol]		findvalue/TEXT=(matchStr)/TXOP=2 matchWave		if (V_Value > -1)			finalOutWv[i][] = fromWv[v_Value][q]			SetDimLabel 0,i,$GetDimLabel(fromWv, 0, v_Value ),finalOutWv 			count+=1		endif	endfor	print "wave_transferRowsByMatchingCol count",countendfunction coords_getRotatedX(x,y,deg)	Double x,y,deg		Double rad = deg * 2*pi/360		return x*cos(rad) + y*sin(rad)endfunction coords_getRotatedY(x,y,deg)	Double x,y,deg		Double rad = deg * 2*pi/360		return y*cos(rad) - x*sin(rad)end//rotate a wave of x,y cartesian coordinates. expects those coords are two columns with x,y pairs//requires 2 additional columns where rotated coordinates are stored. these must already be displayed//in order to see updates//controls://angular rotation origin (x,y) -- setvariables//angular rotation -- slider//offset x,y -- setvariables//offset yFunction disp_rotationControl(win,ref,xCol_orig,yCol_orig,xCol_rot,yCol_rot)	String win,ref	//ref to rotate	Variable xCol_orig,yCol_orig,xCol_rot,yCol_rot		if (strlen(win) < 1)		win=winname(0,1)	endif		String panelN = ref + "_ROT"	String boxN = ref + "_ROT"				NewPanel/N=$panelN/W=(150,50,501,285)/k=1	panelN=S_name		slider angleSlide,pos={0,0},size={20,170},limits={-360,360,1},value=0,proc=disp_rotationControlSA,win=$panelN,ticks=5,side=2	setvariable angleSet,pos={20,172},size={55,20},limits={-360,360,1},win=$panelN,value=_NUM:0,title="º",proc=disp_rotationControlSVA	setvariable rotOrigin_X,pos={20,191},size={55,20},limits={-inf,inf,0.1},win=$panelN,value=_NUM:0,title="x"	setvariable rotOrigin_Y,pos={20,209},size={55,20},limits={-inf,inf,0.1},win=$panelN,value=_NUM:0,title="y"		setwindow $panelN,userdata(win)=win	setwindow $panelN, userdata(ref)=ref	setwindow $panelN, userdata(boxN)=boxN	setwindow $panelN, userdata(xCol_orig)=num2str(xCol_orig)	setwindow $panelN, userdata(yCol_orig)=num2str(yCol_orig)	setwindow $panelN, userdata(xCol_rot)=num2str(xCol_rot)	setwindow $panelN, userdata(yCol_rot)=num2str(yCol_rot)endfunction disp_rotationControlSVA(S) : SetVariableControl	STRUCT WMSetVariableAction &s			disp_rotationControlUpdate(s.win,0,s.dval)endfunction disp_rotationControlSA(s) : SliderControl	STRUCT WMSliderAction &s		disp_rotationControlUpdate(s.win,1,s.curval)endfunction disp_rotationControlUpdate(panelN,callFromSliderNotSetVar,angle)	STring panelN	Variable callFromSliderNotSetVar		//1 for slider, 0 for set val	Variable angle		//keep slider and setvar yoked	if (callFromSliderNotSetVar)		setvariable angleSet,win=$panelN,value=_NUM:angle	else		slider angleSlide,win=$panelN,value=angle	endif	controlinfo/w=$panelN rotOrigin_X	Variable rotOrigin_X = V_value	controlinfo/w=$panelN rotOrigin_Y	Variable rotOrigin_Y = V_value			String win=getuserdata(panelN,"","win")	String ref=getuserdata(panelN,"","ref")	String boxN=getuserdata(panelN,"","boxN")	Variable xCol_orig=str2num(getuserdata(panelN,"","xCol_orig"))	Variable yCol_orig=str2num(getuserdata(panelN,"","yCol_orig"))	Variable xCol_rot=str2num(getuserdata(panelN,"","xCol_rot"))	Variable yCol_rot=str2num(getuserdata(panelN,"","yCol_rot"))	WAVe wv=$ref		wv[][xCol_rot]=coords_getRotatedX(wv[p][xCol_orig]-rotOrigin_X,wv[p][yCol_orig]-rotOrigin_Y,angle)	wv[][yCol_rot]=coords_getRotatedY(wv[p][xCol_orig]-rotOrigin_X,wv[p][yCol_orig]-rotOrigin_Y,angle)		//store choice	String angleStr=num2str(angle)	setwindow $panelN, userdata(rotationAngle)=angleStr	String noteStr=note(wv)	noteStr=replacestringbykey("disp_rotationControl_ANGLE",notestr,angleStr)	note/k wv,notestr		TextBox/W=$win/C/N=$boxN/F=0/A=MC "ROTATION= "+angleStr+"º"endfunction/S wave_getSizeList(outRef)	string outref			String waves = wavelist("*",";","")	Variable numwaves=itemsinlist(waves)	make/o/n=(numwaves,6) $outref/wave=out	make/o/t/free/n=(numwaves) sortNames = stringfromlist(p,waves)		setdimlabel 1,0,numpnts,out	out[][0] = numpnts($stringfromlist(p,waves))	setdimlabel 1,1,nullNumericTextDfWaverefs,out	out[][1] = wavetype($stringfromlist(p,waves),1)	setdimlabel 1,2,textOrBitTypeValues,out	out[][2] = wavetype($stringfromlist(p,waves))	setdimlabel 1,3,float32,out	out[][3] = ( out[p][2] & 2^1 )  > 0	setdimlabel 1,4,float64,out	out[][4] = ( out[p][2] & 2^2 )  > 0	setdimlabel 1,5,estSize,out	out[][5] = sizeOfType(out[p][2]) * out[p][0]		sortcolumns/kndx={5,0,1,4,3}/R sortwaves={out,sortNames}		variable i	for (i=0;i<numwaves;i+=1)		setdimlabel 0,i,$sortnames[i],out	endfor		return nameofwave(out)endfunction img_splitLayers(img,numOutputImages,outBaseName)	WAVE img; Variable numOutputImages;string outBaseName	//	String outBaseName=nameofwave(img)+"_L"	Make/o/t/n=(numOutputImages)/free outNames=outBaseName+num2str(p)		Variable numLayers=dimsize(img,2),i,outputLayer	String outName	for (i=0;i<numLayers;i+=1)		outName=outNames[mod(i,numOutputImages)]		imagetransform/p=(i) getPlane img		if (i==0)			WAVE M_ImagePlane		endif		if (i<numOutputImages)		//first use of each output image, create them			Duplicate/o M_imagePlane, $outName		else			concatenate/np=2 {M_imagePLane},$outname		endif	endforendfunction dmd_wvToTxt(wv,depth,pathStr)	WAVE Wv	Variable depth	//bit depth	String pathSTr		Variable minDist=5	Variable avgDist=5.5		Variable i,rows=dimsize(wv,0),j,cols=dimsize(wv,1),k,layers=dimsize(Wv,2)	print "rows",rows,"cols",cols,"layers",layers	PathInfo/S $pathStr	if (!V_Flag)								//this checks that the global string 		newpath $pathStr		if (V_flag > 0)			Print "dmd_waveToTxt() failed to set save path. aborting"			return 0		endif	endif		Variable fileRefNum	Open/P=$pathStr fileRefNum		fprintf fileRefNum,"MightexVector1.0 \r\n"	fprintf fileRefNum,"# Mightex Sample Vector file for %u x %u grid scan.\r\n", cols,rows	fprintf fileRefNum,"# Minimum Distance = %f, Average Distance = %f\r\n",minDist,avgDist	fprintf fileRefNum,"# Type and BitDepth\r\n"	fprintf fileRefNum,"Grid\r\n"	fprintf fileRefNum,"%u\r\n",depth	fprintf fileRefNum,"# Columns and Rows\r\n"	fprintf fileRefNum,"%u\r\n",cols	fprintf fileRefNum,"%u\r\n",rows			String patternStart="#======== Pattern "	String patternEnd=" ========\r\n"	String firstRowStartStr="Bin\t"	String otherRowsStartStr="\t"	String rowEndStr=";\r\n"	String d=" "		//delimiter	Variable startPos,endPos		Variable colsOver100 = cols > 100	Variable colsMod100,colsOf100,noColMod	String normColsStr,lastColsStr,normColsStr_lastCol	if (colsOver100)		//much slower case to deal with		colsOf100=floor(cols/100)		colsMod100=mod(cols,100)		normColsStr=text_Getrepeatedstr("%u ",100)			lastColsStr=text_Getrepeatedstr("%u ",colsMod100)			lastColsStr=lastColsStr[0,strlen(lastColsStr)-2]	//remove last space		normColsStr_lastCol = normColsStr[0,strlen(normColsStr)-2]	 //remove last space .. this is only used when cols is a multiple of 100		noColMod=colsMod100 == 0	else		normColsStr=text_Getrepeatedstr("%u ",cols)		normColsStr=normColsStr[0,strlen(normColsStr)-2]		endif	for (k=0;k<layers;k+=1)		fprintf fileRefNum,patternStart+"%u"+patternEnd,k		imagetransform/P=(k) getPlane wv		if (k==0)			WAVE M_ImagePlane			redimension/n=(-1,-1) M_imagePlane		endif				if (colsOver100)			for (i=0;i<rows;i+=1)				if (i==0)					fprintf fileRefNum,firstRowStartStr				else					fprintf fileRefNum,otherRowsStartStr				endif							for (j=0;j<colsOf100;j+=1)					duplicate/o/r=[i,i][j*100,(j+1)*100-1]/free M_imagePlane,temp										if (noColMod && (j == colsOf100-1)) //is this the last column?						wfprintf fileRefNum,normColsStr_lastCol,temp					else						wfprintf fileRefNum,normColsStr,temp					endif				endfor								if (!noColMod)					duplicate/o/r=[i,i][j*100,j*100+colsMod100-1]/free M_imagePlane,temp					wfprintf fileRefNum,lastColsStr,temp				endif								fprintf fileRefNum,rowEndStr			endfor				else					wfprintf fileRefNum,firstRowStartStr+normColsStr+rowEndStr/R=[0,0],M_imagePlane			if (rows > 1)				wfprintf fileRefNum,otherRowsStartStr+normColsStr+rowEndStr/R=[1,rows-1],M_imagePlane			endif					endif			endforend//USE 854 rows x 480 columns for full resolution, and use unsigned integers /u as wave type, so://make/o/u/n=(854,480) wvfunction dmd_wvToPng(list,pathStr)	String list		//list of waves	String pathStr	PathInfo/S $pathStr	if (!V_Flag)								//this checks that the global string 		newpath $pathStr		if (V_flag > 0)			Print "img_pixelGratingSet() failed to set save path. aborting"			return 0		endif	endif	Variable i,num=itemsinlist(list)	String ref,savename	for (i=0;i<num;i+=1)		ref=stringfromlist(i,list)		savename=ref+".png"		imagesave/t="png"/P=$pathStr $ref as savename	endforend	function dmd_pixelGratingSet(cycleLen_pix,pathStr,saveNAmeBaseStr,type)	Variable cycleLen_pix,type		//see switch for type	String pathStr,saveNAmeBaseStr			//information on DMD	Variable rows=854		//based on WVGA aspect ratio: 854	Variable cols=480		//based on WVGA aspect ratio: 480	Double pixelSize_um_4x=3.72549019607843	//from a 200 by 200 command square imaged and compared with stage micrometer image	Variable referenceMag = 4	Double pixelSize_um_1x=pixelSize_um_4x*referenceMag //from a 200 by 200 command square imaged and compared with 		//16.2		//this is best measured empirically 	Variable mag=referenceMag	//objective .. most accurate if this matches reference mag where calibration was performed		Double pixelSize_um=pixelSize_um_1x/mag			PathInfo/S $pathStr	if (!V_Flag)								//this checks that the global string 		newpath $pathStr		if (V_flag > 0)			Print "img_pixelGratingSet() failed to set save path. aborting"			return 0		endif	endif	make/o/n=(rows,cols)/free temp	string savename	Variable i		switch (type)		case 0:		//			for (i=0;i<cycleLen_pix;i+=1)				temp = mod(i+p,cycleLen_pix) / cycleLen_pix < 0.5				savename = saveNAmeBaseStr+num2str(i)+".png"				imagesave/t="png"/P=$pathStr temp as savename			endfor			break		case 1:	endswitchendstatic constant cap_levelSearchStartPos=0.02	//finds rising to new cycle from herestatic constant cap_stimFreq=1000static constant cap_analysisStartPosX=0.0215855static constant cap_detectorCycles=900//initial calibration -- get measurement phase angle, scale factorfunction/S cap_initCal(exStim,wc_cap_pF,wc_res_Mohm)	String exStim		//example stimulus, assumes all are equal but should check and maybe use an average or change to calc all	Double wc_cap_pF,wc_res_Mohm		//settings from wc compensation		WAVE stim = $exStim	Variable sampleLen = dimdelta(stim,0)	VAriable sRate = 1/sampleLen	Double stimCycleLen=1/cap_stimFreq	Double stimFreqRad = 2*pi*cap_stimFreq	Variable detectorLenX=cap_detectorCycles*stimCycleLen	Variable detectorPnts=detectorLenX*srate	Variable startPnt=x2pnt(stim,cap_analysisStartPosX)	Variable endPnt=startPnt+detectorPnts-1			make/o/n=(detectorPnts)/d cap_detector_stimPhase,cap_detector_stimOrtho,cap_detector,cap_detector_ortho	setscale/p x,cap_analysisStartPosX,sampleLen,"s",cap_detector_stimPhase,cap_detector_stimOrtho,cap_detector,cap_detector_ortho	cap_detector_stimPhase=sin(stimFreqRad*(x-cap_analysisStartPosX))	cap_detector_stimOrtho=cos(stimFreqRad*(x-cap_analysisStartPosX))		make/o/d/n=(10) cap_initVals	VAriable ii=-1	ii+=1;dl_assignAndLbl(cap_initVals,ii,sampleLen,"sampleLen")	ii+=1;dl_assignAndLbl(cap_initVals,ii,sRate,"sRate")	ii+=1;dl_assignAndLbl(cap_initVals,ii,stimCycleLen,"stimCycleLen")	ii+=1;dl_assignAndLbl(cap_initVals,ii,stimFreqRad,"stimFreqRad")	ii+=1;dl_assignAndLbl(cap_initVals,ii,detectorLenX,"detectorLenX")	ii+=1;dl_assignAndLbl(cap_initVals,ii,detectorPnts,"detectorPnts")	ii+=1;dl_assignAndLbl(cap_initVals,ii,startPnt,"startPnt")			ii+=1;dl_assignAndLbl(cap_initVals,ii,endPnt,"endPnt")	ii+=1;dl_assignAndLbl(cap_initVals,ii,wc_cap_pF,"wc_cap_pF")	ii+=1;dl_assignAndLbl(cap_initVals,ii,wc_res_Mohm,"wc_res_Mohm")endstatic constant inPhase_c=0static constant ortho_c=1static constant inPhase_1Mohm_c=2static constant ortho_1Mohm_c=3static constant inPhase_100fF_c=4static constant ortho_100fF_c=5static constant deltaInPhase_1Mohm_c=6static constant deltaOrtho_1Mohm_c=7static constant resNormFactor_c=8static constant deltaInPhase_100fF_c=9static constant deltaOrtho_100fF_c=10static constant capNormFactor_c=11static constant lastCapCalRow_c=12static constant lastResCalRow_c=13static constant totalCap_c=14static constant totalRes_c=15static constant deltaCap_c=16static constant deltaRes_c=17static constant deltaCapCorrected_c=18static constant totalCapCorrected_c=19static constant cap_CF_c=20function cap_measure(respList_0Mohm,phase_rad,respList_1Mohm,last100fFRow,respList_100fF,restart,baselineRow)	STring respList_0Mohm			//response under normal conditions (only required list)	Variable phase_rad					//phase in radians of access resistance component; pass if not passing a respList_1Mohm. If that list is passed, it is used to recalculate phase_rad	STring respList_1Mohm			//pass to recalculate phase of access resistance component	Variable last100fFRow				//row in resultsRef of last Cm calibration; pass if not passing a respList_100fF -- could often be zero	String respList_100fF			//pass to recalibrate capacitance value	Variable restart					//pass to restart analysis	Variable baselineRow			//row that is baseline for subtraction -- usually zero or start of a given measurement		WAVE civ=$"cap_initVals"		Variable numUniqueParams=21		//num params not including baseline subtraction	String resultsRef="cap_results"	Variable row,rows	String resultsNote	if (restart || !waveExists($resultsRef))		//Print "cap_measure() new results wave created, resultsRef:",resultsRef		make/o/d/n=(1000,numUniqueParams*2) $resultsRef/wave=results		results=nan		row=0		setdimlabel 1,inPhase_c,inPhase,results		setdimlabel 1,ortho_c,ortho,results		setdimlabel 1,inPhase_1Mohm_c,inPhase_1Mohm,results		setdimlabel 1,ortho_1Mohm_c,ortho_1Mohm,results		setdimlabel 1,inPhase_100fF_c,inPhase_100fF,results		setdimlabel 1,ortho_100fF_c,ortho_100fF,results		setdimlabel 1,deltaInPhase_1Mohm_c,deltaInPhase_1Mohm,results		setdimlabel 1,deltaOrtho_1Mohm_c,deltaOrtho_1Mohm,results		setdimlabel 1,resNormFactor_c,resNormFactor,results		setdimlabel 1,deltaInPhase_100fF_c,deltaInPhase_100fF,results		setdimlabel 1,deltaOrtho_100fF_c,deltaOrtho_100fF,results		setdimlabel 1,capNormFactor_c,capNormFactor,results		setdimlabel 1,lastCapCalRow_c,lastCapCalRow,results		setdimlabel 1,lastResCalRow_c,lastResCalRow,results		setdimlabel 1,totalCap_c,totalCap,results		setdimlabel 1,totalRes_c,totalRes,results		setdimlabel 1,deltaCap_c,deltaCap,results		setdimlabel 1,deltaRes_c,deltaRes,results		setdimlabel 1,deltaCapCorrected_c,deltaCapCorrected,results		setdimlabel 1,totalCapCorrected_c,totalCapCorrected,results		setdimlabel 1,cap_CF_c,cap_CF,results		dl_lblsToLbls(resultsRef,1,0,numUniqueParams,resultsRef,1,numUniqueParams,"_bs",0)		resultsNote=""	else		WAVE results = $resultsRef		resultsNote=note(results)		row=numberbykey("row",resultsNote)		rows=dimsize(results,0)		if (row >= rows)			redimension/n=(rows+1000,-1) results			results[row,][]=nan		endif	endif			//FIND CURRENT PHASE OF ACCESS RESISTANCE COMPONENT -- and make detectors		Double real_0Mohm,imag_0Mohm	Double real_1Mohm,imag_1Mohm	Double real_delta1Mohm,imag_delta1Mohm	Double mag_1Mohm,phase_1Mohm	Double real_100fF,imag_100fF	Variable has1MohmTest=itemsinlist(respList_1Mohm) > 0	Variable has100fFTest=itemsinlist(respList_100fF) > 0	if (has1MohmTest)			//CAP INIT MUST BE RUN TO GENERATE cap_detector_stimPhase,cap_detector_stimOrtho,cap_initVals (which is civ here)		cap_getAvgVector("cap_detector_stimPhase","cap_detector_stimOrtho",respList_0Mohm,civ[%startPnt],civ[%endPnt],real_0Mohm,imag_0Mohm)		cap_getAvgVector("cap_detector_stimPhase","cap_detector_stimOrtho",respList_1Mohm,civ[%startPnt],civ[%endPnt],real_1Mohm,imag_1Mohm)		real_delta1Mohm=real_1Mohm-real_0Mohm		imag_delta1Mohm=imag_1Mohm-imag_0Mohm		mag_1Mohm=sqrt(real_delta1Mohm^2+imag_delta1Mohm^2)		phase_rad=atan(imag_delta1Mohm/real_delta1Mohm)	else		if (numtype(phase_rad))			print "cap_measure() UNEXPECTED LACK OF PHASE INFORMATION.. phase_rad parameter is not a real number and no 1Mohm response was passed! May fail unless detectors are premade properly"		endif	endif	Variable stimFreqRad=civ[%stimFreqRad]	WAVE cap_detector,cap_detector_ortho		//created by cap_init	cap_detector=sin(stimFreqRad*(x-cap_analysisStartPosX)+phase_rad)		//capacitance is (approximately) orthogonal to series resistance vector	cap_detector_ortho=cos(stimFreqRad*(x-cap_analysisStartPosX)+phase_rad)		//series resistance is in phase with itself			Double inPhase=nan,ortho=nan,inPhase_1Mohm=nan,ortho_1Mohm=nan,inPhase_100fF=nan,ortho_100fF=nan	Double deltaInPhase_1Mohm=nan,deltaOrtho_1Mohm=nan,resNormFactor=nan	Double deltaInPhase_100fF=nan,deltaOrtho_100fF=nan,capNormFactor=nan		//MAIN MEASUREMENT	cap_getAvgVector("cap_detector","cap_detector_ortho",respList_0Mohm,civ[%startPnt],civ[%endPnt],inPhase,ortho)		//RECALIBRATE ACCESS IF POSSIBLE	Variable lastResCalRow	if (has1MohmTest)		cap_getAvgVector("cap_detector","cap_detector_ortho",respList_1Mohm,civ[%startPnt],civ[%endPnt],inPhase_1Mohm,ortho_1Mohm)		deltaInPhase_1Mohm=inPhase_1Mohm-inPhase		deltaOrtho_1Mohm=ortho_1Mohm-ortho		resNormFactor=deltaOrtho_1Mohm/1		//resistance is approximately orthogonal to capacitance..this is ortho per MOhm		lastResCalRow=row	else		if (row == 0)			print "cap_measure() WARNING INITIALIZATION WITHOUT ACCESS RESISTANCE CALIBRATION"		else			lastResCalRow=results[row-1][lastResCalRow_c]			resNormFactor=results[row-1][resNormFactor_c]		endif	endif		//RECALIBRATE CAPACITANCE IF POSSIBLE	Variable lastCapCalRow	if (has100fFTest)		cap_getAvgVector("cap_detector","cap_detector_ortho",respList_100fF,civ[%startPnt],civ[%endPnt],inPhase_100fF,ortho_100fF)		deltaInPhase_100fF=inPhase_100fF-inPhase		deltaOrtho_100fF=ortho_100fF-ortho		capNormFactor=deltaInPhase_100fF/0.1		//capacitance is approximately in phase with itself (hopefully!) .. this is delta per pF		lastCapCalRow=row	else		if (row == 0)			print "cap_measure() WARNING INITIALIZATION WITHOUT CAPACITANCE CALIBRATION"		else			lastCapCalRow=results[row-1][lastCapCalRow_c]			capNormFactor=results[row-1][capNormFactor_c]		endif	endif		//calculate real values and totals	Double deltaCap=inPhase/capNormFactor			//take delta and divide by delta/pF for pF	Double totalCap = civ[%wc_cap_pF]+deltaCap	Double deltaRes=ortho/resNormFactor				//take ortho and divide by ortho/Mohm for Mohm	Double totalRes = civ[%wc_res_Mohm]+deltaRes		Double totalCapForCal,lastCapCalCap,lastCapCalRes	Double cap_CF,deltaCapCorrected,totalCapCorrected	if (row==0)		//cap_CF is truly also zero if has100fFTest is true, but it's interesting to compare actual and anticipated values if possible		cap_CF=1	else		Variable lastRowHadCapCal = lastCapCalRow == row-1		//find best guess for current capacitance		if (lastRowHadCapCal)			//if last row had capacitance calibration, use that total capacitance			totalCapForCal=results[row-1][totalCap_c]				else								//otherwise, use the last row's corrected capacitance value			totalCapForCal=results[row-1][totalCapCorrected_c]		endif		lastCapCalCap=results[lastCapCalRow][totalCap_c]		lastcapCalRes=results[lastCapCalRow][ortho_c]		cap_CF=( totalCapForCal^2/lastCapCalCap^2 ) * ( lastcapCalRes/ortho )		deltaCapCorrected = capNormFactor*inPhase*cap_CF		totalCapCorrected = civ[%wc_cap_pF]+deltaCapCorrected	endif		print "totalCapForCal",totalCapForCal	results[row][inPhase_c]=inPhase	results[row][ortho_c]=ortho	results[row][inPhase_1Mohm_c]=inPhase_1Mohm	results[row][ortho_1Mohm_c]=ortho_1Mohm	results[row][inPhase_100fF_c]=inPhase_100fF	results[row][ortho_100fF_c]=ortho_100fF	results[row][deltaInPhase_1Mohm_c]=deltaInPhase_1Mohm	results[row][deltaOrtho_1Mohm_c]=deltaOrtho_1Mohm	results[row][resNormFactor_c]=resNormFactor	results[row][deltaInPhase_100fF_c]=deltaInPhase_100fF	results[row][deltaOrtho_100fF_c]=deltaOrtho_100fF	results[row][capNormFactor_c]=capNormFactor	results[row][lastCapCalRow_c]=lastCapCalRow	results[row][lastResCalRow_c]=lastResCalRow	results[row][totalCap_c]=totalCap	results[row][totalRes_c]=totalRes	results[row][deltaCap_c]=deltaCap	results[row][deltaRes_c]=deltaRes	results[row][deltaCapCorrected_c]=deltaCapCorrected	results[row][totalCapCorrected_c]=totalCapCorrected	results[row][cap_CF_c]=cap_CF		//calculate baseline subtracted values	results[row][numUniqueParams,2*numUniqueParams-1]=results[row][q-numUniqueParams]-results[baselineRow][q-numUniqueParams]	note/k/nocr results,replacestringbykey("row",resultsNote,num2str(row+1))		return phase_radendfunction cap_getAvgVector(inPhaseDetectorRef,orthoDetectorRef,refs,refStartPnt,refEndPnt,realVar,imagVar)	String inPhaseDetectorRef,orthoDetectorRef	String refs	VAriable refStartPnt,refEndPnt	Double &realVar,&imagVar		Variable hasInPhase=strlen(inPhaseDetectorRef) > 0	Variable hasOrtho=strlen(orthoDetectorRef) > 0	VAriable hasBoth = hasInPhase && hasOrtho	if (hasInPhase)		WAVE inPhaseDetector=$inPhaseDetectorRef	endif	if (hasOrtho)		WAVE orthoDetector=$OrthoDetectorRef	endif			realVar=0	imagVar=0	Variable i,num=itemsinlist(refs)	string respRef	if (hasBoth)		for (i=0;i<num;i+=1)			respRef=stringfromlist(i,refs)			WAVE resp=$respREf			matrixop/o/free subReg=subRange(resp,refStartPnt,refEndPnt,0,0)			matrixop/o/free subReg=subReg-mean(subReg)		//baseline subtract			matrixop/o/free temp = sum(inPhaseDetector*subReg)			realVar+=temp[0]			matrixop/o/free temp = sum(orthoDetector*subReg)			imagVar+=temp[0]		endfor		return 0	endif		if (hasInPhase)		for (i=0;i<num;i+=1)			respRef=stringfromlist(i,refs)			WAVE resp=$respREf			matrixop/o/free subReg=subRange(resp,refStartPnt,refEndPnt,0,0)			matrixop/o/free subReg=subReg-mean(subReg)		//baseline subtract			matrixop/o/free temp = sum(inPhaseDetector*subReg)			realVar+=temp[0]		endfor		return 0	endif			if (hasOrtho)		for (i=0;i<num;i+=1)			respRef=stringfromlist(i,refs)			WAVE resp=$respREf			matrixop/o/free subReg=subRange(resp,refStartPnt,refEndPnt,0,0)			matrixop/o/free subReg=subReg-mean(subReg)		//baseline subtract			matrixop/o/free temp = sum(inPhaseDetector*subReg)			imagVar+=temp[0]		endfor		return 0	endif	endfunction power_quickPower(list,ptsPerSegment,overlapPts,startX,endX,avgOutRef,repsOutRef)	String list,repsOutRef,avgOutRef	Variable ptsPerSegment,overlapPts,startX,endX		String out,ref	Variable i,num=itemsinlist(list),count=0	for (i=0;i<num;i+=1)		ref=stringfromlist(i,list)		dspperiodogram/pars/dslg/nodc=1/segn={(ptsPerSegment),(overlapPts)}/dest=powerTemp/R=((startX),(endX))/Q $ref		count+=1				if (i==0)			duplicate/o powerTemp,$avgOutRef/wave=avg,$repsOutRef		else			concatenate/np=1 {powerTemp},$repsOutRef			avg+=powerTemp		endif	endfor		powerTemp/=countend//replace list items, and unlike build in addlistitem()//pads with blank items as necessary to make sure that newItem is really the requested itemNum indexfunction/S text_setListItem(itemNum,newItem,list)	Variable itemNum		//list index to set	String newItem 	//new string to put in position	String list		//original list		String listSepStr=";"		//could make input parameter	String padStr=""				//default to adding empty strings	Variable num=itemsinlist(list)		String out		//simplest case: itemNum < num : just put in index	if (itemNum <= num)		if (itemNum < num)			out = removelistitem(itemNum,list,listSepStr)		else //the case where itemNum is the next in the list, no need to remove anything			out = list		endif		out = addlistitem(newItem,out,listSepStr,itemNum)			return out	endif		//itemNum > num	Variable i,numToAdd = itemNum-num	out=list	for (i=0;i<numToAdd;i+=1)		out+=padStr+listSepStr	endfor	out+=newItem+listSepStr		return outendfunction layout_appendGraphs(layoutName,graphMatchStr,numGraphs)	String layoutName; String graphMatchStr; Variable numGraphs		String layouts = winlist("*",";","WIN:4")	if (strlen(layoutName) < 1)		layoutName=stringfromlist(0,layouts)	else		if (whichlistitem(layoutName,layouts) < 0)		//no window of name, make new			newlayout/N=$layoutName			layoutname=s_name			print "layout_appendGraphs() new layout",layoutName		endif	endif		String graphs=winlist(graphMatchStr,";","WIN:1")	Variable i,numGraphsFound=itemsinlist(graphs)	Variable num=min(numGraphsFound,numGraphs)	String graphN	for (i=0;i<num;i+=1)		graphN = stringfromlist(i,graphs)		appendlayoutobject/w=$layoutName graph $graphN	endfor	endfunction/S wave_makeStep(wv,stepStartX,preStepVal,postStepVal,unitsStr,appendWin,vertAppendAx,doAppend,saveRef)	WAVE wv	Variable stepStartX	Double preStepVal,postSTepVal	String unitsStr,appendWin,vertAppendAx,saveRef	Variable doAppend		Variable useDelta=0		//"Width" of step -- useDelta=1 uses sampling rate, useDelta=0 uses a very very tiny width		if (strlen(appendWin) < 1)		appendWin=winname(0,1)	endif			if (strlen(vertAppendAx) < 1)		vertAppendAx="left"	endif		Variable startX=dimoffset(wv,0)	Variable pnts=dimsize(wv,0)	Variable delta=dimdelta(wv,0)	Variable preStepPnt=stepStartX- (usedelta ? delta : 1e-15)	Variable endX=startX + pnts*delta	String xUnits=waveunits(wv,0)	String outRef= selectstring(strlen(saveRef) < 1,saveRef,nameofwave(wv)+"_step")	outRef=wave_getUnusedName(outRef)	Make/o/d/n=(4,2) $outREf/wave=out	SetScale  d, 0, 1 ,unitsStr,out	SetScale  x, 0, 1 ,xUnits,out	setdimlabel 1,0,xVals,out	setdimlabel 1,1,yVals,out	setdimlabel 0,0,startPnt,out	setdimlabel 0,1,preStepPnt,out	setdimlabel 0,2,stepPnt,out	setdimlabel 0,3,endPnt,out	out[0][0]=startX;out[0][1]=preStepVal	out[1][0]=preStepPnt;out[1][1]=preStepVal	out[2][0]=stepStartX;out[2][1]=postStepVal	out[3][0]=endX;out[3][1]=postStepVal		String cmd	Variable isLeft = stringmatch(vertAppendAx,"L*")	if (isLeft)		if (doAppend)			appendtograph/L=$vertAppendAx/W=$appendWin out[][%yVals] vs out[][%xVals]		endif		cmd="appendtograph/L="+vertAppendAx+"/W="+appendWin+" "+outRef+"[][%yVals] vs "+outRef+"[][%xVals]"	else		if (doAppend)			appendtograph/R=$vertAppendAx/W=$appendWin out[][%yVals] vs out[][%xVals]		endif		cmd="appendtograph/R="+vertAppendAx+"/W="+appendWin+" "+outRef+"[][%yVals] vs "+outRef+"[][%xVals]"	endif			return cmdend//returns an unused wave name based on reffunction/S wave_getUnusedName(ref)	String ref	String out=ref	Variable i,attLimits=10000	for (i=0;i<attLimits;i+=1)		if (waveexists($out))			break		endif		out=ref+num2str(i)	endfor		return refendfunction TransAx_dimFlashScale18051800_FA1(w,x)	WAVE w; Variable x				return x*0.011355*10^15end//function fft_power_forcePars(sourceWv,powerWv)//	WAVE sourceWv,powerWv//	//	Duplicate/FREE powerWv,wp	// Preserve original//	wp[0]/=2				// Correct the 0 bin//	wp[numpnts(wp)-1] /=2		// Correct the Nyquist bin//	MatrixOP/FREE sourceMagSqr=magsqr(sourceWv)/numPoints(sourceWv)//	Double sourceSum=sum(sourceMagSqr)//	Double powerSum=sum(wp)//	Double scale = sourceSum/powerSum//	powerWv*=scale	//	String scaleStr//	sprintf scaleStr,"%20.20f",scale//	note/nocr powerWv,"fft_power_forcePars_scaled:"+scaleStr+";"//	CheckNormalization(sourceWv,powerWv)//endfunction fft_power_safeConvolve(srcWv,convWv,outRef)	WAVE srcWv	WAVE convWv		//	STring outREf		fft/free/dest=src_fd srcWv	fft/free/dest=conv_fd convWv	conv_fd*=src_fd	ifft/free/dest=conv_td conv_fd	dspperiodogram/pars/dest=$outRef conv_tdend	function analysis_thresholdFromSnrPowerSpecs(signalPower,noisePower,out_snrSpectrum,out_stats,startHz,endHz)	WAVE signalPower	WAVE noisePower	String out_snrSpectrum	VAriable startHz,endHZ	String out_stats		Variable srateSignal=1/dimdelta(signalPower,0)	Variable srateNoise=1/dimdelta(noisePower,0)	Variable lowerHzSignal=dimoffset(signalPower,0)	lowerHzSignal=lowerHzSignal<startHz? startHz : lowerHzSignal	variable higherHzSignal=lowerHzSignal+dimsize(signalPower,0)/sRateSignal	higherHzSignal=higherHzSignal>endHz?endHz : higherHzSignal	Variable lowerHzNoise=dimoffset(noisePower,0)	lowerHzNoise=lowerHzNoise<startHz?startHz :  lowerHzNoise	variable higherHzNoise=lowerHzNoise+dimsize(noisePower,0)/sRateNoise	higherHzNoise=higherHzNoise>endHz?endHz : higherHzNoise	variable intepolate=srateSignal!=srateNoise	Variable interpoleToNoise		if (intepolate)		interpoleToNoise = srateNoise < srateSignal		//interpolate to lower srate		if (interpoleToNoise)				duplicate/o/free noisePower,signalPower_I;interpolate2/I=3/Y=signalPower_I signalPower;			duplicate/o/free noisePower,noisePower_I		//just for naming consistency		else			duplicate/o/free signalPower,noisePower_I;interpolate2/I=3/Y=noisePower_I noisePower;			duplicate/o/free signalPower,signalPower_I		endif	else		duplicate/o/free noisePower,noisePower_I			duplicate/o/free signalPower,signalPower_I	endif		duplicate/o/free signalPower_I,snrSpectrum	snrSpectrum=signalPower_I/noisePower_I		Double snrPower=area(snrSpectrum,startHz,endHz)	Double snr=sqrt(snrPower)	Double threshold=1/snr		Double signalTotalPower=area(signalPower_I,startHz,endHz)	Double signal=sqrt(signalTotalPower)	Double noiseTotalPower=area(noisePower_I,startHz,endHz)	Double noise=sqrt(noiseTotalPower)	Double snr2=signal/noise	Double threshold2=1/snr2		if (strlen(out_snrSpectrum) > 0)		duplicate/o snrSpectrum,$out_snrSpectrum	endif		print "snr",snr,"threshold",threshold,"snr2",snr2,"threshold2",threshold2,"signal",nameofwave(signalPower),"noise",nameofwave(noisePower)		if (strlen(out_stats) > 0 )		make/o/d/n=(11) $out_stats/wave=out		Variable i		i=-1		i+=1;dl_assignAndLbl(out,i,threshold2,"threshold2")		i+=1;dl_assignAndLbl(out,i,snr2,"snr2")		i+=1;dl_assignAndLbl(out,i,noise,"noise")		i+=1;dl_assignAndLbl(out,i,noiseTotalPower,"noiseTotalPower")		i+=1;dl_assignAndLbl(out,i,signal,"signal")		i+=1;dl_assignAndLbl(out,i,signalTotalPower,"signalTotalPower")		i+=1;dl_assignAndLbl(out,i,threshold,"threshold")		i+=1;dl_assignAndLbl(out,i,snr,"snr")		i+=1;dl_assignAndLbl(out,i,snrPower,"snrPower")				i+=1;dl_assignAndLbl(out,i,startHz,"startHz")		i+=1;dl_assignAndLbl(out,i,endHz,"endHz")		endif				return threshold2endfunction/S wave_colList(wv,colLbl,includeRules,matchAllIncludeRules,excludeRules,includeBlanks,[layer])	WAVE/T wv	String colLbl				//label of column of data to return or "" to receive list of associated row labels	String includeRules		//include waves matching these rules (semi-colon between rules), each rule is colLbl,matchStr. Optionally colLbl,matchStr,layer for non zero layer	Variable matchAllIncludeRules		//0 include matches to one or more rules, 1 to include only matches to all rules	String excludeRules		//exclude waves matching these rules (semi-colon between rules), each rule is colLbl,matchStr. Optionally colLbl,matchStr,layer for non zero layer	Variable includeBlanks	//0 to remove blanks from output, 1 to include	Variable layer		Variable outLayer = (PAramIsDefault(layer) || (numtype(layer)>0)) ? 0 : layer		String out="",itemStr=""		Variable returnRowLbls=strlen(colLbl) < 1		Variable col= returnRowLbls ? nan : finddimlabel(wv,1,colLbl) 	Variable i,rows=dimsizE(wv,0),j,ruleCol	Variable numIncludeRules=itemsinlist(includeRules)	Variable hasIncludeRules=numIncludeRules>0	Variable numExcludeRules=itemsinlist(excludeRules)	String rule,ruleMatchStr,ruleLbl,valStr	Variable numIncludeMatches,ruleMatch,ruleLayer,exclude	for (i=0;i<rows;i+=1)		//check include rules		numIncludeMatches=0		for (j=0;j<numIncludeRules;j+=1)			rule=c2sc(stringfromlist(j,includeRules))			ruleLbl=stringfromlist(0,rule)			ruleCol=finddimlabel(wv,1,ruleLbl)			if (ruleCol < 0)				print "wave_colList() failed to find include rule",ruleLbl,"which was including matches to=",ruleMatchStr				return ""			endif			ruleMatchStr=stringfromlist(1,rule)			ruleLayer = (itemsinlist(rule) > 2) ? str2num(stringfromlist(2,rule)) : 0			valStr=wv[i][ruleCol][ruleLayer]			ruleMatch=stringmatch(valStr,ruleMatchStr)			numIncludeMatches+=ruleMatch		endfor		if (hasIncludeRules && numIncludeMatches==0)		//include rules ignored if not passed			continue		endif		if (matchAllIncludeRules && (numIncludeMatches!=numIncludeRules) )			continue		endif				//check exclude rules		exclude=0		for (j=0;j<numExcludeRules;j+=1)			rule=c2sc(stringfromlist(j,excludeRules))			ruleLbl=stringfromlist(0,rule)			ruleCol=finddimlabel(wv,1,ruleLbl)			if (ruleCol < 0)				print "wave_colList() failed to find exclude rule",ruleLbl,"which was excluding matches to=",ruleMatchStr				return ""			endif			ruleMatchStr=stringfromlist(1,rule)			ruleLayer = (itemsinlist(rule) > 2) ? str2num(stringfromlist(2,rule)) : 0			valStr=wv[i][ruleCol][ruleLayer]			ruleMatch=stringmatch(valStr,ruleMatchStr)			if (ruleMatch)				exclude=1				break				endif		endfor						if (exclude)			continue		endif				if (returnRowLbls)			itemStr=getdimlabel(wv,0,i)		else			itemStr=wv[i][col][outLayer]		endif				if (includeBlanks || (strlen(itemStr)>0) )			out+=itemStr+";"			endif	endfor		return outendfunction disp_removeOpac(winN)	String winN		disp_changeOpac(winN,1)endfunction disp_changeOpac(winN,opacProp)		String winN	Variable opacProp		//between 0 for fully transparent and 1 for fully opaque		Variable fullyOpaque=opacProp==1	Variable opacity = (-1+2^16)*opacProp		if (strlen(winN) < 1)		winN=winname(0,1)	endif		String trace,traces=tracenamelist(winN,";",1),info,rgbInfo,rgbStr	Variable i,num=itemsinlist(traces),red,green,blue	for (i=0;i<num;i+=1)		trace=stringfromlist(i,traces)		info=traceinfo(winN,trace,0)		rgbInfo=stringfromlist(0,listmatch(info,"rgb(x)=(*"))		if (strlen(rgbInfo) > 0)			rgbStr=replacestring("rgb(x)=(",rgbInfo,"")			rgbStr=replacestring(")",rgbStr,"")			red=str2num(stringfromlist(0,rgbStr,","))			green=str2num(stringfromlist(1,rgbStr,","))			blue=str2num(stringfromlist(2,rgbStr,","))			if (fullyOpaque)				modifygraph/w=$winN rgb($trace)=(red,green,blue)			else				modifygraph/w=$winN rgb($trace)=(red,green,blue,opacity)			endif			endif	endforendfunction disp_arrayAxes(winN,axMatchStr,spaceFrac,orderedList)	String winN,axMatchStr	Variable spaceFrac		//what fraction of total goes to EACH space?	String orderedList		//bottom to top		if (strlen(winN) < 1)		winN=winname(0,1)	endif		String ax,axes	if (strlen(orderedList)<1)		axes=listmatch(axislist(winN),axMatchStr)	else		axes=orderedList	endif	Variable i,num=itemsinlist(axes)	Variable totalSpace= num>1 ? (num-1)*spaceFrac : 0	Variable totalFilled=1-totalSpace	Variable fillPerAx=totalFilled/num	Variable currStart	for (i=0;i<num;i+=1)		ax=stringfromlist(i,axes)		currStart=i*fillPerAx+i*spaceFrac		modifygraph/w=$winN axisenab($ax)={currStart,currStart+fillPerAx}	endforendfunction/s text_safeName(name)		String name		Variable i,maxtries=1000	String out=name	for (i=0;i<maxTries;i+=1)		NVAR/Z nv=$out		SVAR/Z sv=$out		pathinfo $out		if ( !wintype(out)&&!Nvar_exists(nv)&&!Svar_exists(sv)&&!waveexists($name)&&!V_flag)			return replacestring("^",out,"")		endif				out=name+"^"+num2str(i)	endfor		STring randStr	Variable rand=(1+enoise(1))*100000		//use 6 random digits	sprintf randStr,"%6.0f",rand	return name+randStr//num2str((1+enoise(1))*100000)	end//add to a graph being used for tracing (setwindow $"" winhook(tracing_simpleCsrFollowPntHook)=tracing_simpleCsrFollowPntHook)//and then any graphs plotting the combinedSegRef / combinedSegWv will get a csr on the current cc pntfunction tracing_simpleCsrFollowPntHook(s)	STRUCT WMWinHookStruct &s		String winN = s.winName			Variable selPnt_overallIndex = tracing_getSelPntData(winN,nan)	//Variable selPnt_segIndex = tracing_getSegPntNumForCCPnt(winN,selPnt_overallIndex)	//Variable selPntSegNum = tracing_getSegNumForCCPnt(winN,selPnt_overallIndex)			String tracedWaveName = img_getImageName(winN)		String combinedSegRef = tracing_getCombinedSegref(tracedWaveName)		if (!WaveExists($combinedSegRef))		return 0	endif				String graphsWithCCWave = disp_getWinListForWv(combinedSegRef,forceWinTypes=1),graph			Variable i,num=itemsinlist(graphsWithCCWave)	for (i=0;i<num;i+=1)		graph=stringfromlist(i,graphsWithCCwave)		Cursor/A=1/P/W=$graph A,$combinedSegRef,selPnt_overallIndex		showinfo/W=$graph	endfor		return 0end//only supports rows or columnsfunction dl_getSubset(wv,dlDimension,dlListOrListOfMatchStrs,outRef)	WAVE wv		//wave to produce a subset of indexes matching dlList	Variable dlDimension	//dimension to look for matching labels in	string dlListOrListOfMatchStrs	//list of dimension labels or match string	String outRef		String matchingList = dl_getLblsAsList(nameofwave(wv),dlDimension,0,inf,matchingThisMatchStrListOnly=dlListOrListOfMatchStrs)				Variable i,num=itemsinlist(matchingList),ind	String lbl	for (i=0;i<num;i+=1)		lbl=stringfromlist(i,matchingList)		ind=finddimlabel(wv,dlDimension,lbl)		if (dlDimension == 0)		//rows			if (i==0)				duplicate/o/r=[ind][] wv, $outRef/wave=out;redimension/n=(1,-1) out			else				duplicate/o/r=[ind][]/free wv, temp;redimension/n=(1,-1) temp				concatenate/dl/np=0 {temp},out				setdimlabel 0,i,$lbl,out			endif		else		//cols			if (i==0)				duplicate/o/r=[][ind] wv, $outref/wave=out;redimension/n=(-1) out			else				duplicate/o/r=[][ind]/free wv, temp;redimension/n=(-1) temp				concatenate/np=1 {temp},out				setdimlabel 1,i,$lbl,out			endif		endif 	endforendfunction loop2(startRow,numRows)	Variable startRow,numRows		WAVE/T wmc	STring cpnOut,avg,nw_expRef,w_expRef	SVAR/Z nw_fitInfoRefs,w_fitInfoRefs	Variable ro,rows=dimsize(wmc,0),count=0	for (ro=startRow;ro<rows;ro+=1)		avg=wmc[ro][%pulseTimedAvg_outAvg];		if (waveExists($avg))			print "LOOP2 STARTING ROW",ro			nw_expRef=avg+"_nwE";w_expRef = avg +"_wE";			cpnOut=analysis_cellParamsNew(avg,avg,str2num(wmc[ro][%vCmdVal]),0,str2num(wmc[ro][%fitWinSizeX]),"","","",nw_expRef,w_expRef,4,1,0,respCol=1,semCol=16)			wmc[ro][%nw_fitInfoRefs]=nw_fitInfoRefs			wmc[ro][%w_fitInfoRefs]=w_fitInfoRefs;		endif				count+=1		if (count >= numRows)			break		endif	endfor	end//MOST UP TO 	DATE (and stream-lined) CAPACITANCE TRANSIENT ANALYSIS AS OF 2/8/18. intended for use after step_exciseAndNorm_avgI//params out order is params for unweighted (nw_) and then weighted (w_) (dim labels)//NEED TO ADD BEFOREHAND THE PARAMS CALCULATED HERE!!! BUT STILL FIGURE OUT IF ORDERING OK ON OUTPUTSfunction/S analysis_cellParamsNew(respRef,semRef,vCmdVal,stepStartX,fitWinSizeX,outRef,nw_prevExps,w_prevExps,nw_outExpRef,w_outExpRef,forceMaxNumFits,basesubbed,doDisp[respCol,semCol,skipFits,forceBaseCurrent,xWvRef])	String	respRef		//a normalized baseline subtracted capacitance transient as generated by step_exciseAndNorm_avgI()	String semRef		//the SEM for that wave from step_exciseAndNorm_avgI()'s subfunction step_exciseAndNorm_avgI_g()	Double vCmdVal		//vCmdVal in V	Double stepStartX,fitWinSizeX	String outRef	Variable forceMaxNumFits		//optionally pass to limit maxNumFits .. useful for seal fits	String nw_prevExps,w_prevExps //for unweighted and weighted exp fits, respectively, any previous fit coefs (as generated by analysis_cellParams_ES_VC_cf)	String nw_outExpRef,w_outExpRef		//place to store output exps	Variable basesubbed		//pass 1 if baseline subtraction has already been performed, 0 if not. If pulseTA notes exist (from analysis_pulseTimedAvg or analysis_pulseTimedAvg_L) then will try to include the baseline measured there in summary output	Variable respCol			//for wave with different parameter columns (e.g., mean sem etc.) pass a column number that the average resp is stored in	Variable semCol 			//for wave with different parameter columns (e.g., mean sem etc.) pass a column number that the sem is stored in	variable doDisp			//optionally pass to display fits	Variable skipFits		//optionally pass skipFits=1 to skip fitting for exponentials (which can be slow).. requires these have been calculated previously and are passed as w_prevExps, nw_preExps	Double forceBaseCurrent	String xWvRef		//optionally pass an xWv for non-uniform dt. sem-based stats for capacitance transient integration wont be calculated, everything else should work if respRef and semRef (if the latter is needed) are matched to xWvRef		Variable hasXWv=!paramisdefault(xWvRef) && (strlen(xWvRef)>0)	Variable defaultNumFits = numtype(forceMaxNumFits) == 0 ? max(forceMaxNumFits,4) : 4	Variable forceUserGuidance = 0		//supercedes skipUserGuidedFitting	Variable skipUserGuidedFitting =1	Double assumedSpecificCap = 0.01 			//pF / um^2 conversion to F / m ^ 2: 1 F / 10^12 pF * 10^6 um / m * 10^6 um / m = x pF/um^2 = F/ m ^ 2	Variable numFits = (numtype(forceMaxNumFits) > 0) ? defaultNumFits : forceMaxNumFits			Double baselineStartX_relStepStartX = -0.0011	Double baselineLen = 0.001		Double ss_estTimeToSS = 0.006				//used for ssRin				Double ss_avgLenX = 0.001						//used for ssRin			Double integration_estTimeToSS = min(0.01,fitWinSizeX)	//used for integration of transient .. if fitendX is less than this, defaults to fit end x	Double integration_ssAvgLen = 0.001		//used for integration of transient	variable resWinStartXForThresh=2,i	if (hasxwv)		WAVE xWv=$xwvref		Variable stepStartP,ss_estTimeToSS_P,ss_avgEnd_P			findlevel/edge=1/p/q xwv,stepStartX		stepStartP=V_levelx		findlevel/edge=1/p/q xwv,ss_estTimeToSS		ss_estTimeToSS_P=V_levelx		findlevel/edge=1/p/q xwv,ss_estTimeToSS+ss_avgLenX		ss_avgEnd_P=V_levelx			endif			if (strlen(outRef) < 1)		outRef = respRef + "_cpn"			//for cell params new	endif		String/G nw_fitInfoRefs="",w_fitInfoRefs=""		//global to make it easier to save	String fitInfoOutRefBase=outRef+"_fi_"	for (i=0;i<numFits;i+=1)		nw_fitInfoRefs+=num2str(i)+":"+fitInfoOutRefBase+"nw_"+num2str(i)+";"		w_fitInfoRefs+=num2str(i)+":"+fitInfoOutRefBase+"w_"+num2str(i)+";"	endfor		Print "analysis_cellParamsNew outRef",outRef		if (strlen(semRef) < 1)		semRef=respRef	endif			String usedRespRef = respRef+"_TEMP_avg",usedSemRef=semRef+"_TEMP_sem"	if (!ParamIsDefault(respCol) && (numtype(respCol) == 0))		duplicate/o/r=[][respCol] $respRef,$usedRespRef/wave=resp		redimension/n=(-1) resp	else		duplicate/o $respRef,$usedRespRef/wave=resp	endif		Variable hasSem=0	if (!ParamIsDefault(semCol) && (numtype(semCol) == 0))		duplicate/o/r=[][semCol] $semRef,$usedSemRef/wave=sem		redimension/n=(-1) sem		hasSem=1	elseif (strlen(semRef)>0)		duplicate/o $semRef,$usedSemRef/wave=sem		hasSem=1	endif			Double ssCurrent_noModel	if (hasxwv)		ssCurrent_noModel = faveragexy(xwv,resp,stepStartX,stepStartX+ss_estTimeToSS+ss_avgLenX)	else		ssCurrent_noModel = mean(resp,stepStartX+ss_estTimeToSS,stepStartX+ss_estTimeToSS+ss_avgLenX)	endif	Double baseCurrent,ssDeltaCurrent 	if (baseSubbed)		String noteStr = note(resp)		String baseCurrentStr = stringbykey("pulseTa_baselineMean",noteStr)		//implemented in analysis_pulseTimedAvg or analysis_pulseTimedAvg_L		baseCurrent = !ParamIsDefault(forceBaseCurrent) ? forceBaseCurrent : str2num(baseCurrentStr)			ssDeltaCurrent = ssCurrent_noModel		else		baseCurrent = !ParamIsDefault(forceBaseCurrent) ? forceBaseCurrent : mean(resp,stepStartX-baselineStartX_relStepStartX,stepStartX-baselineStartX_relStepStartX+baselineLen)		resp -= baseCurrent		ssDeltaCurrent = ssCurrent_noModel - baseCurrent	endif		Double ssRin_noModel = vCmdVal / ssDeltaCurrent	Double ssConductance_noModel = 1 / ssRin_noModel	Double peakLoc	if (hasXWv)		Variable peakLocP		wavestats/Q/R=[stepStartP,ss_estTimeToSS_P] resp		peakLocP = v_maxrowloc		peakLoc = xWv[peakLocP]	else		WaveStats/Q/R=(stepStartX,ss_estTimeToSS)	resp	//search for peak of transient, assume peak must be by the presumed steady-state time for integration analysis		peakLoc = V_maxloc	endif	Double peakVal = V_max		Double accessR_noModel=vCmdVal/peakVal 		//vCmdVal is 1 for the current peak val 	double memR_noModel=	(vCmdVal-(accessR_noModel	*ssDeltaCurrent) )/ssDeltaCurrent		//(1-(accessR_noModel*ssConductance_noModel))/ssConductance_noModel	//from Neher paper   Rm =  ( deltaV - (Ra * Iss) ) / Iss				Double fitStartX = peakLoc	Double fitEndX = peakLoc + fitWinSizeX		if (hasXWv)		Variable fitstartP = peakLocP		findlevel/p/q/edge=1 resp,fitEndX		Variable fitEndP = V_levelx	else		fitStartP = x2pnt(resp,fitStartX)		fitEndP = x2pnt(resp,fitEndX)	endif		//store parameters	Variable numParams = 29,ii=-1	make/o/d/n=(numParams) $outRef/wave=out	String outNote=""	String noteKeysStartStr="analysis_cellParamsNew_"	outNote=replacestringbykey(noteKeysStartStr+"respRef",outNote,respRef)	outNote=replacestringbykey(noteKeysStartStr+"semRef",outNote,semRef)	outNote=replacestringbykey(noteKeysStartStr+"vCmdVal",outNote,num2str(vCmdVal))	outNote=replacestringbykey(noteKeysStartStr+"stepStartX",outNote,num2str(stepStartX))	outNote=replacestringbykey(noteKeysStartStr+"fitWinSizeX",outNote,num2str(fitWinSizeX))	outNote=replacestringbykey(noteKeysStartStr+"outRef",outNote,outRef)	outNote=replacestringbykey(noteKeysStartStr+"nw_prevExps",outNote,nw_prevExps)	outNote=replacestringbykey(noteKeysStartStr+"w_prevExps",outNote,w_prevExps)	outNote=replacestringbykey(noteKeysStartStr+"nw_outExpRef",outNote,nw_outExpRef)	outNote=replacestringbykey(noteKeysStartStr+"w_outExpRef",outNote,w_outExpRef)	outNote=replacestringbykey(noteKeysStartStr+"forceMaxNumFits",outNote,num2str(forceMaxNumFits))	outNote=replacestringbykey(noteKeysStartStr+"basesubbed",outNote,num2str(basesubbed))	outNote=replacestringbykey(noteKeysStartStr+"doDisp",outNote,num2str(doDisp))	outNote=replacestringbykey(noteKeysStartStr+"respCol",outNote,num2str(ParamIsDefault(respCol) ? nan : respCol))	outNote=replacestringbykey(noteKeysStartStr+"semCol",outNote,num2str(ParamIsDefault(semCol) ? nan : semCol))	note/nocr out, outNote		ii+=1;dl_assignAndLbl(out, ii, numParams, "analysis_cellParamsNew_numParams")	ii+=1;dl_assignAndLbl(out, ii, forceMaxNumFits, "forceMaxNumFits")	ii+=1;dl_assignAndLbl(out, ii, ParamIsDefault(respCol) ? nan : respCol, "respCol")	ii+=1;dl_assignAndLbl(out, ii, ParamIsDefault(semCol) ? nan : respCol, "semCol")	ii+=1;dl_assignAndLbl(out, ii, fitWinSizeX, "fitWinSizeX")	ii+=1;dl_assignAndLbl(out, ii, vCmdVal, "vCmdVal")	ii+=1;dl_assignAndLbl(out, ii, ss_estTimeToSS, "ss_estTimeToSS")	ii+=1;dl_assignAndLbl(out, ii, ss_avgLenX, "ss_avgLenX")	ii+=1;dl_assignAndLbl(out, ii, resWinStartXForThresh, "resWinStartXForThresh")	ii+=1;dl_assignAndLbl(out, ii, integration_estTimeToSS, "integration_estTimeToSS")		ii+=1;dl_assignAndLbl(out, ii, integration_ssAvgLen, "integration_ssAvgLen")	ii+=1;dl_assignAndLbl(out, ii, stepStartX, "stepStartX")	ii+=1;dl_assignAndLbl(out, ii, ssRin_noModel, "ssRin_noModel")	ii+=1;dl_assignAndLbl(out, ii, ssConductance_noModel, "ssConductance_noModel")	ii+=1;dl_assignAndLbl(out, ii, ssCurrent_noModel, "ssCurrent_noModel")		ii+=1;dl_assignAndLbl(out, ii, baseSubbed, "baseSubbed")	ii+=1;dl_assignAndLbl(out, ii, baseCurrent, "baseCurrent")	ii+=1;dl_assignAndLbl(out, ii, ssDeltaCurrent, "ssDeltaCurrent")	ii+=1;dl_assignAndLbl(out, ii, peakLoc, "peakLoc")	ii+=1;dl_assignAndLbl(out, ii, peakVal, "peakVal")		ii+=1;dl_assignAndLbl(out, ii, accessR_noModel, "accessR_noModel")	ii+=1;dl_assignAndLbl(out, ii, memR_noModel, "memR_noModel")	ii+=1;dl_assignAndLbl(out, ii, fitStartX, "fitStartX")	ii+=1;dl_assignAndLbl(out, ii, fitendX, "fitendX")	ii+=1;dl_assignAndLbl(out, ii, assumedSpecificCap, "assumedSpecificCap")		ii+=1;dl_assignAndLbl(out, ii, vCmdVal, "vCmdVal")		ii+=1;dl_assignAndLbl(out, ii, fitStartP, "fitStartP")		ii+=1;dl_assignAndLbl(out, ii, fitEndP, "fitEndP")		ii+=1;dl_assignAndLbl(out, ii, nan, "analysis_cellParamsNew_EndParams")			//run integration time course analysis 	if (hasSem)		analysis_integrateCapNew(resp,fitStartX,fitStartX+integration_estTimeToSS,integration_estTimeToSS-integration_ssAvgLen/2,integration_estTimeToSS+integration_ssAvgLen/2,assumedSpecificCap,vCmdVal,0,"analysis_esVcCfTemp",xWvRef=selectstring(hasXwv,"",xWvRef),semWv=sem)		else		analysis_integrateCapNew(resp,fitStartX,fitStartX+integration_estTimeToSS,integration_estTimeToSS-integration_ssAvgLen/2,integration_estTimeToSS+integration_ssAvgLen/2,assumedSpecificCap,vCmdVal,0,"analysis_esVcCfTemp",xWvRef=selectstring(hasXwv,"",xWvRef))		endif	dl_appendToLbls($"analysis_esVcCfTemp",0,"",1,0,inf)		concatenate/dl/np=0 {$"analysis_esVcCfTemp"},out		//non SEM cap trans fit	analysis_capTransFitsNew(resp,fitStartX,fitEndX,vCmdVal,assumedSpecificCap,defaultNumFits,numFits,"analysis_esVcCfTemp",templateCoefsRef=nw_prevExps,allFinalCoefsRef=nw_outExpRef,noUserGuidance=skipUserGuidedFitting,forceUserGuidance=forceUserGuidance,saveFitInfoRefs=nw_fitInfoRefs,skipFits=(!ParamIsDefault(skipFits)&&skipFits),xWvRef=selectstring(hasXwv,"",xWvRef))	if (!hasSEM)		duplicate/o/free $"analysis_esVcCfTemp", dummy		//make a placeholder for sem wave	endif	dl_appendToLbls($"analysis_esVcCfTemp",0,"nw_",1,0,inf)		//nw_ for no weight	concatenate/dl/np=0 {$"analysis_esVcCfTemp"},out		//sem cap trans fit or skip	if (hasSem)		analysis_capTransFitsNew(resp,fitStartX,fitEndX,vCmdVal,assumedSpecificCap,defaultNumFits,numFits,"analysis_esVcCfTemp",semWv=sem,templateCoefsRef=w_prevExps,allFinalCoefsRef=w_outExpRef,noUserGuidance=skipUserGuidedFitting,forceUserGuidance=forceUserGuidance,saveFitInfoRefs=w_fitInfoRefs,skipFits=(!ParamIsDefault(skipFits)&&skipFits),xWvRef=selectstring(hasXwv,"",xWvRef))			dl_appendToLbls($"analysis_esVcCfTemp",0,"w_",1,0,inf)		//w_ for weight		concatenate/dl/np=0 {$"analysis_esVcCfTemp"},out	else		dummy=nan	//use a placeholder from the no weight output wave		dl_appendToLbls(dummy,0,"w_",1,0,inf)			concatenate/dl/np=0 {dummy},out	endif		String expsToFitList = ""	for (i=0;i<numFits;i+=1)		expsToFitList += num2str(i) + ";"	endfor	if (hasxwv)		print "display command: analysis_cellParamsNew_plotExps(\""+expsToFitList+"\","+nameofwave(out)+",0,1,xwvref=\""+xwvref+"\")"	else		print "display command: analysis_cellParamsNew_plotExps(\""+expsToFitList+"\","+nameofwave(out)+",1,1) or 0,1) for unweighted"	endif	if (doDisp)			analysis_cellParamsNew_plotExps(expsToFitList,out,1,1)	endif		killwaves/Z  $usedRespRef,$usedSemRef		return outRef	end	//analysis_cellParamsNew()//display resultant fits from analysis_cellParamsNew()function analysis_cellParamsNew_plotExps(expsToFitList,fitParamWv,weighted,appendRes,[forceWinStartStr,xWvRef])	String expsToFitList		//list of exponential fits to plot e.g. "0;1" plots 0th exponential fit, which is single exponential fit and plots 1st exponential fit which is double exponential fit	WAVE fitParamWv				//outRef from analysis_cellParamsNew	Variable weighted				//pass 1 to plot weighted fit, 0 to plot unweighted fit.. weighted requires an sem wv, if one was not passed to analysis_cellParamsNew() then unweighted are plotted regardless 	Variable appendRes			//pass 1 to append residuals	String forceWinStartStr	String xWvRef			Variable hasxwv=!paramisdefault(xWvRef) && (strlen(xWvRef)>0)	if (hasxwv)		WAVE xWv=$xwvref	endif	String info = note(fitParamWv)	String noteKeysStartStr="analysis_cellParamsNew_"	String respREf = stringbykey(noteKeysStartStr+"respRef",info)	String semRef = stringbykey(noteKeysStartStr+"semRef",info)	Variable hasSem = (strlen(semRef) > 0) && waveexists($semRef)	Variable plotWeighted = weighted && hasSem	Variable respCol = numtype(fitParamWv[%respCol]) ? 0 : fitParamWv[%respCol]	Variable semCol = numtype(fitParamWv[%respCol]) ? 0 : fitParamWv[%respCol]		String dlStart = selectstring(plotWeighted,"nw_","w_"),fitDlStart,fitCoefsStartDl	String dl = dlStart+"cf_fitStartX"	Variable fitStartX = fitParamWv[%$dl]	Variable fitEndX = fitParamWv[%$(dlStart+"cf_fitEndX")]	Variable fitStartP=fitParamWv[%$(dlStart+"cf_fitStartP")]		//only used here for x waves	Variable fitEndP=fitParamWv[%$(dlStart+"cf_fitEndP")]		//only used here for x waves	Variable/G x0 = fitStartX		//required for myExp fit function		Variable i,j,numFits = itemsinlist(expsToFitList),expInd	Double componentCap,componentSphDia	Variable acceptModelPval,bestModel,ssres_sim,ssres_cpx,ssRes_fc	String componentCapStr,componentSphDiaStr,componentTauStr,componentAmpStr,componentStr,tbStr,acceptModelPvalStr,bestModelStr	String ssResStr,ssres_fcStr,expIndStr	Variable fitCoefsStartInd,numCoefs,numExps,dblExpAcceptModelPVal	String overallFitName,componentName,componentNames,winN	String overallFitbaseName = selectstring(ParamIsDefault(forceWinStartStr),forceWinStartStr,respRef) + "_exp_"	String resFitBaseName = overallFitbaseName + "r_",resName	String componentDlStart	make/o/d/n=3 componentCoefs	for (i=0;i<numFits;i+=1)		expIndStr=stringfromlist(i,expsToFitList)		expInd = str2num(expIndStr)		fitDlStart = dlStart + "cf_"+expIndStr+"_"		fitCoefsStartDl = fitDlStart + "coef_0_y0"		fitCoefsStartInd = finddimlabel(fitPAramWv,0,fitCoefsStartDl)		numExps=fitParamWv[%$(fitDlStart+"numExps")]		numCoefs=fitParamWv[%$(fitDlStart+"numCoefs")]		duplicate/o/d/free/r=[fitCoefsStartInd,fitCoefsStartInd+numCoefs-1] fitParamWv,coefsWv		overallFitName = overallFitbaseName + expIndStr		winN = overallFitName +"_win"		if (hasxwv)			duplicate/o/r=[fitStartP,fitEndP][respCol] $respRef,$overallFitName/wave=overallFit			duplicate/o/r=[fitStartP,fitEndP][respCol] xWv,$(overallFitName+"_X")/wave=overallFit_X			overallFit = myexp(coefsWv,overallFit_X[p])		else			duplicate/o/r=(fitStartX,fitEndX)[respCol] $respRef,$overallFitName/wave=overallFit			overallFit = myexp(coefsWv,x)		endif				note/nocr overallFit, replacestringbykey("analysis_cellParamsNew_plotExps_overallFitCoefs",wave_print(coefsWv,","),note(overallFit))		if (wintype(winN) > 0)			vis_clearGraph(winN)			dowindow/f $winN		else			display/k=1/n=$winN;			winN =s_name		endif		if (hasxwv)			appendtograph/w=$winN/c=(0,0,0) $respRef[][respCol] vs xwv;			appendtograph/w=$winN/c=(65535,0,52428,20000) overallFit vs overallFit_X;		else			appendtograph/w=$winN/c=(0,0,0) $respRef[][respCol];			appendtograph/w=$winN/c=(65535,0,52428,20000) overallFit;		endif		modifygraph lsize($overallFitName)=1.5		setaxis/w=$winN bottom,fitStartX-0.001,fitEndX;		if (hasSEM)			ErrorBars/w=$winN $respRef SHADE= {0,0,(0,0,0,19661),(0,0,0,0)},wave=($respRef[*][%sem],$respRef[*][%sem]);		//plot sem error bars at ~40% opac		endif				if (appendRes)			resName = resFitBaseName + expIndStr			duplicate/o overallFit, $resName/wave=res			WAVE resp =$respRef			if (hasxwv)				res = resp[p+fitStartP][respCol] - overallFit[p]				appendtograph/w=$winN/L=left2 res vs overallFit_X			else				res = resp(x)[respCol] - overallFit(x)				appendtograph/w=$winN/L=left2 res			endif			modifygraph/w=$WinN freepos=0,lblpos=55,axisenab(left2)={0.75,1},axisenab(left)={0,0.68}			Label/w=$WinN left2 "Res (\\U)"		endif				componentNames = ""		tbStr = ""		componentCoefs[0] = coefsWv[0]		//y0 always included		for (j=0;j<numExps;j+=1)			componentName = overallFitName + "_c" + num2str(j)			componentNames += componentName + ","			duplicate/o overallFit,$componentName/wave=component			componentCoefs[1] = coefsWv[1+2*j]		//amplitude is at position 1,3,5,...			componentCoefs[2] = coefsWv[1+2*j+1]	//tau is at position 2,4,6,...			if (hasxwv)				component = myexp(componentCoefs,overallFit_X[p])				appendtograph/w=$winN/c=(65535,0,52428) component vs overallFit_X			else				component = myexp(componentCoefs,x)				appendtograph/w=$winN/c=(65535,0,52428) component;			endif			note/nocr component, replacestringbykey("analysis_cellParamsNew_plotExps_overallFitCoefs",wave_print(coefsWv,","),note(component))			modifygraph/W=$winN lstyle($componentName)=1						componentDlStart = fitDlStart + "co"+num2str(j)+"_"			componentCap = fitParamWv[%$(componentDlStart+"cap_c")] * 10^12		//convert from F to pF			componentSphDia = fitParamWv[%$(componentDlStart+"sph_dia_c")]	* 10^12		//convert from m^2 to um^2							sprintf componentTauStr,"%3.3e",componentCoefs[2]*10^3			//convert from S to mS			sprintf componentAmpStr,"%3.3f",componentCoefs[1]*10^12		//convert from A to pA			sprintf componentCapStr,"%2.2e",componentCap			sprintf componentSphDiaStr,"%2.2e",componentSphDia			componentStr = "C"+num2str(j)+": τ="+componentTauStr+" A="+componentAmpStr+" C="+componentCapStr+" d="+componentSphDiaStr			tbStr+= componentStr+"\r"		endfor		bestModel=fitParamWv[%$(dlStart + "cf_f_bestModel")]		bestModelStr = num2str(bestModel)		if (expInd == 0)		//monoexponential fit, no simpler model to compare to, see if double exponential passed f test			dblExpAcceptModelPVal=fitParamWv[%$(dlStart+"cf_1_stats_f_p")]			acceptModelPval = dblExpAcceptModelPVal > 0.05		//if reject double model, then accept mono model			acceptModelPvalStr = num2str(acceptModelPval) + " (dblExpPVal="+num2str(dblExpAcceptModelPVal)		else			ssres_cpx = fitParamWv[%$(fitDlStart+"stats_ssres_cpx")]				ssres_sim = fitParamWv[%$(fitDlStart+"stats_ssres_sim")]				ssres_fc = ssres_cpx / ssres_sim			sprintf ssResStr,"ssRes=%2.5e fc=%2.2f",ssres_cpx,ssres_fc			acceptModelPval=fitParamWv[%$(fitDlStart+"stats_f_p")]		//see if fstat p < 0.05			acceptModelPvalStr = num2str(acceptModelPval<0.05) + " (pval="+num2str(acceptModelPval)+" "+ssResStr		endif		tbStr = "\\f04FTEST Accept="+acceptModelPvalStr+" Best model="+bestModelStr +")\\f00\r"+tbStr		drawtext/w=$winN 0.25,0.5,tbStr		note/nocr overallFit, replacestringbykey("analysis_cellParamsNew_plotExps_componentNames",componentNames,note(overallFit))					//label zero on residuals		getaxis/q bottom		if (appendRes)			setdrawenv/w=$winN xcoord=bottom,ycoord=left2,linefgc=(0,0,0,30000),dash=8			DrawLine/w=$winN v_min,0,v_max,0		endif	endforend//analysis_cellParamsNew_plotExps similar to above but an offshoot made for layers, may be mostly redundant in brkInDialysis.pxpfunction/S analysis_cellParamsNew_plotExps2(expsToFitList,fitParamWv,weighted,appendRes,[forceWinStartStr,dontClear])	String expsToFitList		//list of exponential fits to plot e.g. "0;1" plots 0th exponential fit, which is single exponential fit and plots 1st exponential fit which is double exponential fit	WAVE fitParamWv				//outRef from analysis_cellParamsNew	Variable weighted				//pass 1 to plot weighted fit, 0 to plot unweighted fit.. weighted requires an sem wv, if one was not passed to analysis_cellParamsNew() then unweighted are plotted regardless 	Variable appendRes			//pass 1 to append residuals	String forceWinStartStr	Variable dontClear			//dont clear pre-existing window..useful along with forceWinStartStr to plot on one graph				String info = note(fitParamWv)	String noteKeysStartStr="analysis_cellParamsNew_"	String respREf = stringbykey(noteKeysStartStr+"respRef",info)	String semRef = stringbykey(noteKeysStartStr+"semRef",info)	Variable hasSem = (strlen(semRef) > 0) && waveexists($semRef)	Variable plotWeighted = weighted && hasSem	Variable respCol = numtype(fitParamWv[%respCol]) ? 0 : fitParamWv[%respCol]	Variable semCol = numtype(fitParamWv[%respCol]) ? 0 : fitParamWv[%respCol]		String dlStart = selectstring(plotWeighted,"nw_","w_"),fitDlStart,fitCoefsStartDl	String dl = dlStart+"cf_fitStartX"	Variable fitStartX = fitParamWv[%$dl]	Variable fitEndX = fitParamWv[%$(dlStart+"cf_fitEndX")]	Variable/G x0 = fitStartX		//required for myExp fit function		Variable uniqueNames=!ParamIsDefault(dontclear) && dontclear	Variable i,j,numFits = itemsinlist(expsToFitList),expInd	Double componentCap,componentSphDia	Variable acceptModelPval,bestModel,ssres_sim,ssres_cpx,ssRes_fc	String componentCapStr,componentSphDiaStr,componentTauStr,componentAmpStr,componentStr,tbStr,acceptModelPvalStr,bestModelStr	String ssResStr,ssres_fcStr,expIndStr	Variable fitCoefsStartInd,numCoefs,numExps,dblExpAcceptModelPVal	String overallFitName,componentName,componentNames,winN	String overallfitbasename	if (uniqueNames)		overallFitbaseName = respref + "_exp_"	else		overallFitbaseName = selectstring(ParamIsDefault(forceWinStartStr),forceWinStartStr,respRef) + "_exp_"	endif	String resFitBaseName = overallFitbaseName + "r_",resName	String componentDlStart	String tracesList=""	make/o/d/n=3 componentCoefs	for (i=0;i<numFits;i+=1)		expIndStr=stringfromlist(i,expsToFitList)		expInd = str2num(expIndStr)		fitDlStart = dlStart + "cf_"+expIndStr+"_"		fitCoefsStartDl = fitDlStart + "coef_0_y0"		fitCoefsStartInd = finddimlabel(fitPAramWv,0,fitCoefsStartDl)		numExps=fitParamWv[%$(fitDlStart+"numExps")]		numCoefs=fitParamWv[%$(fitDlStart+"numCoefs")]		duplicate/o/d/free/r=[fitCoefsStartInd,fitCoefsStartInd+numCoefs-1] fitParamWv,coefsWv		overallFitName = overallFitbaseName + expIndStr		winN = selectstring(ParamIsDefault(forceWinStartStr),forceWinStartStr,respRef) + "_exp_" +expIndStr +"_win"		duplicate/o/r=(fitStartX,fitEndX)[respCol] $respRef,$overallFitName/wave=overallFit		overallFit = myexp(coefsWv,x)		note/nocr overallFit, replacestringbykey("analysis_cellParamsNew_plotExps_overallFitCoefs",wave_print(coefsWv,","),note(overallFit))		if (wintype(winN) > 0)			if (ParamIsDefault(dontClear) || !dontClear)				vis_clearGraph(winN)			endif			dowindow/F $winN		else			display/k=1/n=$winN;			winN =s_name		endif		appendtograph/w=$winN/c=(0,0,0) $respRef[][respCol];tracesList+=respRef+";"		appendtograph/w=$winN overallFit;tracesList+=nameofwave(overallFit)+";"		setaxis/w=$winN bottom,fitStartX-0.001,fitEndX;		if (hasSEM)			ErrorBars/w=$winN $respRef SHADE= {0,0,(0,0,0,19661),(0,0,0,0)},wave=($respRef[*][%sem],$respRef[*][%sem]);		//plot sem error bars at ~40% opac		endif				if (appendRes)			resName = resFitBaseName + expIndStr			duplicate/o overallFit, $resName/wave=res			WAVE resp =$respRef			res = resp(x)[respCol] - overallFit(x)			appendtograph/w=$winN/L=left2 res;tracesList+=nameofwave(res)+";"			modifygraph/w=$WinN freepos=0,lblpos=55,axisenab(left2)={0.75,1},axisenab(left)={0,0.68}			Label/w=$WinN left2 "Res (\\U)"		endif				componentNames = ""		tbStr = ""		componentCoefs[0] = coefsWv[0]		//y0 always included		for (j=0;j<numExps;j+=1)			if (ParamIsDefault(dontClear) || !dontclear)				componentName = overallFitName + "_c" + num2str(j)			else				componentName = respRef + "_c" + num2str(j)			endif			componentNames += componentName + ","			duplicate/o overallFit,$componentName/wave=component			componentCoefs[1] = coefsWv[1+2*j]		//amplitude is at position 1,3,5,...			componentCoefs[2] = coefsWv[1+2*j+1]	//tau is at position 2,4,6,...			component = myexp(componentCoefs,x)			note/nocr component, replacestringbykey("analysis_cellParamsNew_plotExps_overallFitCoefs",wave_print(coefsWv,","),note(component))			appendtograph/w=$winN/c=(65535,0,52428) component;tracesList+=nameofwave(component)+";"			modifygraph/W=$winN lstyle($componentName)=1						componentDlStart = fitDlStart + "co"+num2str(j)+"_"			componentCap = fitParamWv[%$(componentDlStart+"cap_c")] * 10^12		//convert from F to pF			componentSphDia = fitParamWv[%$(componentDlStart+"sph_dia_c")]	* 10^12		//convert from m^2 to um^2							sprintf componentTauStr,"%3.3e",componentCoefs[2]*10^3			//convert from S to mS			sprintf componentAmpStr,"%3.3f",componentCoefs[1]*10^12		//convert from A to pA			sprintf componentCapStr,"%2.2e",componentCap			sprintf componentSphDiaStr,"%2.2e",componentSphDia			componentStr = "C"+num2str(j)+": τ="+componentTauStr+" A="+componentAmpStr+" C="+componentCapStr+" d="+componentSphDiaStr			tbStr+= componentStr+"\r"		endfor		bestModel=fitParamWv[%$(dlStart + "cf_f_bestModel")]		bestModelStr = num2str(bestModel)		if (expInd == 0)		//monoexponential fit, no simpler model to compare to, see if double exponential passed f test			dblExpAcceptModelPVal=fitParamWv[%$(dlStart+"cf_1_stats_f_p")]			acceptModelPval = dblExpAcceptModelPVal > 0.05		//if reject double model, then accept mono model			acceptModelPvalStr = num2str(acceptModelPval) + " (dblExpPVal="+num2str(dblExpAcceptModelPVal)		else			ssres_cpx = fitParamWv[%$(fitDlStart+"stats_ssres_cpx")]				ssres_sim = fitParamWv[%$(fitDlStart+"stats_ssres_sim")]				ssres_fc = ssres_cpx / ssres_sim			sprintf ssResStr,"ssRes=%2.5e fc=%2.2f",ssres_cpx,ssres_fc			acceptModelPval=fitParamWv[%$(fitDlStart+"stats_f_p")]		//see if fstat p < 0.05			acceptModelPvalStr = num2str(acceptModelPval<0.05) + " (pval="+num2str(acceptModelPval)+" "+ssResStr		endif		tbStr = "\\f04FTEST Accept="+acceptModelPvalStr+" Best model="+bestModelStr +")\\f00\r"+tbStr		drawtext/w=$winN 0.25,0.5,tbStr		note/nocr overallFit, replacestringbykey("analysis_cellParamsNew_plotExps_componentNames",componentNames,note(overallFit))				if (appendRes)				//label zero on residuals			getaxis/q bottom			setdrawenv/w=$winN xcoord=bottom,ycoord=left2,linefgc=(0,0,0,30000),dash=8			DrawLine/w=$winN v_min,0,v_max,0		endif	endfor		return tracesListendfunction analysis_capTransFitsNew(wv,fitStartX,fitEndX,vCmdVal,assumedSpecificCap,numFits,forceMaxNumFits,outRef,[semWv,allFinalCoefsRef,templateCoefsRef,noUserGuidance,forceUserGuidance,saveFitInfoRefs,skipFits,xWvRef])		//cf for capfit	WAVE/D wv, semWv		//latter optional standard error wave for fitting with weights.. currently needs same length as wv	Double fitStartX,fitEndX	Double vCmdVal		//voltage command size, used for calculating parameters	Variable numFits					//standard is 4	Variable forceMaxNumFits		//actual num fits computed .. use numFits to keep output parameter number constant across many fits, use this to limit actual number performed case by case	String outRef			//store all fit params	Double assumedSpecificCap //= 0.01 			//pF / um^2 conversion to F / m ^ 2: 1 F / 10^12 pF * 10^6 um / m * 10^6 um / m = x pF/um^2 = F/ m ^ 2			//these parameters are useful for implementing user-guided fitting	String allFinalCoefsRef	//pass to get a return of all final coefs, column by column	String templateCoefsRef	//pass to override autogenerated fit guesses and start with these instead (for higher order, 3exp+, fits for now). Also used with skipFits==1 to override fitting entirely	Variable noUserGuidance	//pass to override user guidance on higher order fit failures (3exp+)	Variable forceUserGuidance	//pass to force user guideance no matter what -- normally user guidance is only sought if an error occurs in fitting 	String saveFitInfoRefs		//optionally pass to save fit info refs	Variable skipFits			//optionally pass as 1 to skip fitting, using old templateCoefsRef instead. 	String xWvRef		//optionally pass an xWv for non-uniform dt			Variable doExhaustiveFittingForHigherOrder=1		//exhaustive instead of user guided fitting (the latter being pretty slow in practice is not recommended) for 3+ exp component fits	Variable doExhaustiveForLowerOrder=1				//exhaustive IN ADDITION TO Igor automated guess fitting for single and double exp fits	Variable numOldTauTauTests = 3//3	Variable numNewTauAmpTests = 8,numNewTauTauTests=8//goes with doExhaustiveFittingForHigherOrder==1	Double expFitMaxTau = 0.008		//set a fit constraint for maximum tau. avoids problem of having an extremely small amplitude component with an extremely long tau	Variable ampUseLog = 1	Variable ftest_pcrit = 0.05		Variable numFTestChiStats=17 	//must agree with stats_ftestChi_simple	Variable fitStartP,fitEndP,fitPnts	Variable hasXwv=!paramisdefault(xWvRef) && strlen(xWvRef)>0	if (hasXwv)		WAVE xWv=$xWvRef		findlevel/p/edge=1/q xwv,fitStartX		fitStartP=V_levelx		findlevel/p/edge=1/q xwv,fitendx		fitEndP=V_levelx-1		else		fitStartP = x2pnt(wv,fitStartX)		fitEndP = x2pnt(wv,fitEndX) 	endif	fitPnts = fitendP-fitstartP		Variable hasWeightWv = !ParamIsDefault(semWv) && waveExists(semWv) && (numtype(sum(semWv,fitStartX,fitEndX))==0)	if (hasWeightWv)		duplicate/o/d semWv, weightWvTemp	else		duplicate/o/d wv, weightWvTemp		weightWvTemp = 1 		//equal weights	endif		variable/g x0=fitStartX		//for fitting procedure		variable i,j,k,numExps,nas	Double amp_sum,proportion,amp_new,tau_oldMin,tau_oldMax,tau_oldRange,tau_newMin,tau_newMax,tau_newRange,tau_new	Double ssres_sim	,ssres_cpx	Variable oldNumParams,newAmpIndex,newTauIndex,RF,V_FitError,V_fitQuitReason,numCoefs,startIndex,componentDataStartInd,compInd,ii,iii	Double V_chisq		//residuals, or chi sq values for fitting with weight	double iSS_equivGss,ssRin,iPeak_equivGpeak,rPeak_equivRa,Rmem_tot,iSS_real,iPeak_real	double Ra_csum,q_csum,q_peak_cSum,cap_cSum,cap_peak_cSum=0,sa_cSum,sa_peak_cSum,sph_dia_cSum,sph_dia_peak_cSum	double tau_cIndex,amp_cIndex,tau_c,amp_c,Ra_c,iPeak_c,Ra_peak_c,amp_real_c,iPeak_real_c,q_c,q_peak_c,cap_c,cap_peak_c,sa_c,sa_peak_c,sph_dia_c,sph_dia_peak_c		Double Ra_c_fr,q_c_fr,q_peak_c_frcap_c_fr,cap_c_fr,cap_peak_c_fr,q_peak_c_fr	Double nearFinalVal, peakVal , maxAmp, minAmp,minTau,level95Complete,maxTau,ssres_cpxExh	Variable f_bestModel=0, chi_bestModel = 0,numTests	String dlStart,dlComp,lblstr,fitInfoRef	//calculate the size of the output params wave -- goes in order actual wave	Variable numOverallParams = 31		//confirmed overall params		//params per fit	Variable numPreFitParams = 1	//confirmed	Variable numCoefsPerFit = 2*numFits + 1		//confirmed coefs for each fit really max / worst case .. all but highest will have fewer	Variable numNonStatsFitParams = 29			//confirmed non-stats params for each fit	//numFTestChiStats is the stats param for each fit	Variable numPostFitParams = 1	//confirmed	Variable numNonCompFitPars = numPreFitParams + numCoefsPerFit +numNonStatsFitParams +  numFTestChiStats	+numPostFitParams	Variable numParamsPerComponent = 20	//confirmed -- numParamsPerComponent per fit	Variable numComponentParamsPerFit = 	numParamsPerComponent * numFits		//again really max num components .. all but highest order will have fewer	Variable totalParamsPerFit = numNonCompFitPars + numComponentParamsPerFit	//total output params	Variable numParams = numOverallParams + totalParamsPerFit * numFits	make/o/d/n=(numParams) $outref/wave=out		//related to using and storing previous (user guided) fits  -- only affects nonExhaustive	String guidedFitWinN="userGuidedMyExp"	Variable fitsAlreadyMAtch,prevCoefsToUse	Variable userGuesses=ParamIsDefault(noUserGuidance) || !noUserGuidance	Variable passedGuessCoefs=!ParamIsDefault(templateCoefsRef) && (strlen(templateCoefsRef) > 0) && waveexists($templateCoefsRef)	if (passedGuessCoefs)		WAVE/d templateCoefs=$templateCoefsRef	endif	Variable doFitting = ParamIsDefault(skipFits) || !skipFits || !passedGuessCoefs		//skipping fitting requires skipFits==1 AND passedGuessCoefs	Variable returnFinalCoefs=!Paramisdefault(allFinalCoefsRef) && (strlen(allFinalCoefsRef) > 0)	if (returnFinalCoefs )		make/o/n=(numCoefsPerFit,numFits)/d	$allFinalCoefsRef/wave=finalCoefsWv	//rows for up to max num coefs, cols for each fit	else		make/o/n=(numCoefsPerFit,numFits)/d/free finalCoefsWv	endif		//related to setting up for exhaustive fitting	//amplitudes	if (hasxwv)		nearFinalVal = faverageXY(xwv,wv,fitEndX-0.00025,fitEndX)		//mean(wv,fitEndX-0.00025,fitEndX)	//currently constrains fitting!		peakVal = wv(xwv[fitstartp])				//min tau as min gap in xwv		minTau = wave_getMinAdjacentDiff(xwv,fitStartP,fitEndP) * 2	else		nearFinalVal = mean(wv,fitEndX-0.00025,fitEndX)	//currently constrains fitting!		peakVal = wv[fitStartP]		minTau = dimdelta(wv,0)*2		//new tau guesses start at 1% of last tau or 2 sampling rate  -- wil	endif	maxAmp = peakVal-nearFinalVal		//starts at peak	minAmp = 0.005 *maxAmp			//0.5% of maxAmp 	level95Complete = nearFinalVal + 0.05 * (peakVal - nearFinalVal)	if (hasxwv)		FindLevel/B=3/R=(fitStartX,fitEndX)/P/Q wv, level95Complete		maxTau = V_flag ? 0.003 : xwv[V_levelX]-fitStartX		else		FindLevel/B=3/R=(fitStartX,fitEndX)/Q wv, level95Complete		maxTau = V_flag ? 0.003 : V_levelX	-fitStartX		//if level find failed, go with 0.003 -- recently added fitStartX (Feb 2019) which seems like it should be here, even though we generally arent using this any more	endif	Variable constrainMaxAmp = 1	Double ampConstraintMultiplier = 1.1	print "analysis_capTransFitsNew","nearFinalVal",nearFinalVal,"peakVal",peakVal,"maxAmp",maxAmp,"minAmp",minAmp,"level95Complete",level95Complete,"maxTau",maxTau		//main exponential fits + analysis	for (i=0;i<numFits;i+=1)		numExps = i+1		numCoefs = 2*numExps+1		dlStart = "cf_"+num2str(i) + "_"			startIndex = numOverallParams + totalParamsPerFit * i		componentDataStartInd = startIndex+numNonCompFitPars		V_FitError=0	//set to zero so that errors are ignored for handling by us		if (numExps == 1)			make/o/d/n=(1+2*numExps) coefs;coefs=nan						if ( (i < forceMaxNumFits) && doFitting )				if (hasxwv)					Curvefit/W=2/N=1/Q=1 exp_XOffset, kwCWave=coefs, wv[fitStartP, fitendP]/C=analysis_expFit_getConstaints(wv,dimsize(coefs,0),fitStartP,fitEndP,xWvRef=xWvRef)/W=weightWvTemp[fitStartP, fitendP]/x=xwv[fitStartP, fitendP]					//Curvefit/W=2/N=1/Q=1 exp_XOffset, kwCWave=coefs, wv[fitStartP, fitendP]/W=weightWvTemp[fitStartP, fitendP]/x=xwv				else					Curvefit/W=2/N=1/Q=1 exp_XOffset, kwCWave=coefs, wv[fitStartP, fitendP]/C=analysis_expFit_getConstaints(wv,dimsize(coefs,0),fitStartP,fitEndP,xWvRef=xWvRef)/W=weightWvTemp[fitStartP, fitendP]				endif				analysis_sortExpCoefWave(coefs)	//rearrange coefs so that exponentials are ordered from fastest (smallest tau) to slowest				ssres_cpx = V_chisq			endif						if (doExhaustiveForLowerOrder && doFitting)				make/o/d/n=(numCoefs,4) specWv;specWv=nan		//had been free making it unfree for debugging				//y zero values 				specWv[0][0,1]=1;specWv[0][2]=nearFinalVal		//hold y zero guess				//amp can go from min to max  -- not using log scaling				specWv[1][0]=numNewTauAmpTests;specWv[1][1]=0;specWv[1][2]=(numOldTauTauTests > 1 ? minAmp : maxAmp);specWv[1][3]=maxAmp				//tau can go from min to max  -- use log scaling				specWv[2][0]=numNewTauTauTests;specWv[2][1]=1;specWv[2][2]=(numNewTauTauTests > 1 ? minTau : maxTau/3);specWv[2][3]=maxTau				make/o/d/n=(4)/free ampSpecWv={maxAmp,NaN,constrainMaxAmp,ampConstraintMultiplier}					ssres_cpxExh = expFit_exhaustive(specWv,wv,fitStartX,fitEndX,expFitMaxTau,selectstring(hasWeightWv,"","weightWvTemp"),"coefs_exh",ampSpecWv=ampSpecWv,xwvref=xwvref)				WAVE coefs_exh				if (!PAramIsDefault(saveFitInfoRefs))					fitInfoRef = stringbykey(num2str(i),saveFitInfoRefs)					if (strlen(fitInfoRef) > 0)						duplicate/o $"fitInfo",$fitInfoRef/wave=fitInfoWv						numTests = dimsize(fitInfoWv,1)						redimension/n=(-1,numTests+1) fitInfoWv						fitInfoWv[0,numCoefs-1][numTests]=nan		//no initial guesses for this						fitInfoWv[numCoefs,2*numCoefs-1][numTests]=coefs[p-numCoefs]						fitInfoWv[2*numCoefs][numTests]=ssres_cpx						fitInfoWv[2*numCoefs+1,][numTests]=nan					endif				endif											if (ssres_cpxExh < ssres_cpx)					print "exhaustive beat igor guesses!! exp",i					duplicate/o coefs_exh,coefs					ssres_cpx = ssres_cpxExh				endif			endif						if (!doFitting)				duplicate/o/free/d/r=[0,numCoefs-1][i] templateCoefs,coefs				redimension/n=(-1) coefs				if (hasWeightWv)					ssres_cpx =  expFit_getRes(wv,coefs,fitStartX,fitEndX,xwvref=xwvref,weightWv=weightWvTemp)				else					ssres_cpx =  expFit_getRes(wv,coefs,fitStartX,fitEndX,xwvref=xwvref)				endif			endif						elseif (numExps == 2)			Duplicate/O coefs, coefs_last				//putting this at end instead? ssres_sim = V_chisq			Make/O/D/N=(1 + 2*numExps) coefs;coefs=nan						if ( (i < forceMaxNumFits) && doFitting )				if (hasxwv)					Curvefit/W=2/N=1/Q=1 dblexp_XOffset, kwCWave=coefs, wv[fitStartP, fitendP]/C=analysis_expFit_getConstaints(wv,dimsize(coefs,0),fitStartP,fitEndP,xwvref=xwvref)/W=weightWvTemp[fitStartP, fitendP]/x=xwv[fitStartP, fitendP]				else						Curvefit/W=2/N=1/Q=1 dblexp_XOffset, kwCWave=coefs, wv[fitStartP, fitendP]/C=analysis_expFit_getConstaints(wv,dimsize(coefs,0),fitStartP,fitEndP,xwvref=xwvref)/W=weightWvTemp[fitStartP, fitendP]				endif				analysis_sortExpCoefWave(coefs)	//rearrange coefs so that exponentials are ordered from fastest (smallest tau) to slowest				ssres_cpx = V_chisq			endif						if (doExhaustiveForLowerOrder && doFItting)			//goes much like the if statement for doExhaustiveForHigherORder				make/o/d/n=(numCoefs,4) specWv;specWv=nan		//had been free making it unfree for debugging				//y zero values 				specWv[0][0,1]=1;specWv[0][2]=nearFinalVal		//hold y zero guess				//for amp value				specWv[1][0]=numOldTauTauTests;specWv[1][1]=1;specWv[1][2]=(numOldTauTauTests > 1 ? minAmp : coefs_last[1]);specWv[1][3]=coefs_last[1]				//for tau value				specWv[2][0]=1;specWv[2][1]=1;specWv[2][2]=coefs_last[2]				//set amp range for new tau				specWv[3][0] = numNewTauAmpTests;specWv[3][1] = 0;specWv[3][2] = minAmp;specWv[3][3] = maxAmp						//new component amplitude and tau				specWv[4][0] = numNewTauTauTests;specWv[4][1] = 1;specWv[4][2] = minTau;specWv[4][3] = maxTau				//tell expFit that the first component amp initial guess should be adjusted to give total equal to base subbed peakVal				make/o/d/n=(4)/free ampSpecWv={maxAmp,3,constrainMaxAmp,ampConstraintMultiplier}									ssres_cpxExh = expFit_exhaustive(specWv,wv,fitStartX,fitEndX,expFitMaxTau,selectstring(hasWeightWv,"","weightWvTemp"),"coefs_exh",ampSpecWv=ampSpecWv,xwvref=xwvref)				WAVE coefs_exh				if (!PAramIsDefault(saveFitInfoRefs))					fitInfoRef = stringbykey(num2str(i),saveFitInfoRefs)					if (strlen(fitInfoRef) > 0)						duplicate/o $"fitInfo",$fitInfoRef/wave=fitInfoWv						numTests = dimsize(fitInfoWv,1)						redimension/n=(-1,numTests+1) fitInfoWv						fitInfoWv[0,numCoefs-1][numTests]=nan		//no initial guesses for this						fitInfoWv[numCoefs,2*numCoefs-1][numTests]=coefs[p-numCoefs]						fitInfoWv[2*numCoefs][numTests]=ssres_cpx						fitInfoWv[2*numCoefs+1,][numTests]=nan					endif				endif											if (ssres_cpxExh < ssres_cpx)					print "exhaustive beat igor guesses!! exp",i					duplicate/o coefs_exh,coefs					ssres_cpx = ssres_cpxExh				endif			endif						if (!doFitting)				duplicate/o/free/d/r=[0,numCoefs-1][i] templateCoefs,coefs				redimension/n=(-1) coefs				if (hasWeightWv)					ssres_cpx =  expFit_getRes(wv,coefs,fitStartX,fitEndX,xwvref=xwvref,weightWv=weightWvTemp)				else					ssres_cpx =  expFit_getRes(wv,coefs,fitStartX,fitEndX,xwvref=xwvref)				endif			endif									else  //numExps > 2					if ( (i < forceMaxNumFits) && doFitting)							if (numExps == 3)					make/o/d/n=(numexps-1) newAmps,newTaus				else					Redimension/N=(numExps-1) newAmps,newTaus				endif							Duplicate/O coefs, coefs_last		//this is already sorted fastest to slowest tau								oldNumParams=dimsize(coefs,0)				newAmpIndex = oldNumParams				newTauIndex = oldNumParams+1				redimension/n=(oldNumParams+2) coefs								//pick an amplitude for the new component, pretty arbitrary				prevCoefsToUse=0		//assume prev guesses arent available, then check if they are												if (passedGuessCoefs)					duplicate/o/free/d/r=[0,numCoefs-1][i] templateCoefs,lastCoefs					redimension/n=(-1) lastCoefs										if (numtype(sum(lastCoefs)) == 0)		//as long as all the values are not nan/inf in coefs, go ahead and use them						coefs=lastCoefs						prevCoefsToUse=1					else						Print "last coefs rejected!!!"					endif				endif								if (!prevCoefsToUse)									newAmps = coefs_last[1+2*p]					newTaus = coefs_last[2+2*p]					proportion = 1/numExps		//if amplitude was evenly distributed across all components, what proportion of the total would one component have?					amp_sum = sum(newAmps)					amp_new = amp_sum/numExps	//give new guess the proportion of the amplitude it would have if all parts were equal								newAmps *= (numExps-1)/numExps					//scale down the remaining amplitudes to make room for that one					coefs[1,newAmpIndex-1;2] = newAmps[(p-1)/2]	//transfer rescaled amplitudes to new coef wave (initial guesses)					coefs[newAmpIndex] = amp_new											//pick a tau for the new component, also arbitrary					tau_oldMin = newTaus[0]					tau_oldMax = newTaus[dimsize(newTaus,0)-1]					tau_oldRange = tau_oldMax-tau_oldMin					tau_newMin = tau_oldMin/2					tau_newMax = tau_oldMax*2					tau_newRange = tau_newMax-tau_newMin					tau_new = tau_newMin + tau_newRange * 0.5		//put new tau squarely in the middle					newTaus = tau_newMin + tau_newRange * ( (newTaus[p]-tau_oldMin) / tau_oldRange )		//redistribute old taus across new range in proportion to their original value					coefs[2,newTauIndex-1;2] = newTaus[(p-2)/2]					coefs[newTauIndex] = tau_new						//Print "analysis_cellparams_es_vc_cap() on wave",nameofwave(wv),"numExps",numExps								endif								if (doExhaustiveFittingForHigherOrder == 0)		//original fitting routine, defaults to user guidance on screw up or with user request									if (i < forceMaxNumFits)						WAVE/T constraintsWv=analysis_expFit_getConstaints(wv,dimsize(coefs,0),fitStartP,fitEndP,xwvref=xwvref)						String constraintsWvRef=nameofwave(constraintsWv)						Variable/G x0 = fitStartX						if (hasxwv)							FuncFit/NTHR=0/W=2/N=1/Q=1 myExp, coefs, wv[fitStartP, fitendP]/C=constraintsWv/W=weightWvTemp[fitStartP, fitendP]	/x=xwv[fitStartP, fitendP]						else							FuncFit/NTHR=0/W=2/N=1/Q=1 myExp, coefs, wv[fitStartP, fitendP]/C=constraintsWv/W=weightWvTemp[fitStartP, fitendP]								endif												if (!hasxwv && ( !ParamIsDefault(forceUserGuidance) && forceUserGuidance ) || (userGuesses && (V_FitError > 0)) )							fitsAlreadyMAtch = EqualWaves(coefs, lastCoefs ,1,1e-13) && (numtype(sum(coefs) == 0)) 	//the numtype checks that real values exist in coefs							if (!fitsAlreadyMatch)								Print "analysis_cellParams_ES_VC_cf() fit had error V_FitError=",V_fitError,"seeking user guidance (starts from original guesses)"								duplicate/o coefs,coefwave;								analysis_labelExpCoefWave(coefwave)								fit_getUserFit_main(coefwave,wv,x0,fitStartX,fitEndX,"myExp",guidedFitWinN,weightWv=weightWvTemp,constraintsWvRef=constraintsWvRef)								duplicate/o coefwave,coefs								Variable/G x0 = fitStartX								FuncFit/NTHR=0/W=2/N=1/Q=1 myExp, coefs, wv[fitStartP, fitendP]/C=constraintsWv/W=weightWvTemp[fitStartP, fitendP]	//one more fit to se V_chiSq							endif						endif												ssres_cpx = V_chisq					endif								else		//doExhaustiveFittingForHigherOrder > 0 new version.. no user input .. exhaustive		.. but not yet supported!							make/o/d/n=(numCoefs,4) specWv;specWv=nan		//had been free making it unfree for debugging					//y zero values 					specWv[0][0,1]=1;specWv[0][2]=nearFinalVal		//hold y zero guess						//for now, initial guess old component amps and taus taus near there original value					for (iii=0;iii<(numExps-1);iii+=1)							//amplitude guesses						specWv[2*iii+1][0]=numOldTauTauTests						specWv[2*iii+1][1]=1		//use log						specWv[2*iii+1][2]=numOldTauTauTests > 1 ? minAmp : coefs_last[p]				//if not testing multiple values, use old value						specWv[2*iii+1][3]=coefs_last[p]			//can only be as large as original							//tau guesses						specWv[2*iii+2][0,1]=1		//just one tau to try						specWv[2*iii+2][2]=coefs_last[p]					endfor						//set amp range for new tau					specWv[2*iii+1][0] = numNewTauAmpTests					specWv[2*iii+1][1] = 0	//amp uses linear					specWv[2*iii+1][2] = minAmp					specWv[2*iii+1][3] = maxAmp								//new component amplitude and tau					specWv[2*iii+2][0] = numNewTauTauTests					specWv[2*iii+2][1] = 1	//tau uses log					specWv[2*iii+2][2] = minTau					specWv[2*iii+2][3] = maxTau					make/o/d/n=(4)/free ampSpecWv={maxAmp,2*iii+1,constrainMaxAmp,ampConstraintMultiplier}	//tell expFit that all amp index values excep this last one should be adjusted to give total equal to base subbed peakVal										ssres_cpx = expFit_exhaustive(specWv,wv,fitStartX,fitEndX,expFitMaxTau,selectstring(hasWeightWv,"","weightWvTemp"),"coefs",ampSpecWv=ampSpecWv,xwvref=xwvref)											if (!PAramIsDefault(saveFitInfoRefs))						fitInfoRef = stringbykey(num2str(i),saveFitInfoRefs)						if (strlen(fitInfoRef) > 0)							duplicate/o $"fitInfo",$fitInfoRef						endif					endif								endif								analysis_sortExpCoefWave(coefs)	//rearrange coefs so that exponentials are ordered from fastest (smallest tau) to slowest							else //doFitting==0							if (passedGuessCoefs)					duplicate/o/free/d/r=[0,numCoefs-1][i] templateCoefs,coefs					redimension/n=(-1) coefs					if (hasWeightWv)						ssres_cpx =  expFit_getRes(wv,coefs,fitStartX,fitEndX,xwvref=xwvref,weightWv=weightWvTemp)					else						ssres_cpx =  expFit_getRes(wv,coefs,fitStartX,fitEndX,xwvref=xwvref)					endif				else					ssres_cpx = nan					continue				endif						endif	//end for if (doFitting)				endif	//endif for if (numExps == whatever)						//FOR FITS OF ANY SIZE				RF = V_FitError > 0		if (RF)			Print "analysis_cellParams_ES_VC_cf(): fit rejection. numExps=",numExps,"V_fitQuitReason",V_fitQuitReason,"V_FitError",V_FitError//," saved as",(nameofwave(wv) + "fitFail_"+num2str(i))," and follows:"			Print/d coefs		//	Duplicate/O coefs, $(nameofwave(wv) + "fitFail_"+num2str(i))		endif			print "final coefs i==",i, coefs				iSS_real = coefs[0]		//steady current of fit, normalized (and thus conductance)		ssRin = vCmdVal/iSS_real			//steady resistance of fit		iPeak_real = myExp(coefs,fitStartX)		//peak capacitance current of fit, normalized (and thus conductance)		rPeak_equivRa = vCmdVal/iPeak_real					//access resistance of fit (resistance at peak of transient)		Rmem_tot =( vCmdVal - (rPeak_equivRa*iSS_real) ) / iSS_real			//membrane resistance from simple single compartment model				iSS_equivGss = iSS_real / vCmdVal		iPeak_equivGpeak = iPeak_real / vCmdVal		Ra_csum=0;q_csum=0;q_peak_cSum=0;cap_cSum=0;cap_peak_cSum=0;sa_cSum=0;sa_peak_cSum=0;sph_dia_cSum=0;sph_dia_peak_cSum=0		for (j=0;j<numExps;j+=1)		//component analysis part 2			tau_cIndex = 2 + 2*j		//order is y0 + amp0 + tau0 + amp1 + tau1 ...			amp_cIndex = 1 + 2*j							tau_c = coefs[tau_cIndex]			amp_c = coefs[amp_cIndex]					Ra_c = vCmdVal / amp_c; Ra_csum+=Ra_c;			iPeak_c = coefs[0] + amp_c			Ra_peak_c = vCmdVal / iPeak_c						amp_real_c = amp_c		//kept around in case ever run on normalized responses 			iPeak_real_c = iPeak_c 						q_c = tau_c * amp_real_c; q_csum+=q_c		//Jonas method -- not sure if it's right to exclude the SS component though, so doing it both ways			q_peak_c = tau_c * iPeak_real_c; q_peak_cSum+=q_peak_c		//peak includes that component						cap_c = q_c / vCmdVal	;cap_cSum+=cap_c	//vCmdVal actually cancels out but leaving for clarity			cap_peak_c = q_peak_c / vCmdVal; cap_peak_cSum+= cap_peak_c						sa_c = cap_c / assumedSpecificCap;sa_cSum+=sa_c			//units of m^2 [F/ (F/m^2) = m^2]			sa_peak_c = cap_peak_c / assumedSpecificCap;sa_peak_cSum+=sa_peak_c							sph_dia_c = 2*sqrt(sa_c/4/pi)	;sph_dia_cSum+=sph_dia_c;	//surface area to sphere diameter ( from SA = 4*pi(d/2)^2 )			sph_dia_peak_c = 2*sqrt(sa_peak_c/4/pi);sph_dia_peak_cSum+=sph_dia_peak_c			endfor //end component analysis part 1						for (j=0;j<numFits;j+=1)	//component analysis part 2-- compute fractional versions -- but do for all so labels can be assigned			if (j<numExps)		//still in range for this fit							tau_cIndex = 2 + 2*j		//order is y0 + amp0 + tau0 + amp1 + tau1 ...				amp_cIndex = 1 + 2*j									tau_c = coefs[tau_cIndex]				amp_c = coefs[amp_cIndex]							Ra_c = vCmdVal / amp_c; Ra_c_fr = Ra_c / Ra_csum				iPeak_c = iSS_equivGss + amp_c				Ra_peak_c = 1 / iPeak_c								amp_real_c = amp_c * vCmdVal				iPeak_real_c = iPeak_c * vCmdVal								q_c = tau_c * amp_real_c;q_c_fr = q_c / q_csum	//Jonas method -- not sure if it's right to exclude the SS component though, so doing it both ways				q_peak_c = tau_c * iPeak_real_c;q_peak_c_fr = q_peak_c/ q_peak_cSum	//peak includes that component								cap_c = q_c / vCmdVal	;cap_c_fr = cap_c / cap_cSum//vCmdVal actually cancels out but leaving for clarity				cap_peak_c = q_peak_c / vCmdVal; cap_peak_c_fr = cap_peak_c / cap_peak_cSum								sa_c = cap_c / assumedSpecificCap			//units of m^2 [F/ (F/m^2) = m^2]				sa_peak_c = cap_peak_c / assumedSpecificCap									sph_dia_c = 2*sqrt(sa_c/4/pi)		//surface area to sphere diameter ( from SA = 4*pi(d/2)^2 )				sph_dia_peak_c = 2*sqrt(sa_peak_c/4/pi)									nas=0			else				nas=1		//no assigning values, assign nan			endif					compInd =  componentDataStartInd + j*numParamsPerComponent //numParamsPerComponent should matc number of compInd+=1 lines below			dlComp=dlStart+"co"+num2str(j) + "_"			dl_assignAndLbl(out,compInd,nas ? nan : tau_c,dlComp+"tau_c")			compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : amp_c,dlComp+"amp_c")			compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : Ra_c,dlComp+"Ra_c")			compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : iPeak_c,dlComp+"iPeak_c")			compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : Ra_peak_c,dlComp+"Ra_peak_c")						compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : amp_real_c,dlComp+"amp_real_c")			compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : iPeak_real_c,dlComp+"iPeak_real_c")			compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : q_c,dlComp+"q_c")			compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : q_peak_c,dlComp+"q_peak_c")			compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : cap_c,dlComp+"cap_c")						compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : cap_peak_c,dlComp+"cap_peak_c")			compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : sa_c,dlComp+"sa_c")			compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : sa_peak_c,dlComp+"sa_peak_c")			compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : sph_dia_peak_c,dlComp+"sph_dia_peak_c")			compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : Ra_c_fr,dlComp+"Ra_c_fr")						compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : q_c_fr,dlComp+"q_c_fr")			compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : q_peak_c_fr,dlComp+"q_peak_c_fr")			compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : cap_c_fr,dlComp+"cap_c_fr")			compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : cap_peak_c_fr,dlComp+"cap_peak_c_fr")				compInd+=1;dl_assignAndLbl(out,compInd,nas ? nan : sph_dia_c,dlComp+"sph_dia_c")	//20		update numParamsPerComponent if changes			//store all the subtotals! Including coefs!		endfor			//FOR HIGHER ORDER FITS -- test against others 		if (i>0)			//note: ssres_sim will have been appopriately set in previous iteration			stats_ftestChi_simple(ssres_sim,ssres_cpx,dimsize(coefs_last,0),dimsize(coefs,0),fitPnts,"analysis_ftestCapFitTemp",ftest_pcrit)			WAVE/D ftest = $	"analysis_ftestCapFitTemp"			//save it!			if (ftest[%f_acceptComplex])				f_bestModel = i			endif					if (ftest[%chi_acceptComplex])				chi_bestModel = i			endif		else			//get a placeholder hopefully			stats_ftestChi_simple(nan,nan,nan,nan,nan,"analysis_ftestCapFitTemp",nan)			WAVE/D ftest = $	"analysis_ftestCapFitTemp"			ftest=nan		endif				//pre-fit params spacer length stored in numPreFitParams		ii=startIndex		setdimlabel 0,ii,$(dlStart+"FITPARAMS_START"),out; out[ii]=nan				//assign and label coefs		ii=startIndex + numPreFitParams		for (k=0;k<numCoefsPerFit;k+=1)			lblstr=dlStart+"coef_"+num2str(k)+"_"			if (k==0)				lblstr+="y0"			else				if (mod(k,2))		//odd					lblstr+="amp"+num2str(floor(k/2))				else					lblstr+="tau"+num2str(floor((k-1)/2))				endif			endif			SetDimLabel 0,ii+k,$lblstr,out 			out[ii+k]=nan		//set to nan for now so only rows with actual coef values in this fit have a value		endfor		out[ii,ii+numCoefs-1] = coefs[p-ii]	//only assign the coefs that actually present for this fit			//assign and label fit-specific params	-- if #s change update numNonStatsFitParams			ii=startIndex+numPreFitParams+numCoefsPerFit					dl_assignAndLbl(out,ii,i,dlStart+"fitNum")		//if more values are added here must update numNonStatsFitParams		ii+=1;dl_assignAndLbl(out,ii,numExps,dlStart+"numExps")		ii+=1;dl_assignAndLbl(out,ii,numCoefs,dlStart+"numCoefs")		ii+=1;dl_assignAndLbl(out,ii,V_fitQuitReason,dlStart+"V_fitQuitReason")		ii+=1;dl_assignAndLbl(out,ii,V_FitError,dlStart+"V_FitError")				ii+=1;dl_assignAndLbl(out,ii,V_FitError & 2^1,dlStart+"SingularMat")		ii+=1;dl_assignAndLbl(out,ii,V_FitError & 2^2,dlStart+"OutOfMem")		ii+=1;dl_assignAndLbl(out,ii,V_FitError & 2^3,dlStart+"ReturnedNaNInf")		ii+=1;dl_assignAndLbl(out,ii,V_FitError & 2^4,dlStart+"FuncRequestedStop")		ii+=1;dl_assignAndLbl(out,ii,V_FitError & 2^5,dlStart+"ReentrantFittingS")	//second fit started during first				ii+=1;dl_assignAndLbl(out,ii,V_fitQuitReason==1,dlStart+"IterLimit")	//iteration limit		ii+=1;dl_assignAndLbl(out,ii,V_fitQuitReason==2,dlStart+"UserAbort")	//user abort		ii+=1;dl_assignAndLbl(out,ii,V_fitQuitReason==3,dlStart+"IterLimitWOChi")	//"the limit of passes without decreasing chi-square was reached"		ii+=1;dl_assignAndLbl(out,ii,iSS_equivGss,dlStart+"iSS_equivGss")		ii+=1;dl_assignAndLbl(out,ii,ssRin,dlStart+"ssRin")				ii+=1;dl_assignAndLbl(out,ii,iPeak_equivGpeak,dlStart+"iPeak_equivGpeak")		ii+=1;dl_assignAndLbl(out,ii,rPeak_equivRa,dlStart+"rPeak_equivRa")		ii+=1;dl_assignAndLbl(out,ii,Rmem_tot,dlStart+"Rmem_tot")		ii+=1;dl_assignAndLbl(out,ii,iSS_real,dlStart+"iSS_real")		ii+=1;dl_assignAndLbl(out,ii,iPeak_real,dlStart+"iPeak_real")				ii+=1;dl_assignAndLbl(out,ii,Ra_csum,dlStart+"Ra_csum")		ii+=1;dl_assignAndLbl(out,ii,q_csum,dlStart+"q_csum")		ii+=1;dl_assignAndLbl(out,ii,q_peak_cSum,dlStart+"q_peak_cSum")		ii+=1;dl_assignAndLbl(out,ii,cap_cSum,dlStart+"cap_cSum")		ii+=1;dl_assignAndLbl(out,ii,cap_peak_cSum,dlStart+"cap_peak_cSum")				ii+=1;dl_assignAndLbl(out,ii,sa_cSum,dlStart+"sa_cSum")		ii+=1;dl_assignAndLbl(out,ii,sa_peak_cSum,dlStart+"sa_peak_cSum")		ii+=1;dl_assignAndLbl(out,ii,sph_dia_cSum,dlStart+"sph_dia_cSum")		ii+=1;dl_assignAndLbl(out,ii,sph_dia_peak_cSum,dlStart+"sph_dia_peak_cSum")	//29				//assign stats		ii=startIndex+numPreFitParams+numCoefsPerFit+numNonStatsFitParams		out[ii,ii+numFTestChiStats-1] = ftest[p-ii]		dl_lblsToLbls(nameofwave(ftest),0,0,inf,nameofwave(out),0,ii,dlStart+"stats_",1)				//post-fit params spacer, length stored in numPostFitParams		ii=startIndex+numPreFitParams+numCoefsPerFit+numNonStatsFitParams+numFTestChiStats		setdimlabel 0,ii,$(dlStart+"COMPONENTPARAMS_START"),out;out[ii]=nan				//store final coefs in easily accessible format		setdimlabel 1,i,$("fit_"+num2str(i)),finalCoefsWv		finalCoefsWv[0,numcoefs-1][i] = coefs[p]		if (dimsize(finalCoefsWv,0) > numcoefs)			finalCoefsWv[numcoefs,][i] = nan		endif				ssres_sim=ssres_cpx	endfor //end fits loop		//general params start at begining of wave -- starts from 0 add more change numOverallParams	ii=0;dl_assignAndLbl(out,ii,NaN,"cf_"+"OVERALL_MULTI-EXPFIT_START")	ii+=1;dl_assignAndLbl(out,ii,assumedSpecificCap,"cf_"+"assumedSpecificCap")	ii+=1;dl_assignAndLbl(out,ii,ftest_pcrit,"cf_"+"ftest_pcrit")	ii+=1;dl_assignAndLbl(out,ii,numFTestChiStats,"cf_"+"numFTestChiStats")	ii+=1;dl_assignAndLbl(out,ii,fitStartX,"cf_"+"fitStartX")	ii+=1;dl_assignAndLbl(out,ii,fitEndX,"cf_"+"fitEndX")	ii+=1;dl_assignAndLbl(out,ii,fitStartP,"cf_"+"fitStartP")	ii+=1;dl_assignAndLbl(out,ii,fitEndP,"cf_"+"fitEndP")	ii+=1;dl_assignAndLbl(out,ii,numFits,"cf_"+"numFits")	ii+=1;dl_assignAndLbl(out,ii,fitPnts,"cf_"+"fitPnts")	ii+=1;dl_assignAndLbl(out,ii,hasWeightWv,"cf_"+"hasWeightWv")	ii+=1;dl_assignAndLbl(out,ii,x0,"cf_"+"x0")	ii+=1;dl_assignAndLbl(out,ii,numPreFitParams,"cf_"+"numPreFitParams")	ii+=1;dl_assignAndLbl(out,ii,numOverallParams,"cf_"+"numOverallParams")	ii+=1;dl_assignAndLbl(out,ii,numCoefsPerFit,"cf_"+"numCoefsPerFit")	ii+=1;dl_assignAndLbl(out,ii,numNonStatsFitParams,"cf_"+"numNonStatsFitParams")	ii+=1;dl_assignAndLbl(out,ii,numPostFitParams,"cf_"+"numPostFitParams")	ii+=1;dl_assignAndLbl(out,ii,numNonCompFitPars,"cf_"+"numNonCompFitPars")	ii+=1;dl_assignAndLbl(out,ii,numParamsPerComponent,"cf_"+"numParamsPerComponent")	ii+=1;dl_assignAndLbl(out,ii,numComponentParamsPerFit,"cf_"+"numComponentParamsPerFit")		ii+=1;dl_assignAndLbl(out,ii,totalParamsPerFit,"cf_"+"totalParamsPerFit")	ii+=1;dl_assignAndLbl(out,ii,numParams,"cf_"+"numParams")	ii+=1;dl_assignAndLbl(out,ii,f_bestModel,"cf_"+"f_bestModel")	ii+=1;dl_assignAndLbl(out,ii,chi_bestModel,"cf_"+"chi_bestModel")		//24			//add more info on best model		Variable f_bestModel_numExps = f_bestModel+1	Variable best_numCoefs = 1+2*f_bestModel_numExps	Variable best_slowTauCoefWvInd = best_numCoefs - 1	Variable best_slowAmpPos = best_numCoefs - 2	Variable best_slowTau = finalCoefsWv[best_slowTauCoefWvInd][f_bestModel]	Variable best_slowAmp = finalCoefsWv[best_slowAmpPos][f_bestModel]		ii+=1;dl_assignAndLbl(out,ii,f_bestModel_numExps,"cf_"+"f_bestModel_numExps")		//25		ii+=1;dl_assignAndLbl(out,ii,best_numCoefs,"cf_"+"best_numCoefs")	ii+=1;dl_assignAndLbl(out,ii,best_slowTauCoefWvInd,"cf_"+"best_slowTauCoefWvInd")	ii+=1;dl_assignAndLbl(out,ii,best_slowAmpPos,"cf_"+"best_slowAmpPos")	ii+=1;dl_assignAndLbl(out,ii,best_slowTau,"cf_"+"best_slowTau")	ii+=1;dl_assignAndLbl(out,ii,best_slowAmp,"cf_"+"best_slowAmp")			//30		ii+=1;dl_assignAndLbl(out,ii,NaN,"cf_"+"OVERALL_MULTI-EXPFIT_END")		//31endfunction/d wave_getMinAdjacentDiff(wv,startp,endp)	WAVE wv; Variable startp,endp		if (numtype(startp))		startp=0	endif	if (numtype(endp))		endp=dimsize(wv,0)-1	endif	duplicate/o/r=[startp,endp]/free wv,temp	temp[0,dimsize(temp,0)-2]=wv[p+1]-wv[p]	temp[dimsize(temp,0)-2]=nan	Double minDiff = wavemin(temp)		return minDiffend//assumes transient has been normalized to a unit (1V) stepfunction analysis_integrateCapNew(respWv,startX,endX,steadyStartX,steadyEndX,assumedSpecificCap,dv,preNormalized,outRef,[semWv,xWvRef])	WAVE/D respWv			//e.g., mean column from grand average output by step_exciseAndNorm_avgI()	WAVE/D semWv			//same for sem column, just pass for a rough estimate	Variable startX,endX	//range for integration	Variable steadyStartX,steadyEndX		//steady state current shouldn't be integrated, so choose region to measure mean and subtract. Perhaps from endX to 1 ms after would be good	Double assumedSpecificCap,dv	//assumed specific capacitance in SI units F/m^2 (equiv. pF / um2 anyway) and voltage command step size in V for calculating actual values	String outRef	Variable preNormalized		//pass true if response has been normalized to 1V stimulus, otherwise pass 0	String xWvRef		//optionally pass an x wave for non-uniform dt (NOT SUPPORTING semWv STUFF AT PRESENT)		Variable hasXWvRef=!ParamIsDefault(xWvRef) && strlen(xWvRef)>0		Double ssMean	if (hasXWvRef)		WAVE xWv = $xWvRef		ssMean = faverageXY(xWv, respWv, steadyStartX,steadyEndX)		Variable startp,endp		WAVE xwv=$xwvref		if (numtype(startx)==0)			findlevel/edge=1/p xwv,startx			startp = V_levelx		else			startp=0		endif		if (numtype(startx)==0)			findlevel/edge=1/p xwv,endx			endp = V_levelx - 1		else			endp=dimsize(respWv,0)-1		endif		duplicate/o/free/r=[startp,endp] respWv,noDc		duplicate/o/free/r=[startp,endp] xwv,xwvSub	else		ssMean = mean(respWv,steadyStartX,steadyEndX)		Duplicate/o/free/r=(startX,endX) respWv,noDC	endif	noDC -= ssMean		//subtract SS		make/o/d/n=1 noDC_int		if (hasXWvRef)		integrate/t noDC/D=noDC_int/X=xwvSub	else		integrate/t noDC/D=noDC_int		//could use area instead since I think we only look at the last point here	endif		variable pnts = dimsize(noDC_int,0)	Double unit_charge,charge,cap,sa_mSq,sa_umSq,sph_dia_m,sph_dia_um	if (preNormalized)		unit_charge = noDC_int[pnts-1]			charge = unit_charge * dv			cap = unit_charge		//equal to unit cap because Q=CV --> C = Q/V and V=1 for unit charge so C=Q	else		charge = noDC_int[pnts-1]			unit_charge = charge / dv		cap = unit_charge	endif		sa_mSq = cap / assumedSpecificCap		//sa in meters, since cap is in F	sa_umSq = sa_mSq * 10^12	sph_dia_m = 2*sqrt(sa_mSq/4/pi)	sph_dia_um = 2*sqrt(sa_umSq/4/pi)		//really still need to include the SEM of the average that was steady subtracted too.. though it should be small in comparison	//this is probably imperfect and not necessary	Double unit_charge_sem=nan,charge_sem=nan,cap_sem=nan,sa_mSq_sem=nan,sa_umSq_sem=nan,sph_dia_m_sem=nan,sph_dia_um_sem=nan	if (!ParamIsDefault(semWv) && !hasXWvRef)		duplicate/o/free/r=(startx,endx) semWv,semWvIntReg		matrixop/o/free unit_charge_semWv = sqrt(sumSqr(semWvIntReg)))	//based on added independent errors..may not be right and only doing to compare to direct measurement trace by trace		unit_charge_sem = unit_charge_semWv[0]		charge_sem = unit_charge_sem * dv		//multiplication ok		cap_sem = unit_charge_sem		sa_mSq_sem = cap_sem / assumedSpecificCap		//multiplication ok		sa_umSq_sem = sa_mSq_sem * 10^12				//multiplication ok		sph_dia_m_sem = 2*sqrt(sa_umSq_sem/4/pi)		//multiplication ok, sqrt is more complicated would have to translate e.g. an estimate on wikipedia		sph_dia_um_sem = 2*sqrt(sph_dia_m_sem/4/pi)	endif		Variable numParams=24,ii	make/o/d/n=(numPArams) $outref/wave=out	ii=0;dl_assignAndLbl(out, ii, numParams, "INTCAP_START_numParams")		ii+=1;dl_assignAndLbl(out, ii, startX, "intcap_startX")	ii+=1;dl_assignAndLbl(out, ii, endX, "intcap_endX")	ii+=1;dl_assignAndLbl(out, ii, steadyStartX, "intcap_steadyStartX")	ii+=1;dl_assignAndLbl(out, ii, steadyEndX, "intcap_steadyEndX")		ii+=1;dl_assignAndLbl(out, ii, assumedSpecificCap, "intcap_assumedSpecificCap")	ii+=1;dl_assignAndLbl(out, ii, dv, "intcap_dv")	ii+=1;dl_assignAndLbl(out, ii, ssMean, "intcap_ssMean")	ii+=1;dl_assignAndLbl(out, ii, pnts, "intcap_pnts")	ii+=1;dl_assignAndLbl(out, ii, unit_charge, "intcap_unit_charge")		ii+=1;dl_assignAndLbl(out, ii, charge, "intcap_charge")	ii+=1;dl_assignAndLbl(out, ii, cap, "intcap_cap")	ii+=1;dl_assignAndLbl(out, ii, sa_mSq, "intcap_sa_mSq")	ii+=1;dl_assignAndLbl(out, ii, sa_umSq, "intcap_sa_umSq")	ii+=1;dl_assignAndLbl(out, ii, sph_dia_m, "intcap_sph_dia_m")		ii+=1;dl_assignAndLbl(out, ii, sph_dia_um, "intcap_sph_dia_um")	//16	ii+=1;dl_assignAndLbl(out, ii, unit_charge_sem, "intcap_unit_charge_sem")	ii+=1;dl_assignAndLbl(out, ii, charge_sem, "intcap_charge_sem")	ii+=1;dl_assignAndLbl(out, ii, cap_sem, "intcap_cap_sem")	ii+=1;dl_assignAndLbl(out, ii, sa_mSq_sem, "intcap_sa_mSq_sem")		ii+=1;dl_assignAndLbl(out, ii, sa_umSq_sem, "intcap_sa_umSq_sem")	ii+=1;dl_assignAndLbl(out, ii, sph_dia_m_sem, "intcap_sph_dia_m_sem")	ii+=1;dl_assignAndLbl(out, ii, sph_dia_um_sem, "intcap_sph_dia_um_sem")	//23	ii+=1;dl_assignAndLbl(out, ii, nan, "INTCAP_END")	//24	endfunction/D waveRef_valAtX(x,ref)	String ref	Double x		WAVE wv = $ref	return wv(x)endfunction/D waveRef_valAtLbl(lbl,ref)	String ref,lbl		WAVE wv = $ref	return wv[%$lbl]end//from https://www.wavemetrics.com/code-snippet/get-free-memory-gb thomas braunFunction GetFreeMemoryInGb()    variable freeMem	#if defined(IGOR64)	    freeMem = NumberByKey("PHYSMEM", IgorInfo(0)) - NumberByKey("USEDPHYSMEM", IgorInfo(0))	#else	    freeMem = NumberByKey("FREEMEM", IgorInfo(0))	#endif    return freeMem / 1024 / 1024 / 1024Endfunction expFit_getRes(wv,coefs,startX,endX,[weightWv,xWvRef])	WAVE/D wv,coefs	Variable startX,endX	WAVE/D weightWv	String xWvRef	//optionally pass an xWave for non-uniform dt -- must be monotonically increasing		Variable hasxwv=!paramisdefault(xwvref) && strlen(xWvRef)>0	if (hasxwv)		Variable startp,endp		WAVE xwv=$xwvref		if (numtype(startx)==0)			findlevel/edge=1/p xwv,startx			startp = V_levelx		else			startp=0		endif		if (numtype(startx)==0)			findlevel/edge=1/p xwv,endx			endp = V_levelx - 1		else			endp=dimsize(wv,0)-1		endif		duplicate/o/free/r=[startp,endp][0] wv,wvSub,res		duplicate/o/free/r=[startp,endp][0] xWv,xSub		duplicate/o/free/r=[startp,endp][0] weightWv,weight	else		duplicate/o/free/r=(startx,endx)[0] wv,res	endif	redimension/n=(-1) res	Variable/G x0=startX	if (hasXwv)		if (!ParamIsDefault(weightWv))			res =  ( ( wvSub(xSub[p]) - myexp(coefs,xSub[p]) ) * weight(xSub[p]) )^2		//scaling before squaring matches v_Chisq returned by curvefit / funcfit		else			res = (wvSub(xSub[p]) - myexp(coefs,xSub[p]))^2		endif	else		if (!ParamIsDefault(weightWv))			res =  ( ( wv(x) - myexp(coefs,x) ) * weightWv(x) )^2		//scaling before squaring matches v_Chisq returned by curvefit / funcfit		else			res = (wv(x) - myexp(coefs,x))^2		endif	endif		return sum(res)end//previously called acpn_smallSlowComponentCorrection//attempts a correction to ignore very slow, very low amplitude components. //now also calculates proportion of tau function acpn_additionalParams(corrAmp_pA)	Variable corrAmp_pA	WAVE/D acpn		//delete repeated vCmdVal if necessary	String dupLbls=dl_getDupLbls(acpn,1),lbls	if (itemsinlist(listmatch(dupLbls,"vCmdVal")) > 0)		lbls = dl_getLblsAsList("acpn",1,0,inf)		Variable firstInstance = WhichListItem("vCmdVal", lbls)		variable secondInstance = WhichListItem("vCmdVal", lbls,";", firstInstance+1)		deletepoints/m=1 secondInstance,1,acpn	endif		//change highTemp to acpn_highTemp if necessary to differentiate from temp settings in wmc, which this has been getting concatenated with	Variable highTempLblPos = finddimlabel(acpn,1,"highTemp")	if (highTempLblPos >= 0)		setdimlabel 1,highTempLblPos,acpn_highTemp,acpn	endif		String dlStart = "w_",fitDlStart,fitCoefsStartDl	Variable i,rows = dimsize(acpn,0),cols=dimsize(acpn,1)	lbls = "bestModelSlowComponentBelow2pF;w_cf_best_slowTau_corr;w_cf_best_slowAmp_corr;w_cf_best_slowAmpTimesSlowTau_corr;"	lbls+="w_cf_best_slowAmpTimesSlowTauDivDv_corr;w_cf_best_slow_num_corr;isPeriph;"	Variable numModels=acpn[0][%forceMaxNumFits]	for (i=0;i<numModels;i+=1)		lbls+="capProp_model"+num2str(i)+";"	endfor	lbls+="capProp_bestModel;"	dl_createIfMissing("acpn",lbls,"1;")					VAriable bestModel,bestTauInd,bestAmpInd,fitCoefsStartInd,nextBestTauInd,nextBestAmpInd,needsCorr,stillNeedsCorr,numCorrs	Variable singleCorrs=0,doubleCorrs=0	Double newBestTau,newBestAmp	for (i=0;i<rows;i+=1)		numCorrs=0		bestModel = acpn[i][%w_cf_f_bestModel]		bestTauInd = acpn[i][%w_cf_best_slowTauCoefWvInd]		bestAmpInd = bestTauInd-1		fitDlStart = dlStart + "cf_"+num2str(bestModel)+"_"		fitCoefsStartDl = fitDlStart + "coef_0_y0"		fitCoefsStartInd = finddimlabel(acpn,1,fitCoefsStartDl)				needsCorr = acpn[i][fitCoefsStartInd+bestAmpInd] < corrAmp_pA*10^-12		acpn[i][%bestModelSlowComponentBelow2pF]=needsCorr				if ( (bestTauInd > 2) && needsCorr)			nextBestTauInd = bestTauInd-2			nextBestAmpInd = bestAmpInd-2			numCorrs+=1			singleCorrs+=1		else			nextBestTauInd = bestTauInd			nextBestAmpInd = bestAmpInd			endif				newBestTau = acpn[i][fitCoefsStartInd+nextBestTauInd]		newBestAmp = acpn[i][fitCoefsStartInd+nextBestAmpInd]		stillNeedsCorr = (newBestAmp < corrAmp_pA*10^-12) && needsCorr				if ( (nextBestTauInd > 2) && stillNeedsCorr)			nextBestTauInd-=2			nextBestAmpInd-=2			numCorrs+=1			doubleCorrs+=1		endif				acpn[i][%w_cf_best_slowTau_corr] = acpn[i][fitCoefsStartInd+nextBestTauInd]		acpn[i][%w_cf_best_slowAmp_corr] = acpn[i][fitCoefsStartInd+nextBestAmpInd]		acpn[i][%w_cf_best_slow_num_corr] = numCorrs	endfor		acpn[][%w_cf_best_slowAmpTimesSlowTau_corr]=acpn[p][%w_cf_best_slowTau_corr]*acpn[p][%w_cf_best_slowAmp_corr]	acpn[][%w_cf_best_slowAmpTimesSlowTauDivDv_corr]=acpn[p][%w_cf_best_slowAmpTimesSlowTau_corr]/acpn[p][%vCmdVal]		print "acpn_additionalParams() singleCorrs",singleCorrs,"doubleCorrs",doubleCorrs		//correct tau	make/o/n=(numModels)/free capPropInds = finddimlabel(acpn,1,"capProp_model"+num2str(p))	make/o/n=(numModels)/free modelCapInds = finddimlabel(acpn,1,"w_cf_"+num2str(p)+"_cap_cSum")		//w_cf_2_cap_cSum	for (i=0;i<numModels;i+=1)		acpn[][capPropInds[i]]=acpn[p][modelCapInds[i]]/acpn[p][%intcap_cap]	endfor	acpn[][%capProp_bestModel] = acpn[p][capPropInds[acpn[p][%w_cf_f_bestModel]]]	//acpn[p][%intcap_cap]		//peripheral	acpn[][%isPeriph] = acpn[p][%finalEcc] > 1.5endfunction wave_histFromXYCol(wv,ycol,xcol,binSizeX,outRef,unitStr)	WAVE wv	VAriable ycol,xcol,binSizeX	String outRef,unitStr		WAVEstats/rmd=[*][xcol]/q wv	Variable minVal = V_min	Variable maxVal = v_max	Variable range = maxVal - minVal	Variable numBins = floor(range/binSizeX) + 1	make/o/n=(numBins,3) $outref/wave=out	setscale/p x,minVal,binSizeX,unitStr,out	setdimlabel 1,0,mean,out	setdimlabel 1,1,count,out	setdimlabel 1,2,sum,out	out=0		Variable i,cols=dimsize(wv,0),pnt	Double xVal	for (i=0;i<cols;i+=1)		//if (wv[i][%highTemp] == 0)			xVal = wv[i][xCol]			pnt = floor ((xVal - minVal) / binSizeX)			out[pnt][2] += wv[i][yCol]			out[pnt][1] += 1		//endif	endfor			out[][0] = out[p][2]/out[p][1]	//setscale/p x,minVal+binsizex/2,binSizeX,unitStr,outendfunction/S analysis_loess_2col(wv,xcolLbl,ycolLbl,smoothing,robust,order,conf,outpnts,outRef,longName,doDisp,printInfo,[winN,passes,minX,maxX])	WAVE/D wv	String xColLbl,yColLbl		//pass unless wv is 2 column with col0 as x pnts and col1 as y pnts, then pass "" and the labels/data will be retrieved automatically	Variable outpnts		//how many points in the output data (1D wave)	String outRef		//contains data in col 0, data+99%conf interval in col 1, and data-99% conf in col 2	Variable doDisp		//1 for new graph (with data), 2 for append to top graph	Double smoothing			//ranges 0 to 1	Variable robust		//pass 1 for robust loess option	Variable order		//pass to set order (default is 2)	Variable conf		//confidence interval eg 0.99 for 99%	Variable longName	String winN		//optionally pass to try to force a name for a new window (doDisp==1) or the name of an existing window to append to (doDisp==2)	Variable passes		//optionally include a specified number of passes for the /pass flag in loess fit	Double minX,maxX	//for x subrange	Variable printInfo			Variable xcol,ycol		//handle whether labels were passed, if "", defaults to 0th col for xcollbl and 1st column for ycollbl	if (strlen(xColLbl) < 1)		xcol=0		xColLbl=getdimlabel(wv,1,xcol)	else		xcol=finddimlabel(wv,1,xcollbl)	endif		if (strlen(yColLbl) < 1)		yCol=1		yColLbl=getdimlabel(wv,1,yCol)	else		yCol=finddimlabel(wv,1,yCollbl)	endif		if ( (xcol<0) || (ycol<0) )		print "analysis_loess_2col couldnt find data col lbls xcolLbl",xcolLbl,"ycolLbl",ycolLbl,"xcol",xcol,"ycol",ycol		return ""	endif		String defaultName=selectstring(longname,"",nameofwave(wv)+"_")+yColLbl+"_vs_"+xColLbl+"_loess"	if (strlen(outRef) < 1)		outRef=defaultName		if (printinfo)			Print "analysis_loess_2col() auto outRef",outRef		endif	endif		String xDataRef=xcolLbl	String yDataRef=yColLbl	Duplicate/o/r=[][xcol] wv,$xDataRef/wave=xdata;redimension/n=(-1) xdata	Duplicate/o/r=[][ycol] wv,$yDataRef/wave=ydata;redimension/n=(-1) ydata		if (!paramisdefault(minX) || !ParamisDefault(maxX))		Double usedMaxX = ParamIsDefault(maxX) ? wavemax(xdata) : maxX		Double usedMinX = ParamIsdEfault(minX) ? wavemin(xData) : minX		Variable i,rows=dimsize(xdata,0)		for (i=rows-1;i>-1;i-=1)			if ((xdata[i] < usedMinX) || (xdata[i] > usedMaxX))				deletepoints/m=0 i,1,xdata,ydata			endif		endfor	endif		make/o/d/n=(outpnts) $outRef/wave=out	wavestats/q xdata	setscale/i x,v_min,V_max,"",out;print v_max	if (Paramisdefault(passes))		Loess/CONF={conf, ciPlus, ciMinus}/DEST=out/DFCT/SMTH=(smoothing)/r=(robust)/ord=(order) srcWave=ydata, factors={xdata}	else		Loess/CONF={conf, ciPlus, ciMinus}/DEST=out/DFCT/SMTH=(smoothing)/r=(robust)/ord=(order)/pass=(passes) srcWave=ydata, factors={xdata}	endif	duplicate/o/free ciPlus,ci;ci=ciPlus-out		//calculate ci on its own (more useful for shaded error bar display)	concatenate/kill/np=1 {ciPlus,ciMinus,ci},out 	setdimlabel 1,0,loessFit,out	setdimlabel 1,1,ciPlus,out	setdimlabel 1,2,ciMinus,out	setdimlabel 1,3,ci,out		if (doDisp>0)		String usedWinN		Variable passedwinN = !paramisDefault(winN) && (strlen(winN)>0)		if (doDisp==1)			usedWinN=selectstring(passedwinN,defaultName+"_win",winN)			display/k=1/N=$usedWinN wv[][%$ycollbl] vs wv[][%$xcollbl]			usedWinN=S_name			appendtograph/w=$usedWinN out[][%loessFit]			ModifyGraph/w=$usedWinN mode(cpWm)=3,marker(cpWm)=8,rgb(cpWm)=(0,0,0)			ErrorBars $outRef SHADE= {0,4,(0,0,0,0),(0,0,0,0)},wave=($outRef[*][%ci],$outRef[*][%ci])		elseif (doDisp==2)			usedWinN=selectstring(passedwinN,winname(0,1),winN)			appendtograph/W=$usedWinN $outref[][%loessfit]			modifygraph/W=$usedWinN lsize($outref)=2,rgb($outref)=(0,0,0)			ErrorBars/W=$usedWinN $outref SHADE={0,0,(0,0,0,13107),(0,0,0,0)},wave=($outref[*][%ci],$outref[*][%ci])		endif			endif	if (printInfo)		String dispStr="TO APPEND WITH ERROR BARS:\r"		dispStr+="appendtograph "+outref+"[][%loessfit]\r"		dispStr+="modifygraph lsize("+outref+")=2,rgb("+outref+")=(0,0,0)\r"		dispStr+="ErrorBars "+outref+" SHADE={0,0,(0,0,0,13107),(0,0,0,0)},wave=("+outref+"[*][%ci],"+outref+"[*][%ci])\r"		print/len=(2500) dispStr	endif	return outrefend//automatically sorted from lowest x value to highestfunction/WAVE wave_intoManyYBy1X(wv,tol,xCol,yCol,appendStats,outRef)	WAVE wv	Variable tol //tolerance for binning x values, e.g., 0.49 for effectively rounding to the nearest integer, as for findValue	Variable xCol,yCol	Variable appendStats		//pass 1 to calculate and append statistics for all the y columns 	String outRef	//stores output, which is a wave where column 0 contains all x values from input and other columns store any associated y values. leave "" for free wave return		if (numtype(tol))		tol=0.499	endif	Variable rows=dimsize(wv,0)		//maximum number of columns if all points have same value, maximum number of rows if no points have same value		duplicate/o/r=[][xCol]/free wv,xvals	duplicate/o/r=[][yCol]/free wv,yvals	sort/DIML xvals, xvals,yvals		if (strlen(outRef) < 1)		make/o/d/n=(rows,rows)/free out	else		make/o/d/n=(rows,rows) $outref/wave=out	endif	setdimlabel 1,0,xVals,out	setdimlabel 1,1,yValsStart,out	out=nan		Double currMax=-inf	Variable i,outputRow=-1,outputCol,maxOutputCol = -inf	for (i=0;i<rows;i+=1)		if (numtype(xvals[i]))			continue		endif			if (xvals[i] > currMax)		//new value found, store it			outputRow+=1			out[outputRow][%xVals] = xvals[i]			currMax = xvals[i] + tol			outputCol=1			//never start at zero since that is occupied by x vals		endif				out[outputRow][outputCol]=yvals[i]		if (outputCol > maxOutputCol)			maxOutputCol = outputCol		endif		outputCol+=1	endfor		redimension/n=(outputRow+1,maxOutputCol+1) out		if (appendStats)		WAVE statsTemp=wave_colStats(out,0,inf,1,inf,"",normalityTest=1)		concatenate/dl/np=1 {statsTemp},out	endif		return outendfunction wave_catYxPairsIntoManyYBy1X(xyWvList,outRef,tol,sortByX,appendStats,xCol,yCol,[transposeFirst,killAfter])	String xyWvList	//list of references to waves of xy pairs -- column 0 is x, column 1 is y (unless xCol or yCol is specified)	String outRef	//stores output, which is a wave where column 0 contains all x values from input and other columns store any associated y values	Variable tol		//tolerance for binning x values, e.g., 0.49 for effectively rounding to the nearest integer. as for findValue	Variable sortByX		//pass 1 to sort rows by x value afterwards (default is smallest to largest), 2 to sort in reverse (largest to smallest)	Variable appendStats		//pass 1 to calculate and append statistics for all the y columns 	Variable xCol,yCol	Variable transposeFirst		//pass to go along columns instead	Variable killAfter		//kill xy pairs after		Variable i,numWvs=itemsinlist(xyWvList)	String xyWvList_used,ref,tempRef	Variable doTranspose=!paramIsdefault(transposeFirst) && transposeFirst	if (doTranspose)		xyWvList_used=""		for (i=0;i<numWvs;i+=1)			ref=stringfromlist(i,xyWvList)			tempRef=ref+"_wave_catYxPairsIntoManyYBy1X_temp"			duplicate/o $ref,$tempRef			matrixtranspose $tempRef			xyWvList_used += tempRef+";"		endfor	else		xyWvList_used=xyWvList	endif		if (numtype(tol))		tol=0.499	endif	if (numWvs < 1)		return 0	endif		Variable maxOutRows=0	//find max num rows .. will resize once at end if not all were used	for (i=0;i<numWvs;i+=1)		ref = stringfromlist(i,xyWvList_used)		WAVE wv = $ref		maxOutRows+=dimsize(wv,0)	endfor		make/o/d/n=(maxOutRows,numWvs+1) $outRef/wave=out	out=nan	String oldxlbl=getdimlabel($stringfromlist(0,xyWvList_used),1,xCol)	String xColLbl = selectstring(strlen(oldxlbl) > 0,"xValues",oldxlbl)	setdimlabel 1,0,$xColLbl,out			Variable xVal,rows,j,outCol,nextNewRow=0,outRow	for (i=0;i<numWvs;i+=1)		outCol=i+1		//one column per wave		ref = stringfromlist(i,xyWvList_used)		setdimlabel 1,outCol,$ref,out		WAVE wv = $ref		rows = dimsize(wv,0)		for (j=0;j<rows;j+=1)			xval = wv[j][xCol]			if ((i>0) || (j>0))	//not the first point, so do findvalue on output wave x values				findvalue/T=(tol)/rmd=[0,nextNewRow-1][0]/V=(xval) out				if (V_value < 0)		//x value does not exist, so make a new row for it 					out[nextNewRow][0]=xVal					outRow=nextNewRow					nextNewRow+=1				else					outRow=V_value	//x value does exist, so put it in a row				endif			else	//first point				out[nextNewRow][0]=xVal				outRow=0					nextNewRow+=1				endif			out[outRow][outCol]=wv[j][yCol]		endfor		endfor		redimension/n=(nextNewRow,-1) out		if (sortByX)		if (sortByX == 2)		//reverse sort			sortColumns/kndx={0}/R sortwaves={out}		else			sortColumns/kndx={0} sortwaves={out}		endif	endif		if (appendStats)		WAVE statsTemp=wave_colStats(out,0,inf,1,inf,"",normalityTest=1)		concatenate/dl/np=1 {statsTemp},out	endif		if (doTranspose || (!paramIsDefault(killAfter) && killAfter))		killwavesbyname(xyWvList_used)	endifend function/wave cone_canonicalDims(outRef)	String outRef		Variable asFreeWv=strlen(outRef) < 1		if (asFreeWv)		make/o/d/n=(11,2)/free out	else		make/o/d/n=(11,2) $outRef/wave=out	endif		setdimlabel 1,0,periph,out	setdimlabel 1,1,foveola,out		Variable i=-1	i+=1;setdimlabel 0,i,is_len,out	i+=1;setdimlabel 0,i,is_dia,out	i+=1;setdimlabel 0,i,soma_len,out	i+=1;setdimlabel 0,i,soma_dia,out	i+=1;setdimlabel 0,i,ax_len,out	i+=1;setdimlabel 0,i,ax_dia,out	i+=1;setdimlabel 0,i,ped_len,out	i+=1;setdimlabel 0,i,ped_dia,out	i+=1;setdimlabel 0,i,gm,out	i+=1;setdimlabel 0,i,cm,out	i+=1;setdimlabel 0,i,ra,out		out[%is_len][1]=40	out[%is_dia][1]=1.5	out[%soma_len][1]=8	out[%soma_dia][1]=3	out[%ax_len][1]=350	out[%ax_dia][1]=1.6	out[%ped_len][1]=8	out[%ped_dia][1]=5	out[%gm][1]=0.0001	out[%cm][1]=1	out[%ra][1]=70		out[%is_len][0]=nan	out[%is_dia][0]=10	out[%soma_len][0]=8	out[%soma_dia][0]=10	out[%ax_len][0]=35	out[%ax_dia][0]=1.6	out[%ped_len][0]=8	out[%ped_dia][0]=10	out[%gm][0]=0.0001	out[%cm][0]=1	out[%ra][0]=70		String saContributionsList="is;soma;ax;ped;"	Double assumedSpecificCap = 0.01 			//pF / um^2 (conversion to F / m ^ 2: 1 F / 10^12 pF * 10^6 um / m * 10^6 um / m = x pF/um^2 = F/ m ^ 2)	String lbl	variable num=itemsinlist(saContributionsList)	make/o/d/n=(num,3) surfaceAreas //2πrh+2πr^2	surfaceAreas[][]=(2*pi*out[%$(stringfromlist(p,saContributionsList)+"_len")][%foveola]*out[%$(stringfromlist(p,saContributionsList)+"_dia")][%foveola]/2)*(2*pi*(out[%$(stringfromlist(p,saContributionsList)+"_dia")][%foveola]/2)^2)	dl_assignLblsFromList(surfaceAreas,0,0,saContributionsList,"",0)	setdimlabel 1,0,sa_um2,surfaceAreas	setdimlabel 1,1,cap_pF,surfaceAreas	setdimlabel 1,2,propTotalCap,surfaceAreas	surfaceAreas[][%cap_pF] = surfaceAreas[p][%sa_um2] * assumedSpecificCap	matrixop/free totalCapWv = sumcols(surfaceAreas)	Double totalCap = totalCapWv[finddimlabel(surfaceareas,1,"cap_pf")]	surfaceAreas[][%propTotalCap] = surfaceAreas[p][%cap_pF] / totalCap		print "cone_canonicalDims() created wave=surfaceAreas for foveola"	return outendfunction/D weber(x,halfDensitization)	Double x,halfDensitization	return 1/(1+x/halfDensitization)endFunction CheckNormalization(srcWave, periodogramWave)	Wave srcWave			// A real valued time series	Wave periodogramWave		// e.g., W_Periodogram	Duplicate/FREE periodogramWave,wp	// Preserve original	wp[0]/=2				// Correct the 0 bin	wp[numpnts(wp)-1] /=2		// Correct the Nyquist bin	MatrixOP/FREE w2=magsqr(srcWave)/numPoints(srcWave)	Print sum(wp), sum(w2)		// Parseval: These should be equalEnd//function histogramXY(xCol,yCol,outRef)//	String yRef, xRef, outRef; Variable numXBins, putOnTopGraph, startX, endX//	//	Duplicate/O/R=(startX, endX) $yRef, yWave2D, yOutTemp//	Duplicate/O/R=(startX, endX) $xRef, xWave2D, xOutTemp//	yOutTemp = 0//	xOutTemp = 0//	//	//sort x wave in ascending order so that we can then quickly go through and bin similar points together.//	sort xWave2D, xWave2D, yWave2D		//using xWave2D as key but also sorting yWave rearranged yWave positions in the array as positions are rearranged for xWave during the sort//	//	Variable xMinVal = xWave2D[0]//	Variable xRange = xWave2D[numpnts(xWave2D)-1] - xWave2D[0]//	Variable rangePerBin = xRange/numXBins//	//	Make/O/D/N=(numXBins,2) binValues			//2 columns, 0 = x vals, 1 = y vals//	Make/O/N=(numXBins,2) binLocs				//2 columns 0 = bin start, 1 = binEnd//	Variable i, currXVal, currYVal, currBinXAvg, currBinYAvg//	Variable currBinNum = 0, currNextBinThresh = xMinVal + rangePerBin, currBinLen = 0//	binLocs[0][0] = 0//	for (i=0;i<numpnts(xWave2D);i+=1)		//		if ((xWave2D[i] >= currNextBinThresh) || (i == numpnts(xWave2D) - 1))//		//	Print "Last Bin = " + num2str(currBinNum) + ". BinThresh(real,norm) = " + num2str(currNextBinThresh) + "," + num2str((currNextBinThresh-xMinVal)/xRange)//				//store old values//			binValues[currBinNum][0] = currBinXAvg / currBinLen//			binValues[currBinNum][1] = currBinYAvg / currBinLen//			binLocs[currBinNum][1] = i - 1//				//clear values for last bin//			currBinXAvg = 0//			currBinYAvg = 0//			currBinLen = 0//				//iterate as needed//			currBinNum +=1//			currNextBinThresh += rangePerBin//				//store start of bin//			if (i < numpnts(xWave2D) - 1)//				binLocs[currBinNum][0] = i//			endif//		endif//		currBinXAvg += xWave2D[i]//		currBinYAvg += yWave2D[i]//		currBinLen += 1//	endfor////	Duplicate/O binValues, $outRef//	KillWaves/Z xOutTemp, yOutTemp //,xWave2D, yWave2D//	//	if (putOnTopGraph)//		String traceName = outRef + "_binned"//		AppendToGraph $outRef[][1]/TN=$traceName vs $outRef[][0]//		ModifyGraph mode($traceName)=3,marker($traceName)=19,mrkThick($traceName)=2;DelayUpdate//		ModifyGraph rgb($traceName)=(0,0,0)//	endif//endfunction fft_periodgramCols(wv,outRef)	String outRef	WAVE wv		Variable cols=dimsize(wv,1),i	Variable rows=dimsize(wv,0)	Variable rowsUsed=mod(rows,2)>0 ? rows-1:rows	print "rowsUsed",rowsUsed,"time length",rowsUsed*dimdelta(wv,0)	for (i=0;i<cols;i+=1)		duplicate/o/r=[0,rowsUsed-1][i]/free wv,temp		redimension/n=(-1) temp		dspperiodogram/PARS/Q/dest=fft_dspperiodogramCols_temp temp		//had had nodc=1		if (i==0)			Duplicate/o fft_dspperiodogramCols_temp,$outRef/wave=out		else			concatenate/np=1/dl {fft_dspperiodogramCols_temp},out		endif	endfor	endfunction wave_deletePnts(wv,pntsList,dim,outRef)	WAVE wv; String pntsList; Variable dim	STring outRef		//points are deleted from wv if outRef=""!		if (strlen(outRef) < 1)		WAVE outWv=wv	else		duplicate/o wv,$outRef/wave=outWv	endif		pntsList = SortList(pntsList,";",1)	Variable i,num=itemsinlist(pntsList),pnt	for (i=0;i<num;i+=1)		pnt=str2num(stringfromlist(i,pntsList))		DeletePoints/M=(dim) pnt,1,outWv	endfor	endfunction wave_findLevelsColumns(levelsWv,colWv,outRef)	WAVE levelsWv	//for now shoubd monotonically decreasing set of levels	WAVE colWv		//monotonically decreasing down columns	String outRef		Variable levels=dimsize(levelsWv,0),i,cols=dimsize(colwv,1),j,offset=dimoffset(colWv,0)	Variable lastLevelX,potentialLevelDelta=levelsWv[1]-levelsWv[0]		//attempt scaling in case of even delta wave	Double level		make/o/d/n=(levels,cols) $outref/wave=out	for (i=0;i<levels;i+=1)		setdimlabel 0,i,$num2str(levelswv[i]),out	endfor	setscale/p x,levelswv[0],potentialLevelDelta,"",out	out=nan	dl_lblsToLbls(nameofwave(colWv),1,0,inf,outRef,1,0,"",0)		for (i=0;i<cols;i+=1)		duplicate/o/free/r=[][i] colwv,col		lastLevelX=offset		for (j=0;j<levels;j+=1)			level=levelsWv[j]			//findlevel/EDGE=2/Q/R=(offset,) col,level			findlevel/EDGE=2/Q/R=(offset,) col,level			out[j][i]=V_FLAG ? nan : V_levelX			lastLevelX=V_LevelX		endfor	endforend//originally implemented with findlevels but that seemed to miss crossings wave_findLevelsColumns(levelsWv,colWv,outRef)	WAVE levelsWv	//for now shoubd monotonically decreasing set of levels	WAVE colWv		//monotonically decreasing down columns	String outRef		Variable levels=dimsize(levelsWv,0),i,cols=dimsize(colwv,1),j,offset=dimoffset(colWv,0),rows=dimsize(Colwv,0),levelFound	Variable lastLevelX,potentialLevelDelta=levelsWv[1]-levelsWv[0]		//attempt scaling in case of even delta wave	Double level		make/o/d/n=(levels,cols) $outref/wave=out	for (i=0;i<levels;i+=1)		setdimlabel 0,i,$num2str(levelswv[i]),out	endfor	setscale/p x,levelswv[0],potentialLevelDelta,"",out	out=nan	dl_lblsToLbls(nameofwave(colWv),1,0,inf,outRef,1,0,"",0)		for (j=0;j<cols;j+=1)		lastLevelX=offset		for (i=0;i<levels;i+=1)			level=levelsWv[i]			levelFound=0			for (k=0;k<rows;k+=1)				if (colwv[k][j])<=level)					out[j][i]=pnt2x(colwv,k)					levelFound=1					break				endif			endfor			if (levelFound)		//level not found, so levels are now below range of points in wave				break			endif						lastLevelX=V_LevelX		endfor	endforendfunction brkInDataMergeWmc(brkInWv,wmcWv,[forcestart])	WAVE/t brkInWv,wmcWv; variable forcestart		variable wmcRows=dimsize(wmcWv,0)	Variable brkInwVRows=dimsize(brkInWv,0),brkInRow,i,wmc_newFrom,numSteps,j,hasStepRamp,numResps,startVal,endVal,allStepsOk	String dl,stepStartTimes,stepStartTimeInfo,stepStartTime,rangeStr,resps	for (i=paramisdefault(forcestart)?0:forcestart;i<wmcRows;i+=1)		dl=getdimlabel(wmcWv,0,i)		brkInRow=finddimlabel(brkInWv,0,dl)		if (brkInRow < 0)			brkInRow = dimsize(brkInWv,0)			redimension/n=(brkInRow+1,-1) brkInWv			brkInWv[brkInRow][%wmc_newFrom]="1"		else			brkInWv[brkInRow][%wmc_newFrom]="0"		endif		brkInWv[brkInRow][%wmc_row]=num2str(i)		stepStartTimes=wmcWv[i][%stepStartTimes]		numSteps=itemsinlist(stepStartTimes)		resps=wmcWv[i][%resps]		brkInWv[brkInRow][%wmc_allResps] =resps		brkInWv[brkInRow][%wmc_allTiming]=stepStartTimes		Variable ecc = sqrt( str2num(wmcwv[i][%finalx])^2 + str2num(wmcwv[i][%finaly])^2 )		brkInWv[brkInRow][%periph]=num2str(ecc > 1.5)		brkInWv[brkInRow][%finalX]=wmcwv[i][%finalX]		brkInWv[brkInRow][%finalY]=wmcwv[i][%finalY]		brkInWv[brkInRow][%ecc]=num2str(ecc)		setdimlabel 0,brkInRow,$dl,brkInWv		hasStepRamp=-1;allStepsOk=0		for (j=0;j<numSteps;j+=1)			stepStartTimeInfo=stringfromlist(j,stepStartTimes)			if (itemsinlist(stepStartTimeInfo,":") <2)								if (stringmatch(stepStartTimeInfo,"*.07*") && (itemsinlist(stepStartTimeInfo,",")==1))					hasStepRamp = j					allStepsOk=1					break		//stop after first ramp found				else					//print "brkInDataMergeWmc() at",i,"has single step start time but it is not expected time for step-step-ramp, skipping"				endif						else				stepStartTime=stringfromlist(1,stepStartTimeInfo,":")				if (itemsinlist(stepStartTime) == 1)					if (stringmatch(stepStartTime,"*.07*"))						hasStepRamp = j						break		//stop after first ramp found					else						print "brkInDataMergeWmc() at",i,"has single step start time but it is not expected time for step-step-ramp, skipping"					endif				endif			endif		endfor				if (hasStepRamp<0)			brkInWv[brkInRow][%wmc_hadStepRamp]="0"			brkInWv[brkInRow][%wmc_resps]=""			continue		endif		brkInWv[brkInRow][%wmc_hadStepRamp]="1"		rangeStr=stringfromlist(0,stepStartTimeInfo,":")		numResps=itemsinlist(resps)		if (allStepsOk || (strlen(rangeStr) < 1) || stringmatch(rangeStr,"~"))		//first item is used			brkInWv[brkInRow][%wmc_resps]=resps		else			brkInWv[brkInRow][%wmc_resps]=""		endif				startval=str2num(stringfromlist(0,rangeStr,"~"))		endval=str2num(stringfromlist(1,rangeStr,"~"))		if (numtype(startval) == 2)			startval = 0		endif		if (numtype(endVal) == 2)			endval = numResps		endif		for (j=startval;j<endval;j+=1)			brkInWv[brkInRow][%wmc_resps] += stringfromlist(j,resps) +";"		endfor		brkInWv[brkInRow][%wmc_stepStartTimes]=stepStartTime		//does this cell have step-step-ramp protocol?		//text_strByIndFromKeyRange(ind,keyRangedList)	endfor	endfunction analysis_brkIn(dataWv,outWv,type,ht)	WAVE/T dataWv;WAVE outWv	//assumed both are of form brkInData and brkSum (Waves in currentDensities.pxp)	Variable type		//0 for standard timing	Variable ht			//use high tem recs		Variable bsx,bex,ssx,initstartx,initendx,sfsx,sfex,bsbsx,bsbse,bsssx,bsinitstartx,bsinitendx,stepStartX_int,stepEndX_int,steadyStartX_int,steadyEndX_int,rin_stepStartX,rin_stepEndX,bsFsx,bsFex,deltaCmd,bsDeltaCmd	Variable lsx,lex,lsInitStartX,lsInitEndX,lsFsx,lsDeltaCmd		//for type=1	if (type)		ssx=0.081213 					//step start x		//0.063425		//baseline start x		bex=ssx-3.3e-05					//baseline end x		bsx=bex-0.001		initStartX=ssx+0.0045			//how long after ssx to start measurement of baseline		initEndX=initStartX+0.001		//when to end init measurement		//sex=0.083458					//step end x  -- replaced by initEndX		sfsx=0.213475					//step final start x -- 140 ms after step		sfex=0.223274					//step final end x == 150 ms after step		bsSsx=0.28121		bsBse=0.28121-3.3e-05		bsBsx=bsBse-0.001				//same as above for bs = "big step"		bsInitStartX=bsSsx+0.0045		bsInitEndX=bsInitStartX+0.001		//bsSex=0.283422		bsFsx=0.318322		bsFex=0.323322		stepStartX_int=ssx		//integrating capacitance transient info		stepEndX_int=stepStartX_int+0.003		steadyStartX_int=stepStartX_int+0.006		steadyEndX_int=stepStartX_int+0.007		rin_stepStartX=ssx+0.005		//input resistance range relative to start x -- dont want to wait for ih to come on		rin_stepEndX=ssx+0.0055				//analyzing long ih step		lsx=0.481404		lex=1.48117		//long step end x		lsInitStartX=lsx+0.01		//give tail current some time to recover, ok since ih is pretty slow, at least at RT		lsInitEndX=lsInitStartX+0.005		lsFsx=lex-0.01		//avg last 10 ms		lsDeltaCmd=-0.02		//delta command in volts, for leak correction	else		//ssx=0.073458 					//step start x		//bsx=0.072425//0.063425		//baseline start x		//bex=0.073425					//baseline end x		//sex=0.083458					//step end x  -- replaced by initEndX				ssx=0.073458 					//step start x		bex=ssx-3.3e-05					//baseline end x		bsx=bex-0.001		//baseline start x		initStartX=ssx+0.0045			//how long after ssx to start measurement of baseline		initEndX=initStartX+0.001		//when to end init measurement		sfex=0.223274					//step final end x == 150 ms after step		sfsx=sfex-0.001				//step final start x -- 140 ms after step		deltaCmd = -0.01		//delta cmd in V, for leak correction calculation					//as above for bs = "big step"		bsSsx=0.27344		//step start x as above		bsBse=bsSsx-3.3e-05 //bsBse=0.273422		bsBsx=bsBse-0.001					bsInitStartX=bsSsx+0.0045		bsInitEndX=bsInitStartX+0.001		bsFex=0.3234		bsFsx=bsFex-0.001//0.318322		//bsSex=0.283422		stepStartX_int=0.073425		//integrating capacitance transient info		stepEndX_int=0.080425		steadyStartX_int=0.079425		steadyEndX_int=0.080425		rin_stepStartX=ssx+0.005		//input resistance range relative to start x -- dont want to wait for ih to come on		rin_stepEndX=ssx+0.0055		bsDeltaCmd=0.08		//delta command in V, for leak correction calculation	endif			Variable rows=dimsize(outwv,0),i,nd	String avgRef	for (i=0;i<rows;i+=1)		avgRef=dataWv[i][%$(selectstring(ht,"","ht_")+"respAvg")]		nd=(strlen(avgRef) < 1)		//is there no data (nd)		if (!nd)			WAVE avg = $avgRef		endif		outwv[i][%vBase]=nd ? nan : mean(avg,bsx,bex)		outwv[i][%vStepInit]=nd ? nan : mean(avg,initStartX,initEndX)		//mean(avg,ssx,sex)		outwv[i][%vStepFinal]=nd ? nan : mean(avg,sfsx,sfex)		outwv[i][%bs_vbase]=nd ? nan : mean(avg,bsBsx,bsBse)		outwv[i][%bs_vStepInit]=nd ? nan : mean(avg,bsInitStartX,bsInitEndX)//mean(avg,bsSsx,bsSex)		outwv[i][%bs_vStepFinal]=nd ? nan : mean(avg,bsFsx,bsFex)		if (!nd)			analysis_ES_integrateCap(avg,"",stepStartX_int,stepEndX_int,steadyStartX_int,steadyEndX_int,0.01,-0.01,avgRef+"_intCap",notNormalized=1)			WAVE cap = $(avgRef+"_intCap")			outwv[i][16,31]=	cap[q-16]		else			outwv[i][16,31]=nan		endif		outwv[i][%vMin]=nd ? nan : wavemin(avg,stepStartX_int,stepEndX_int)				if (type)		//lsx,lex,lsInitStartX,lsInitEndX,lsFsx			outwv[i][%ls_vStepInit]=nd ? nan : mean(Avg,lsInitStartX,lsInitEndX)			outwv[i][%ls_vStepFinal]=nd ? nan : mean(avg,lsFsx,lex)				endif	endfor	•outwv[][%vdStepInit]=outwv[p][%vStepInit]-outwv[p][%vBase]		//deltaV from baseline right after step	•outwv[][%vdStepFinal]=outwv[p][%vStepFinal]-outwv[p][%vBase]	//deltaV from baseline at end of step	•outwv[][%vdFinalInit]=outwv[p][%vStepFinal]-outwv[p][%vStepInit]	//deltaV from start of step at end of step	•outwv[][%vfFinalInit]=outwv[p][%vdStepFinal]/outwv[p][%vdStepInit]	//fold deltaV from start of step at end of step	•outwv[][%bs_vdStepInit]=outwv[p][%bs_vStepInit]-outwv[p][%bs_vBase]	//deltaV from baseline right after step	•outwv[][%bs_vdStepFinal]=outwv[p][%bs_vStepFinal]-outwv[p][%bs_vBase]	//deltaV from baseline at end of step	•outwv[][%bs_vdFinalInit]=outwv[p][%bs_vStepFinal]-outwv[p][%bs_vStepInit]	//deltaV from start of step at end of step	•outwv[][%bs_vfFinalInit]=outwv[p][%bs_vdStepFinal]/outwv[p][%bs_vdStepInit]	//fold deltaV from start of step at end of step	 outwv[][%rIn]=-0.01/outwv[p][%vdStepInit]	 outwv[][%gIn]=1/outwv[p][%rIn]	•outwv[][%vdFinalInit_perUmSq]=outwv[p][%vdFinalInit]/outwv[p][%sa_umSq]	•outwv[][%bs_vdFinalInit_perUmSq]=outwv[p][%bs_vdFinalInit]/outwv[p][%sa_umSq]	•outwv[][%vdMin]=outwv[p][%Vmin]-outwv[p][%vBase]	•outwv[][%accessR]=-0.01/outwv[p][%Vmin]	•outwv[][%vdFinalInit_timesRin]=outwv[p][%vdFinalInit]*outwv[p][%Rin]	outwv[][%bs_vdFinalInit_timesRin]=outwv[p][%bs_vdFinalInit]*outwv[p][%Rin]			if (!type)		outwv[][%isFoveal]=!str2num(datawv[p][%periph])	endif	outwv[][%ecc]=str2num(datawv[p][%ecc])>10 ? 10 : str2num(datawv[p][%ecc])		//add leak corrections (4 new columns): leakExpected,vdStepFinal_lcorr,bs_leakExpected,bs_vdStepFinal_lcorr	outwv[][%leakExpected]=deltaCmd/outwv[p][%rIn]	//change in current expected from leak alone is Vcmd=Iexpected*Rin --> Iexpected=Vcmd/Rin	outwv[][%vdStepFinal_lcorr]=outwv[p][%vdStepFinal]-outwv[p][%leakExpected]	outwv[][%bs_leakExpected]=bsDeltaCmd/outwv[p][%rIn]	outwv[][%bs_vdStepFinal_lcorr]=outwv[p][%bs_vdStepFinal]-outwv[p][%bs_leakExpected]		if (type)		//extra column labels for type==1: ls_vStepInit,ls_vStepFinal,ls_vdStepInit,ls_vdStepFinal,ls_vdFinalInit,ls_vfFinalInit,ls_leakExpected,ls_vdStepFinal_lcorr		outwv[][%ls_vdStepInit]=outwv[p][%ls_vStepInit]-outWv[p][%vBase]				outwv[][%ls_vdStepFinal]=outwv[p][%ls_vStepFinal]-outwv[p][%vBase]	//use baseline at start of recording and compare to step evoking ih; needs leak correction		outwv[][%ls_vdFinalInit]=outwv[p][%ls_vStepFinal]-outwv[p][%ls_vStepInit]		outwv[][%ls_vfFinalInit]=outwv[p][%ls_vStepFinal]/outwv[p][%ls_vStepInit]		outwv[][%ls_leakExpected]=lsDeltaCmd/outwv[p][%rIn]		outwv[][%ls_vdStepFinal_lcorr]=outwv[p][%ls_vdStepFinal]-outwv[p][%ls_leakExpected]	endifendfunction/S analysis_cellParamsNew_layerPlot(indWv,ro,recalculate,plotComponents)	WAVE/T indWv		//e.g., wmct	Variable ro	Variable recalculate		//skip recalclating timing wave -- which requires underlying waves	Variable plotComponents	//0 for no, 1 for just components, 2 for components and markers at taus		String forceWinStartStr=nameofwave(indwv)+"_"+num2str(ro)+"_",traces,trace	String basename = getdimlabel(indwv,0,ro)	String timingRef=basename+"_brkInTiming"	String layerComb=basename+"_layerComb",cpnRefs=""	Variable numTimingParams=19,numRefs,brkInTime	Variable i,maxLayers=dimsize(indwv,2),j,numTraces,fNum	Double range,mult,sub,access,origAccess,scale,brkInTime_secs,minSweepTime,midSweepTime,maxSweepTime,tau0_breakin,tau1_breakin,amp0_breakin,amp1_breakin	String cpnRef,refs,notestr,ref,brkInSweep	Variable actualLayers=0		//see which layers have responses and find max access	Double maxAccess=inf	for (i=0;i<maxLayers;i+=1)		cpnRef=indwv[ro][%cellParams_outRef][i]		if (strlen(cpnRef) < 1)			break		endif					cpnRefs+=cpnref+";"		WAVE cpn=$cpnRef		access=cpn[%accessR_nomodel]		if (cpn[%accessR_nomodel]<maxAccess)			maxAccess=access		endif	endfor	actualLayers=i	for (i=0;i<actualLayers;i+=1)		//deal with making the normalized plot		cpnRef=indwv[ro][%cellParams_outRef][i]		WAVE cpn=$cpnRef		traces=analysis_cellParamsNew_plotExps2("1;",cpn,i!=0,0,forceWinStartStr=forceWinStartStr,dontclear=1)		numTraces=itemsinlist(traces)		range=cpn[%peakVal]-cpn[%ssCurrent_noModel]		mult=1/range		sub= -cpn[%ssCurrent_noModel]*mult		access=cpn[%accessR_nomodel]				if (i==0)			scale=1	//presumed break in sweep		else			scale=maxAccess	/access		endif				mult*=scale		sub*=scale		for (j=0;j<numTraces;j+=1)			trace=stringfromlist(j,traces)			modifygraph muloffset($trace)={0,mult},offset($trace)={0,sub}		endfor						if (recalculate)			//deal with making a wave that can serve as an x axis with time since break in 			refs=indwv[ro][%resps][i]			duplicate/o/free/r=[0,4][1] $indwv[ro][%$(selectstring(i==0,"w_","nw_")+"expOutRef")][i] ,coefs			if (i==0)		//presumed break in sweep				brkInSweep=stringfromlist(0,refs)				fNum=text_getinfofromwavename_V(brkInSweep,1)				brkInTime_secs=text_fd_getRelTimeSinceFile(brkInSweep, fNum, 5)				make/o/d/n=(actualLayers,numTimingParams) $timingRef/wave=timing				timing=nan				setdimlabel 1,0,minTime_secs_relBrkIn,timing				setdimlabel 1,1,maxTime_secs_relBrkIn,timing				setdimlabel 1,2,midTime_secs_relBrkIn,timing					setdimlabel 1,3,minTime_mins_relBrkIn,timing				setdimlabel 1,4,maxTime_mins_relBrkIn,timing				setdimlabel 1,5,midTime_mins_relBrkIn,timing						setdimlabel 1,6,brkInTime_secs_relFileStart,timing				timing[0][]=q==6 ? brkInTime_secs : 0								setdimlabel 1,7,tau0_amp,timing				setdimlabel 1,8,tau0_plotAmp,timing				setdimlabel 1,9,tau0_plotTau,timing				setdimlabel 1,10,tau0_plotAmp_scaled,timing				setdimlabel 1,11,tau0_amp_norm,timing				setdimlabel 1,12,tau0_norm,timing								setdimlabel 1,13,tau1_amp,timing				setdimlabel 1,14,tau1_plotAmp,timing				setdimlabel 1,15,tau1_plotTau,timing				setdimlabel 1,16,tau1_plotAmp_scaled,timing				setdimlabel 1,17,tau1_amp_norm,timing				setdimlabel 1,18,tau1_norm,timing								amp0_breakin=coefs[1]				tau0_breakin=coefs[2]				amp1_breakin=coefs[3]				tau1_breakin=coefs[4]			else				numRefs=itemsinlist(refs)				minSweepTime=text_fd_getRelTimeSinceFile(stringfromlist(0,refs), fNum, 5)				if (numRefs<2)					maxSweepTime=minSweepTime					midSweepTime=minSweepTime				else					maxSweepTime=text_fd_getRelTimeSinceFile(stringfromlist(numRefs-1,refs), fNum, 5)					midSweepTime=minSweepTime + (maxSweepTime-minSweepTime)/2				endif				timing[i][%minTime_secs_relBrkIn]=minSweepTime-brkInTime_secs				timing[i][%midTime_secs_relBrkIn]=midSweepTime-brkInTime_secs				timing[i][%maxTime_secs_relBrkIn]=maxSweepTime-brkInTime_secs			endif						timing[i][%tau0_amp]=coefs[1]			timing[i][%tau0_plotAmp]=coefs[0]+coefs[1]/exp(1)// use this version to plot with main plot instead of with component (coefs[1]/exp(1)) + myExp({coefs[0],coefs[3],coefs[4]},coefs[2]	)			timing[i][%tau0_plotTau]=coefs[2]					timing[i][%tau0_plotAmp_scaled]=timing[i][q-2]*mult+sub			timing[i][%tau0_amp_norm]=i==0 ? coefs[1] : coefs[1]/amp0_breakin			timing[i][%tau0_norm]= coefs[2]/tau0_breakin						timing[i][%tau1_amp]=coefs[3]			timing[i][%tau1_plotAmp]=coefs[0]+coefs[3]/exp(1)// use this version to plot with main plot instead of with component (coefs[3]/exp(1)) + myExp({coefs[0],coefs[1],coefs[2]},coefs[4])			timing[i][%tau1_plotTau]=coefs[4]			timing[i][%tau1_plotAmp_scaled]=timing[i][q-2]*mult+sub			timing[i][%tau1_amp_norm]=i==0 ? coefs[3] : coefs[3]/amp1_breakin			timing[i][%tau1_norm]=coefs[4]/tau1_breakin				endif	endfor	if (recalculate)		timing[1,][3,5]=timing[p][q-3]/60		//calculate time elapsed in min since break in	else		WAVE timing=$timingRef	endif	concatenate/dl/o cpnRefs,$layerComb/wave=comb		print "timingRef",timingRef,"layerComb",layerComb		indwv[ro][%timing][0]=timingRef	indwv[ro][%layerComb][0]=layerComb	if (plotComponents==0)		disp_general_ta("removefromgraph %s",0,"*_c*","*",1)	 		disp_general_ta("removefromgraph %s",0,"*_exp_*","*",1)		elseif (plotComponents < 3)		disp_general_ta("removefromgraph %s",0,"*_exp_*","*",1)		endif	disp_general_ta("errorbars %s OFF",0,"*","*",1)	disp_general_ta("modifygraph rgb(%s)=(0,0,0,25000)",0,"*A","*",1)	Label left "∆Voltage (norm.)\\u#2"	Label bottom,"Time (ms)\\u#2"	String brkInAvgRef=indwv[ro][%pulseTimedAvg_outAvg][0]	modifygraph rgb($brkInAvgRef)=(65535,0,0)	reordertraces _front_,{$brkInAvgRef}	modifygraph fsize=12	if (plotComponents==2)		appendtograph timing[][%tau0_plotAmp_scaled]/tn=plotTau0 vs timing[][%tau0_plotTau]		appendtograph timing[][%tau1_plotAmp_scaled]/tn=plotTau1 vs timing[][%tau1_plotTau]		ModifyGraph mode(plotTau0)=3,marker(plotTau0)=8,rgb(plotTau0)=(65535,0,52428),mode(plotTau1)=3,marker(plotTau1)=8,rgb(plotTau1)=(65535,0,52428)	endif		String winN=basename+"_tauVsTimeWin"	display/k=1 timing[][%tau1_plotTau] vs timing[][%midTime_mins_relBrkIn];ModifyGraph mode=3,marker=8,rgb=(0,0,0);setaxis left 0,*	winN=s_name	appendtograph/l=left2/w=$winN comb[%accessR_nomodel][1,] vs timing[1,][%midTime_mins_relBrkIn];	appendtograph/l=left3/w=$winN timing[1,][%tau1_amp] vs timing[1,][%midTime_mins_relBrkIn];	modifygraph/w=$winN freepos=0,lblpos=52,mode=3,marker=8,rgb=(0,0,0)		//axisenab(left)={0.3,1},axisenab(left2)={0,0.4}	disp_arrayAxes(winN,"",0.08,"left2;left3;left;")	setaxis/w=$winN/A bottom,0,*	setaxis/w=$winN left 0,*	setaxis/w=$winN/A left2,0,*	setaxis/w=$winN/A left3,0,*	doupdate	getaxis/W=$winN bottom	SetDrawEnv/w=$winN xcoord= bottom,ycoord= left,linefgc= (65535,0,0),dash= 2	DrawLine/w=$winN V_min,tau1_breakin,v_max,tau1_breakin	Label/w=$winN bottom "Minutes from Patch Rupture"	Label/w=$winN left "IS τ\\BSlow\\M (ms)\\u#2"	Label/w=$winN left2 "R\\BAccess\\M (MΩ)\\u#2"	Label/w=$winN left3 "A\\BSlow\\M (pF)\\u#2"	modifygraph/w=$winN  fsize=12	disp_setwinsize(2,2,2);doupdate;	disp_setwinsize(0,0,2)	return timingRef	endfunction wave_list_merge(list,xColLbl,yColLbl,outRef)	String list,outRef,yColLbl,xColLbl		String ref=stringfromlist(0,list),assignments	Variable yCol=finddimlabel($ref,1,yColLbl)	Variable xCol=finddimlabel($ref,1,xColLbl)	Variable i,num=itemsinlist(list)	Variable start,rows,j	for (i=0;i<num;i+=1)		ref=stringfromlist(i,list)		WAVE wv=$ref		rows=dimsize($ref,0)		if (i==0)			make/o/d/n=(rows,2) $outref/wave=out			setdimlabel 1,0,$xColLbl,out			setdimlabel 1,1,$yColLbl,out			start=0		else			start=dimsize(out,0)			redimension/n=(start+rows,-1) out		endif		out[start,start+rows-1][0]=wv[p-start][xCol]		out[start,start+rows-1][1]=wv[p-start][yCol]		assignments=""		for (j=0;j<rows;j+=1)			assignments+=ref+"_"+num2str(j)+";"		endfor		dl_assignLblsFromList(out,0,start,assignments,"",0)	endforendfunction/s analysis_wmc(startRow,numRow,startLayer,numLayers,recalcOptions)	Variable startRow,numRow		//hcAfter runs analysis_wmcHoldingComp after the end of each row	Variable StartLayer,numLayers,recalcOptions			//bitwise: bit0 for avg from raw , bit1 for acpn from avg, bit2 for analysis_wmcHoldingComp																	//so 1 3 or 7 for instance to do first, first and second, or all three		WAVE/t wmc	Variable i,j,maxLayer=dimsize(wmc,2)-1,maxRow=dimsize(wmc,0)-1,ro,la,loadedGlobals=0	STring avgRef,repsRef,nw_expRef,w_expRef,cpnRef,resps	for (i=0;i<numRow;i+=1)		ro = i + startRow		if (ro > maxRow)			break		endif				for (j=0;j<numLayers;j+=1)			la = startLayer + j			if (la > maxLayer)				continue			endif					resps = wmc[ro][%resps][la]			if (itemsinlist(resps) < 1)				break			endif			if (recalcOptions & 2^0)				avgRef=analysis_pulseTimedAvg_L(resps,"","","",nan,nan,"","",str2num(wmc[ro][%prePulseAvgDur][la]),str2num(wmc[ro][%avgLenX][la]),str2num(wmc[ro][%dcSubStartX][la]),str2num(wmc[ro][%dcSubLenX][la]),forcePulseTimingStr=wmc[ro][%stepStartTimes][la],weightStr=wmc[ro][%weights][la],outliers=wmc[ro][%outliers][la],loadWvOptions=1,killAfter=1)				wmc[ro][%pulseTimedAvg_outAvg][la]=avgRef;wmc[ro][%pulseTimedAvg_outReps][la]=stringbykey("pulseTA_out_reps",note($avgRef))			endif						if (recalcOptions & 2^1)				avgRef=wmc[ro][%pulseTimedAvg_outAvg][la];nw_expRef=avgRef+"_nwE";w_expRef = avgRef +"_wE";				cpnRef=analysis_cellParamsNew(avgRef,avgRef,str2num(wmc[ro][%vCmdVal][la]),0,str2num(wmc[ro][%fitWinSizeX][la]),"","","",nw_expRef,w_expRef,2,1,1,respCol=1,semCol=16)				wmc[ro][%nw_expOutRef][la]=nw_expRef				wmc[ro][%w_expOutRef][la]=w_expRef				wmc[ro][%cellParams_outRef][la]=cpnRef				if (loadedGlobals==0)					SVAR nw_fitInfoRefs					SVAR w_fitInfoRefs					loadedGlobals=1				endif				wmc[ro][%nw_fitInfoRefs][la]=nw_fitInfoRefs				wmc[ro][%w_fitInfoRefs][la]=w_fitInfoRefs;			endif		endfor			if (recalcOptions & 2^2)			print "analysis_wmcHoldingComp output", analysis_wmcHoldingComp(ro,1)		endif	endforendout=analysis_pulseTimedAvg_L(wmc[ro][%resps][la],"","","",nan,nan,"","",str2num(wmc[ro][%prePulseAvgDur][la]),str2num(wmc[ro][%avgLenX][la]),str2num(wmc[ro][%dcSubStartX][la]),str2num(wmc[ro][%dcSubLenX][la]),forcePulseTimingStr=wmc[ro][%stepStartTimes][la],weightStr=wmc[ro][%weights][la],outliers=wmc[ro][%outliers][la])reps = out[0,strlen(out)-2] + "R"disp_cols_simple($reps,0);modifygraph rgb=(0,0,0,10000);appendtograph $out[][%avg];setaxis bottom -0.00015,0.01;setaxis/A=2 leftwmc[ro][%pulseTimedAvg_outAvg][la]=out;wmc[ro][%pulseTimedAvg_outReps][la]=stringbykey("pulseTA_out_reps",note($out))avg=wmc[ro][%pulseTimedAvg_outAvg][la];nw_expRef=avg+"_nwE";w_expRef = avg +"_wE";cpnOut=analysis_cellParamsNew(avg,avg,str2num(wmc[ro][%vCmdVal][la]),0,str2num(wmc[ro][%fitWinSizeX][la]),"","","",nw_expRef,w_expRef,2,1,1,respCol=1,semCol=16);wmc[ro][%nw_expOutRef][la]=nw_expRef;wmc[ro][%w_expOutRef][la]=w_expRef;wmc[ro][%cellParams_outRef][la]=cpnOut;wmc[ro][%nw_fitInfoRefs][la]=nw_fitInfoRefs;wmc[ro][%w_fitInfoRefs][la]=w_fitInfoRefs;function/S analysis_wmcHoldingComp(startRow,numRow)	Variable startRow,numRow	String outRef					WAVE/T wmc		Variable i,row,maxRow=dimsize(wmc,0)-1,numLayers,j,layer,maxLayer=dimsize(wmc,2)-1,count,holding,acpnRows	String holdingCompLayers,cpnRef,lbl,holdCompCpn,currCpn,outREfs="",isPeriph,ecc,highTemp	for (i=0;i<numRow;i+=1)		row = i + startRow		if (row > maxRow)			break		endif				holdingCompLayers = wmc[row][%holdingCompLayers][0]		numLayers = itemsinlist(holdingCompLayers)		count=0		make/o/n=(numLayers) holdVals		for (j=0;j<numLayers;j+=1)			layer=str2num(stringfromlist(j,holdingCompLayers))			if ( (layer > maxLayer) || numtype(layer))				print "analysis_wmcHoldingComp() unexpected skip layer in row",row,"likely to screw shit up"				continue			endif						lbl = getdimlabel(wmc,0,row)			holdCompCpn = lbl +"_hcCpn"			holding = str2num(wmc[row][%holding][layer])			holdVals[count]=holding			currCpn=wmc[row][%cellParams_outRef][layer]						isPeriph=wmc[row][%isPeriph][0]			ecc=wmc[row][%ecc][0]			highTemp=wmc[row][%highTemp][0]			dl_addVal(str2num(isPeriph), "isPeriph", currCpn, 0)			dl_addVal(str2num(ecc), "ecc", currCpn, 0)			dl_addVal(str2num(highTemp), "highTemp", currCpn, 0)						if (count==0)				duplicate/o $currCpn, $holdCompCpn/wave=hcCpn				redimension/n=(-1,1) hcCpn				wmc[row][%holdCompCpn][0] = holdCompCpn			else				concatenate/np=1/dl {$currCpn},hcCpn			endif						setdimlabel 1,count,$("L"+num2str(layer)+"_H"+text_num2str(holding)+"_"+currCpn),hcCpn						count+=1		endfor				if (numLayers>0)			acpnRows=dimsize(hcCpn,0)			redimension/n=(acpnRows+1,-1) hcCpn			hcCpn[acpnRows][] = holdVals[q]			setdimlabel 0,acpnRows,holding,hcCpn			outREfs+=holdCompCpn+";"		endif	endfor		return outREfsendfunction ih_calc(startRow,numRows,doDisp)	Variable startRow,numRows,doDisp		Variable reloadOnlyNonExistent =1		WAVE/T ihInd //{"periph","preIvFam","washinFam","washin_start","washin_end","inIvFam","washoutFam","washout_start","washout_end","postIvFam"}	Double ivHold=-0.03,testPulse1=-0.005,testPulse2=0.005	//make/o/d/free ivSteps = {-0.06,-0.05,-0.04,-0.03,-0.02,-0.01,0.01}		//set based on list in ivSteps_mV	make/o/d/free washSteps = {-0.06}		//must be just one repeated step; otherwise would need to change output datastructure from one column for each of pre/post washin/washout	make/o/d/free eRevs = {0,-0.015,-0.03,-0.045}		//for conductance calc, what reversal potentials to try (number can vary)	make/o/d/free expFitInfo = {4.9,1.1,0.025,0.012}		//for stats_ivFam exponential fitting	Variable initAvgLenX=0.005,initDelay=0.02		//initial period before Ih begins to average for a form of baseline subtraction		//times should be first and last point during step..these are defaults but if stored in corresponding column for each index, those supercede	Variable pulse1StartX_default=0.24065,pulse1EndX_default=0.31562,pulse2StartX_default=0.51565,pulse2EndX_default=0.59065		//test pulses for	Variable ivStepStartX_default=1.3407,ivStepEndX_default=6.3406		//start and end for variable region	Variable pulse1StartX,pulse1EndX,pulse2StartX,pulse2EndX,ivStepStartX,ivStepEndX		Variable baselineDelay = 0.0015	//how long before step to stop baseline measurement	Variable ivBaselineAvgLenX = 0.2	Variable ivStepAvgLenX = 0.2	Variable ivStepDelay = 0.01		//how long before step end to stop step average measurement	Variable ivTailDelay = 7e-05		//how long AFTER step end to start measuring tail current	Variable ivTailAvgLenX = 0.000125 		//how long to average for tail -- for Ih the tail current looks quite brief			Variable inputWinSizeX=0.005	Variable baseline1StartX,baseline1EndX,input1StartX,input1EndX	Variable baseline2StartX,baseline2EndX,input2StartX,input2EndX	String outAppendStr = "_ih"	String washTraces = "washin_start;washin_end;washout_start;washout_end;"	String ivFams = "preIvFam;inIvFam;postIvFam;preMinusInFam;postMinusInFam;"	String ivfamsForReload=""//"preIvFam;inIvFam;postIvFam;"		//none for now bc these get reloaded for subtraction	String avgWvLblsForInput = text_appendToStrsInList(ivFams,"_avg",0,";") //	 = "preIvFam_avg;inIvFam_avg;postIvFam_avg;"	//labels for saving averages used for input res calc	Variable numIvFams = itemsinlist(avgWvLblsForInput)		String washFams = "washinFam;washoutFam;"		//need an output column with these items +"Stats" at the end of the label ..output will be cellName + "_ih[washFam]Stats" saved in the appropriate column where [washFam] is set by this list	Variable numWashFams = itemsinlist(washFams)		//setup parameters for boltzmann fits	String boltzmannCols = "preMinusInFam;postMinusInFam;preMinusInFam_stat;postMinusInFam_stat;"	//cols in iv2Dstats to compute boltzmann fit	String boltzmannParams = "coef0_G;coef1_vHalf;coef2_K;V_FitError;V_Pr;V_r2;V_FitQuitReason;gInit;vHalfInit;kInit;findlevel_flag;findlevel_x;findLevel_rising;findLevel_vFound;vHalfInit_outOfRange;hasData;periph;n67_current;sa_umSq;presumedERev;drivingForce;n67_current_norm;n67_conductance;n67_conductance_norm;coef0_G_norm;n67i_current;n67i_current_norm;n67i_conductance;n67i_conductance_norm;div;blocker;"	String boltzmannFitStatsRef,layerLbl	Variable gInit_periph=-3.03e-10,gInit_foveal=-9.62e-9,boltzmann_K_guess=-0.0068,boltzmann_vHalf_guess=-0.1,layer,numBoltzmannFitPnts=100,boltzmannStartVm=-0.11,boltzmannEndVm=0.01,boltzmannDelta=(boltzmannEndVm-boltzmannStartVm)/(numBoltzmannFitPnts-1)	//limits for automate vHalf guessing for fit initialization	Variable numBoltzmannCols=itemsinlist(boltzmannCols),numBoltzmannParams=itemsinlist(boltzmannParams),ivRows,numSteps,V_FitError,V_Pr,V_r2,V_FitQuitReason	Variable stepStartV,stepDeltaV			make/n=(numIvFams)/free hasFams; dl_assignLblsFromList(hasFams,0,0,ivFams,"",0)	Variable ro,i,numInFam,j,baselineSubLenP,ivCount,numWashTraces,washCount,numIvSteps,periph	Double input1,input2,input,baseline1,baseline2,delta1,delta2,inputForLeakSub,presumedERev,drivingForce	string ihStatsRef,cellname,avgRef,fam,ihIvStatsRef,avgLbl,famLbl,washStatsRef,capTransStatsRef,normedCapTransientRefs,capTransRef,allLoaded,loaded,washLbl,washTraceRef,washFam,washFamList,washRefs,washFamStatsRef	make/o/free/t saNormList = {"stats","iv2DStats","washStatsRef"}	Double sa_umSq	String ref; Variable higherDim,numToSaNorm=dimsize(saNormList,0)	for (i=0;i<numRows;i+=1)		ro=startRow+i		if (ro >= dimsize(ihInd,0))			break		endif		cellname = GetDimLabel(ihInd, 0, ro ) 		periph = str2num(ihInd[ro][%periph])		allLoaded = ""		print "starting row",ro,"cellname",cellname						//PULSE AND STEP TIMING		pulse1startX = strlen(ihInd[ro][%pulse1StartX])>0 ? str2num(ihInd[ro][%pulse1StartX]) : pulse1StartX_default		pulse1EndX = strlen(ihInd[ro][%pulse1EndX])>0 ? str2num(ihInd[ro][%pulse1EndX]) : pulse1EndX_default		pulse2StartX = strlen(ihInd[ro][%pulse2StartX])>0 ? str2num(ihInd[ro][%pulse2StartX]) : pulse2StartX_default		pulse2EndX = strlen(ihInd[ro][%pulse2EndX])>0 ? str2num(ihInd[ro][%pulse2EndX]) : pulse2EndX_default		ivStepStartX = strlen(ihInd[ro][%ivStepStartX])>0 ? str2num(ihInd[ro][%ivStepStartX]) : ivStepStartX_default		ivStepEndX = strlen(ihInd[ro][%ivStepEndX])>0 ? str2num(ihInd[ro][%ivStepEndX]) : ivStepEndX_default				baseline1StartX=pulse1StartX-baselineDelay-inputWinSizeX		baseline1EndX=pulse1StartX-baselineDelay		input1StartX=pulse1EndX-baselineDelay-inputWinSizeX		input1EndX=pulse1EndX-baselineDelay		baseline2StartX=pulse2StartX-baselineDelay-inputWinSizeX		baseline2EndX=pulse2StartX-baselineDelay		input2StartX=pulse2EndX-baselineDelay-inputWinSizeX		input2EndX=pulse2EndX-baselineDelay				//LOAD WAVES if needed				loaded="";da_fd_loadWavesFromWaveName(ihInd[ro][%capTransFam],reloadOnlyNonExistent,out_loadedWvList=loaded)		allLoaded += loaded				//CAP TRANSIENT		capTransStatsRef = cellName + "_ihCapStats"		ihInd[ro][%capTransStats]=capTransStatsRef		baselineSubLenP = 0.005/dimdelta($stringfromlist(0,ihInd[ro][%capTransFam]),0)				ihInd[ro][%normedCapTransRefs]=step_exciseAndNorm_avgI(ihInd[ro][%capTransFam],"0;","1,3,5,7,;",{-2,2,-1,1},1,baselineSubLenP,0,0.01,0.07,"ihCap",1,0,1)		capTransRef = stringbykey("outRef_canonical_w",ihInd[ro][%normedCapTransRefs])		WAVE capTrans=$capTransRef		analysis_ES_integrateCap(capTrans,"",0,0.015,0.013,0.015,0.01,0.0025,capTransStatsRef,removeSemStats=1)		WAVE capStats = $capTransStatsRef				//IV: outputs		ihStatsRef = cellname + "_ihStats"		ihIvStatsRef = cellname + "_ihIvStats"		//just the iv stats in a more easy to read, step-by-step form		ihInd[ro][%stats]=ihStatsRef		ihInd[ro][%iv2DStats]=ihIvStatsRef				//IV: calculate IV fam raw differences		if (hasFams[%inIvFam] && hasFams[%preIvFam])			da_fd_loadWavesFromWaveName(ihInd[ro][%inIvFam]+ihInd[ro][%preIvFam],reloadOnlyNonExistent,out_loadedWvList=loaded)			ihInd[ro][%preMinusInFam]=wave_subtractLists(ihInd[ro][%inIvFam],ihInd[ro][%preIvFam])		endif		if (hasFams[%inIvFam] && hasFams[%postIvFam])			da_fd_loadWavesFromWaveName(ihInd[ro][%postIvFam],reloadOnlyNonExistent,out_loadedWvList=loaded)			ihInd[ro][%postMinusInFam]=wave_subtractLists(ihInd[ro][%inIvFam],ihInd[ro][%postIvFam])		endif				//IV: analyze IV families -- calculate average and then compute input resistances from that [in stats_input] and compute I(V) and g(V) relation [in stats_ivFam]		hasFams=0		ivCount=0		numIvSteps = itemsinlist(ihInd[ro][%ivSteps_mV])		make/o/d/free/n=(numIvSteps) ivSteps; ivSteps = str2num(stringfromlist(p,ihInd[ro][%ivSteps_mV]))/1000		for (j=0;j<numIvFams;j+=1)			avgLbl=stringfromlist(j,avgWvLblsForInput)			famLbl=stringfromlist(j,ivFams)			fam = ihInd[ro][%$famLbl]			hasFams[j] = itemsinlist(fam) >= 1			if (!hasFams[j])				continue			endif						if (whichlistitem(famLbl,ivFamsForReload)>=0)				loaded="";da_fd_loadWavesFromWaveName(fam,reloadOnlyNonExistent,out_loadedWvList=loaded)				allLoaded += loaded			endif			avgRef = wave_avgFromStrList(fam,";","",0,-inf,inf,np=1)			ihInd[ro][%$avgLbl] = avgRef			WAVE avg = $avgRef					WAVE inputInfo=stats_twoStepInput(avg,baseline1StartX,baseline1EndX,input1StartX,input1EndX,testPulse1,baseline2StartX,baseline2EndX,input2StartX,input2EndX,testPulse2)						inputForLeakSub = inputInfo[%resistance_input2]		//positive going step seems less subject to change toward net inward current .. likely because in negative direction there is a reduction in ikx?			make/o/d/free/n=(1) linearIvStats			WAVE ivStats = stats_ivFam(fam,ivSteps,eRevs,ivHold,ivStepStartX,ivStepEndX,ivBaselineAvgLenX,baselineDelay,ivStepAvgLenX,ivStepDelay,ivTailAvgLenX,ivTailDelay,initAvgLenX,initDelay,inputForLeakSub,linearStatsWv=linearIvStats,expFitInfo=expFitInfo)		//act fit len, deact fit len, act fit delay, deact fit delay			//stats_ivFam(responsesList,stepDeltasWv,eRevs,holdLevel,StepStartx,StepEndX,BaselineAvgLenX,baselineDelay,StepAvgLenX,StepDelay,tailAvgLenX,tailDelay,initAvgLenX,initDelay,inputForLeakSub,[linearStatsWv,repeatLastDelta,expFitInfo])									concatenate/free/dl/o {inputInfo,capStats,linearIvStats},ihStatsTemp						if (ivCount==0)				duplicate/o ihStatsTemp,$ihStatsRef/wave=ihStats				redimension/n=(-1,1) ihStats				duplicate/o ivStats,$ihIvStatsRef/wave=ihIvStats				redimension/n=(-1,-1,1) ihIvStats			else				concatenate/dl/np=1 {ihStatsTemp},ihStats				concatenate/dl/np=2 {ivStats},ihIvStats			endif			setdimlabel 1,ivCount,$famLbl,ihStats			setdimlabel 2,ivCount,$famLbl,ihIvStats						ivCount+=1		endfor				//IV: calculate stat differences		if (hasFams[%inIvFam] && hasFams[%preIvFam])			//IV summary statistics			WAVE ihStats = $ihStatsRef			redimension/n=(-1,dimsize(ihStats,1)+1) ihStats			setdimlabel 1,dimsize(ihStats,1)-1,preMinusInFam_stat,ihStats			ihStats[][%preMinusInFam_stat] = ihStats[p][%preIvFam] - ihStats[p][%inIvFam]						//IV 2D summary statistics			WAVE ihIvStats = $ihIvStatsRef			redimension/n=(-1,-1,dimsize(ihIvStats,2)+1) ihIvStats			setdimlabel 2,dimsize(ihIvStats,2)-1,preMinusInFam_stat,ihIvStats			ihIvStats[][][%preMinusInFam_stat] = ihIvStats[p][q][%preIvFam] - ihIvStats[p][q][%inIvFam]		endif		if (hasFams[%inIvFam] && hasFams[%postIvFam])			//IV summary statistics			WAVE ihStats = $ihStatsRef			redimension/n=(-1,dimsize(ihStats,1)+1) ihStats			setdimlabel 1,dimsize(ihStats,1)-1,postMinusInFam_stat,ihStats			ihStats[][%postMinusInFam_stat] = ihStats[p][%postIvFam] - ihStats[p][%inIvFam]						//IV 2D summary statistics			WAVE ihIvStats = $ihIvStatsRef				redimension/n=(-1,-1,dimsize(ihIvStats,2)+1) ihIvStats			setdimlabel 2,dimsize(ihIvStats,2)-1,postMinusInFam_stat,ihIvStats			ihIvStats[][][%postMinusInFam_stat] = ihIvStats[p][q][%postIvFam] - ihIvStats[p][q][%inIvFam]		endif					//boltzmann calc 		ihIvStatsRef = cellname + "_ihIvStats"		boltzmannFitStatsRef = cellname + "_boltzmannStats"		ihInd[ro][%boltzmannFitStats] = boltzmannFitStatsRef		make/o/d/n=(numBoltzmannFitPnts+numBoltzmannParams,numBoltzmannCols) $boltzmannFitStatsRef/wave=boltzmannFitStats		boltzmannFitStats=nan		dl_assignLblsFromList(boltzmannFitStats,0,numBoltzmannFitPnts,boltzmannParams,"",0)		dl_assignLblsFromList(boltzmannFitStats,1,0,boltzmannCols,"",0)		boltzmannFitStats[%vHalfInit][]=boltzmann_vHalf_guess		boltzmannFitStats[%kInit][]=boltzmann_k_guess				setscale/p x,boltzmannStartVm,boltzmannDelta,"V",boltzmannFitStats		WAVE ihIvStats = $ihIvStatsRef		numSteps = dimsize(ihIvStats,1)		make/o/d/n=(3)/free boltzmannCoefsTemp				for (j=0;j<numBoltzmannCols;j+=1)			layerLbl=stringfromlist(j,boltzmannCols)			layer=finddimlabel(ihIvStats,2,layerLbl)			duplicate/o/free/r=[finddimlabel(ihIvStats,0,"stepCondE_m0p03")][][layer][0] ihIvStats,stepAvg		//get raw data			duplicate/o/free/r=[finddimlabel(ihIvStats,0,"stepLevel")][][finddimlabel(ihIvStats,2,"preIvFam")][0] ihIvStats,stepLevel			redimension/n=(-1,-1) stepAvg,stepLevel;matrixtranspose stepAvg;matrixtranspose stepLevel;redimension/n=(-1) stepAvg,stepLevel		//put into rows			boltzmannFitStats[%hasData][]=numtype(sum(stepAvg))==0			if (!boltzmannFitStats[%hasData])				continue			endif			boltzmannFitStats[%gInit][j]=periph ? gInit_periph : gInit_foveal		//average last 3 steps for initial guess at max -- note that it's actually falling unlike ikx			//			findlevel/P/Q stepAvg,boltzmannFitStats[%gInit][j]/2		//estimate vHalf//			boltzmannFitStats[%findlevel_flag][j]=V_flag//			boltzmannFitStats[%findlevel_x][j]=V_levelX//			boltzmannFitStats[%findLevel_rising][j]=V_rising//			if (V_flag)		//level not found//				boltzmannFitStats[%vHalfInit][j]=vHalfDefault//				boltzmannFitStats[%vHalfInit_outOfRange][j]=-1//				boltzmannFitStats[%findLevel_vFound][j]=nan//			else//				boltzmannFitStats[%findLevel_vFound][j]=stepLevel[V_levelX]//				boltzmannFitStats[%vHalfInit_outOfRange][j] = (boltzmannFitStats[%findLevel_vFound][j]>vHalfMax) || (boltzmannFitStats[%findLevel_vFound][j]<vHalfMin)//				boltzmannFitStats[%vHalfInit][j] = boltzmannFitStats[%vHalfInit_outOfRange][j] ? vHalfDefault : boltzmannFitStats[%findLevel_vFound][j]//			endif			boltzmannCoefsTemp = {boltzmannFitStats[%gInit][j],boltzmann_vHalf_guess,boltzmann_k_guess}			V_FitError=0;V_Pr=NaN;V_r2=NaN;V_FitQuitReason=0			funcfit/W=2/N=1/Q=1 fit_boltzmann,boltzmannCoefsTemp,stepAvg/x=stepLevel			boltzmannFitStats[%coef0_G][j]=boltzmannCoefsTemp[0]			boltzmannFitStats[%coef1_vHalf][j]=boltzmannCoefsTemp[1]			boltzmannFitStats[%coef2_K][j]=boltzmannCoefsTemp[2]			boltzmannFitStats[%V_FitError][j]=V_FitError			boltzmannFitStats[%V_Pr][j]=V_Pr			boltzmannFitStats[%V_r2][j]=V_r2			boltzmannFitStats[%V_FitQuitReason][j]=V_FitQuitReason						if (V_FitQuitReason == 0)				boltzmannFitStats[0,numBoltzmannFitPnts-1][j] = fit_boltzmann(boltzmannCoefsTemp,x)			endif			//interpolate because boltzmann fits dont seem very good -- probably because reversal potential wasnt constant and because baseline is not zero				//for conductance			boltzmannFitStats[%n67i_conductance][j]=interp(-0.067, stepLevel, stepAvg )				//for current			duplicate/o/free/r=[finddimlabel(ihIvStats,0,"stepMinusBaseline")][][layer][0] ihIvStats,stepAvg		//get raw data			duplicate/o/free/r=[finddimlabel(ihIvStats,0,"stepLevel")][][finddimlabel(ihIvStats,2,"preIvFam")][0] ihIvStats,stepLevel			redimension/n=(-1,-1) stepAvg,stepLevel;matrixtranspose stepAvg;matrixtranspose stepLevel;redimension/n=(-1) stepAvg,stepLevel		//put into rows			boltzmannFitStats[%n67i_current][j]=interp(-0.067, stepLevel, stepAvg )		endfor		sa_umSq = capStats[%sa_umSq]		//for surface area normalization		presumedERev = ihIvStats[%eRev_m0p03][0][%preIvFam][0]		drivingForce = -0.067 - presumedERev		boltzmannFitStats[%periph][]=periph		boltzmannFitStats[%div][]=str2num(ihInd[ro][%DIV])		boltzmannFitStats[%blocker][]=str2num(ihInd[ro][%$"blocker (0:Cs;1:ZD6288)"])		boltzmannFitStats[%n67_current][]=fit_boltzmann({boltzmannFitStats[%coef0_G][q],boltzmannFitStats[%coef1_vHalf][q],boltzmannFitStats[%coef2_K][q]},-0.067)		boltzmannFitStats[%sa_umSq][]=sa_umSq		boltzmannFitStats[%presumedERev][]=presumedERev		boltzmannFitStats[%drivingForce][]=drivingForce		boltzmannFitStats[%n67_current_norm][]=boltzmannFitStats[%n67_current][q]/sa_umSq		boltzmannFitStats[%n67i_current_norm][]=boltzmannFitStats[%n67i_current][q]/sa_umSq		boltzmannFitStats[%n67_conductance][]=boltzmannFitStats[%n67_current][q]/drivingForce		boltzmannFitStats[%n67_conductance_norm][]=boltzmannFitStats[%n67_conductance][q]/sa_umSq		boltzmannFitStats[%n67i_conductance_norm][]=boltzmannFitStats[%n67i_conductance][q]/sa_umSq		boltzmannFitStats[%coef0_G_norm][]=boltzmannFitStats[%coef0_G][q]/sa_umSq						//WASHIN/WASHOUT: outputs		String inBlockStatsRef		washStatsRef = cellname + "_ihWashStats"		ihInd[ro][%washStatsRef]=washStatsRef		inBlockStatsRef = cellname + "_ihInBlockStats"		ihInd[ro][%inBlockStatsRef]=inBlockStatsRef				//WASHIN/WASHOUT: calculate differences		ihInd[ro][%washinStartMinusEnd]=stringfromlist(0,wave_subtractLists(ihInd[ro][%washin_end],ihInd[ro][%washin_start]))		//string from list just to remove ";" bc only one in each list		ihInd[ro][%washoutEndMinusStart]=stringfromlist(0,wave_subtractLists(ihInd[ro][%washout_start],ihInd[ro][%washout_end]))				//stats on in block trace		WAVE washStats = stats_ivFam(ihInd[ro][%washinStartMinusEnd],washSteps,eRevs,ivHold,ivStepStartX,ivStepEndX,ivBaselineAvgLenX,baselineDelay,ivStepAvgLenX,ivStepDelay,ivTailAvgLenX,ivTailDelay,initAvgLenX,initDelay,nan,expFitInfo=expFitInfo)		duplicate/o washStats,$inBlockStatsRef 				//WASHIN/WASHOUT: calculate input resistances		numWashTraces=itemsinlist(washTraces);washCount=0		make/o/n=(numWashTraces) hasWashTraces;dl_assignLblsFromList(hasWashTraces,0,0,washTraces,"",0)		hasWashTraces = waveexists($ihInd[ro][%$stringfromlist(p,washTraces)])		for (j=0;j<numWashTraces;j+=1)			if (!hasWashTraces[j])				continue			endif						washLbl = stringfromlist(j,washTraces)			washTraceRef=ihInd[ro][%$washLbl]			WAVE washTrace = $washTraceRef			WAVE inputInfo=stats_twoStepInput(washTrace,baseline1StartX,baseline1EndX,input1StartX,input1EndX,testPulse1,baseline2StartX,baseline2EndX,input2StartX,input2EndX,testPulse2)//input resistance			inputForLeakSub=inputInfo[%resistance_input2] 	//then calculate conductance change during washin/washout -- treat as a 1 step I(V) relation:			WAVE ivStats=stats_ivFam(washTraceRef,washSteps,eRevs,ivHold,ivStepStartX,ivStepEndX,ivBaselineAvgLenX,baselineDelay,ivStepAvgLenX,ivStepDelay,ivTailAvgLenX,ivTailDelay,initAvgLenX,initDelay,inputForLeakSub,expFitInfo=expFitInfo)			concatenate/o/dl/np=0/free {inputInfo,ivStats},washTemp //combine input stats and step (iv) stats						if (washCount == 0)				duplicate/o washTemp,$washStatsRef/wave=washStats				redimension/n=(-1,1) washStats						else				concatenate/dl/np=1 {washTemp},washStats						endif			setdimlabel 1,washCount,$washLbl,washStats						washCount+=1		endfor				//two additional columns: one for washinStartMinusEnd, other for washoutEndMinusStart		if (hasWashTraces[%washin_start] && hasWashTraces[%washin_end])			redimension/n=(-1,dimsize(washStats,1)+1) washStats			setdimlabel 1,dimsize(washStats,1)-1,washinStartMinusEnd,washStats			washStats[][%washinStartMinusEnd] = washStats[p][%washin_start] - washStats[p][%washin_end]		endif		if (hasWashTraces[%washout_start] && hasWashTraces[%washout_end])			redimension/n=(-1,dimsize(washStats,1)+1) washStats			setdimlabel 1,dimsize(washStats,1)-1,washoutEndMinusStart,washStats			washStats[][%washoutEndMinusStart] = washStats[p][%washout_end] - washStats[p][%washout_start]		endif				//FULL WASHIN / WASHOUT STATS -- per sweep basis throughout washinFam and washoutFam		for (j=0;j<numWashFams;j+=1)			washFam = stringfromlist(j,washFams)			washRefs = ihInd[ro][%$washFam]			if (itemsinlist(washRefs) < 1)				continue			endif						loaded="";da_fd_loadWavesFromWaveName(washRefs,reloadOnlyNonExistent,out_loadedWvList=loaded)			allLoaded += loaded			WAVE inputInfo=stats_twoStepInput_fam(washRefs,baseline1StartX,baseline1EndX,input1StartX,input1EndX,testPulse1,baseline2StartX,baseline2EndX,input2StartX,input2EndX,testPulse2)			WAVE ivStats=stats_ivFam(washRefs,washSteps,eRevs,ivHold,ivStepStartX,ivStepEndX,ivBaselineAvgLenX,baselineDelay,ivStepAvgLenX,ivStepDelay,ivTailAvgLenX,ivTailDelay,initAvgLenX,initDelay,nan,repeatLastDelta=1)						washFamStatsRef = cellName + "_ih_"+washFam+"Stats"			concatenate/dl/np=0 {inputInfo,ivStats},$washFamStatsRef/wave=washFamStats			dl_assignLblsFromList(washFamStats,1,0,washRefs,"",0)			ihInd[ro][%$(washFam + "Stats")] = washFamStatsRef		endfor						//SURFACE AREA NORMALIZATION CALCULATION: for ihStats,ihIvStats,washStats, append a second index at higher dimension		sa_umSq = capStats[%sa_umSq]		for (j=0;j<numToSaNorm;j+=1)			WAVE toNorm = $ihInd[ro][%$saNormList[j]]			higherDim = wave_dimensionality(toNorm) + 1			duplicate/o/free toNorm,normedTemp			normedTemp /= sa_umSq			concatenate/np=(higherDim)/dl {normedTemp}, toNorm			dl_assignLblsFromList(toNorm,higherDim,0,"rawData;saNormalizedData;","",0)		endfor				killwavesbyname(allLoaded)	endfor		if (doDisp)		ih_disp(startRow,numRows,"",0)	endifendfunction wave_dimensionality(wv)	WAVE wv		Variable i,maxDim = 3		//igor only supports 0th,1st,2nd,and 3rd dimensions so max is 3	for (i=1;i<=maxDim;i+=1)		if (dimsize(wv,i) < 2)			return i - 1		endif	endfor		return maxDimendfunction ih_disp(startrow,numRows,typeStr,bringToTopOnly)	Variable startRow,numRows	String typeStr		//semi colon delimited list of options. current valid options are "iv" and "raw", or "" for all	Variable bringToTopOnly		WAVE/T ihInd		//see ih_calc() for formatting info .. ih_calc will have to have been run on the rows of interest	Variable reload=0		String bottomAxList = "b_pre;b_in;b_post;"		//list of bottom axis names when seperateBottomAxes = 1	Variable seperateBottomAxes = 1	Variable ro,i,j,periph,k,l,numBottomAx=itemsinlist(bottomAxList),expStartRow,numSteps,fitStartX,fitEndX,x0	String statsRef,cellname,rawWinN,subtractedWinN,stat,traceWinN,lblStr,bAx,color,axes,fitRef,expWinN,ivStatsRef	,inBlockRef,washinStartMinusEnd,inBlockStatsRef,actTauStr,deactTauStr	Variable totalAxSpace,axLen,axStart,axEnd,axSpace =0.04	String statsList = "stepMinusBaseline;stepMinusBaseline_leakSub"		//displays raw and subtracted results in ihStats for these column labels	String famsOfInterest = "preIvFam;inIvFam;postIvFam;preMinusInFam;postMinusInFam;"	Variable numFamsOfInterest = itemsinlist(famsOfInterest)		Variable numStats=itemsinlist(statsList)	for (i=0;i<numRows;i+=1)		ro=startRow+i		if (ro >= dimsize(ihInd,0))			break		endif		cellname = getdimlabel(ihInd,0,ro)		statsRef = ihInd[ro][%iv2DStats]		periph = str2num(ihInd[ro][%periph])		WAVE statsWv = $statsRef						//SUMMARY I(V) stats display		if (itemsinlist(listmatch(typeStr,"iv")) || !strlen(typeStr))			for (j=0;j<numStats;j+=1)						stat = stringfromlist(j,statsList)				rawWinN = cellName + "_RAW_" + stat								if ( (finddimlabel(statsWv,2,"preIvFam")>-1) ||  (finddimlabel(statsWv,2,"inIvFam")>-1) ||  (finddimlabel(statsWv,2,"postIvFam")>-1))					if (bringTotopOnly)						dowindow/F $rawWinN						continue					else						rawWinN = disp_makeOrClear(rawWinN);dowindow/F $rawWinN					endif										if (finddimlabel(statsWv,2,"preIvFam")>-1)						appendtograph/c=(0,0,0)/W=$rawWinN statsWv[%$stat][*][%preIvFam]/tn=pre vs statsWv[%stepLevel][*][%preIvFam]					endif					if (finddimlabel(statsWv,2,"inIvFam")>-1)						appendtograph/W=$rawWinN statsWv[%$stat][*][%inIvFam]/tn=in vs statsWv[%stepLevel][*][%inIvFam]					endif					if (finddimlabel(statsWv,2,"postIvFam")>-1)						appendtograph/c=(39321,39321,39321)/W=$rawWinN statsWv[%$stat][*][%postIvFam]/tn=post vs statsWv[%stepLevel][*][%postIvFam]					endif				endif								if ( (finddimlabel(statsWv,2,"preMinusInFam_stat")>-1) ||  (finddimlabel(statsWv,2,"postMinusInFam")>-1))					if (finddimlabel(statsWv,2,"preMinusInFam_stat")>-1)						appendtograph/c=(0,0,0)/W=$rawWinN/L=L_sub statsWv[%$stat][*][%preMinusInFam_stat]/tn=pre vs statsWv[%stepLevel][*][%preIvFam]					endif					if (finddimlabel(statsWv,2,"postMinusInFam_stat")>-1)						appendtograph/c=(39321,39321,39321)/W=$rawWinN/L=L_sub statsWv[%$stat][*][%postMinusInFam_stat]/tn=post vs statsWv[%stepLevel][*][%postIvFam]					endif					modifygraph/W=$rawWinN freepos=0,lblpos=52,axisenab(left)={0.52,1},axisenab(L_sub)={0,0.48}				endif			endfor								//SUMMARY I(V) KINETICS			if (itemsinlist(listmatch(typeStr,"iv_kin")) || !strlen(typeStr))				String lbl,winN				winN = cellName + "_ivKinetics"				if (bringToTopOnly)					dowindow/F $winN				else					winN = disp_makeOrclear(winN);dowindow/F $winN				endif								statsRef = ihInd[ro][%iv2DStats]				WAVE statsWv = $statsRef				appendtograph/W=$winN/c=(0,0,0) statsWv[%act_singleExp_coef2_tau0][][%preMinusInFam]/tn=act vs statsWv[%stepLevel][*][%preIvFam]				appendtograph/W=$winN/c=(0,0,0)/l=L_deact statsWv[%de_singleExp_coef2_tau0][][%preMinusInFam]/tn=deact vs statsWv[%stepLevel][*][%preIvFam]				modifygraph/W=$winN freepos=0,lblpos=-52,axisenab(left)={0.52,1},axisenab(L_deact)={0,0.48},log(left)=1,log(L_deact)=1			endif		endif				//RAW DATA DISPLAY  -- overall view		if (itemsinlist(listmatch(typeStr,"raw"))  || !strlen(typeStr))			lblStr = cellName + ": " + selectstring(periph,"FOVEAL","PERIPH")					traceWinN = cellName+ "_TRACES_IhVI"			if (bringTotopOnly)				dowindow/F $traceWinN				continue			else				traceWinN = disp_makeOrClear(traceWinN);dowindow/F $traceWinN			endif						//pre			bAx = selectstring(seperateBottomAxes,"bottom",stringfromlist(0,bottomAxList))			color = selectstring(seperateBottomAxes,"0;0;0","0;0;0")			disp_appendTracesToGraph(2,ihInd[ro][%$("preIvFam")],"",gName=traceWinN,color=color,bottomAxN=bAx,reload=reload)						//in			bAx = selectstring(seperateBottomAxes,"bottom",stringfromlist(1,bottomAxList))			color = selectstring(seperateBottomAxes,"0;0;0","0;0;0")			disp_appendTracesToGraph(2,ihInd[ro][%$("inIvFam")],"",gName=traceWinN,color=color,bottomAxN=bAx,reload=reload)						//post			bAx = selectstring(seperateBottomAxes,"bottom",stringfromlist(2,bottomAxList))			color = selectstring(seperateBottomAxes,"0;0;0;24000","0;0;0")			disp_appendTracesToGraph(2,ihInd[ro][%$("postIvFam")],"",gName=traceWinN,color=color,bottomAxN=bAx,reload=reload)						//pre-in			bAx = selectstring(seperateBottomAxes,"bottom",stringfromlist(0,bottomAxList))			color = selectstring(seperateBottomAxes,"0;0;0;24000","0;0;0")			disp_appendTracesToGraph(2,ihInd[ro][%$("preMinusInFam")],"",gName=traceWinN,color=color,leftAxN="left_sub",bottomAxN=bAx,reload=reload)					//post-in			bAx = selectstring(seperateBottomAxes,"bottom",stringfromlist(2,bottomAxList))			color = selectstring(seperateBottomAxes,"30000;0;0;24000","0;0;0")			disp_appendTracesToGraph(2,ihInd[ro][%$("postMinusInFam")],"",gName=traceWinN,color=color,leftAxN="left_sub",bottomAxN=bAx,reload=reload)						//overlay exponential fits on pre-in subtraction to show activation and deactivation kinetic fits			ivStatsRef = ihInd[ro][%$("iv2DStats")]			WAVE/z ivStats=$ivStatsRef			if (waveExists(ivStats))				expStartRow = finddimlabel(ivStats,0,"act_singleExp_coef0_y0")				numSteps=dimsize(ivStats,1)				for (l=0;l<numSteps;l+=1)						inBlockRef = stringfromlist(l,ihInd[ro][%$("preMinusInFam")])					WAVE inBlockWv = $inBlockRef					fitStartX = ivStats[%act_fitStartX][l][%$("preMinusInFam")]					fitEndX=ivStats[%act_fitEndX][l][%$("preMinusInFam")]					x0 = ivStats[%act_singleExp_x0][l][%$("preMinusInFam")]					duplicate/o/free/r=[expStartRow,expStartRow+2][l][finddimlabel(ivStats,2,"preMinusInFam")] ivStats,coefs					fitRef = ivStatsRef + "_actExpFit_"+num2str(l)					bAx = selectstring(seperateBottomAxes,"bottom",stringfromlist(0,bottomAxList))					expWinN=disp_plotExpFit(coefs,inBlockWv,fitStartX,fitEndX,x0,fitEndX,x0,fitRef,traceWinN,2,"left_sub",bAx,1,1)						endfor			endif						modifygraph/W=$traceWinN freepos=0,lblpos=52,axisenab(left)={0.535,1},axisenab(left_sub)={0,0.465}			if (seperateBottomAxes)				axes = axislist(traceWinN)				totalAxSpace = axSpace * (numBottomAx-1)				axLen = (1 - totalAxSpace) / numBottomAx				for (l=0;l<numBottomAx;l+=1)					axStart=l*axLen + l*axSpace					axEnd=axStart + axLen					bAx = stringfromlist(l,bottomAxList)					if (itemsinlist(listmatch(axes,bAx)))						modifygraph/W=$traceWinN axisenab($stringfromlist(l,bottomAxList)) = {axStart,axEnd}						label/W=$traceWinN, $stringfromlist(l,bottomAxList),selectstring(l==1,"",lblStr+"\r") + replacestring("b_",stringfromlist(l,bottomAxList),"") + " (\\U)"					endif				endfor			else				label/W=$traceWinN bottom,lblStr			endif						label/W=$traceWinN left, "raw (\\U)"			label/W=$traceWinN left_sub, "subtracted (\\U)"									endif				//exponential fit to wash in display		if (itemsinlist(listmatch(typeStr,"exp"))  || !strlen(typeStr))						expWinN = cellName+ "_TRACES_ihIv_inBlock_EXPFIT"			if (bringToTopOnly)				dowindow/F $expWinN			else				expWinN = disp_makeOrClear(expWinN);dowindow/F $expWinN			endif					washinStartMinusEnd = ihInd[ro][%washinStartMinusEnd]			inBlockStatsRef=ihInd[ro][%inBlockStatsRef]			WAVE inBlockWv = $washinStartMinusEnd			WAVE inBlockStats = $inBlockStatsRef						expStartRow = finddimlabel(inBlockStats,0,"act_singleExp_coef0_y0")			fitStartX = inBlockStats[%act_fitStartX]					fitEndX=inblockStats[%act_fitEndX] 			x0 = inblockStats[%act_singleExp_x0]			duplicate/o/free/r=[expStartRow,expStartRow+2] inBlockStats,coefs			fitRef = inBlockStatsRef + "_actExpFit"			expWinN=disp_plotExpFit(coefs,inBlockWv,fitStartX,fitEndX,x0,fitEndX,x0,fitRef,expWinN,2,"","",1,0)			setaxis/W=$expWinN bottom fitStartX-0.05,fitEndX+0.05				expStartRow = finddimlabel(inBlockStats,0,"de_singleExp_coef0_y0")			fitStartX = inBlockStats[%de_fitStartX]					fitEndX=inblockStats[%de_fitEndX] 			x0 = inblockStats[%de_singleExp_x0]			duplicate/o/free/r=[expStartRow,expStartRow+2] inBlockStats,coefs			fitRef = inBlockStatsRef+"_deactExpFit"			expWinN=disp_plotExpFit(coefs,inBlockWv,fitStartX,fitEndX,x0,fitEndX,x0,fitRef,expWinN,2,"L_deact","top",1,0)			setaxis/W=$expWinN top fitStartX-0.05,fitEndX+0.05						sprintf actTauStr,"%2.2f",inBlockStats[%act_singleExp_coef2_tau0]*1000			sprintf deactTauStr,"%2.2f",inBlockStats[%de_singleExp_coef2_tau0]*1000						DrawText/W=$expWinN 0.851851851851852,0.704545454545455,"τ\\BAct\\M="+actTauStr+"ms"			DrawText/W=$expWinN 0.835648148148148,0.0852272727272727,"τ\\BDeact\\M="+deactTauStr+"ms"						modifygraph/W=$expWinN freepos=0,lblpos=52,axisenab(left)={0,0.48},axisenab(L_deact)={0.52,1}		endif	endforendfunction ih_summaryIvDisp(statColLbl,statStr,conditionStr,showNormed)	String statColLbl	//label for column containing stat wave of interest in ihInd. usually either "stats","iv2DStats",or "washStatsRef"							//for iv2dstats, will plot vs IV step holding potential by default							//for others, conditionStr is ignored	String statStr		//string found in a row of iv2DStats or washStats wave e.g., stepMinusBaseline_leakSub	String conditionStr	//string found in a column of iv2DStats  or washStats wave e.g., preMinusInFam	Variable showNormed		//0 for not normalized to surface area, 1 for surface area normalized	WAVE/T ihInd		Variable i,rows=dimsize(ihInd,0),periph,isZD,DIV	String statsRef,cellname		String winN = "ihIvStatSummary_"+statStr + "_" + conditionStr + selectstring(showNormed,"","_normSA")	disp_makeOrClear(winN);dowindow/F $winN		for (i=0;i<rows;i+=1)		cellname = getdimlabel(ihInd,0,i)		if (strlen(cellname) < 1)			continue		endif		statsRef = ihInd[i][%$statColLbl]		if (!waveexists($statsReF))			continue		endif		WAVE statsWv = $statsRef			periph = str2num(ihInd[i][%periph])		isZD  = str2num(ihInd[i][%$"blocker (0:Cs;1:ZD6288)"]) == 1		DIV = str2num(ihInd[i][%DIV])		WAVE cs=getColorSet( periph ? 3 : 2 )				if (stringmatch(statColLbl,"iv2DStats"))			appendtograph/W=$winN/c=(cs[0],cs[1],cs[2],30000) statsWv[%$statStr][*][%$conditionStr][showNormed]/tn=$cellname vs statsWv[%stepLevel][*][%preIvFam]		else			appendtograph/W=$winN/c=(cs[0],cs[1],cs[2],30000) statsWv[%$statStr][0,2][showNormed]/tn=$cellname		endif						if (isZD)			modifygraph/W=$winN lstyle($cellname)=3		endif		if (DIV == 0)			modifygraph/W=$winN lsize($cellname)=2		endif	endforend//iterate through a wavelist for stats_twoStepInput, returns as 2D with one column per item in listfunction/WAVE stats_twoStepInput_fam(list,baseline1StartX,baseline1EndX,input1StartX,input1EndX,testPulse1,baseline2StartX,baseline2EndX,input2StartX,input2EndX,testPulse2)	String list	Double baseline1StartX,baseline1EndX,input1StartX,input1EndX		//baseline average range and range for average in step for first step	Double testPulse1			//deltaV for first step	Double baseline2StartX,baseline2EndX,input2StartX,input2EndX		//same for second step	Double testPulse2		Variable i,num=itemsinlist(list)	String ref	for (i=0;i<num;i+=1)		ref=stringfromlist(i,list)		WAVE wv = $ref		WAVE inputStats = stats_twoStepInput(wv,baseline1StartX,baseline1EndX,input1StartX,input1EndX,testPulse1,baseline2StartX,baseline2EndX,input2StartX,input2EndX,testPulse2)		if (i==0)			redimension/n=(-1,1) inputStats			duplicate/o inputStats,out		else			concatenate/dl/np=1/free {inputStats},out		endif		setdimlabel 1,i,$ref,out	endfor	return outendfunction/WAVE stats_twoStepInput(avg,baseline1StartX,baseline1EndX,input1StartX,input1EndX,testPulse1,baseline2StartX,baseline2EndX,input2StartX,input2EndX,testPulse2)	WAVE avg	//wave to average	Double baseline1StartX,baseline1EndX,input1StartX,input1EndX		//baseline average range and range for average in step for first step	Double testPulse1			//deltaV for first step	Double baseline2StartX,baseline2EndX,input2StartX,input2EndX		//same for second step	Double testPulse2		WAVE inputInfo1 = stats_input(avg,baseline1StartX,baseline1EndX,input1StartX,input1EndX,testPulse1)	WAVE inputInfo2 = stats_input(avg,baseline2StartX,baseline2EndX,input2StartX,input2EndX,testPulse2)	duplicate/o/free inputInfo1,avgInput	avgInput = (inputInfo1 + inputInfo2)/2	dl_appendToLbls(inputInfo1,0,"_input1",0,0,inf)	dl_appendToLbls(inputInfo2,0,"_input2",0,0,inf)	dl_appendToLbls(avgInput,0,"_avgInput",0,0,inf)		concatenate/dl/free/np=0 {inputInfo1,inputInfo2},avgInput	return avgInputendfunction/WAVE stats_input(wv,baselineStartX,baselineEndX,stepStartX,stepEndX,deltaV)	WAVE wv		//wave to measure in amps	Variable baselineStartX,baselineEndX	Variable stepStartX,stepEndX	Double deltaV		Variable numParams = 6	make/o/free/d/n=(numParams) out	setdimlabel 0,0,deltaV,out	setdimlabel 0,1,baselineI,out	setdimlabel 0,2,stepI,out	setdimlabel 0,3,deltaI,out	setdimlabel 0,4,resistance,out	setdimlabel 0,5,conductance,out		out[%deltaV] = deltaV	out[%baselineI] = mean(wv,baselineStartX,baselineEndX)	out[%stepI] = mean(wv,stepStartX,stepEndX)	out[%deltaI] = out[%stepI] - out[%baselineI]	out[%resistance] = deltaV / out[%deltaI]	out[%conductance] = 1/out[%resistance]	return outendfunction/wave stats_currentActDeact(wv,StepStartx,StepEndX,actFitLenX,deactFitLenX,actFitStartDelayX,deactFitStartDelayX)	WAVE wv	Double StepStartx,StepEndX		//start and end time for step	Double actFitLenX,deactFitLenX	//had been using 0.3 and 1 (in seconds)	Variable actFitStartDelayX// = 0.002	Variable deactFitStartDelayX// = 0.002		String overallParams = "stepStartX;stepEndX;maxTauProp;"		String actDeactParams = "fitLenX;fitStartDelayX;fitStartX;fitEndX;"	actDeactParams+="singleExp_V_FitError;singleExp_V_Pr;singleExp_V_r2;singleExp_V_FitQuitReason;singleExp_x0;singleExp_coef0_y0;singleExp_coef1_amp0;singleExp_coef2_tau0;"	actDeactParams+="dblExp_V_FitError;dblExp_V_Pr;dblExp_V_r2;dblExp_V_FitQuitReason;dblExp_x0;dblExp_coef0_y0;dblExp_coef1_amp0;dblExp_coef2_tau0;dblExp_coef3_amp1;dblExp_coef4_tau1;"	actDeactParams+="truncatedStartX;truncatedEndX;maxTau;"		Variable numOverallParams = itemsinlist(overallParams)	Variable numActDeactParams = itemsinlist(actDeactParams)	Variable numParams = numOverallParams + 2*numActDeactParams		make/o/d/free/n=(numParams) out	dl_assignLblsFromList(out,0,0,overallParams,"",0)	out[%stepStartX]=stepStartX	out[%stepEndX]=stepEndX	out[%maxTauProp]=0.8		//do not allow taus longer than this proportion from x0 to end of fit			String appendStrs = "act_;de_;",as,maxTauStr	Variable i,num=itemsinlist(appendStrs);	//i=0 for act, i=1 for deact	Variable fitLenX,fitStartDelayX,fitStartX,fitEndX,x0,minStartX=pnt2x(wv,0),maxEndX=pnt2x(wv,dimsize(wv,0)-1),maxTau	make/o/t/n=(1)/free singleExpConstraints	make/o/t/n=(2)/free dblExpConstraints	for (i=0;i<2;i+=1)		as = stringfromlist(i,appendStrs)		dl_assignLblsFromList(out,0,numOverallParams+i*numActDeactParams,actDeactParams,as,1)		if (i==0)			fitLenX = actFitLenX			fitStartDelayX = actFitStartDelayX			fitStartX = stepStartX + fitStartDelayX			fitEndX = stepStartX + actFitLenX			x0 = stepStartX		else			fitLenX = deactFitLenX			fitStartDelayX = deactFitStartDelayX			fitStartX = stepEndX + fitStartDelayX			fitEndX = stepEndX + deactFitLenX				x0 = stepEndX			endif				maxTau = out[%maxTauProp] * (fitEndX - x0)				sprintf maxTauStr,"%5.5e",maxTau		singleExpConstraints = {"K2 < " +maxTauStr}		dblExpConstraints = {"K2 < " +maxTauStr,"k4 < "+maxTauStr}				if (fitStartX < minStartX)			fitStartX = minStartX			out[%$(as+"truncatedStartX")]=1		else			out[%$(as+"truncatedStartX")]=0		endif		if (fitEndX > maxEndX)			fitEndX = maxEndX			out[%$(as+"truncatedEndX")]=1		else			out[%$(as+"truncatedEndX")]=0		endif			out[%$(as+"fitLenX")]=fitLenX		out[%$(as+"fitStartDelayX")]=fitStartDelayX		out[%$(as+"fitStartX")]=fitStartX		out[%$(as+"fitEndX")]=fitEndX		out[%$(as+"maxTau")]=maxTau				//single exponential fit		Double V_FitError=0,V_Pr=nan,V_r2=nan,V_FitQuitReason=nan		Curvefit/W=2/N=1/Q=1/k={x0}  exp_xoffset wv(fitStartX,fitEndX)/c=singleExpConstraints		if (i==0)			WAVE/D W_coef		endif		out[%$(as+"singleExp_V_FitError")]=V_FitError		out[%$(as+"singleExp_V_Pr")]=V_Pr		out[%$(as+"singleExp_V_r2")]=V_r2		out[%$(as+"singleExp_V_FitQuitReason")]=V_FitQuitReason		out[%$(as+"singleExp_x0")]=x0		out[%$(as+"singleExp_coef0_y0")]=W_coef[0]		out[%$(as+"singleExp_coef1_amp0")]=W_coef[1]		out[%$(as+"singleExp_coef2_tau0")]=W_coef[2]				//double exponential fit		V_FitError=0;V_Pr=NaN;V_r2=NaN;V_FitQuitReason=NaN		Curvefit/W=2/N=1/Q=1/k={x0}  dblexp_xoffset wv(fitStartX,fitEndX)/c=dblExpConstraints		out[%$(as+"dblExp_V_FitError")]=V_FitError		out[%$(as+"dblExp_V_Pr")]=V_Pr		out[%$(as+"dblExp_V_r2")]=V_r2		out[%$(as+"dblExp_V_FitQuitReason")]=V_FitQuitReason		out[%$(as+"dblExp_x0")]=x0		out[%$(as+"dblExp_coef0_y0")]=W_coef[0]		out[%$(as+"dblExp_coef1_amp0")]=W_coef[1]		out[%$(as+"dblExp_coef2_tau0")]=W_coef[2]			out[%$(as+"dblExp_coef3_amp1")]=W_coef[3]		out[%$(as+"dblExp_coef4_tau1")]=W_coef[4]	endfor		return outend	//currently assumes positive valencefunction/WAVE stats_ivFam(responsesList,stepDeltasWv,eRevs,holdLevel,StepStartx,StepEndX,BaselineAvgLenX,baselineDelay,StepAvgLenX,StepDelay,tailAvgLenX,tailDelay,initAvgLenX,initDelay,inputForLeakSub,[linearStatsWv,repeatLastDelta,expFitInfo])	String responsesList	WAVE stepDeltasWv		//for each step, an item in this wave holds the change in commanded value (currently expected as change from hold, not absolute value)	Double holdLevel			//absolute hold level, steLevelsWv is relative to this	WAVE eRevs				//assumed eRevs to calculate conductance for	Double StepStartx,StepEndX		//start and end time for step	Double BaselineAvgLenX		//baseline length to average	Double baselineDelay		//how long before step start to end averaging	Double StepAvgLenX			//length during step to average	Double StepDelay			//how long before step end to end step response averaging	Double tailAvgLenX,tailDelay		//same for tail	Double initAvgLenX,initDelay	//recently added measurement of initial response after step	Double inputForLeakSub		//pass an input resistance for linear leak subtraction -- step size in the absence of a change in current is subtracted based on V=IR	WAVE linearStatsWv		//optionally pass a wave to store linear stats wv in -- gets overwritten	Variable repeatLastDelta	//pass one if it is expected that stepDeltasWv will have fewer rows than there are items in responsesList and the last index should be used after stepDeltasWv rows run out	WAVE expFitInfo		//optionally pass to fit single and double exponentials from stepStartX. should have 2 items, first is activation fit win len, second is deactivation fit win length, third is activation delay, fourth is deactivation delay.. how much of the beginning of the step is ignored  e.g. due to pipette cap		Variable numResps = itemsinlist(responsesList)	Variable numDeltas = dimsize(stepDeltasWv,0)	Variable doRepeatLastDelta = !ParamisDefault(repeatLastDelta) && repeatLastDelta	if ( (numResps != numDeltas) && !doRepeatLastDelta)		print "stats_ivFam() numResps != numDeltas. numResps",numResps,"numDeltas",numDeltas,"first resp = ",stringfromlist(0,responsesList)		make/o/d/n=(0) dummy		return dummy	endif				//stats not related to reversal potential -- fixed number per step	String rowLblsList="holdLevel;stepStartX;stepEndX;baselineAvgLenX;baselineDelay;stepAvgLenX;stepDelay;tailAvgLenX;tailDelay;initAvgLenX;initDelay;inputForLeakSub;"		//likely fixed items same for all steps	rowLblsList+="stepDelta;stepLevel;leakDelta;baselineAvg;stepAvg;stepMinusBaseline;stepMinusBaseline_leakSub;stepRes;stepRes_leakSub;stepCond;stepCond_leakSub;tailAvg;tailMinusBaseline;tailRes;tailCond;"			//items analyzed and differing across steps	rowLblsList+="initAvg;initMinusBaseline;initRes;initCond;stepMinusInit;stepMinusInitRes;stepMinusInitCond;"	Variable nonNonRevStatsPerStep = itemsinlist(rowLblsList)		//stats related to reversal potential -- final number depends on num eRevs passed	Variable numRevs = dimsize(eRevs,0)	String eRevStats = "eRev;drivingForce;stepAbsCondE;stepCondE;stepCondE_leakSub;tailDrivingForce;tailCondE;"	Variable numRevStats = itemsinlist(eRevStats)	Variable numRevStatsPerStep = numRevs * numRevStats 		Variable numStatsPerStep = nonNonRevStatsPerStep + numRevStatsPerStep	make/o/d/free/n=(numStatsPerStep,numResps) out		//assign non rev stats	dl_assignLblsFromList(out,0,0,rowLblsList,"",0)	//assign rev stat labels and fixed info	Variable i,statsInd=nonNonRevStatsPerStep	String eRevStr	for (i=0;i<numRevs;i+=1)		eRevStr = "_"+text_num2str(eRevs[i])		dl_assignLblsFromList(out,0,statsInd,eRevStats,eRevStr,0)		out[%$("eRev"+eRevStr)][]=eRevs[i]		statsInd+=numRevStats	endfor		out[%holdLevel][]=holdLevel	out[%stepStartX][]=stepStartX	out[%stepEndX][]=stepEndX	out[%baselineAvgLenX][]=BaselineAvgLenX	out[%baselineDelay][]=baselineDelay	out[%stepAvgLenX][]=stepAvgLenX	out[%stepDelay][]=stepDelay	out[%tailAvgLenX][]=tailAvgLenX	out[%tailDelay][]=tailDelay	out[%initAvgLenX][]=initAvgLenX	out[%initDelay][]=initDelay	out[%inputForLeakSub][]=inputForLeakSub		if (doRepeatLastDelta)		out[%stepDelta][]= (q >= numDeltas) ? stepDeltasWv[numDeltas-1] : stepDeltasWv[q]	else		out[%stepDelta][]=stepDeltasWv[q]	endif	out[%stepLevel][]=out[%stepDelta][q]+holdLevel	out[%leakDelta][]=out[%stepDelta][q]/out[%inputForLeakSub][q]		Variable j,startX,endX	String ref,levelStr	for (i=0;i<numResps;i+=1)			ref = stringfromlist(i,responsesList)		levelStr=text_num2str(out[%stepDelta][i])		setdimlabel 1,i,$("N="+num2str(i)+",L="+levelStr+",W="+ref+","),out		WAVE wv = $ref						//baseline		startX = stepStartX - baselineDelay - baselineAvgLenX		endX = stepStartX - baselineDelay		out[%baselineAvg][i] = mean(wv,startX,endX)		//step		startX = stepEndX - stepDelay - stepAvgLenX		endX = stepEndX - stepDelay		out[%stepAvg][i] = mean(wv,startX,endX)		//tail		startX = stepEndX + tailDelay		endX = stepEndX + tailDelay + tailAvgLenX		out[%tailAvg][i] = mean(wv,startX,endX)			//init		startX = stepStartX + initDelay		endX = stepStartX + initDelay + initAvgLenX		out[%initAvg][i] = mean(wv,startX,endX)	endfor		//differences from baseline	out[%stepMinusBaseline][] = out[%stepAvg][q] - out[%baselineAvg][q]	//without leak subtraction	out[%stepMinusBaseline_leakSub][] = out[%stepMinusBaseline][q] - out[%leakDelta][q]		//with leak subtraction	out[%tailMinusBaseline][] = out[%tailAvg][q] - out[%baselineAvg][q] //assuming tail hold = baseline hold, theres no need to correct tail current. needs adding if not equal	out[%initMinusBaseline][] = out[%initAvg][q] - out[%baselineAvg][q]	//could add leak sub			//and for initial - final for step	out[%stepMinusInit][] = out[%stepAvg][q] - out[%initAvg][q]			//resistance -- not reversal potential corrected (and so assumes reverses at baseline holding)	out[%stepRes][] = out[%stepDelta][q] / out[%stepMinusBaseline][q]	out[%stepRes_leakSub][] = out[%stepDelta][q] / out[%stepMinusBaseline_leakSub][q]	out[%tailRes][] = out[%stepDelta][q] / out[%tailMinusBaseline][q]	out[%initRes][] = out[%stepDelta][q] / out[%initMinusBaseline][q]	out[%stepMinusInitRes][] = out[%stepDelta][q] / out[%stepMinusInit][q]		//conductance -- not reversal potential corrected (and so assumes reverses at baseline holding)	out[%stepCond][] = 1 / out[%stepRes][q]	out[%stepCond_leakSub][] = 1 / out[%stepRes_leakSub][q]	out[%tailCond][] = 1 / out[%tailRes][q]	out[%initCond][] = 1 / out[%initRes][q]	out[%stepMinusInitCond][] = 1 / out[%stepMinusInitRes][q]		//conductance -- reversal potential corrected	statsInd=nonNonRevStatsPerStep	for (i=0;i<numRevs;i+=1)		eRevStr = "_"+text_num2str(eRevs[i])		out[%$("drivingForce"+eRevStr)][]=out[%stepLevel][q]-out[%$("eRev"+eRevStr)][q]		out[%$("stepAbsCondE"+eRevStr)][]=out[%stepAvg][q]/out[%$("drivingForce"+eRevStr)][q]			//stepAbsCondE		out[%$("stepCondE"+eRevStr)][]=out[%stepMinusBaseline][q]/out[%$("drivingForce"+eRevStr)][q]		out[%$("stepCondE_leakSub"+eRevStr)][]=out[%stepMinusBaseline_leakSub][q]/out[%$("drivingForce"+eRevStr)][q]				//tail current  tailDrivingForce		out[%$("tailDrivingForce"+eRevStr)][]=out[%holdLevel][q]-out[%$("eRev"+eRevStr)][q]		//should be a constant, also assumes hold == tail which it does in my standard protocol		out[%$("tailCondE"+eRevStr)][]=out[%tailAvg][q]/out[%$("tailDrivingForce"+eRevStr)][q]						//could add change during step from init to final	endfor		if (!ParamIsDefault(expFitInfo))		Variable rows = dimsize(out,0),toAdd		for (i=0;i<numResps;i+=1)				ref = stringfromlist(i,responsesList)			levelStr=text_num2str(out[%stepDelta][i])			setdimlabel 1,i,$("N="+num2str(i)+",L="+levelStr+",W="+ref+","),out			WAVE wv = $ref						WAVE actDeact = stats_currentActDeact(wv,StepStartx,StepEndX,expFitInfo[0],expFitInfo[1],expFitInfo[2],expFitInfo[3])			if (i==0)				toAdd = dimsize(actDeact,0)				redimension/n=(rows+toAdd,-1) out				dl_lblsToLbls("",0,0,inf,"",0,rows,"",0,forceToWv=out,forceFromWv=actDeact)			endif			out[rows,][i] = actDeact[p-rows]		endfor	endif		if (!ParamIsDefault(linearStatsWv))		String rowLbls,colLbl,outLbl		Variable linearLen = numStatsPerStep*numResps,linearStartRow		make/o/d/n=(linearLen)/free linearStatsTemp		duplicate/o linearStatsTemp,linearStatsWv		//transfer data		linearStatsWv = out[mod(p,numStatsPerStep)][floor(p/numStatsPerStep)]				//transfer labels		rowLbls = dl_getLblsAsList("",0,0,inf,forceFromWv=out)		for (i=0;i<numResps;i+=1)			colLbl = getdimlabel(out,1,i)			dl_assignLblsFromList(linearStatsWv,0,i*numStatsPerStep,rowLbls,"_"+colLbl,0)		endfor	endif		if (numResps == 1)		redimension/n=(-1) out	endif		return outendfunction/S wave_subtractLists(subtractThisWaveList,fromThisWaveList)	String subtractThisWaveList,fromThisWaveList	if ( (strlen(subtractThisWaveList) < 1) || (strlen(fromThisWaveList) < 1))		return ""	endif		Variable subtractThisListLen = itemsinlist(subtractThisWaveList)	Variable fromThisWaveListLen = itemsinlist(fromThisWaveList)		if (subtractThisListLen != fromThisWaveListLen)		print "wave_subtractLists() subtractThisListLen != fromThisWaveList. subtractThisListLen",subtractThisListLen,"fromThisWaveList",fromThisWaveList,"first subtractThisWaveList = ",stringfromlist(0,subtractThisWaveList),"first fromThisWaveList = ",stringfromlist(0,fromThisWaveList)		return ""	endif		if (itemsinlist(subtractThisWaveList) < 1)		return ""	endif		Variable i	String subtractThisWaveRef,fromThisWaveRef,outRef,outList=""	for (i=0;i<subtractThisListLen;i+=1)		subtractThisWaveRef = stringfromlist(i,subtractThisWaveList)		fromThisWaveRef = stringfromlist(i,fromThisWaveList)		WAVE subtractThisWave = $subtractThisWaveRef		WAVE fromThisWave = $fromThisWaveRef		outRef = fromThisWaveRef +"_minus_"+subtractThisWaveRef		duplicate/o fromThisWave,$outRef/wave=out		note/nocr out,"wave_subtractLists_fromThisWave:"+fromThisWaveRef+";wave_subtractLists_subtractThisWave:"+fromThisWaveRef+";"		out = fromThisWave - subtractThisWave		outList+=outRef+";"	endfor	return outListend//from node 20912 (user==tony)menu "edit", hideable, dynamic    TableClipMenu("Transpose Paste/F2"), TransposePaste()endfunction /s TableClipMenu(str)    string str        if(WinType("")==2)        return str    endif    return ""endfunction iKx_calc(startRow,numRows,doDisp)	Variable startRow,numRows,doDisp		Variable reloadOnlyNonExistent = 1	Variable killReloadedWvs=0		String outAppendStr="_iKx"	WAVE/T indWv = $"iKxInd" //must have specific column labels, one row for each cell / each washin+washout experiment	Double ivHold = -0.03,testPulse1=-0.005,testPulse2=0.005		//ivHold applies to n30, but n90 is also calculated	make/o/d/free washSteps = {-0.06}		//must be just one repeated step; otherwise would need to change output datastructure from one column for each of pre/post washin/washout	make/o/d/free eRevs = {-0.09267}		//for conductance calc, what reversal potential(s) to try (number can vary)		//times should be first and last point during step..these are defaults but if stored in corresponding column for each index, those supercede	Variable pulse1StartX_default=0.131275,pulse1EndX_default=0.20625,pulse2StartX_default=0.406275,pulse2EndX_default=0.48125		//test pulses for	Variable ivStepStartX_default=0.731275,ivStepEndX_default=1.23125		//start and end for variable region	Variable pulse1StartX,pulse1EndX,pulse2StartX,pulse2EndX,ivStepStartX,ivStepEndX		Variable baselineDelay = 0.0015	//how long before step to stop baseline measurement	Variable ivBaselineAvgLenX = 0.2	Variable ivStepAvgLenX = 0.2	Variable ivStepDelay = 0.01		//how long before step end to stop step average measurement	Variable ivTailDelay = 0.005	//how long AFTER step end to start measuring tail current	Variable ivTailAvgLenX = 0.0023		//how long to average for tail		Variable ivInitDelay = 0.009		//newly added IV initial measurement	Variable ivInitAvgLenX = 0.003	//newly added IV final measurement			Variable inputWinSizeX=0.005	Variable baseline1StartX,baseline1EndX,input1StartX,input1EndX	Variable baseline2StartX,baseline2EndX,input2StartX,input2EndX		Variable wash_pulse1StartX,wash_pulse1EndX,wash_pulse2StartX,wash_pulse2EndX,wash_stepStartX,wash_stepEndX	Variable wash_baseline1StartX,wash_baseline1EndX,wash_input1StartX,wash_input1EndX	Variable wash_baseline2StartX,wash_baseline2EndX,wash_input2StartX,wash_input2EndX			String capStatsAddLbls = "periph;rigX;rigY;accessStable;DIV;DNase;"	Variable numStatsAddedToCap=itemsinlist(capStatsAddLbls)	String washTraces = "washin_start;washin_end;washout_start;washout_end;"	String ivFams = "preIvFam_n90;preIvFam_n30;inIvFam_n90;inIvFam_n30;postIvFam_n90;postIvFam_n30;preMinusInFam_n90;preMinusInFam_n30;postMinusInFam_n90;postMinusInFam_n30;"		//column labels for all IV relations	String ivFamStepsLbls = "ivSteps_mv_n90;ivSteps_mV_n30;ivSteps_mv_n90;ivSteps_mv_n30;ivSteps_mv_n90;ivSteps_mv_n30;ivSteps_mv_n90;ivSteps_mV_n30;ivSteps_mv_n90;ivSteps_mv_n30;"	//matched to column label index, column label to find step sizes for this IV family	String ivFamOutputAppendStrs = "_n90;_n30;_n90;_n30;_n90;_n30;_n90;_n30;_n90;_n30;"		//for each appendstr, two ouputs are generated stats and IV stats.. these must match to ivFams index and any one with same string must have same ivFamStepsLbl in ivFamStepsLbls		//there must also be a corresponding column label of stats_+ivFamOutputAppendStr and iv2Dstats_+ivFamOutputAppendStr for each unique item in ivFamOutputAppendStrs			//specify subtraction pairs: these must share matching IV steps and ivFamOutputAppendStr	String ivFamSubtractFromThese = "preIvFam_n90;preIvFam_n30;postIvFam_n90;postIvFam_n30"	//for measuring drug-sensitive current define bulk current IVs	String ivFamSubtractTheseFromThose = "inIvFam_n90;inIvFam_n30;inIvFam_n90;inIvFam_n30;" //and define currents in drug to subtract from bulk -- indices must match ivFamSubtractFromThese	String ivFamStoreSubtractionResult ="preMinusInFam_n90;preMinusInFam_n30;postMinusInFam_n90;postMinusInFam_n30;"	String avgWvLblsForInput = text_appendToStrsInList(ivFams,"_avg",0,";") //column labels for saving averages used for input res calc	Variable numIvFams = itemsinlist(ivFams),n3	Variable numIvSubtractions=itemsinlist(ivFamSubtractFromThese)		//not checked but # in this list should match itemsinlist(ivFamSubtractTheseFromThose)			//setup parameters for boltzmann fits	String boltzmannCols = "preMinusInFam_n30;postMinusInFam_n30;preMinusInFam_n30_stat;postMinusInFam_n30_stat;"	//cols in _n30 iv2Dstats to compute boltzmann fit	String boltzmannParams = "coef0_G;coef1_vHalf;coef2_K;V_FitError;V_Pr;V_r2;V_FitQuitReason;gInit;vHalfInit;kInit;findlevel_flag;findlevel_x;findLevel_rising;findLevel_vFound;vHalfInit_outOfRange;hasData;periph;n67_current;sa_umSq;presumedERev;drivingForce;n67_current_norm;n67_conductance;n67_conductance_norm;coef0_G_norm;"	String boltzmannFitStatsRef,layerLbl	Variable vHalfMin = -0.125,vHalfMax=0,vHalfDefault=-0.06,boltzmann_K_guess = 0.01,layer,numBoltzmannFitPnts=100,boltzmannStartVm = -0.11,boltzmannEndVm=0.05,boltzmannDelta = (boltzmannEndVm - boltzmannStartVm)/(numBoltzmannFitPnts-1)	//limits for automate vHalf guessing for fit initialization	Variable numBoltzmannCols=itemsinlist(boltzmannCols),numBoltzmannParams=itemsinlist(boltzmannParams),ivRows,numSteps,V_FitError,V_Pr,V_r2,V_FitQuitReason	make/n=(numIvFams)/free hasFams; dl_assignLblsFromList(hasFams,0,0,ivFams,"",0)	Variable ro,i,numInFam,j,baselineSubLenP,numWashTraces,washCount,numIvSteps,origNumCapStats,periph	Double input1,input2,input,baseline1,baseline2,delta1,delta2,inputForLeakSub	string ihStatsRef,cellname,avgRef,fam,ihIvStatsRef,avgLbl,famLbl,stepsLbl,steps,ivFamOutputAppendStr,ivFamOutputAppendStrsUsed,washStatsRef,capTransStatsRef,normedCapTransientRefs,capTransRef,allLoaded,loaded,washLbl,washTraceRef	String subtractFromThisFam,subtractThese,subtractFromThisFam_lbl,subtractThese_lbl,subStore_lbl		make/o/free/t saNormList = {"stats_n90","iv2DStats_n90","stats_n30","iv2DStats_n30","washStatsRef"}	Double sa_umSq,presumedERev,drivingForce	String ref,inBlockStatsRef; Variable higherDim,numToSaNorm=dimsize(saNormList,0)	for (i=0;i<numRows;i+=1)		ro=startRow+i		if (ro >= dimsize(indWv,0))			break		endif		cellname = GetDimLabel(indWv, 0, ro ) 		periph=str2num(indWv[ro][%periph])		allLoaded = ""				//PULSE AND STEP TIMING		pulse1startX = strlen(indWv[ro][%pulse1StartX])>0 ? str2num(indWv[ro][%pulse1StartX]) : pulse1StartX_default		pulse1EndX = strlen(indWv[ro][%pulse1EndX])>0 ? str2num(indWv[ro][%pulse1EndX]) : pulse1EndX_default		pulse2StartX = strlen(indWv[ro][%pulse2StartX])>0 ? str2num(indWv[ro][%pulse2StartX]) : pulse2StartX_default		pulse2EndX = strlen(indWv[ro][%pulse2EndX])>0 ? str2num(indWv[ro][%pulse2EndX]) : pulse2EndX_default		ivStepStartX = strlen(indWv[ro][%ivStepStartX])>0 ? str2num(indWv[ro][%ivStepStartX]) : ivStepStartX_default		ivStepEndX = strlen(indWv[ro][%ivStepEndX])>0 ? str2num(indWv[ro][%ivStepEndX]) : ivStepEndX_default				baseline1StartX=pulse1StartX-baselineDelay-inputWinSizeX;baseline1EndX=pulse1StartX-baselineDelay;input1StartX=pulse1EndX-baselineDelay-inputWinSizeX;input1EndX=pulse1EndX-baselineDelay		baseline2StartX=pulse2StartX-baselineDelay-inputWinSizeX;baseline2EndX=pulse2StartX-baselineDelay;input2StartX=pulse2EndX-baselineDelay-inputWinSizeX;input2EndX=pulse2EndX-baselineDelay				//LOAD WAVES if needed		loaded="";da_fd_loadWavesFromWaveName(indWv[ro][%capTransFam],reloadOnlyNonExistent,out_loadedWvList=loaded)		allLoaded += loaded				//CAP TRANSIENT		capTransStatsRef = cellName +outAppendStr+"_capStats"		indWv[ro][%capTransStats]=capTransStatsRef		baselineSubLenP = 0.005/dimdelta($stringfromlist(0,indWv[ro][%capTransFam]),0)				indWv[ro][%normedCapTransRefs]=step_exciseAndNorm_avgI(indWv[ro][%capTransFam],"0;","1,3,5,7,;",{-2,2,-1,1},1,baselineSubLenP,0,0.01,0.07,"ihCap",1,0,1)		capTransRef = stringbykey("outRef_canonical_w",indWv[ro][%normedCapTransRefs])		WAVE capTrans=$capTransRef		analysis_ES_integrateCap(capTrans,"",0,0.015,0.013,0.015,0.01,0.0025,capTransStatsRef,removeSemStats=1)		WAVE capStats = $capTransStatsRef				//add x y positions and other stats if available		origNumCapStats = dimsize(capStats,0)		redimension/n=(origNumCapStats+numStatsAddedToCap) capStats		dl_assignLblsFromList(capStats,0,origNumCapStats,capStatsAddLbls,"",0)		capStats[origNumCapStats,] = str2num(indWv[ro][%$stringfromlist(p-origNumCapStats,capStatsAddLbls)])				//IV: calculate raw difference IVs		for (j=0;j<numIvSubtractions;j+=1)			ivFamOutputAppendStr = stringfromlist(j,ivFamOutputAppendStrs)			ihStatsRef = cellname + outAppendStr+ivFamOutputAppendStr+"_stats"			ihIvStatsRef = cellname + outAppendStr+ivFamOutputAppendStr+"_ivStats"			WAVE ihStats = $ihStatsRef			WAVE ihIvStats = $ihIvStatsRef			subtractFromThisFam_lbl = stringfromlist(j,ivFamSubtractFromThese)			subtractThese_lbl = stringfromlist(j,ivFamSubtractTheseFromThose)			subStore_lbl = stringfromlist(j,ivFamStoreSubtractionResult)			subtractFromThisFam = indwv[ro][%$subtractFromThisFam_lbl]			subtractThese = indwv[ro][%$subtractThese_lbl]			indWv[ro][%$subStore_lbl]=wave_subtractLists(subtractThese,subtractFromThisFam)		endfor				//IV: analyze IV families -- calculate average and then compute input resistances from that [in stats_input] and compute I(V) and g(V) relation [in stats_ivFam]		hasFams=0		ivFamOutputAppendStrsUsed=""		for (j=0;j<numIvFams;j+=1)			avgLbl=stringfromlist(j,avgWvLblsForInput)			famLbl=stringfromlist(j,ivFams)			fam = indWv[ro][%$famLbl]			stepsLbl=stringfromlist(j,ivFamStepsLbls)			ivHold = text_str2num(stringfromlist(2,stepsLbl,"_"))*10^-3			steps = indWv[ro][%$stepsLbl]			ivFamOutputAppendStr = stringfromlist(j,ivFamOutputAppendStrs)			hasFams[j] = itemsinlist(fam) >= 1			if (!hasFams[j])				continue			endif			if (itemsinlist(steps) < 1)				print "iKx_calc(row="+num2str(ro)+"): For IV family",famLbl,"first wave=",stringfromlist(0,fam),"could not find IV steps, expected lbl=",stepsLbl,"skipping"				continue			endif						//IV: outputs			ihStatsRef = cellname + outAppendStr+ivFamOutputAppendStr+"_stats"	//will be 3D version: parameters (input stats and IV steps), conditions (pre,in,post,pre-in etc), and normalization			ihIvStatsRef = cellname + outAppendStr+ivFamOutputAppendStr+"_ivStats"		//will be 4D version: IV parameters, IV step, conditions, normalization						n3=stringmatch(ivFamOutputAppendStr,"_n30")						numIvSteps = itemsinlist(steps)			make/o/d/free/n=(numIvSteps) ivSteps; ivSteps = str2num(stringfromlist(p,steps))/1000			loaded="";da_fd_loadWavesFromWaveName(fam,1,out_loadedWvList=loaded)			allLoaded += loaded			avgRef = wave_avgFromStrList(fam,";","",0,-inf,inf,np=1)			indWv[ro][%$avgLbl] = avgRef			WAVE avg = $avgRef					WAVE inputInfo=stats_twoStepInput(avg,baseline1StartX,baseline1EndX,input1StartX,input1EndX,testPulse1,baseline2StartX,baseline2EndX,input2StartX,input2EndX,testPulse2)						inputForLeakSub = inputInfo[%resistance_input2]		//positive going step seems less subject to change toward net inward current .. likely because in negative direction there is a reduction in ikx?			make/o/d/free/n=(1) linearIvStats			WAVE ivStats = stats_ivFam(fam,ivSteps,eRevs,ivHold,ivStepStartX,ivStepEndX,ivBaselineAvgLenX,baselineDelay,ivStepAvgLenX,ivStepDelay,ivTailAvgLenX,ivTailDelay,ivInitAvgLenX,ivInitDelay,inputForLeakSub,linearStatsWv=linearIvStats,expFitInfo={0.47,1,n3 ? 0.012 : 0.004,0.012})						concatenate/free/dl/o {inputInfo,capStats,linearIvStats},ihStatsTemp						if (whichlistitem(ivFamOutputAppendStr,ivFamOutputAppendStrsUsed) < 0)		//is this the first time these outputs need to be used? if so create and log, otherwise concatenate to them				duplicate/o ihStatsTemp,$ihStatsRef/wave=ihStats				redimension/n=(-1,1) ihStats				indWv[ro][%$("stats"+ivFamOutputAppendStr)]=ihStatsRef								duplicate/o ivStats,$ihIvStatsRef/wave=ihIvStats				redimension/n=(-1,-1,1) ihIvStats				indWv[ro][%$("iv2DStats"+ivFamOutputAppendStr)]=ihIvStatsRef								ivFamOutputAppendStrsUsed += ivFamOutputAppendStr +";"			else				WAVE ihStats = $ihStatsRef				concatenate/dl/np=1 {ihStatsTemp},ihStats				WAVE ihIvStats = $ihIvStatsRef				concatenate/dl/np=2 {ivStats},ihIvStats			endif			setdimlabel 1,dimsize(ihStats,1)-1,$famLbl,ihStats			setdimlabel 2,dimsize(ihIvStats,2)-1,$famLbl,ihIvStats					endfor				//IV: calculate stat wave differences		for (j=0;j<numIvSubtractions;j+=1)			ivFamOutputAppendStr = stringfromlist(j,ivFamOutputAppendStrs)			ihStatsRef = cellname + outAppendStr+ivFamOutputAppendStr+"_stats"			ihIvStatsRef = cellname + outAppendStr+ivFamOutputAppendStr+"_ivStats"			WAVE ihStats = $ihStatsRef			WAVE ihIvStats = $ihIvStatsRef			subtractFromThisFam_lbl = stringfromlist(j,ivFamSubtractFromThese)			subtractThese_lbl = stringfromlist(j,ivFamSubtractTheseFromThose)			subStore_lbl = stringfromlist(j,ivFamStoreSubtractionResult) + "_stat"		//distinguishes column label from stat labels directly on raw data subtractions			subtractFromThisFam = indwv[ro][%$subtractFromThisFam_lbl]			subtractThese = indwv[ro][%$subtractThese_lbl]						//IV summary stats subtraction			redimension/n=(-1,dimsize(ihStats,1)+1) ihStats			setdimlabel 1,dimsize(ihStats,1)-1,$subStore_lbl,ihStats			if ( (finddimlabel(ihStats,1,subtractFromThisFam_lbl) >= 0) && (finddimlabel(ihStats,1,subtractThese_lbl) >= 0) )				ihStats[][%$subStore_lbl] = ihStats[p][%$subtractFromThisFam_lbl] - ihStats[p][%$subtractThese_lbl]					else				ihStats[][%$subStore_lbl] = nan			endif							//IV 2D summary stats			redimension/n=(-1,-1,dimsize(ihIvStats,2)+1) ihIvStats			setdimlabel 2,dimsize(ihIvStats,2)-1,$subStore_lbl,ihIvStats			if ( (finddimlabel(ihIvStats,2,subtractFromThisFam_lbl) >= 0) && (finddimlabel(ihIvStats,2,subtractThese_lbl) >= 0)  )				ihIvStats[][][%$subStore_lbl] = ihIvStats[p][q][%$subtractFromThisFam_lbl] - ihIvStats[p][q][%$subtractThese_lbl]				else				ihIvStats[][][%$subStore_lbl] = nan			endif				endfor				//boltzmann calc		ihIvStatsRef = cellname + outAppendStr+"_n30"+"_ivStats"		boltzmannFitStatsRef = cellname + outAppendStr + "_n30" + "_boltzmannStats"		indWv[ro][%boltzmannFitStats] = boltzmannFitStatsRef		make/o/d/n=(numBoltzmannFitPnts+numBoltzmannParams,numBoltzmannCols) $boltzmannFitStatsRef/wave=boltzmannFitStats		boltzmannFitStats=nan		dl_assignLblsFromList(boltzmannFitStats,0,numBoltzmannFitPnts,boltzmannParams,"",0)		dl_assignLblsFromList(boltzmannFitStats,1,0,boltzmannCols,"",0)		boltzmannFitStats[%kInit][]=boltzmann_k_guess				setscale/p x,boltzmannStartVm,boltzmannDelta,"V",boltzmannFitStats		WAVE ihIvStats = $ihIvStatsRef		numSteps = dimsize(ihIvStats,1)		make/o/d/n=(3)/free boltzmannCoefsTemp				for (j=0;j<numBoltzmannCols;j+=1)			layerLbl=stringfromlist(j,boltzmannCols)			layer=finddimlabel(ihIvStats,2,layerLbl)			duplicate/o/free/r=[finddimlabel(ihIvStats,0,"tailAvg")][][layer][0] ihIvStats,tailAvg			duplicate/o/free/r=[finddimlabel(ihIvStats,0,"stepLevel")][][finddimlabel(ihIvStats,2,"preIvFam_n30")][0] ihIvStats,stepLevel			redimension/n=(-1,-1) tailAvg,stepLevel;matrixtranspose tailAvg;matrixtranspose stepLevel;redimension/n=(-1) tailAvg,stepLevel		//put into rows			boltzmannFitStats[%hasData]=numtype(sum(tailAvg))==0			if (!boltzmannFitStats[%hasData])				continue			endif			boltzmannFitStats[%gInit][j]=(tailAvg[numSteps-3] + tailAvg[numSteps-2] + tailAvg[numSteps-1]) / 3		//average last 3 steps for initial guess at max			findlevel/P/Q tailAvg,boltzmannFitStats[%gInit][j]/2		//estimate vHalf			boltzmannFitStats[%findlevel_flag][j]=V_flag			boltzmannFitStats[%findlevel_x][j]=V_levelX			boltzmannFitStats[%findLevel_rising][j]=V_rising			if (V_flag)		//level not found				boltzmannFitStats[%vHalfInit][j]=vHalfDefault				boltzmannFitStats[%vHalfInit_outOfRange][j]=-1				boltzmannFitStats[%findLevel_vFound][j]=nan			else				boltzmannFitStats[%findLevel_vFound][j]=stepLevel[V_levelX]				boltzmannFitStats[%vHalfInit_outOfRange][j] = (boltzmannFitStats[%findLevel_vFound][j]>vHalfMax) || (boltzmannFitStats[%findLevel_vFound][j]<vHalfMin)				boltzmannFitStats[%vHalfInit][j] = boltzmannFitStats[%vHalfInit_outOfRange][j] ? vHalfDefault : boltzmannFitStats[%findLevel_vFound][j]			endif			boltzmannCoefsTemp = {boltzmannFitStats[%gInit][j],boltzmannFitStats[%vHalfInit][j],boltzmann_k_guess}			V_FitError=0;V_Pr=NaN;V_r2=NaN;V_FitQuitReason=0			funcfit/W=2/N=1/Q=1 fit_boltzmann,boltzmannCoefsTemp,tailAvg/x=stepLevel			boltzmannFitStats[%coef0_G][j]=boltzmannCoefsTemp[0]			boltzmannFitStats[%coef1_vHalf][j]=boltzmannCoefsTemp[1]			boltzmannFitStats[%coef2_K][j]=boltzmannCoefsTemp[2]			boltzmannFitStats[%V_FitError][j]=V_FitError			boltzmannFitStats[%V_Pr][j]=V_Pr			boltzmannFitStats[%V_r2][j]=V_r2			boltzmannFitStats[%V_FitQuitReason][j]=V_FitQuitReason						if (V_FitQuitReason == 0)				boltzmannFitStats[0,numBoltzmannFitPnts-1][j] = fit_boltzmann(boltzmannCoefsTemp,x)			endif		endfor				sa_umSq = capStats[%sa_umSq]		//for surface area normalization		presumedERev = ihIvStats[%eRev_m0p09267][0][%preIvFam_n30][0]		drivingForce = ivHold - presumedERev		boltzmannFitStats[%periph][]=periph		boltzmannFitStats[%n67_current][]=fit_boltzmann({boltzmannFitStats[%coef0_G][q],boltzmannFitStats[%coef1_vHalf][q],boltzmannFitStats[%coef2_K][q]},-0.067)		boltzmannFitStats[%sa_umSq][]=sa_umSq		boltzmannFitStats[%presumedERev][]=presumedERev		boltzmannFitStats[%drivingForce][]=drivingForce		boltzmannFitStats[%n67_current_norm][]=boltzmannFitStats[%n67_current][q]/sa_umSq		boltzmannFitStats[%n67_conductance][]=boltzmannFitStats[%n67_current][q]/drivingForce		boltzmannFitStats[%n67_conductance_norm][]=boltzmannFitStats[%n67_conductance][q]/sa_umSq		boltzmannFitStats[%coef0_G_norm][]=boltzmannFitStats[%coef0_G][q]/sa_umSq				//WASHIN/WASHOUT: outputs		washStatsRef = cellname + outAppendStr+"_washStats"		inBlockStatsRef = cellname + "_inBlockStats"		indWv[ro][%washStatsRef]=washStatsRef		indWv[ro][%inBlockStatsRef]=inBlockStatsRef				//WASHIN/WASHOUT: calculate differences		indWv[ro][%washinStartMinusEnd]=stringfromlist(0,wave_subtractLists(indWv[ro][%washin_end],indWv[ro][%washin_start]))		//string from list just to remove ";" bc only one in each list		indWv[ro][%washoutEndMinusStart]=stringfromlist(0,wave_subtractLists(indWv[ro][%washout_start],indWv[ro][%washout_end]))				//WASHIN/WASHOUT: calculate input resistances		wash_pulse1StartX=str2num(indwv[ro][%wash_pulse1StartX]);wash_pulse1EndX=str2num(indwv[ro][%wash_pulse1EndX]);wash_pulse2StartX=str2num(indwv[ro][%wash_pulse2StartX])		wash_pulse2EndX=str2num(indwv[ro][%wash_pulse2EndX]);wash_stepStartX=str2num(indwv[ro][%wash_stepStartX]);wash_stepEndX=str2num(indwv[ro][%wash_stepEndX])		wash_baseline1StartX=wash_pulse1StartX-baselineDelay-inputWinSizeX;wash_baseline1EndX=wash_pulse1StartX-baselineDelay;wash_input1StartX=wash_pulse1EndX-baselineDelay-inputWinSizeX;wash_input1EndX=wash_pulse1EndX-baselineDelay		wash_baseline2StartX=wash_pulse2StartX-baselineDelay-inputWinSizeX;wash_baseline2EndX=wash_pulse2StartX-baselineDelay;wash_input2StartX=wash_pulse2EndX-baselineDelay-inputWinSizeX;wash_input2EndX=wash_pulse2EndX-baselineDelay				//stats for subtracted traces qqqqqqqq		WAVE washStats = stats_ivFam(indWv[ro][%washinStartMinusEnd],washSteps,eRevs,ivHold,wash_stepStartX,wash_stepEndX,ivBaselineAvgLenX,baselineDelay,ivStepAvgLenX,ivStepDelay,ivTailAvgLenX,ivTailDelay,ivInitAvgLenX,ivInitDelay,nan,expFitInfo={0.3,1,0.004,0.012})		duplicate/o washStats,$inBlockStatsRef 				numWashTraces=itemsinlist(washTraces);washCount=0		make/o/n=(numWashTraces) hasWashTraces;dl_assignLblsFromList(hasWashTraces,0,0,washTraces,"",0)		hasWashTraces = waveexists($indWv[ro][%$stringfromlist(p,washTraces)])		for (j=0;j<numWashTraces;j+=1)			if (!hasWashTraces[j])				continue			endif						washLbl = stringfromlist(j,washTraces)			washTraceRef=indWv[ro][%$washLbl]			WAVE washTrace = $washTraceRef			WAVE inputInfo=stats_twoStepInput(washTrace,wash_baseline1StartX,wash_baseline1EndX,wash_input1StartX,wash_input1EndX,testPulse1,wash_baseline2StartX,wash_baseline2EndX,wash_input2StartX,wash_input2EndX,testPulse2)//input resistance			inputForLeakSub=inputInfo[%resistance_input2] 	//then calculate conductance change during washin/washout -- treat as a 1 step I(V) relation:			WAVE ivStats=stats_ivFam(washTraceRef,washSteps,eRevs,ivHold,ivStepStartX,ivStepEndX,ivBaselineAvgLenX,baselineDelay,ivStepAvgLenX,ivStepDelay,ivTailAvgLenX,ivTailDelay,ivInitAvgLenX,ivInitDelay,inputForLeakSub)			concatenate/o/dl/np=0/free {inputInfo,ivStats},washTemp //combine input stats and step (iv) stats						if (washCount == 0)				duplicate/o washTemp,$washStatsRef/wave=washStats				redimension/n=(-1,1) washStats						else				concatenate/dl/np=1 {washTemp},washStats					endif			setdimlabel 1,washCount,$washLbl,washStats						washCount+=1		endfor				//two additional columns: one for washinStartMinusEnd, other for washoutEndMinusStart		if (hasWashTraces[%washin_start] && hasWashTraces[%washin_end])			redimension/n=(-1,dimsize(washStats,1)+1) washStats			setdimlabel 1,dimsize(washStats,1)-1,washinStartMinusEnd,washStats			washStats[][%washinStartMinusEnd] = washStats[p][%washin_start] - washStats[p][%washin_end]		endif		if (hasWashTraces[%washout_start] && hasWashTraces[%washout_end])			redimension/n=(-1,dimsize(washStats,1)+1) washStats			setdimlabel 1,dimsize(washStats,1)-1,washoutEndMinusStart,washStats			washStats[][%washoutEndMinusStart] = washStats[p][%washout_end] - washStats[p][%washout_start]		endif				//SURFACE AREA NORMALIZATION CALCULATION: for ihStats,ihIvStats,washStats, append a second index at higher dimension		sa_umSq = capStats[%sa_umSq]		for (j=0;j<numToSaNorm;j+=1)			WAVE toNorm = $indWv[ro][%$saNormList[j]]			higherDim = wave_dimensionality(toNorm) + 1			duplicate/o/free toNorm,normedTemp			normedTemp /= sa_umSq			concatenate/np=(higherDim)/dl {normedTemp}, toNorm			dl_assignLblsFromList(toNorm,higherDim,0,"rawData;saNormalizedData;","",0)		endfor				if (killReloadedWvs)			killwavesbyname(allLoaded)		endif				//boltzmann fits for tailAvg pre - in:		ivFamOutputAppendStr = "_n30"		ihIvStatsRef = cellname + outAppendStr+ivFamOutputAppendStr+"_ivStats"		WAVE ihStats = $ihStatsRef			endfor		if (doDisp)		iKx_disp(startRow,numRows,"iv;raw;",0,0)	endifendfunction iKx_disp(startrow,numRows,typeStr,seperateBottomAxes,bringToTopOnly)	Variable startRow,numRows	String typeStr		//semi colon delimited list of options. current valid options are "" for all options; or any combination of "iv","raw","exp"	Variable seperateBottomAxes	//for raw data display, use separate bottom axes or plot overlaid?	Variable bringToTopOnly		WAVE/T indWv	=$"iKxInd"	//see ih_calc() for formatting info .. ih_calc will have to have been run on the rows of interest		String bottomAxList = "b_pre;b_in;b_post;"		//list of bottom axis names when seperateBottomAxes = 1		Variable ro,i,j,periph,k,l,numBottomAx=itemsinlist(bottomAxList)	String statsRef,cellname,ivWinN,stat,traceWinN,lblStr,bAx,color,axes,famAppendStr	String famAppendStrList = "_n90;_n90;_n30;_n30;"		//for raw data display	String statsList = "stepMinusBaseline;stepMinusBaseline_leakSub;stepMinusBaseline;tailAvg;"		//which stats to display for each famAppendStr item (index paired)	String stats_famAppendStrList="_n90;_n90;_n30;_n30;"		//for statsList, matched to index	Variable numFamAppendStr = itemsinlist(famAppendStrList)	Variable totalAxSpace,axLen,axSpace=0.04,axStart,axEnd		String expWinN,washinStartMinusEnd,fitRef,fitColorRef,inBlockStatsRef,actTauStr,deactTauStr,inBlockRef,ivStatsRef	Variable expStartRow,fitStartX,fitEndX,x0,numSteps			Variable numStats=itemsinlist(statsList)	for (i=0;i<numRows;i+=1)		ro=startRow+i		if (ro >= dimsize(indWv,0))			break		endif		cellname = getdimlabel(indWv,0,ro)		periph = str2num(indWv[ro][%periph])						//SUMMARY I(V) stats display -- based on raw data		if (itemsinlist(listmatch(typeStr,"iv")) || !strlen(typeStr))			for (j=0;j<numStats;j+=1)						famAppendStr = stringfromlist(j,stats_famAppendStrList)				stat = stringfromlist(j,statsList)				statsRef = indWv[ro][%$("iv2DStats"+famAppendStr)]				WAVE statsWv = $statsRef				ivWinN = cellName + "_RAW" + famAppendStr + "_" + stat								if ( (finddimlabel(statsWv,2,"preIvFam"+famAppendStr)>0) || (finddimlabel(statsWv,2,"inIvFam"+famAppendStr)>0) || (finddimlabel(statsWv,2,"postIvFam"+famAppendStr)>0) || (finddimlabel(statsWv,2,"preMinusInFam"+famAppendStr)>0) || (finddimlabel(statsWv,2,"postMinusInFam"+famAppendStr)>0) )					if (bringToTopOnly)						dowindow/F $ivWinN						continue					else						ivWinN = disp_makeOrClear(ivWinN);dowindow/F $ivWinN					endif										//raw					if (finddimlabel(statsWv,2,"preIvFam"+famAppendStr)>=0)						appendtograph/c=(0,0,0)/W=$ivWinN statsWv[%$stat][*][%$("preIvFam"+famAppendStr)]/tn=pre vs statsWv[%stepLevel][*][%$("preIvFam"+famAppendStr)]					endif					if (finddimlabel(statsWv,2,"inIvFam"+famAppendStr)>=0)						appendtograph/W=$ivWinN statsWv[%$stat][*][%$("inIvFam"+famAppendStr)]/tn=in vs statsWv[%stepLevel][*][%$("inIvFam"+famAppendStr)]					endif					if (finddimlabel(statsWv,2,"postIvFam"+famAppendStr)>=0)						appendtograph/c=(39321,39321,39321)/W=$ivWinN statsWv[%$stat][*][%$("postIvFam"+famAppendStr)]/tn=post vs statsWv[%stepLevel][*][%$("postIvFam"+famAppendStr)]					endif					Label/W=$ivWinN/Z left,"Raw (pA)\\u#2"									//differences					if ((finddimlabel(statsWv,2,"preMinusInFam"+famAppendStr+"_stat")>=0) || (finddimlabel(statsWv,2,"postMinusInFam"+famAppendStr+"_stat")>=0))						if ((finddimlabel(statsWv,2,"preMinusInFam"+famAppendStr)>=0))							appendtograph/c=(0,0,0)/W=$ivWinN/L=L_sub statsWv[%$stat][*][%$("preMinusInFam"+famAppendStr+"_stat")]/tn=pre_diff vs statsWv[%stepLevel][*][%$("preIvFam"+famAppendStr)]						endif						if ((finddimlabel(statsWv,2,"postMinusInFam"+famAppendStr)>=0))							appendtograph/c=(39321,39321,39321)/W=$ivWinN/L=L_sub statsWv[%$stat][*][%$("postMinusInFam"+famAppendStr+"_stat")]/tn=post_diff vs statsWv[%stepLevel][*][%$("postIvFam"+famAppendStr)]						endif						modifygraph/W=$ivWinN freepos=0,lblpos=52,axisenab(left)={0.53,1},axisenab(l_sub)={0,0.47}					endif					Label/W=$ivWinN/Z L_sub,"In-block subtracted (pA)\\u#2"										Label/W=$ivWinN bottom,"V\\BHold\\M (mV)\\u#2 -- " + stat + famAppendStr+ " [pre  \\K(65535,0,0)in  \\K(26214,26214,26214)post]"									endif										endfor						//if tail avg is being plotted, add boltzmann fit			if ( (whichlistitem("tailAvg",statsList) >= 0) && !bringToTopOnly)				ivWinN = cellName + "_RAW" + famAppendStr + "_" + stat				String boltzmannStatsRef=indwv[ro][%boltzmannFitStats]				WAVE boltzmannStats=$boltzmannStatsRef				Variable boltzmannStatsStart=finddimlabel(boltzmannStats,0,"coef0_G")				appendtograph/W=$ivWinN/L=L_sub boltzmannStats[0,boltzmannStatsStart-1][%preMinusInFam_n30_stat]/tn=boltzmann				modifygraph/W=$ivWinN lstyle(boltzmann)=2,rgb(boltzmann)=(0,65535,0)				String boltzmannStr				sprintf boltzmannStr,"G=%2.2fpA V\\B1/2\\M=%2.2fmV K=%2.2fmV",boltzmannStats[%coef0_G][%preMinusInFam_n30_stat]*10^12,boltzmannStats[%coef1_vHalf][%preMinusInFam_n30_stat]*1000,boltzmannStats[%coef2_K][%preMinusInFam_n30_stat]*1000				DrawText/W=$ivWinN 0.407407407407407,0.9375,boltzmannStr			endif						//SUMMARY I(V) KINETICS			if (itemsinlist(listmatch(typeStr,"iv_kin")) || !strlen(typeStr))				String lbl,winN				winN = cellName + "_ivKinetics"				if (bringToTopOnly)					dowindow/F $winN				else					winN = disp_makeOrclear(winN);dowindow/F $winN				endif								statsRef = indWv[ro][%iv2DStats_n90]				WAVE statsWv = $statsRef				appendtograph/W=$winN/c=(0,0,0) statsWv[%act_singleExp_coef2_tau0][][%preMinusInFam_n90]/tn=n90 vs statsWv[%stepLevel][*][%preIvFam_n90]				appendtograph/W=$winN/c=(0,0,0) statsWv[%act_singleExp_coef2_tau0][][%preMinusInFam_n30]/tn=n30 vs statsWv[%stepLevel][*][%preIvFam_n30]				appendtograph/W=$winN/c=(0,0,0)/l=L_deact statsWv[%de_singleExp_coef2_tau0][][%preMinusInFam_n90]/tn=n90deact vs statsWv[%stepLevel][*][%preIvFam_n90]				modifygraph/W=$winN freepos=0,lblpos=-52,axisenab(left)={0.52,1},axisenab(L_deact)={0,0.48},log(left)=1,log(L_deact)=1			endif		endif				//RAW DATA DISPLAY  -- overall view		if (itemsinlist(listmatch(typeStr,"raw"))  || !strlen(typeStr))			lblStr = cellName + ": " + selectstring(periph,"FOVEAL","PERIPH")					for (k=0;k<numFamAppendStr;k+=1)				famAppendStr = stringfromlist(k,famAppendStrList)				traceWinN = cellName+ "_TRACES" + famAppendStr + "_IhVI"				if (bringToTopOnly)					dowindow/F $traceWinN				else					traceWinN = disp_makeOrClear(traceWinN);dowindow/F $traceWinN				endif								//pre				bAx = selectstring(seperateBottomAxes,"bottom",stringfromlist(0,bottomAxList))				color = selectstring(seperateBottomAxes,"0;0;0","0;0;0")				disp_appendTracesToGraph(2,indWv[ro][%$("preIvFam"+famAppendStr)],"",gName=traceWinN,color=color,bottomAxN=bAx,reload=1)								//in				bAx = selectstring(seperateBottomAxes,"bottom",stringfromlist(1,bottomAxList))				color = selectstring(seperateBottomAxes,"0;0;0","0;0;0")				disp_appendTracesToGraph(2,indWv[ro][%$("inIvFam"+famAppendStr)],"",gName=traceWinN,color=color,bottomAxN=bAx,reload=1)								//post				bAx = selectstring(seperateBottomAxes,"bottom",stringfromlist(2,bottomAxList))				color = selectstring(seperateBottomAxes,"0;0;0;24000","0;0;0")				disp_appendTracesToGraph(2,indWv[ro][%$("postIvFam"+famAppendStr)],"",gName=traceWinN,color=color,bottomAxN=bAx,reload=1)								//pre-in				bAx = selectstring(seperateBottomAxes,"bottom",stringfromlist(0,bottomAxList))				color = selectstring(seperateBottomAxes,"0;0;0;24000","0;0;0")				disp_appendTracesToGraph(2,indWv[ro][%$("preMinusInFam"+famAppendStr)],"",gName=traceWinN,color=color,leftAxN="left_sub",bottomAxN=bAx,reload=1)							//post-in				bAx = selectstring(seperateBottomAxes,"bottom",stringfromlist(2,bottomAxList))				color = selectstring(seperateBottomAxes,"30000;0;0;24000","0;0;0")				disp_appendTracesToGraph(2,indWv[ro][%$("postMinusInFam"+famAppendStr)],"",gName=traceWinN,color=color,leftAxN="left_sub",bottomAxN=bAx,reload=1)												//overlay exponential fits on pre-in subtraction to show activation and deactivation kinetic fits				ivStatsRef = indWv[ro][%$("iv2DStats"+famAppendStr)]				WAVE/z ivStats=$ivStatsRef				if (waveExists(ivStats))					expStartRow = finddimlabel(ivStats,0,"act_singleExp_coef0_y0")					numSteps=dimsize(ivStats,1)					for (l=0;l<numSteps;l+=1)							inBlockRef = stringfromlist(l,indWv[ro][%$("preMinusInFam"+famAppendStr)])						WAVE inBlockWv = $inBlockRef						fitStartX = ivStats[%act_fitStartX][l][%$("preMinusInFam"+famAppendStr)]						fitEndX=ivStats[%act_fitEndX][l][%$("preMinusInFam"+famAppendStr)]						x0 = ivStats[%act_singleExp_x0][l][%$("preMinusInFam"+famAppendStr)]						duplicate/o/free/r=[expStartRow,expStartRow+2][l][finddimlabel(ivStats,2,"preMinusInFam"+famAppendStr)] ivStats,coefs						fitRef = ivStatsRef + "_actExpFit_"+num2str(l)						bAx = selectstring(seperateBottomAxes,"bottom",stringfromlist(0,bottomAxList))						expWinN=disp_plotExpFit(coefs,inBlockWv,fitStartX,fitEndX,x0,fitEndX,x0,fitRef,traceWinN,2,"left_sub",bAx,1,1)							endfor				endif								modifygraph/W=$traceWinN freepos=0,lblpos=52,axisenab(left)={0.535,1},axisenab(left_sub)={0,0.465}								if (seperateBottomAxes)					axes = axislist(traceWinN)					totalAxSpace = axSpace * (numBottomAx-1)					axLen = (1 - totalAxSpace) / numBottomAx					for (l=0;l<numBottomAx;l+=1)						axStart=l*axLen + l*axSpace						axEnd=axStart + axLen						bAx = stringfromlist(l,bottomAxList)						if (itemsinlist(listmatch(axes,bAx)))							modifygraph/W=$traceWinN axisenab($stringfromlist(l,bottomAxList)) = {axStart,axEnd}							label/W=$traceWinN, $stringfromlist(l,bottomAxList),selectstring(l==1,"",lblStr+"\r") + replacestring("b_",stringfromlist(l,bottomAxList),"") + " (\\U)"						endif					endfor				else					label/W=$traceWinN bottom,lblStr				endif								label/W=$traceWinN left, "raw (\\U)"				label/W=$traceWinN left_sub, "subtracted (\\U)"							endfor					endif				//exponential fit to wash in display		if (itemsinlist(listmatch(typeStr,"exp"))  || !strlen(typeStr))						expWinN = cellName+ "_TRACES_IKxIv_inBlock_EXPFIT"			if (bringToTopOnly)				dowindow/F $expWinN			else				expWinN = disp_makeOrClear(expWinN);dowindow/F $expWinN			endif					washinStartMinusEnd = indwv[ro][%washinStartMinusEnd]			inBlockStatsRef=indWv[ro][%inBlockStatsRef]			WAVE inBlockWv = $washinStartMinusEnd			WAVE inBlockStats = $inBlockStatsRef						expStartRow = finddimlabel(inBlockStats,0,"act_singleExp_coef0_y0")			fitStartX = inBlockStats[%act_fitStartX]					fitEndX=inblockStats[%act_fitEndX] 			x0 = inblockStats[%act_singleExp_x0]			duplicate/o/free/r=[expStartRow,expStartRow+2] inBlockStats,coefs			fitRef = inBlockStatsRef + "_actExpFit"			expWinN=disp_plotExpFit(coefs,inBlockWv,fitStartX,fitEndX,x0,fitEndX,x0,fitRef,expWinN,2,"","",1,0)			setaxis/W=$expWinN bottom fitStartX-0.05,fitEndX+0.05				expStartRow = finddimlabel(inBlockStats,0,"de_singleExp_coef0_y0")			fitStartX = inBlockStats[%de_fitStartX]					fitEndX=inblockStats[%de_fitEndX] 			x0 = inblockStats[%de_singleExp_x0]			duplicate/o/free/r=[expStartRow,expStartRow+2] inBlockStats,coefs			fitRef = inBlockStatsRef+"_deactExpFit"			expWinN=disp_plotExpFit(coefs,inBlockWv,fitStartX,fitEndX,x0,fitEndX,x0,fitRef,expWinN,2,"L_deact","top",1,0)			setaxis/W=$expWinN top fitStartX-0.05,fitEndX+0.05						sprintf actTauStr,"%2.2f",inBlockStats[%act_singleExp_coef2_tau0]*1000			sprintf deactTauStr,"%2.2f",inBlockStats[%de_singleExp_coef2_tau0]*1000						DrawText/W=$expWinN 0.851851851851852,0.704545454545455,"τ\\BAct\\M="+actTauStr+"ms"			DrawText/W=$expWinN 0.835648148148148,0.0852272727272727,"τ\\BDeact\\M="+deactTauStr+"ms"						modifygraph/W=$expWinN freepos=0,lblpos=52,axisenab(left)={0,0.48},axisenab(L_deact)={0.52,1}		endif	endforendfunction/S disp_plotExpFit(coefsWv,dataWv,fitStartX,fitEndX,startX,endX,x0val,fitSaveRef,winN,newClearOrAdd,vertAxN,horAxN,doColorIndicatorWv,plotFitOnly)	WAVE coefsWv,dataWv		//fit wv is the wave that was fit	Variable fitStartX //start of window used in fitting	Variable fitEndX		//end of window used in fitting	Variable startX		//start time for fit wv to generate (must be subregion of dataWv)	Variable endX		//end time for fit wv to generate	Variable x0val			//fit x0	String fitSaveRef	//place to store fit Wv that will be generated and displayed, or "" to auto generate	String winN			//name of window or "" to use top or autogenerate	Variable newClearOrAdd			//window behavior...calls disp_graphHandling()	String horAxN,vertAxN	Variable doColorIndicatorWv			//differentiates region displayed outside the origina fit	Variable plotFitOnly		//just plot fit, not dataWv			winN = disp_graphHandling(winN,newClearOrAdd)		if (strlen(vertAxN) < 1)		vertAxN = "left"	endif	if (strlen(horAxN) < 1)		horAxN = "bottom"	endif			Variable vertIsLeft = stringmatch(vertAxN,"L*")	Variable horIsBottom = stringmatch(horAxN,"B*")		duplicate/o/r=(startX,endX) dataWv,$fitSaveRef/wave=fit	Variable/g x0 = x0val	fit = myexp(coefsWv,x)		if (vertIsLeft && horIsBottom)		if (!plotFitOnly)			appendtograph/W=$winN/L=$vertAxN/B=$horAxN/c=(0,0,0) dataWv		endif		appendtograph/W=$winN/L=$vertAxN/B=$horAxN fit		elseif (vertIsLeft)		//hor is top		if (!plotFitOnly)			appendtograph/W=$winN/L=$vertAxN/T=$horAxN/c=(0,0,0) dataWv		endif		appendtograph/W=$winN/L=$vertAxN/T=$horAxN fit	elseif (horIsBottom)	//vert is right		if (!plotFitOnly)			appendtograph/W=$winN/R=$vertAxN/B=$horAxN/c=(0,0,0) dataWv		endif		appendtograph/W=$winN/R=$vertAxN/B=$horAxN fit	else			//hor is top and vert is right		if (!plotFitOnly)			appendtograph/W=$winN/R=$vertAxN/T=$horAxN/c=(0,0,0) dataWv		endif		appendtograph/W=$winN/R=$vertAxN/T=$horAxN fit	endif		String colorIndicatorRef=""	if (doColorIndicatorWv)		colorIndicatorRef = fitSaveRef +"_colorWv"		duplicate/o fit,$colorIndicatorRef/wave=color		color = (x > fitStartX) && (x < fitEndX) ? 1 : 0		ModifyGraph/W=$winN zColor($fitSaveRef)={color,*,*,CyanMagenta,0}	endif			return winN			endfunction/S disp_graphHandling(winN,newClearOrAdd)	String winN	Variable newClearOrAdd		//0 for new window -- autogenerated name if winN="" or win exists, creates if not exists									//1 to clear window -- clears named window if exists, creates if it does not exist									//2 adds if window exists (just returns name) and creates if it does not exist		Variable noNamePassed=strlen(winN) < 1,type=nan,graphExists=nan,wrongType=nan	if (!noNamePassed)		type = wintype(winN)		graphExists = !noNamePassed && (type > 0)		wrongType = graphExists && (type != 1)	endif		if (newClearOrAdd == 0)		//new window										if (noNamePassed)			display/k=1			return S_name		endif				display/k=1/n=$winN //if wrong type or already exists, auto naming will take care of it		return S_name									elseif (newClearOrAdd == 1)		if (noNamePassed)			display/k=1			print "disp_graphHandling() win clear requested but no name passed, creating new window with auto name",s_name			return s_name		endif				if (wrongType)			display/k=1/n=$winN			print "disp_graphHandling() win clear requested for win",winN,"but window already exists as non graph, creating new window with auto name",s_name			return S_name		endif				if (graphExists)			vis_clearGraph(winN)		else			display/k=1/n=$winN			return winN		endif				elseif (newClearOrAdd == 2)		if (noNamePassed)			display/k=1			print "disp_graphHandling() add to win requested but no name passed, creating new window with auto name",s_name			return s_name		endif					if (wrongType)			display/k=1/n=$winN			print "disp_graphHandling() add to win requested for win",winN,"but window already exists as non graph, creating new window with auto name",s_name			return S_name		endif					if (graphExists)			return winN		else			display/k=1/n=$winN			return s_name		endif	endifendfunction ikx_summaryIvDisp(statColLbl,statStr,conditionStr,showNormed,n30,[forceWinN])	String statColLbl	//label for column containing stat wave of interest in ihInd. usually either "stats","iv2DStats",or "washStatsRef"							//for iv2dstats, will plot vs IV step holding potential by default							//for others, conditionStr is ignored	String statStr		//string found in a row of iv2DStats or washStats wave e.g., stepMinusBaseline_leakSub	String conditionStr	//string found in a column of iv2DStats  or washStats wave e.g., preMinusInFam	Variable showNormed		//0 for not normalized to surface area, 1 for surface area normalized	Variable n30		//show family from -90 hold or -30 hold?	String forceWinN		//force a winN, otherwise its automatic		WAVE/T indWv = $"iKxInd"		Variable i,rows=dimsize(indWv,0),periph,isZD,DIV	String statsRef,cellname,as = selectstring(n30,"_n90","_n30")		String defaultWinN = "iKx_ivStatSummary_"+statStr +"_"+conditionStr+"_"+ as+  selectstring(showNormed,"","_normSA")	String winN = selectstring( paramIsDefault(forceWinN) || (strlen(forceWinN) < 1) , forceWinN, defaultWinN )	disp_makeOrClear(winN);dowindow/F $winN		for (i=0;i<rows;i+=1)		cellname = getdimlabel(indWv,0,i)		if (strlen(cellname) < 1)			continue		endif		statsRef = indWv[i][%$(statColLbl+as)]		if (!waveexists($statsReF))			continue		endif		WAVE statsWv = $statsRef			periph = str2num(indWv[i][%periph])		DIV = str2num(indWv[i][%DIV])		WAVE cs=getColorSet( periph ? 3 : 2 )				if (stringmatch(statsRef,"*ivstats*"))			appendtograph/W=$winN/c=(cs[0],cs[1],cs[2],30000) statsWv[%$statStr][*][%$(conditionStr+as)][showNormed]/tn=$cellname vs statsWv[%stepLevel][*][%$("preIvFam"+as)][0]		else			appendtograph/W=$winN/c=(cs[0],cs[1],cs[2],30000) statsWv[%$statStr][0,2][showNormed]/tn=$cellname		endif						if (isZD)			modifygraph/W=$winN lstyle($cellname)=3		endif		if (DIV == 0)			modifygraph/W=$winN lsize($cellname)=2		endif	endforendfunction/S ih_getGroup()	WAVE/T ihInd		String groups = "foveal;periph;"	String groupVal = "0;1;"	String checkColLbl = "periph"		String out=replacestring(";",groups,":;"),checkStr,group,cellName	Variable i,rows=dimsize(ihInd,0),groupNum	for (i=0;i<rows;i+=1)		checkStr = ihInd[i][%$checkColLbl]		groupNum = whichlistitem(checkStr,groupVal)		if (groupNum >= 0)			group = stringfromlist(groupNum,groups)			cellName = getdimlabel(ihInd,0,i)			out = text_appendToStringByKey(group, out, cellName +",")		endif	endfor		return outendfunction/S stats_ivWin(traceGroups,yRowLbl,yLayerLbl,xRowLbl,xLayerLbl,isNorm,doAppend)	String traceGroups		//statistical groups in list with "group0:traceName0,traceName1,traceName2,;group1:traceNameA,traceNameB,;	String yRowLbl,yLayerLbl,xRowLbl,xLayerLbl	variable isNorm		//1 for norm, 0 for not (sets chunk)	Variable doAppend	//add waves to graph display? 1 for by group, 2 for just all		String winN = winname(0,1)	Variable numGroups = itemsinlist(traceGroups),groupNum	String traces=tracenamelist(winN,";",1),yRef,xRef,trace,xyDataTemp,groupTraces,groupInfo,groupName	Variable numTraces=itemsinlist(traces),i	String outStartStr = winN + "_winStats"	Variable yRow,yLayer,xRow,xLayer,j,found	Variable chunk = isNorm	String allTempsList=""		//list of xy pair data	make/o/t/free/n=(numGroups) xyTempListForEachGroup = ""		//same for each group			for (i=0;i<numTraces;i+=1)		trace = stringfromlist(i,traces)		xyDataTemp = trace+"_xyTemp"		WAVE yWv = tracenametowaveref(winN,trace)		yRow = finddimlabel(yWv,0,yRowLbl)		yLayer = finddimlabel(yWv,2,yLayerLbl)		WAVE xWv = xWaveRefFromTrace(winN,trace)		xRow = finddimlabel(xWv,0,xRowLbl)		xLayer = finddimlabel(xWv,2,xLayerLbl)				duplicate/o/free/r=[yRow][][yLayer][chunk] yWv,yTemp		redimension/n=(-1,-1) yTemp		matrixtranspose yTemp		redimension/n=(-1) yTemp		duplicate/o/free/r=[xRow][][xLayer][0] xWv,xTemp		redimension/n=(-1,-1) xTemp		matrixtranspose xTemp		redimension/n=(-1) xTemp			concatenate/o/np=1 {xTemp,yTemp},$xyDataTemp				allTempsList += xyDataTemp+";"				found = -1		for (j=0;j<numGroups;j+=1)			groupInfo = stringfromlist(j,traceGroups)			groupTraces = c2sc(stringfromlist(1,groupInfo,":"))			if (whichListitem(trace,groupTraces) >= 0 )				found = j				break			endif		endfor				if (found >= 0)			xyTempListForEachGroup[j] += xyDataTemp +";"		else			print "failed to find trace",trace,"yWv",nameofwave(yWv),"xWv",nameofwave(xWv)		endif		endfor			//calculate stats for all cells regardless of group	String allOutput = outStartStr + "_all"	wave_catYxPairsIntoManyYBy1X(allTempsList,allOutput,0.005,0,1,0,1)		//calculate group stats	String outList ="",currOut		//outputs for each group	for (i=0;i<numGroups;i+=1)		groupInfo = stringfromlist(i,traceGroups)		groupName = stringfromlist(0,groupInfo,":")		currOut = outStartStr + "_"+groupName		if (itemsinlist(xyTempListForEachGroup[i]) > 0)			wave_catYxPairsIntoManyYBy1X(xyTempListForEachGroup[i],currOut,0.005,0,1,0,1,killAfter=1)			outList += currOut +";"		else			print "warning, no traces found for groupNum",i,"groupName",groupName,"groupInfo",groupInfo		endif	endfor		if (doAppend==1)		Variable finalNumGroups=itemsinlist(outList)		for (i=0;i<finalNumGroups;i+=1)			currOut = stringfromlist(i,outList)			appendtograph/W=$winN/c=(0,0,20000) $currOut[][%avg] vs $currOut[][%xValues]			ErrorBars/W=$winN/T=0/L=2/RGB=(0,0,0,40000) $currOut Y,wave=($currOut[*][%sem],$currOut[*][%sem])		endfor	elseif (doappend==2)		appendtograph/W=$winN/c=(0,0,20000) $allOutput[][%avg] vs $allOutput[][%xValues]		ErrorBars/W=$winN/T=0/L=2/RGB=(0,0,0,40000) $allOutput Y,wave=($allOutput[*][%sem],$allOutput[*][%sem])				endif		return outList + allOutput +";"endfunction/S stats_iv_getGroup(indWv)	WAVE/T indWv		String groups = "foveal;periph;"	String groupVal = "0;1;"	String checkColLbl = "periph"		String out=replacestring(";",groups,":;"),checkStr,group,cellName	Variable i,rows=dimsize(indWv,0),groupNum	for (i=0;i<rows;i+=1)		checkStr = indWv[i][%$checkColLbl]		groupNum = whichlistitem(checkStr,groupVal)		if (groupNum >= 0)			group = stringfromlist(groupNum,groups)			cellName = getdimlabel(indWv,0,i)			out = text_appendToStringByKey(group, out, cellName +",")		endif	endfor		return outendfunction/S win_duplicate(winN)	string winN		if (strlen(winN) < 1)		winN = winname(0,1)	endif		String recreation = WinRecreation(winN, 0 ) 	execute/q/z recreation		return stringfromlist(0,winlist("*",";",""))end//display a bunch of sweeps in a row as if concatenated (no change to underlying sweeps, uses display offsets)function disp_catSweeps(list,newClearOrAdd,useFdTiming [winN,reload])	String list,winN	Variable newClearOrAdd	Variable useFdTiming		//if 0, just puts sweeps end to end based on ordering in list; if 1, aligns times to sweep start times based on file directory info stored in wave note	Variable reload		//attempt automatical reloading		if (paramIsDefault(winN))		winN = ""	endif		switch (newClearOrAdd)		case 1:			if (strlen(winN) == 0)				winN = winname(0,1)		//top graph			endif			if (winType(winN) > 0)				vis_clearGraph(winN)			else				Display/K=1/N=$winN				winN = S_name			endif			break		case 2:		//if win exists do nothing			if (strlen(winN) == 0)				winN = winname(0,1)		//top graph			endif			if (winType(winN) == 0)				Display/K=1/N=$winN				winN = S_name			endif			break			default:			if (strlen(winN) == 0)				winN = "Graph"			elseif (winType(winN) > 0)				killwindowsbyname(winN)			endif						Display/K=1/N=$winN			winN = S_name	endswitch			if (!ParamIsDefault(reload))		da_fd_loadWavesFromWaveName(list,1)	endif		Variable num,i,offset	String ref	num=itemsinlist(list)	if (useFdTiming)		String firstRef = stringfromlist(0,list)		for (i=0;i<num;i+=1)			ref=stringfromlist(i,list)			WAVE/Z wv = $ref			if (!waveexists(wv))				continue			endif			appendtograph/W=$winN wv			if (i>0)				offset = text_getWaveTimeDifference(firstRef,ref,5)		//offset in seconds				modifygraph/W=$winN offset($ref)={offset,0}			endif		endfor		else		offset = dimoffset($stringfromlist(0,list),0)		for (i=0;i<num;i+=1)			ref=stringfromlist(i,list)			WAVE/Z wv = $ref			if (!waveexists(wv))				continue			endif			appendtograph/w=$winN wv			if (i>0)				modifygraph/w=$winN offset($ref)={offset,0}			endif			offset += (dimsize(wv,0)+1)*dimdelta(wv,0)		endfor	endifendfunction wave_extendDim(wv,dim,numNewInds,lbls)	WAVE wv	Variable numNewInds,dim	String lbls	//pass "" or lbls to add			Variable origLen=dimsize(wv,dim),newLen = origLen + numNewInds	switch (dim)		case 0:			redimension/n=(newLen,-1,-1-1) wv			break		case 1:			redimension/n=(-1,newLen,-1,-1) wv			break		case 2:			redimension/n=(-1,-1,newLen,-1) wv			break		case 3:			redimension/n=(-1,-1,-1,newLen) wv			break	endswitch		if (strlen(lbls) > 0)		dl_assignlblsfromlist(wv,dim,origLen,lbls,"",0,reuseLast=1)	endif		return newLenendfunction/S graph_duplicate(origWinName,appendStrForNewWaves,[newWinName,appendBefore])	String origWinName		//original window name. Top graph is used in case of ""	String appendStrForNewWaves	//pass "" to make new plot have same waves, pass "" to rename the waves as [origName]+appendStrForNewWaves and have those plotted	String newWinName		//optionally give the window a new name instead of its automatic name	Variable appendBefore		//optionally specify to append appendStrForNewWaves before wave names [Warning: may not work with data folder names?]		Variable startSkipLines = 2		//skip "function ..." and "PauseUpdate ..." lines from beginning of recreation macro	Variable endSkipLines = 1			//skip "PauseUpdate ..." line from recreation macro	Variable attemptTnReplacement=1	//optionally attempt trace name replacement for traces whose name was set by the wave name, when the wave name is changning the trace name will too		if (strlen(origWinName) < 1)	//default to top graph for ""		origWinName = winname(0,1)		endif		Variable i,sameTraceNameAsWaveName,newWaves = strlen(appendStrForNewWaves) > 0	String recreationStr,createdWaves="",origTraceString	if (newWaves)		//use getWindow wavelist and winrecreation to replace unique ##(num)## in recreation macro with new wave names, after duplication		recreationStr = winrecreation(origWinName,2)			getwindow $origWinName, waveList		WAVE/T W_WaveList		//not sure what the difference betweens columns 0 and 1 is in this		Variable numWaves = dimsize(W_WaveList,0)		Variable doAppendBefore = !paramIsDefault(appendBefore) && appendBefore				//set new wave names		make/o/t/free/n=(numWaves) newWaveNames		if (doAppendBefore)			newWaveNames = appendStrForNewWaves + W_waveList[p][0] 		else			newWaveNames = W_waveList[p][0] + appendStrForNewWaves		endif				//duplicate new waves and insert names into recreationStr		String hashTagStr,newWaveName,origWaveName		for (i=0;i<numWaves;i+=1)			origWaveName = W_waveList[i][0]			newWaveName = newWaveNames[i]			hashTagStr = W_waveList[i][2]			Duplicate/o $origWaveName,$newWaveName			recreationStr=replacestring(hashTagStr,recreationStr,newWaveName)			createdWaves += newWaveName + ";"			print "i",i," recreationStr hashTagStr",hashTagStr,"newWaveName",newWaveName,"origWaveName",origWaveName		endfor				if (attemptTnReplacement)		//not yet implemented//			traces = tracenamelist(origWinName,";",2^0+2^1+2^2+2^3+2^4)//			numTraces = itemsinlist(traces)//			for (i=0;i<numTraces;i+=1)//				trace = stringfromlist(i,traces)//				traceRef = tracenametowaveref(origWaveName,trace)//				if (!stringmatch(trace,traceRef))		//not a //			endfor		endif	else		recreationStr = winrecreation(origWinName,0)	endif		//window name handling	String finalName 	if (ParamIsDefault(newWinName) || (strlen(newWinName) < 1) )		//use default window name		finalName = stringfromlist(1,recreationStr," ")	//get window name from recreation macro name.. (allows winStr="" for top window)		finalName = replacestring("()",finalName,"")		//remove () from after recreation macro name	else	//newWinName passed		finalName = newWinName	endif		recreationStr = replacestring("Display",recreationStr,"Display/N="+finalName,0,1)		//modify "Display..." line to include window name		//run commands, line by line to avoid execute length limit	Variable lines = itemsinlist(recreationStr,"\r"),lineLimit = lines - endSkipLines	for (i=startSkipLines;i<lineLimit;i+=1)		execute/q stringfromlist(i,recreationStr,"\r")	endfor		return createdWavesendfunction testwhat()	print getrtstackinfo(0)	print getrtstackinfo(3)end//returns procedure file path for a non-adopted ipf filefunction/S getProcedureFilePath()	String procedureName = stringfromlist(1,getrtstackinfo(3),",")	getwindow/Z $procedureName,file	return stringfromlist(1,S_value)end//cursors are not transferred to the new trace; likely doesn't work for box, violin, contour, or image traces.function/S renameTrace(winN,oldName,newName)	String winN,oldName,newName	 	if (strlen(winN) < 1)		winN = winname(0,1)	endif		String traces = tracenamelist(winN,";",2^0+2^1+2^2+2^3+2^4)	Variable oldPosition = whichlistitem(oldName,traces)		if (oldPosition < 0)		print "renameTrace() in winN",winN,"oldName",oldName,"not found, aborting"		return ""	endif		//make sure new name does not conflict with anything except old name 	if (stringmatch(newName,oldName))		//I guess could be useful if a difference in case is sought		print "renameTrace() newName requested matches oldName. Aborting"		return ""	endif		newName = uniquetraceName(winN,newName)		make/o/t/free axFlags = {"/L=","/B=","/T=","/R="}	setdimlabel 0,0,left,axFlags	setdimlabel 0,1,bottom,axFlags	setdimlabel 0,2,top,axFlags	setdimlabel 0,3,right,axFlags		String winFlag = "/W="+winN	String info = traceinfo(winN,oldName,0)	String xwave = Stringbykey("xwave",info)	Variable hasxwave = strlen(xwave) > 0	WAVE oldWv = $oldName	String ywave = nameofwave(tracenametowaveref(winN,oldName))	String xaxis = Stringbykey("xaxis",info)	String yaxis = Stringbykey("yaxis",info)	String xaxInfo = axisinfo(winN,xaxis)	String xaxType = stringbykey("axtype",xaxInfo)	String yaxInfo = axisinfo(winN,yaxis)	String yaxType = stringbykey("axtype",yaxInfo)	String yRange = Stringbykey("yRange",info)	String xRange = Stringbykey("xRange",info)	String errBars = Stringbykey("errorbars",info)	//trace info not handled:	//TYPE -- contour, box, violin may need different commands	//XWAVEDF -- problematic if X wave has a data folder that is not stored in xwave (same true of ywave perhaps, but there is no key for that in traceInfo)		String appendCmd = "appendtograph"+winFlag+axFlags[%$yaxType]+yaxis+axFlags[%$xaxType]+xaxis+" "+ywave+yRange+"/TN="+newName	if (hasxwave)		appendCmd += " vs " + xwave+xRange	endif		//before removing original, append this trace name 	execute/q appendCmd		if (strlen(errBars) > 0)		WAVE/T errText = listtotextwave(errBars," ")		errText[0] = errText[0] + winFlag	//held beginning of the command, ErrorBars + flags. Append /W=winN		errText[1] = newName			//held original trace name, needs the new trace name		String errBarsCmd		wfprintf errBarsCmd,"%s ",errText				execute/q errBarsCmd	endif		//now remove original trace	removefromgraph/W=$winN $oldName			//now apply style settings		String easyInfo = "dummy~" + replacestring("RECREATION:",info,"|RECREATION~",1) + "|"	String recreation = Stringbykey("RECREATION",easyInfo,"~","|",1)		//recreation is the last key, so put in a nonsense sepStr to get the entirety of the string from RECREATION: on	String styleStr	Variable i,numCmds = itemsinlist(recreation)	for (i=0;i<numCmds;i+=1)		styleStr = stringfromlist(i,recreation)		styleStr = replacestring("(x)",styleStr,"("+newName+")")		execute/Q "modifygraph/w="+winN+" " + styleStr	endfor		//now fix trace ordering 	Variable numTraces = itemsinlist(traces)	if (oldPosition == 0)		//bottom-most		reordertraces _back_, {$newName}	elseif (oldPosition < numTraces - 1)		//if oldPosition == numTraces - 1, it was top-most and is still		Variable followingTracePos = oldPosition + 1		reordertraces $stringfromlist(followingTracePos,traces),{$newName}		//put trace just before following trace, where it was originally	endif		return newNameendfunction/S uniqueTraceName(winN,traceName)	STring winN,traceName		Variable i=0,attemptLimit = 10^5	String traces = tracenamelist(winN,";",2^0+2^1+2^2+2^3+2^4)	String outName = traceName,numStr	do		if (whichListItem(outName,traces) < 0)			return outName		endif				sprintf numStr,"%i",i		outName = traceName + "#"+ numStr		i+=1	while (i < attemptLimit)		String justInCase = 	traceName + "_Unique_" + num2str(floor(10*(0.5+enoise(0.5)))) + num2str(floor(10*(0.5+enoise(0.5)))) + num2str(floor(10*(0.5+enoise(0.5)))) + num2str(floor(10*(0.5+enoise(0.5)))) + num2str(floor(10*(0.5+enoise(0.5))))	return uniqueTraceName(winN,justInCase)endfunction/s dimsizes(wv)	WAVE wv		return num2str(dimsize(wv,0))+";"+num2str(dimsize(wv,1))+";"+num2str(dimsize(wv,2))+";"+num2str(dimsize(wv,3))+";"endfunction setMarqueeByAx(winN,vertAxN,vertBottom,vertTop,horAxN,horLeft,horRight)	String vertAxN,horAxN,winN	Variable vertBottom,vertTop,horLeft,horRight		if (strlen(winN) < 1)		winN=winname(0,1)	endif		if (strlen(vertAxN) < 1)		vertAxN = "left"	endif		if (strlen(horAxN) < 1)		horAxN = "bottom"	endif	 	getwindow $winN, psizeDC	Variable pixHorRange = V_right-V_left	getwindow $winN, psize	Variable pntsHorRange = V_right-V_left	Variable pntsPerPix = pntsHorRange / pixHorRange	Variable bottom=pixelFromAxisVal(winN,vertAxN,vertBottom)*pntsPerPix	Variable top=pixelFromAxisVal(winN,vertAxN,vertTop)*pntsPerPix	Variable left=pixelFromAxisVal(winN,horAxN,horLeft)*pntsPerPix	Variable right=pixelFromAxisVal(winN,horAxN,horRight)*pntsPerPix			SetMarquee/W=$winN left, top, right, bottomendfunction phPerUmSqPerS_fromW(lambda_nm,wPerMSq)	Double lambda_nm,wPerMSq		Double h = 6.62606957*10^(-34)		//J*s	Double c_mPerS = 299792458					//m/s	Double c = c_mPerS * 10^9				//nm/s	Double energyPerPhoton = h*c/lambda_nm	//J*s * (nm/s) / nm == J (in one photon) == W*s/photon		Double photonsPerSPerMSq = wPerMSq / energyPerPhoton		//W/m^2 / (W*s/photon) == photons / s / m^2	Double photonsPerUmSqPerS = photonsPerSPerMSq *10^-12		//photons / s / m^2 * (1m^2 / 10^12 um^2) == photons/s/um^2		return photonsPerUmSqPerSend#include <Graph Utility Procs>Menu "Graph"    "Set All Traces Alpha", mSetAllTracesAlpha()endFunction mSetAllTracesAlpha()    String gname=WinName(0,1)    String traces = TraceNameList(gname, ";", 1)    Variable alpha=65535    Prompt gname, "Graph:"    Prompt alpha, "Alpha [0 to 65535]:"    DoPrompt "Set All Traces Alpha", gname, alpha    if (V_flag == 0)        SetAllTracesAlpha(gname, alpha)    endifendFunction SetAllTracesAlpha(String gname, Variable alpha)    if (strlen(gname) == 0)        gname = WinName(0,1)    endif    if (strlen(gname) == 0)        return 0    endif        Variable i    String traces = TraceNameList(gname, ";", 1)    Variable ntraces = ItemsInList(traces)    for (i = 0; i < ntraces; i++)        String tname = StringFromList(i, traces)        String info = Traceinfo(gname, tname, 0)        String color = WMGetRECREATIONInfoByKey("rgb(x)", info)        String redstr = StringFromList(0, color, ",")        Variable red = str2num(redstr[1,inf])        Variable green = str2num(StringFromList(1, color, ","))        Variable blue = str2num(StringFromList(2, color, ","))        ModifyGraph rgb($tname)=(red, green, blue, alpha)    endforendfunction scrapTextToCmdLine_noComments()	String scrap = getscraptext(),line,cmdNoCmnt=""	String linebrk = "\r"	Variable i,lines=itemsinlist(scrap,linebrk)	for (i=0;i<lines;i+=1)		line = stringfromlist(i,scrap,linebrk)		cmdNoCmnt += replacestring("//",line,"",0,1) +linebrk	endfor	cmdNoCmnt = replacestring("•",cmdNoCmnt,"")	tocommandline cmdNoCmnt	putscraptext cmdNoCmntendMenu "Macros"	"Cmd line paste, no comments/5",/Q,scrapTextToCmdLine_noComments()endMenu "TracePopup"	"Copy RGB(A)", /Q, traceColorToClip()EndMenu "TracePopup"	"Paste RGB(A)",/Q,executeTraceColorFromClip()EndMenu "tracePopup"	"Copy Waves+Disp command",/Q,waveAndDispToClip()EndMenu "TracePopup"	"CopyDspFrmt (Ctrl>Append Shft>rename)",/Q,traceDispAndFormatToClip()endMenu "TracePopup"	"Copy Format",/Q,traceFormatToClip()endMenu "tracePopup"	"Paste Format",/Q,traceFormatFromClip()endMenu "GraphPopup"	"Copy Graph Waves & Disp command",/Q,saveWavesAndGraphToClip()endMenu "Windows"	"Paste Graph Waves & Disp command/7",/Q,executeWavesAndGraphFromClip()endMenu "GraphPopup", dynamic	submenu "Append To Layout"		winlist("*",";","WIN:4")+"~Make New Layout~;",appendWinToLayoutFromPopup()	endEndfunction appendWinToLayoutFromPopup()	getlastusermenuinfo	String layoutN	if (StringMatch(S_Value,"~Make New Layout~"))		newlayout		layoutN=S_name	else		layoutN=S_value	endif		appendWinsToLayout(layoutN,0,S_graphName,1)	doupdateendFunction traceDispAndFormatToClip()	GetLastUserMenuInfo	String info = traceinfo(S_graphname,S_tracename,0)	String easyInfo = "dummy~" + replacestring("RECREATION:",info,"|RECREATION~",1) + "|"	String recreation = Stringbykey("RECREATION",easyInfo,"~","|",1)		//recreation is the last key, so put in a nonsense sepStr to get the entirety of the string from RECREATION: on	Variable keyState = getkeystate(0)	Variable shiftIsPressed = (keyState & 2^2)>0		//prompts for trace rename, inserted into commands. hard to do -- have to right click and then shift	Variable ctrlIsPressed = (keyState & 2^0)>0		//changed "Display" to "AppendToGraph" at start of command	String currentTraceName = s_tracename	Variable changeName	if (shiftIsPressed)		prompt currentTraceName, "Enter New Trace Name: "		doprompt "traceDispAndFormatToClip() rename trace",currentTraceName		if (V_flag)			changeName = 0		else			changeName = 1		endif	endif		String dispCmd = getTraceDispCmdStr(S_graphname,S_tracename,1,ctrlIsPressed,renameTrace=selectstring(changeName,"",currentTraceName))	if (changeName)		recreation = replacestring("(x)",recreation,"("+currentTraceName+")")	else		recreation = replacestring("(x)",recreation,"("+S_tracename+")")	endif	recreation = replacestring(";",recreation,",")	recreation = "ModifyGraph " + recreation[0,strlen(recreation)-2]		//remove last ,	String errBars = Stringbykey("errorbars",info) 		String cmd = dispCmd + "\r" + recreation	if (strlen(errBars) > 0)		WAVE/T errText = listtotextwave(errBars," ")		errText[0] = errText[0] //+ winFlag	//held beginning of the command, ErrorBars + flags. Append /W=winN		errText[1] = selectstring(changeName,s_tracename,currentTraceName)			//held original trace name, needs the new trace name		String errBarsCmd		wfprintf errBarsCmd,"%s ",errText				cmd += "\r" + errBarsCmd	endif		putscraptext cmdEndfunction traceFormatToClip()	GetLastUserMenuInfo	String info = traceinfo(S_graphname,S_tracename,0)	String easyInfo = "dummy~" + replacestring("RECREATION:",info,"|RECREATION~",1) + "|"	String recreation = Stringbykey("RECREATION",easyInfo,"~","|",1)		//recreation is the last key, so put in a nonsense sepStr to get the entirety of the string from RECREATION: on	putscraptext recreationendfunction traceFormatFromClip()	String recreation = getscraptext()		GetLastUserMenuInfo	recreation = replacestring("(x)",recreation,"("+S_tracename+")")	recreation = replacestring(";",recreation,",")	recreation = "ModifyGraph " + recreation[0,strlen(recreation)-2]		//remove last ,	execute/q recreation	endFunction traceColorToClip()	GetLastUserMenuInfo	String info = traceinfo(S_graphname,S_tracename,0)	String easyInfo = "dummy~" + replacestring("RECREATION:",info,"|RECREATION~",1) + "|"	String recreation = Stringbykey("RECREATION",easyInfo,"~","|",1)		//recreation is the last key, so put in a nonsense sepStr to get the entirety of the string from RECREATION: on	String rgb = StringByKey("rgb(x)", recreation,"=")	putscraptext rgbEndfunction executeTraceColorFromClip()	GetLastUserMenuInfo	///String cmd = "Modifygraph/W="+S_graphname+" rgb("+S_tracename+")="+getscraptext() //not needed bc window would always be on top	String cmd = "Modifygraph rgb("+S_tracename+")="+getscraptext()	print cmd	execute cmdendfunction saveWaveAndDispToClip()	GetLastUserMenuInfo	String ref = nameofwave(tracenametowaveref(S_graphname,S_tracename))	save/c/o/p=IgorUserFiles $ref		String info = traceinfo(S_graphname,S_tracename,0)	String xref = Stringbykey("xwave",info)	Variable hasxwave = strlen(xref) > 0		String cmd = "loadwave/p=IgorUserFiles "+ref+";"		if (hasxwave)		save/c/o/p=IgorUserFiles $xref		cmd+="loadwave/p=IgorUserFiles "+xref+";"	endif	 		cmd += "\r"+getTraceDispCmdStr(S_graphname,S_tracename,0,0)		putscraptext cmdendfunction/S getTraceDispCmdStr(graphN,traceName,includeAxes,appendNotDisp[renameTrace])	String graphN,traceName,renameTrace	Variable includeAxes,appendNotDisp		Variable doRenameTrace = !ParamIsDEfault(renameTrace) && (strlen(renameTrace) > 0)	String outputTN = selectstring(doRenameTrace,traceName,renameTrace)		String mainCmd = selectstring(appendNotDisp,"Display","AppendToGraph")	String ref = nameofwave(tracenametowaveref(graphN,traceName))	String info = traceinfo(graphN,traceName,0)	String xref = Stringbykey("xwave",info)	Variable hasxwave = strlen(xref) > 0		make/o/t/free axFlags = {"/L=","/B=","/T=","/R="}	setdimlabel 0,0,left,axFlags	setdimlabel 0,1,bottom,axFlags	setdimlabel 0,2,top,axFlags	setdimlabel 0,3,right,axFlags		String winFlag = ""//"/W="+graphN	String ywave = nameofwave(tracenametowaveref(graphN,traceName))	String xaxis = Stringbykey("xaxis",info)	String yaxis = Stringbykey("yaxis",info)	String xaxInfo = axisinfo(graphN,xaxis)	String xaxType = stringbykey("axtype",xaxInfo)	String yaxInfo = axisinfo(graphN,yaxis)	String yaxType = stringbykey("axtype",yaxInfo)	String yRange = Stringbykey("yRange",info)	String xRange = Stringbykey("xRange",info)//	String errBars = Stringbykey("errorbars",info)	//trace info not handled:	//TYPE -- contour, box, violin may need different commands	//XWAVEDF -- problematic if X wave has a data folder that is not stored in xwave (same true of ywave perhaps, but there is no key for that in traceInfo)		String cmd = mainCmd+" "	if (includeAxes)			cmd+=winFlag+axFlags[%$yaxType]+yaxis+axFlags[%$xaxType]+xaxis+" "	endif		cmd += ref+yRange+"/TN="+outputTN + selectstring(hasxwave,""," vs "+xref+xRange)		return cmdendfunction saveWavesAndGraphToClip()	getlastusermenuinfo	fio_saveGraphWithWaves(0,useUserFilesPath=1,makeRecreationExecutable=1)end//eventually make this save waves to a subfolder in the user files and add a hook to delete it on program closefunction executeWavesAndGraphFromClip()	String clip=getscraptext(),line,strname	VAriable i,lines=itemsinlist(clip,"\r")	for (i=0;i<lines;i+=1)		line=stringfromlist(i,clip,"\r")		if (stringmatch(line,"*String loadWvListStr*"))			SVAR/Z loadWvListStr			if (SVAR_exists(loadWvListStr))				line = replacestring("String ",line,"",0,1)			endif		endif		execute/Q line	endforendfunction/S appendWinsToLayout(layoutN,page,winMatchStr,numWins)	String layoutN,winMAtchStr	Variable page,numWins		if (numtype(page))		page=0	endif		if (strlen(layoutN) < 1)		layoutN = winname(0,4)	endif		if (wintype(layoutN) != 3)		newLayout/n=$layoutN		layoutN = S_name	endif		if (strlen(winMatchStr) < 1)		winMatchStr ="*"	endif		Variable winTypes = 1+2+2^16		//graphs,tables,gizmos (and pictures) allowed	make/o/free/t winTypeStrs = {"graph","table","gizmo"}	dl_assignLblsFromList(winTypeStrs,0,0,"1;2;17;","",0)	String name,wins=winlist(winMatchStr,";","WIN:"+num2str(winTypes)),typeStr	Variable i,num=min(numWins,itemsinlist(wins)),type		for (i=0;i<num;i+=1)		name=stringfromlisT(i,wins)		type=wintype(name)		typeStr=winTypeStrs[%$num2str(type)]		appendlayoutobject/W=$layoutN/PAGE=(page) $typeStr $name	endfor		return layoutNendfunction/D slopeMean(wv,x)	WAVE wv	Variable x		Variable pnt = x2pnt(wv,x)		//one point less	Variable preX = pnt2x(wv,pnt-1)	Double slope0 = (wv[pnt]-wv[pnt-1])/(x-preX)		//one point more	Variable postX = pnt2x(wv,pnt+1)	Double slope1 = (wv[pnt+1]-wv[pnt])/(postX-pnt)		return (slope0+slope1)/2	endfunction/S longestCommonStartStr(list,[listWithoutStartStr])	String list	String &listWithoutStartStr	//optional -- will hold list without startStr		WAVE/T txt = listtotextwave(list,";")		String testChar=(txt[0])[0],commonStartStr=""	Variable i,items=dimsize(txt,0),count,doBreak=0		for (count=0;strlen(testChar)>0;)				for (i=1;i<items;i+=1)			if (!stringmatch( (txt[i])[count],testChar))				doBreak=1				break			endif		endfor					if (doBreak)			break		endif				commonStartStr+=testChar		count+=1		testChar = (txt[0])[count]	endfor		if ( !paramIsDefault(listWithoutStartStr) )		txt = ReplaceString(commonStartStr,txt[p],"",0,1)		wfprintf listWithoutStartStr,"%s;",txt	endif		return commonStartStr	endFunction TransAx_fractionTotalMemConductivity(w, val)	Wave/Z w	Variable val		Variable totalMemCond = 1.879920972222222		return 1 * val / 1.879920972222222endfunction BeforeFileOpenHook(refNum, fileNameStr, pathNameStr, fileTypeStr, fileCreatorStr, fileKind )	Variable refNum  //is the file reference number. You can use this number with file I/O operations to read from the file. Igor closes the file when the user-defined function returns, and refNum  becomes invalid. The file is opened for read-only; if you want to write to the file, you must close and reopen it with write access. refNum  will be -1 for experiment files and XOPs. In this case, Igor has not opened the file for you.	String fileNameStr //  contains the name of the file.	String pathNameStr  // contains the name of the symbolic path. pathNameStr  is not the value of the path. Use the PathInfo operation to determine the path's value.	String fileTypeStr  // contains the Macintosh file type code, if applicable. File type codes are obsolete. Use the file name extension to determine if you want to handle the file. You can use ParseFilePath to obtain the extension from fileNameStr .	String fileCreatorStr // contains the Macintosh creator code, if applicable. Creator codes are obsolete so ignore this parameter.	Variable fileKind // is a number that identifies what kind of file Igor thinks it is. Values for fileKind  are listed in the next section.				return fio_reopenImgPxp(refNum,fileNameStr,pathNameStr)endstatic strconstant ksReopenImgPxpPathToFolder = "Dropbox (HMS):do lab -- unshared:Do Lab:Analysis"		//this should be relative to user folder returned by fio_getUserFolderPathStr()static strconstant ksAcceptedFileExtensions = "png;"		//don't include periods; semi-colon delimitedfunction fio_reopenImgPxp(refNum,fileNameStr,pathNameStr)	Variable refNum;string fileNameStr,pathNameStr		String fileExtension = fio_getFileNameOrExtension(fileNameStr,1)		Variable acceptedFileExtension = itemsinlist(ListMatch(ksAcceptedFileExtensions,"*"+fileExtension)) > 0		if (!acceptedFileExtension)		return 0	endif		String txtFileName = fileNameStr + ".txt"	STring txtFiles = indexedfile($pathNameStr,-1,".txt")	Variable txtFileInd = whichlistitem(txtFileName,txtFiles)			if (txtFileInd < 0)		print "fio_reopenImgPxp() acceptable file type opened but no associated text file found, aborting"		return 0	endif		String info = fio_readTxtFile(pathNameStr,txtFileName)	String experimentName = stringbykey("experimentName",info,"~","\r")	String experimentName_noPrefix = removeending(experimentName,".pxp")		if (stringmatch(experimentName,igorinfo(1)))		print "fio_reopenImgPxp() This pxp created the image"		return 1	endif		WAVE/T openExpInfo = fio_getIgorExperiments("")	Variable expIndex = finddimlabel(openExpInfo,0,experimentName_noPrefix)			if (expIndex >= 0)		Variable is64 = str2num(openExpInfo[expIndex][%is64])		String winTitle=openExpInfo[expIndex][%$"Window Title"]		String activateCmd="nircmd win activate title \""+winTitle+"\""		String flashCmd="nircmd win flash title \""+winTitle+"\""		print "fio_reopenImgPxp() Pxp file that created this image,",experimentName," is already open in",selectstring(is64,"Igor32","Igor64"),"win="+winTitle,"attempting to activate that window (requires nircmd)"		executescripttext/B/Z/w=4 activateCmd				if (V_flag)			print "fio_reopenImgPxp() could not activate pxp that contained image ("+experimentName+"), appears nircmd is not installed. Add nircmd.exe (http://www.nirsoft.net/utils/nircmd.html) to C:/Windows"		else			executescripttext/B/Z/w=1 flashCmd		endif				//doesnt seem like there is any easily available error handling if window is not found		return 1	endif		//make sure path to search for pxp files is set (once per experiment with drag)	//this could be altered to search more of the available drives	pathinfo fio_reopenImgPxpPath	String pxpPath	if (!V_flag)		//path not set attempt automatic path creation to path in ksReopenImgPxpPathToFolder				pxpPath = fio_getUserFolderPathStr() + ksReopenImgPxpPathToFolder		newPath/o/z fio_reopenImgPxpPath,pxpPath		if (V_flag)			newpath/M=("fio_reopenImgPxp() failed to automatically find path="+pxpPath+"Choose a new path for retrieving PXP files on image drag. To avoid in future update ksReopenImgPxpPathToFolder")/o fio_reopenImgPxpPath//fio_reopenImgPxp			if (V_flag)				Print "fio_reopenImgPxp() failed to set path to retrieve pxp files on image drag, aborting. need to set symbolic path with name fio_reopenImgPxpPath"				return 1			endif		endif				pathinfo fio_reopenImgPxpPath		if (!V_flag)		//still no path set			Print "fio_reopenImgPxp() failed to set path to retrieve pxp files on image drag, aborting. need to set symbolic path with name fio_reopenImgPxpPath. To avoid in future update ksReopenImgPxpPathToFolder"			return 1		endif			endif	pxpPath=S_path	Print "pxpPath=",pxpPath		String pxpFiles = indexedfile(fio_reopenImgPxpPath,-1,".pxp")	Variable pxpFileInd = whichlistitem(experimentName,pxpFiles)	if (pxpFileInd<0)		print "fio_reopenImgPxp() pxp that generated image:",experimentName,". not found. need to set symbolic path with name fio_reopenImgPxpPath to proper path, or maybe it has been renamed since last image save"		return 1	endif		String sysPxpPath = parsefilepath(5,pxpPath,"*",0,100)	String fullPath = sysPxpPath+stringfromlist(pxpFileInd,pxpFiles)	print "fio_reopenImgPxp() pxp that generated image found at:",fullPath+". attempting open in new instance of Igor64. Running: executeIgorScript_doCmd("+fullPath+",64,newInstance=1,noCommand=1)"		executeIgorScript_doCmd(fullPath,64,newInstance=1,noCommand=1)		return 1endfunction/S fio_getUserFolderPathStr()	String out = specialDirPath("Documents",0,0,0)	//in practice seems documents is stored in user folder	out = parseFilePath(1,out,":",1,0)		//remove last element, which is Documents	return outendfunction/S fio_getFileNameOrExtension(str,extensionNotName)	String str	Variable extensionNotName		Variable items = itemsinlist(str,".")			if (extensionNotName)		return stringfromlist(items-1,str,".")	endif		String noExt = removelistitem(items-1,str,".")	Variable len = strlen(noExt)		return noExt[0,len-2]		//remove last "."	endFunction/S fio_readTxtFile(pathNameStr,fileNameStr)	String pathNameStr 		//symbolic path for file	String fileNameStr	//full name of file including extension		Variable refNum	Open/R/P=$pathNameStr refNum as fileNameStr		if (refNum == 0)		pathinfo $pathNameStr		print "fio_readTxtFile() failed to find pathNameStr",fileNameStr,"in symbolic path",pathNameStr,"("+S_path+")"		return ""		// Failed	endif	Variable lineNumber, len	String buffer,out=""	lineNumber = 0	do		FReadLine refNum, buffer		len = strlen(buffer)		if (len == 0)			break		// No more lines to be read		endif		out += buffer		if (CmpStr(buffer[len-1],"\r") != 0)	// Last line has no CR ?			out+="\r"		endif		lineNumber += 1	while (1)	close refnum		return outEndfunction/WAVE fio_getIgorExperiments(outRef)	String outRef		//pass "" for free wave		String cmdExeKeys="Image Name;PID;Session Name;Session#;Mem Usage;Status;User Name;CPU Time;Window Title;"		//output from the script below contains items with these keys. formatting is parsed by key in text_getCmdExeListInfo()		ExecuteScriptText/B "tasklist /v /FO LIST /fi \"IMAGENAME eq Igor*\""	WAVE/T instanceInfo = listtotextwave(S_value,"\r\n\r\n")		//format is /r delimited list with key:<\t>itemStr<\r> it seems		duplicate/o/free/t instanceInfo,titleStrs,winTitles,imageNameStrs	Variable numWins = dimsize(instanceInfo,0),i,itemsInWindowTitleStr			Variable numCmdKeys=itemsinlist(cmdExeKeys),numParams=itemsinlist(cmdExeKeys)+3	if (strlen(outRef) == 0)		make/o/free/n=(numWins,numParams)/t out	else		make/o/n=(numWins,numParams)/t $outref/wave=out	endif		String key	for (i=0;i<numCmdKeys;i+=1)		key=stringfromlist(i,cmdExeKeys)		setdimlabel 1,i,$key,out	endfor	setdimlabel 1,numCmdKeys,is64,out	setdimlabel 1,numCmdKeys+1,isDefault,out	setdimlabel 1,numCmdKeys+2,winTitleNoIgorInfo,out		//also stored in the dimension label		out[][0,numCmdKeys]=text_getCmdExeListInfo(stringfromlist(q,cmdExeKeys),instanceInfo[p])		out[][%is64] = num2str(stringmatch(out[p][%$"Image Name"],"*Igor64.exe*"))	out[][%isDefault] = num2str(itemsinlist(out[p][%$"Window Title"]," - ") < 2 )//for named windows, will be 2; for unnamed will be 1 --not a super safe test. Would be better to get Igor version and check a match to expected given 32-bit or 64-bit		String experimentName	for (i=0;i<numWins;i+=1)		experimentName = stringfromlist(0,out[i][%$"Window Title"]," - ")			experimentName = text_removeSurroundingSpaces(experimentName,2)				out[i][%winTitleNoIgorInfo] = experimentName			setdimlabel 0,i,$experimentName,out	endfor			return outendfunction/S text_getCmdExeListInfo(key,list)	String key,list		String match = stringfromlist(0,listmatch(list,key+":*","\r\n"),"\r\n")	match = replacestring(key+":",match,"",0,1)	return text_removeSurroundingSpaces(match,2)end           function/S text_removeSurroundingSpaces(str,beforeAfterOrBoth)	String str; Variable beforeAfterOrBoth		//0 just before, 1 after, 2 both		Variable i,firstNonSpacePos,lastNonSpacePos,len=strlen(str)	if ( (beforeAfterOrBoth==0) || (beforeAfterOrBoth==2) )		for (i=0;i<len;i+=1)			if (!stringmatch(str[i], " "))				break			endif		endfor		firstNonSpacePos = i		if (firstNonSpacePos == len)		//got through whole loop, string is empty or all blank			return ""		endif			if (beforeAfterOrBoth==0)			return str[firstNonSpacePos,inf]		endif	endif		//beforeAfterOrBoth is 1 or 2	for (i=len-1;i>=0;i-=1)		if (!stringmatch(str[i]," "))			break		endif	endfor		lastNonSpacePos = i		if (beforeAfterOrBoth==1)		//just return without ending spaces		if (lastNonSpacePos == 0)	//got through whole loop, string is empty or all blank			return ""		endif			return str[0,lastNonSpacePos]	endif		if (lastNonSpacePos == firstNonSpacePos)	//got through whole loop, string is empty or all blank		return ""	endif									//return without ending and preceding spaces	return str[firstNonSpacePos,lastNonSpacePos]endstrconstant ksExecutable32="IgorBinaries_Win32\Igor.exe"strconstant ksExecutable64="IgorBinaries_x64\Igor64.exe"function executeIgorScript_doCmd(cmdStr,igorVers,[newInstance,noCommand])	String cmdStr			//command to execute in other instance of igor	Variable igorVers		//version of Igor to command	Variable newInstance	//use the /I flag to start a new Igor instance. otherwise, a new instance should only be created if there are no instances of the version of Igor running	Variable noCommand		//suppress the /X command flag. This is required to open a pre-existing pxp file		String windowsIgorPath = SpecialDirPath("Igor Application",0,1,0)	Variable doNewInstance = !ParamIsDefault(newInstance) && newInstance	Variable doCommand = ParamIsDefault(noCommand) || !noCommand	String newInstanceOption = selectstring(doNewInstance,"","/I ")	String commandOption = selectstring(doCommand,"","/X ")	string execPath 	switch (igorVers)		case 32:			execPath =  "\""+ windowsIgorPath  + ksExecutable32 +"\""			break		case 64:			execPath =  "\""+ windowsIgorPath  + ksExecutable64 +"\""			break		default:			return 0		//not a valid igor version	endswitch	String scriptText = execPath +  " " +commandOption + newInstanceOption + "\"" + cmdStr + "\""	ExecuteScriptText  scriptTextend	